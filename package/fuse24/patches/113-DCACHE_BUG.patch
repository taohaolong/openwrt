diff -ruN fuse-2.5.3.orig/kernel/dev.c fuse-2.5.3/kernel/dev.c
--- fuse-2.5.3.orig/kernel/dev.c	2006-02-02 19:04:52.000000000 +0200
+++ fuse-2.5.3/kernel/dev.c	2008-10-23 10:27:53.000000000 +0300
@@ -512,6 +512,9 @@
 {
 	unsigned long offset;
 	int err;
+#ifdef DCACHE_BUG
+	struct vm_area_struct *vma;
+#endif
 
 	unlock_request(cs->req);
 	fuse_copy_finish(cs);
@@ -523,14 +526,22 @@
 		cs->nr_segs --;
 	}
 	down_read(&current->mm->mmap_sem);
+#ifndef DCACHE_BUG
 	err = get_user_pages(current, current->mm, cs->addr, 1, cs->write, 0,
 			     &cs->pg, NULL);
+#else
+	err = get_user_pages(current, current->mm, cs->addr, 1, cs->write, 0,
+			     &cs->pg, &vma);
+#endif
 	up_read(&current->mm->mmap_sem);
 	if (err < 0)
 		return err;
 	BUG_ON(err != 1);
 	offset = cs->addr % PAGE_SIZE;
 	cs->mapaddr = kmap_atomic(cs->pg, KM_USER0);
+#ifdef DCACHE_BUG
+	r4k_flush_cache_page(vma, cs->addr); 
+#endif
 	cs->buf = cs->mapaddr + offset;
 	cs->len = min(PAGE_SIZE - offset, cs->seglen);
 	cs->seglen -= cs->len;
@@ -545,6 +556,11 @@
 {
 	unsigned ncpy = min(*size, cs->len);
 	if (val) {
+#ifdef DCACHE_BUG
+		// patch from mailing list, it is very important, otherwise,
+		// can't mount, or ls mount point will hang
+		flush_cache_all();
+#endif
 		if (cs->write)
 			memcpy(cs->buf, *val, ncpy);
 		else
diff -ruN fuse-2.5.3.orig/kernel/fuse_i.h fuse-2.5.3/kernel/fuse_i.h
--- fuse-2.5.3.orig/kernel/fuse_i.h	2006-02-02 19:04:52.000000000 +0200
+++ fuse-2.5.3/kernel/fuse_i.h	2008-10-22 18:03:50.000000000 +0300
@@ -45,6 +45,10 @@
 #  endif
 #endif
 
+//#if defined(__arm__) && LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#define DCACHE_BUG
+//#endif
+
 #include "config.h"
 #ifndef KERNEL_2_6
 #  include <linux/config.h>

