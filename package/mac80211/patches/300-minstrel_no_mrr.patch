This fixes tx status processing for drivers that do not support mrr.
If the retry count is bigger than the maximum retry count configured in
the hardware, do not count the rate attempt as successful, the hardware
has probably switched to a lower rate.

Signed-off-by: Felix Fietkau <nbd@openwrt.org>

--- a/net/mac80211/rc80211_minstrel.c
+++ b/net/mac80211/rc80211_minstrel.c
@@ -171,6 +171,7 @@ minstrel_tx_status(void *priv, struct ie
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_tx_altrate *ar = info->status.retries;
 	struct minstrel_priv *mp = priv;
+	struct ieee80211_local *local = hw_to_local(mp->hw);
 	int i, ndx, tries;
 	int success = 0;
 
@@ -180,6 +181,13 @@ minstrel_tx_status(void *priv, struct ie
 	if (!mp->has_mrr || (ar[0].rate_idx < 0)) {
 		ndx = rix_to_ndx(mi, info->tx_rate_idx);
 		tries = info->status.retry_count + 1;
+
+		/* If the driver does not support the MRR API, but uses
+		 * a fallback rate, use the long retry limit as indication
+		 * that a rate switch has happened */
+		if (!mp->has_mrr && (tries >= local->long_retry_limit))
+			success = 0;
+
 		mi->r[ndx].success += success;
 		mi->r[ndx].attempts += tries;
 		return;
