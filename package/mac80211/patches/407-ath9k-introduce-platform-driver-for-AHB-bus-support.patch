From 9456893748c407d9fed06046308177edaca38450 Mon Sep 17 00:00:00 2001
From: Gabor Juhos <juhosg@openwrt.org>
Date: Fri, 2 Jan 2009 16:12:30 +0100
Subject: [RFC 07/12] ath9k: introduce platform driver for AHB bus support

This patch adds the platform_driver itself, and modifies the main driver
to register it.

Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
---
 drivers/net/wireless/ath9k/Makefile |    1 +
 drivers/net/wireless/ath9k/ahb.c    |  258 +++++++++++++++++++++++++++++++++++
 drivers/net/wireless/ath9k/core.h   |    8 +
 drivers/net/wireless/ath9k/main.c   |   10 ++
 4 files changed, 277 insertions(+), 0 deletions(-)

--- a/drivers/net/wireless/ath9k/Makefile
+++ b/drivers/net/wireless/ath9k/Makefile
@@ -12,6 +12,7 @@ ath9k-y +=	hw.o \
 		rc.o
 
 ath9k-$(CONFIG_PCI) += pci.o
+ath9k-$(CONFIG_ATHEROS_AR71XX) += ahb.o
 ath9k-$(CONFIG_ATH9K_DEBUG) += debug.o
 
 obj-$(CONFIG_ATH9K) += ath9k.o
--- /dev/null
+++ b/drivers/net/wireless/ath9k/ahb.c
@@ -0,0 +1,258 @@
+/*
+ * Copyright (c) 2008 Atheros Communications Inc.
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/nl80211.h>
+#include <linux/platform_device.h>
+#include "core.h"
+#include "reg.h"
+#include "hw.h"
+
+static dma_addr_t ath_ahb_map_single_to_device(struct ath_softc *sc,
+					       void *p, size_t size)
+{
+	return dma_map_single(NULL, p, size, DMA_TO_DEVICE);
+}
+
+static void ath_ahb_unmap_single_to_device(struct ath_softc *sc,
+					   dma_addr_t da, size_t size)
+{
+	dma_unmap_single(NULL, da, size, DMA_TO_DEVICE);
+}
+
+static dma_addr_t ath_ahb_map_single_from_device(struct ath_softc *sc,
+						 void *p, size_t size)
+{
+	return dma_map_single(NULL, p, size, DMA_FROM_DEVICE);
+}
+
+static void ath_ahb_unmap_single_from_device(struct ath_softc *sc,
+					     dma_addr_t da, size_t size)
+{
+	dma_unmap_single(NULL, da, size, DMA_FROM_DEVICE);
+}
+
+static int ath_ahb_dma_mapping_error(struct ath_softc *sc, dma_addr_t da)
+{
+	return dma_mapping_error(NULL, da);
+}
+
+static void ath_ahb_sync_single_for_cpu(struct ath_softc *sc, dma_addr_t da,
+				       size_t size)
+{
+	dma_sync_single_for_cpu(NULL, da, size, DMA_FROM_DEVICE);
+}
+
+static void *ath_ahb_dma_alloc(struct ath_softc *sc, size_t size,
+			       dma_addr_t *pda)
+{
+	return dma_alloc_coherent(NULL, size, pda, GFP_KERNEL);
+}
+
+static void ath_ahb_dma_free(struct ath_softc *sc, size_t size, void *p,
+			     dma_addr_t da)
+{
+	dma_free_coherent(NULL, size, p, da);
+}
+
+static void ath_ahb_reg_write(struct ath_hal *ah, unsigned reg, u32 val)
+{
+	__raw_writel(val, ah->ah_sh + reg);
+}
+
+static u32 ath_ahb_reg_read(struct ath_hal *ah, unsigned reg)
+{
+	return __raw_readl(ah->ah_sh + reg);
+}
+
+/* return bus cachesize in 4B word units */
+static void ath_ahb_read_cachesize(struct ath_softc *sc, int *csz)
+{
+	*csz = L1_CACHE_BYTES >> 2;
+}
+
+static void ath_ahb_cleanup(struct ath_softc *sc)
+{
+	struct platform_device *pdev = to_platform_device(sc->dev);
+	struct ieee80211_hw *hw = sc->hw;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res)
+		free_irq(res->start, sc);
+
+	ath_detach(sc);
+	iounmap(sc->mem);
+	ieee80211_free_hw(hw);
+	platform_set_drvdata(pdev, NULL);
+}
+
+static struct ath_bus_ops ath_ahb_bus_ops  = {
+	.dma_map_single_to_device = ath_ahb_map_single_to_device,
+	.dma_unmap_single_to_device = ath_ahb_unmap_single_to_device,
+	.dma_map_single_from_device = ath_ahb_map_single_from_device,
+	.dma_unmap_single_from_device = ath_ahb_unmap_single_from_device,
+	.dma_map_single_to_device = ath_ahb_map_single_to_device,
+	.dma_mapping_error = ath_ahb_dma_mapping_error,
+	.dma_sync_single_for_cpu = ath_ahb_sync_single_for_cpu,
+	.dma_alloc = ath_ahb_dma_alloc,
+	.dma_free = ath_ahb_dma_free,
+
+	.reg_read = ath_ahb_reg_read,
+	.reg_write = ath_ahb_reg_write,
+
+	.read_cachesize = ath_ahb_read_cachesize,
+
+	.cleanup = ath_ahb_cleanup,
+};
+
+static int ath_ahb_probe(struct platform_device *pdev)
+{
+	void __iomem *mem;
+	struct ath_softc *sc;
+	struct ieee80211_hw *hw;
+	struct resource *res;
+	int irq;
+	int ret = 0;
+	struct ath_hal *ah;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no memory resource found\n");
+		ret = -ENXIO;
+		goto err_out;
+	}
+
+	mem = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (mem == NULL) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_out;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no IRQ resource found\n");
+		ret = -ENXIO;
+		goto err_iounmap;
+	}
+
+	irq = res->start;
+
+	hw = ieee80211_alloc_hw(sizeof(struct ath_softc), &ath9k_ops);
+	if (hw == NULL) {
+		dev_err(&pdev->dev, "no memory for ieee80211_hw\n");
+		ret = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	hw->flags = IEEE80211_HW_RX_INCLUDES_FCS |
+		IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING |
+		IEEE80211_HW_SIGNAL_DBM |
+		IEEE80211_HW_NOISE_DBM;
+
+	hw->wiphy->interface_modes =
+		BIT(NL80211_IFTYPE_AP) |
+		BIT(NL80211_IFTYPE_STATION) |
+		BIT(NL80211_IFTYPE_ADHOC);
+
+	SET_IEEE80211_DEV(hw, &pdev->dev);
+	platform_set_drvdata(pdev, hw);
+
+	sc = hw->priv;
+	sc->hw = hw;
+	sc->dev = &pdev->dev;
+	sc->mem = mem;
+	sc->bus_ops = &ath_ahb_bus_ops;
+
+	ret = ath_attach(AR5416_AR9100_DEVID, sc);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to attach device, err=%d\n", ret);
+		ret = -ENODEV;
+		goto err_free_hw;
+	}
+
+	ret = request_irq(irq, ath_isr, IRQF_SHARED, "ath9k", sc);
+	if (ret) {
+		dev_err(&pdev->dev, "request_irq failed, err=%d\n", ret);
+		ret = -EIO;
+		goto err_detach;
+	}
+
+	ah = sc->sc_ah;
+	printk(KERN_INFO
+	       "%s: Atheros AR%s MAC/BB Rev:%x, "
+	       "AR%s RF Rev:%x, mem=0x%lx, irq=%d\n",
+	       wiphy_name(hw->wiphy),
+	       ath_mac_bb_name(ah->ah_macVersion),
+	       ah->ah_macRev,
+	       ath_rf_name((ah->ah_analog5GhzRev & AR_RADIO_SREV_MAJOR)),
+	       ah->ah_phyRev,
+	       (unsigned long)mem, irq);
+
+	return 0;
+
+ err_detach:
+	ath_detach(sc);
+ err_free_hw:
+	ieee80211_free_hw(hw);
+	platform_set_drvdata(pdev, NULL);
+ err_iounmap:
+	iounmap(mem);
+ err_out:
+	return ret;
+}
+
+static int ath_ahb_remove(struct platform_device *pdev)
+{
+	struct ieee80211_hw *hw = platform_get_drvdata(pdev);
+
+	if (hw) {
+		struct resource *res;
+		struct ath_softc *sc = hw->priv;
+
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+		if (res)
+			free_irq(res->start, sc);
+
+		ath_detach(sc);
+		iounmap(sc->mem);
+		ieee80211_free_hw(hw);
+		platform_set_drvdata(pdev, NULL);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ath_ahb_driver = {
+	.probe      = ath_ahb_probe,
+	.remove     = ath_ahb_remove,
+	.driver		= {
+		.name	= "ath9k",
+		.owner	= THIS_MODULE,
+	},
+};
+
+int ath_ahb_init(void)
+{
+	return platform_driver_register(&ath_ahb_driver);
+}
+
+void ath_ahb_exit(void)
+{
+	platform_driver_register(&ath_ahb_driver);
+}
--- a/drivers/net/wireless/ath9k/core.h
+++ b/drivers/net/wireless/ath9k/core.h
@@ -874,4 +874,12 @@ static inline int ath_pci_init(void) { r
 static inline void ath_pci_exit(void) {};
 #endif
 
+#ifdef CONFIG_ATHEROS_AR71XX
+int ath_ahb_init(void);
+void ath_ahb_exit(void);
+#else
+static inline int ath_ahb_init(void) { return 0; };
+static inline void ath_ahb_exit(void) {};
+#endif
+
 #endif /* CORE_H */
--- a/drivers/net/wireless/ath9k/main.c
+++ b/drivers/net/wireless/ath9k/main.c
@@ -2533,8 +2533,17 @@ static int __init ath9k_init(void)
 		goto err_rate_unregister;
 	}
 
+	error = ath_ahb_init();
+	if (error < 0) {
+		error = -ENODEV;
+		goto err_pci_exit;
+	}
+
 	return 0;
 
+ err_pci_exit:
+	ath_pci_exit();
+
  err_rate_unregister:
 	ath_rate_control_unregister();
  err_out:
@@ -2544,6 +2553,7 @@ module_init(ath9k_init);
 
 static void __exit ath9k_exit(void)
 {
+	ath_ahb_exit();
 	ath_pci_exit();
 	ath_rate_control_unregister();
 	printk(KERN_INFO "%s: Driver unloaded\n", dev_info);
