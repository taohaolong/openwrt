--- a/ath/if_ath.c
+++ b/ath/if_ath.c
@@ -1300,6 +1300,7 @@
 	vap->iv_key_update_begin = ath_key_update_begin;
 	vap->iv_key_update_end = ath_key_update_end;
 	vap->iv_maxrateindex = 0;
+	vap->iv_minrateindex = 0;
 	if (sc->sc_default_ieee80211_debug) {
 		/* User specified defaults for new VAPs were provided, so
 		 * use those (only). */
--- a/ath_rate/minstrel/minstrel.c
+++ b/ath_rate/minstrel/minstrel.c
@@ -652,6 +652,8 @@
 
 	sn->num_rates = ni->ni_rates.rs_nrates;
 	for (x = 0; x < ni->ni_rates.rs_nrates; x++) {
+		int idx = x;
+
 		sn->rs_rateattempts 	[x] = 0;
 		sn->rs_thisprob 	[x] = 0;
 		sn->rs_ratesuccess 	[x] = 0;
@@ -662,8 +664,12 @@
 		sn->rs_att_hist 	[x] = 0;
 		sn->rs_this_tp 		[x] = 0;
 
-		sn->rates[x].rate = ni->ni_rates.rs_rates[x] & IEEE80211_RATE_VAL;
-		sn->rates[x].rix = sc->sc_rixmap[sn->rates[x].rate];
+		if (vap->iv_minrateindex && (vap->iv_minrateindex <
+				ni->ni_rates.rs_nrates))
+			idx = vap->iv_minrateindex;
+
+		sn->rates[x].rate = ni->ni_rates.rs_rates[idx] & IEEE80211_RATE_VAL;
+		sn->rates[x].rix = sc->sc_rixmap[sn->rates[idx].rate];
 		if (sn->rates[x].rix == 0xff) {
 			DPRINTF(sc, "%s: %s ignore bogus rix at %d\n",
 				dev_info, __func__, x);
--- a/ath_rate/sample/sample.c
+++ b/ath_rate/sample/sample.c
@@ -845,8 +845,15 @@
 		sn->num_rates = vap->iv_maxrateindex;
 
 	for (x = 0; x < ni->ni_rates.rs_nrates; x++) {
-		sn->rates[x].rate = ni->ni_rates.rs_rates[x] & IEEE80211_RATE_VAL;
-		sn->rates[x].rix = sc->sc_rixmap[sn->rates[x].rate];
+		int idx = x;
+
+		if (vap->iv_minrateindex && vap->iv_minrateindex <
+				ni->ni_rates.rs_nrates)
+			idx = vap->iv_minrateindex;
+
+		sn->rates[x].rate = ni->ni_rates.rs_rates[idx] & IEEE80211_RATE_VAL;
+		sn->rates[x].rix = sc->sc_rixmap[sn->rates[idx].rate];
+
 		if (sn->rates[x].rix == 0xff) {
 			DPRINTF(sc, ATH_DEBUG_RATE, "%s: %s ignore bogus rix at %u\n",
 				dev_info, __func__, x);
--- a/net80211/ieee80211_ioctl.h
+++ b/net80211/ieee80211_ioctl.h
@@ -651,6 +651,7 @@
 	IEEE80211_PARAM_SCANBUFS		= 81,	/* Heap analysis for TX DMA */
 	IEEE80211_PARAM_LEAKTXBUFS		= 82,	/* Leak tx buffers */
 	IEEE80211_PARAM_MAXRATE			= 83,	/* Maximum rate (by table index) */
+	IEEE80211_PARAM_MINRATE			= 84,	/* Minimum rate (by table index) */
 };
 
 #define	SIOCG80211STATS			(SIOCDEVPRIVATE+2)
--- a/net80211/ieee80211_var.h
+++ b/net80211/ieee80211_var.h
@@ -292,6 +292,7 @@
 	struct ieee80211_app_ie app_ie[IEEE80211_APPIE_NUM_OF_FRAME]; /* app-specified IEs by frame type */
 	u_int32_t app_filter;				/* filters which management frames are forwarded to app */
 	int iv_maxrateindex;
+	int iv_minrateindex;
 };
 
 /* Debug functions need the defintion of struct ieee80211vap because iv_debug 
--- a/net80211/ieee80211_wireless.c
+++ b/net80211/ieee80211_wireless.c
@@ -2879,6 +2879,12 @@
 		else
 			vap->iv_maxrateindex = 0;
 		break;
+	case IEEE80211_PARAM_MINRATE:
+		if (value > 0)
+			vap->iv_minrateindex = value;
+		else
+			vap->iv_minrateindex = 0;
+		break;
 #ifdef ATH_REVERSE_ENGINEERING
 	case IEEE80211_PARAM_DUMPREGS:
 		ieee80211_dump_registers(dev, info, w, extra);
@@ -3220,6 +3226,9 @@
 	case IEEE80211_PARAM_MAXRATE:
 		param[0] = vap->iv_maxrateindex;
 		break;
+	case IEEE80211_PARAM_MINRATE:
+		param[0] = vap->iv_minrateindex;
+		break;
 	default:
 		return -EOPNOTSUPP;
 	}
@@ -5679,6 +5688,10 @@
 	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "maxrate"},
 	{IEEE80211_PARAM_MAXRATE,
 	 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_maxrate"},
+	{IEEE80211_PARAM_MINRATE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "minrate"},
+	{IEEE80211_PARAM_MINRATE,
+	 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_minrate"},
 	
 #ifdef ATH_REVERSE_ENGINEERING
 	/*
