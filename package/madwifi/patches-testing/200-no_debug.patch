--- a/ath/if_ath.c
+++ b/ath/if_ath.c
@@ -323,8 +323,10 @@
 static void ath_set_dfs_cac_time(struct ieee80211com *, unsigned int seconds);
 
 static unsigned int ath_test_radar(struct ieee80211com *);
-static unsigned int ath_dump_hal_map(struct ieee80211com *ic);
+#ifdef AR_DEBUG
 
+static unsigned int ath_dump_hal_map(struct ieee80211com *ic);
+#endif
 static u_int32_t ath_get_clamped_maxtxpower(struct ath_softc *sc);
 static u_int32_t ath_set_clamped_maxtxpower(struct ath_softc *sc, 
 		u_int32_t new_clamped_maxtxpower);
@@ -334,7 +336,10 @@
 		unsigned int param, unsigned int value);
 
 static u_int32_t ath_get_real_maxtxpower(struct ath_softc *sc);
+
+#ifdef AR_DEBUG
 static int ath_txq_check(struct ath_softc *sc, struct ath_txq *txq, const char *msg);
+#endif
 
 static int ath_countrycode = CTRY_DEFAULT;	/* country code */
 static int ath_outdoor = AH_FALSE;		/* enable outdoor use */
@@ -486,9 +491,11 @@
 	u_int8_t csz;
 
 	sc->devid = devid;
+#ifdef AR_DEBUG
 	ath_debug_global = (ath_debug & ATH_DEBUG_GLOBAL);
 	sc->sc_debug 	 = (ath_debug & ~ATH_DEBUG_GLOBAL);
 	DPRINTF(sc, ATH_DEBUG_ANY, "%s: devid 0x%x\n", __func__, devid);
+#endif
 
 	/* Allocate space for dynamically determined maximum VAP count */
 	sc->sc_bslot = 
@@ -1014,7 +1021,9 @@
 	ic->ic_vap_delete = ath_vap_delete;
 
 	ic->ic_test_radar		= ath_test_radar;
+#ifdef AR_DEBUG
 	ic->ic_dump_hal_map		= ath_dump_hal_map;
+#endif
 
 	ic->ic_set_dfs_testmode		= ath_set_dfs_testmode;
 	ic->ic_get_dfs_testmode		= ath_get_dfs_testmode;
@@ -1285,12 +1294,14 @@
 		/* If no default VAP debug flags are passed, allow a few to
 		 * transfer down from the driver to new VAPs so we can have load
 		 * time debugging for VAPs too. */
+#ifdef AR_DEBUG
 		vap->iv_debug = 0 |
 			((sc->sc_debug & ATH_DEBUG_RATE) ? IEEE80211_MSG_XRATE  : 0) | 
 			((sc->sc_debug & ATH_DEBUG_XMIT) ? IEEE80211_MSG_OUTPUT : 0) | 
 			((sc->sc_debug & ATH_DEBUG_RECV) ? IEEE80211_MSG_INPUT  : 0) |
 			0
 			;
+#endif
 	}
 	ic->ic_debug = (sc->sc_default_ieee80211_debug & IEEE80211_MSG_IC);
 
@@ -2811,6 +2822,7 @@
 #endif
 }
 
+#ifdef AR_DEBUG
 static void
 ath_txq_dump(struct ath_softc *sc, struct ath_txq *txq)
 {
@@ -2866,6 +2878,7 @@
 
 	return 1;
 }
+#endif
 
 /*
  * Insert a buffer on a txq
@@ -8384,7 +8397,9 @@
 ath_tx_timeout(struct net_device *dev)
 {
 	struct ath_softc *sc = dev->priv;
+#ifdef AR_DEBUG
 	int i;
+#endif
 
 	if (ath_chan_unavail(sc))
 		return;
@@ -8393,12 +8408,14 @@
 		(dev->flags & IFF_RUNNING) ? "" : "NOT ",
 		sc->sc_invalid ? "in" : "");
 
+#ifdef AR_DEBUG
 	for (i = 0; i < HAL_NUM_TX_QUEUES; i++) {
 		if (ATH_TXQ_SETUP(sc, i)) {
 			ath_txq_check(sc, &sc->sc_txq[i], __func__);
 			ath_txq_dump(sc, &sc->sc_txq[i]);
 		}
 	}
+#endif
 
 	if ((dev->flags & IFF_RUNNING) && !sc->sc_invalid) {
 		sc->sc_stats.ast_watchdog++;
@@ -10638,6 +10655,7 @@
 				/* XXX validate? */
 				sc->sc_ledpin = val;
 				break;
+#ifdef AR_DEBUG
 			case ATH_DEBUG:
 				sc->sc_debug 	 = (val & ~ATH_DEBUG_GLOBAL);
 				ath_debug_global = (val &  ATH_DEBUG_GLOBAL);
@@ -10645,6 +10663,7 @@
 						"0x%08x.\n", val);
 
 				break;
+#endif
 			case ATH_TXANTENNA:
 				/*
 				 * antenna can be:
@@ -10818,9 +10837,11 @@
 		case ATH_REGDOMAIN:
 			ath_hal_getregdomain(ah, &val);
 			break;
+#ifdef AR_DEBUG
 		case ATH_DEBUG:
 			val = sc->sc_debug | ath_debug_global;
 			break;
+#endif
 		case ATH_TXANTENNA:
 			val = sc->sc_txantenna;
 			break;
@@ -11939,6 +11960,7 @@
 }
 
 /* This is called by a private ioctl (iwpriv) to dump the HAL obfuscation table */
+#ifdef AR_DEBUG
 static unsigned int
 ath_dump_hal_map(struct ieee80211com *ic)
 {
@@ -11947,7 +11969,7 @@
 	ath_hal_dump_map(sc->sc_ah);
 	return 0;
 }
-
+#endif
 /* If we are shutting down or blowing off the DFS channel availability check
  * then we call this to stop the behavior before we take the rest of the
  * necessary actions (such as a DFS reaction to radar). */
--- a/ath_rate/amrr/amrr.c
+++ b/ath_rate/amrr/amrr.c
@@ -70,7 +70,9 @@
 
 #include "amrr.h"
 
+#ifdef AR_DEBUG
 #define	AMRR_DEBUG
+#endif
 #ifdef AMRR_DEBUG
 #define	DPRINTF(sc, _fmt, ...) do {					\
 	if (sc->sc_debug & 0x10)					\
--- a/ath_rate/minstrel/minstrel.c
+++ b/ath_rate/minstrel/minstrel.c
@@ -117,7 +117,9 @@
 
 #include "minstrel.h"
 
+#ifdef AR_DEBUG
 #define	MINSTREL_DEBUG
+#endif
 #ifdef MINSTREL_DEBUG
 enum {
 		ATH_DEBUG_RATE		= 0x00000010	/* rate control */
@@ -963,7 +965,9 @@
 		(struct ieee80211_node_table *)&vap->iv_ic->ic_sta;
 	unsigned int x = 0;
 	unsigned int this_tp, this_prob, this_eprob;
-	struct ath_softc *sc = vap->iv_ic->ic_dev->priv;;
+#ifdef AR_DEBUG
+	struct ath_softc *sc = vap->iv_ic->ic_dev->priv;
+#endif
 
 	IEEE80211_NODE_TABLE_LOCK_IRQ(nt);
 	TAILQ_FOREACH(ni, &nt->nt_node, ni_list) {
--- a/ath_rate/onoe/onoe.c
+++ b/ath_rate/onoe/onoe.c
@@ -66,7 +66,9 @@
 
 #include "onoe.h"
 
+#ifdef AR_DEBUG
 #define	ONOE_DEBUG
+#endif
 #ifdef ONOE_DEBUG
 enum {
 	ATH_DEBUG_RATE	= 0x00000010,	/* rate control */
--- a/ath_rate/sample/sample.c
+++ b/ath_rate/sample/sample.c
@@ -68,7 +68,9 @@
 
 #include "sample.h"
 
-#define	SAMPLE_DEBUG
+#ifdef AR_DEBUG
+#define SAMPLE_DEBUG
+#endif
 #ifdef SAMPLE_DEBUG
 enum {
 	ATH_DEBUG_RATE		= 0x00000010,	/* rate control */
--- a/tools/do_multi.c
+++ b/tools/do_multi.c
@@ -9,16 +9,20 @@
 
     progname = basename(argv[0]);
 
+#ifdef AR_DEBUG
     if(strcmp(progname, "80211debug") == 0)
 	ret = a80211debug_init(argc, argv);
+#endif
     if(strcmp(progname, "80211stats") == 0)
 	ret = a80211stats_init(argc, argv);
     if(strcmp(progname, "athchans") == 0)
 	ret = athchans_init(argc, argv);
     if(strcmp(progname, "athctrl") == 0)
 	ret =  athctrl_init(argc, argv);
+#ifdef AR_DEBUG
     if(strcmp(progname, "athdebug") == 0)
 	ret =  athdebug_init(argc, argv);
+#endif
     if(strcmp(progname, "athkey") == 0)
 	ret =  athkey_init(argc, argv);
     if(strcmp(progname, "athstats") == 0)
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -39,6 +39,10 @@
 
 ATH_HAL = $(TOP)/ath_hal
 
+ifndef ATH_DEBUG
+ATH_DEBUG=1
+endif
+
 #
 # Path to the HAL source code.
 #
@@ -46,17 +50,22 @@
 HAL = $(TOP)/hal
 endif
 
+INCS = -I. -I$(HAL) -I$(TOP) -I$(ATH_HAL) -I$(TOP)/ath
+CFLAGS = -g -O2 -Wall
+ALL_CFLAGS = $(CFLAGS) $(INCS)
+LDFLAGS =
 
 PROGRAMS = athstats 80211stats athkey athchans athctrl \
-	athdebug 80211debug wlanconfig wpakey
+	wlanconfig wpakey
+
+ifeq ($(ATH_DEBUG),1)
+  PROGRAMS += athdebug 80211debug
+  ALL_CFLAGS += -DAR_DEBUG
+endif
 
 OBJS = $(patsubst %,%.o,$(PROGRAMS)) ath_info/ath_info.o
 SUBDIRS = ath_info
 
-INCS = -I. -I$(HAL) -I$(TOP) -I$(ATH_HAL) -I$(TOP)/ath
-CFLAGS = -g -O2 -Wall
-ALL_CFLAGS = $(CFLAGS) $(INCS)
-LDFLAGS =
 
 all: all-subdirs compile
 
--- a/ath/if_ath_hal.h
+++ b/ath/if_ath_hal.h
@@ -1263,6 +1263,7 @@
 
            tail -f /var/log/messages | sed -f hal_unmangle.sed 
  */
+#ifdef AR_DEBUG
 static inline void ath_hal_dump_map(struct ath_hal *ah)
 {
 #ifdef CONFIG_KALLSYMS
@@ -1527,7 +1528,7 @@
 #endif				/* #ifndef CONFIG_KALLSYMS */
 
 }
-
+#endif
 #include "if_ath_hal_wrappers.h"
 #include "if_ath_hal_extensions.h"
 
--- a/net80211/ieee80211_var.h
+++ b/net80211/ieee80211_var.h
@@ -495,9 +495,10 @@
 	/* inject a fake radar signal -- used while on a 802.11h DFS channels */
 	unsigned int (*ic_test_radar)(struct ieee80211com *);
 
+#ifdef AR_DEBUG
 	/* dump HAL */
 	unsigned int (*ic_dump_hal_map)(struct ieee80211com *);
-
+#endif
 	/* DFS channel availability check time (in seconds) */
 	void (*ic_set_dfs_cac_time)(struct ieee80211com *, unsigned int);
 	unsigned int (*ic_get_dfs_cac_time)(struct ieee80211com *);
--- a/net80211/ieee80211_wireless.c
+++ b/net80211/ieee80211_wireless.c
@@ -1557,6 +1557,7 @@
 	return 0;
 }
 
+#ifdef AR_DEBUG
 static int 
 ieee80211_ioctl_hal_map(struct net_device *dev, struct iw_request_info *info,
        void *w, char *extra)
@@ -1567,7 +1568,7 @@
        params[0] = ic->ic_dump_hal_map(ic);
        return 0;
 }
-
+#endif
 
 static int
 ieee80211_ioctl_radar(struct net_device *dev, struct iw_request_info *info,
@@ -5296,8 +5297,10 @@
 	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,   "getwmmparams" },
 	{ IEEE80211_IOCTL_RADAR,
 	  0, 0, "doth_radar" },
+#ifdef AR_DEBUG
 	{ IEEE80211_IOCTL_HALMAP,
 	  0, 0, "dump_hal_map" },
+#endif
 	/*
 	 * These depends on sub-ioctl support which added in version 12.
 	 */
@@ -5751,7 +5754,9 @@
 	set_priv(IEEE80211_IOCTL_SETMLME, ieee80211_ioctl_setmlme),
 	set_priv(IEEE80211_IOCTL_SETKEY, ieee80211_ioctl_setkey),
 	set_priv(IEEE80211_IOCTL_DELKEY, ieee80211_ioctl_delkey),
+#ifdef AR_DEBUG
 	set_priv(IEEE80211_IOCTL_HALMAP, ieee80211_ioctl_hal_map),
+#endif
 	set_priv(IEEE80211_IOCTL_ADDMAC, ieee80211_ioctl_addmac),
 	set_priv(IEEE80211_IOCTL_DELMAC, ieee80211_ioctl_delmac),
 	set_priv(IEEE80211_IOCTL_WDSADDMAC, ieee80211_ioctl_wdsmac),
--- a/ath/if_ath_debug.h
+++ b/ath/if_ath_debug.h
@@ -54,6 +54,10 @@
 	ATH_DEBUG_GLOBAL	= (ATH_DEBUG_SKB|ATH_DEBUG_SKB_REF)
 };
 
+#define	EPRINTF(_sc, _fmt, ...) \
+		printk(KERN_ERR "%s: %s: " _fmt, \
+			SC_DEV_NAME(_sc), __func__, ## __VA_ARGS__)
+
 #ifdef AR_DEBUG
 
 /* DEBUG-ONLY DEFINITIONS */
@@ -68,20 +72,9 @@
 		ath_keyprint((_sc), __func__, _ix, _hk, _mac);		\
 } while (0)
 
-#else /* #ifdef AR_DEBUG */
-
-#define	DFLAG_ISSET(sc, _m)		0
-#define	DPRINTF(sc, _m, _fmt, ...)
-#define	KEYPRINTF(sc, k, ix, mac)
-
-#endif /* #ifdef AR_DEBUG */
 
 #define	IFF_DUMPPKTS(_sc, _m)   DFLAG_ISSET((_sc), (_m))
 
-#define	EPRINTF(_sc, _fmt, ...) \
-		printk(KERN_ERR "%s: %s: " _fmt, \
-			SC_DEV_NAME(_sc), __func__, ## __VA_ARGS__)
-
 #define	WPRINTF(_sc, _fmt, ...) \
 		printk(KERN_WARNING "%s: %s: " _fmt, \
 			SC_DEV_NAME(_sc), __func__, ## __VA_ARGS__)
@@ -89,5 +82,14 @@
 #define	IPRINTF(_sc, _fmt, ...) \
 		printk(KERN_INFO "%s: %s: " _fmt, \
 			SC_DEV_NAME(_sc), __func__, ## __VA_ARGS__)
+#else
+#define	DFLAG_ISSET(sc, _m)		0
+#define	DPRINTF(sc, _m, _fmt, ...)
+#define	KEYPRINTF(sc, k, ix, mac)
+#define WPRINTF(...)
+#define IPRINTF(...)
+#define IFF_DUMPPKTS(...) 0
+
+#endif
 
 #endif /* #ifndef _IF_ATH_DEBUG_H_ */
--- a/ath/if_ath_pci.c
+++ b/ath/if_ath_pci.c
@@ -134,8 +134,10 @@
 	u16 vdevice;
 	int i;
 
-	if (pci_enable_device(pdev))
+	if (pci_enable_device(pdev)) {
+		printk(KERN_ERR "%s: failed to enable PCI device\n", dev_info);
 		return -EIO;
+	}
 
 	/* XXX 32-bit addressing only */
 	if (pci_set_dma_mask(pdev, 0xffffffff)) {
@@ -244,8 +246,10 @@
 		sc->aps_sc.sc_ledpin = 1;
 	}
 
-	if (ath_attach(vdevice, dev, NULL) != 0)
+	if ((i = ath_attach(vdevice, dev, NULL)) != 0) {
+		printk(KERN_ERR "%s: ath_attach failed: %d\n", dev_info, i);
 		goto bad4;
+	}
 
 	athname = ath_hal_probe(id->vendor, vdevice);
 	printk(KERN_INFO "%s: %s: %s: mem=0x%llx, irq=%d\n",
