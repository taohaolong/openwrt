Index: madwifi-ng-r2420-20070602/ath/if_ath.c
===================================================================
--- madwifi-ng-r2420-20070602.orig/ath/if_ath.c	2007-06-04 13:21:58.895023264 +0200
+++ madwifi-ng-r2420-20070602/ath/if_ath.c	2007-06-04 13:21:59.133986936 +0200
@@ -5602,6 +5602,7 @@
 	u_int phyerr;
 	u_int processed = 0, early_stop = 0;
 	u_int rx_limit = dev->quota;
+	u_int mic_fail = 0;
 
 	/* Let the 802.11 layer know about the new noise floor */
 	sc->sc_channoise = ath_hal_get_channel_noise(ah, &(sc->sc_curchan));
@@ -5696,25 +5697,7 @@
 			}
 			if (rs->rs_status & HAL_RXERR_MIC) {
 				sc->sc_stats.ast_rx_badmic++;
-				/*
-				 * Do minimal work required to hand off
-				 * the 802.11 header for notification.
-				 */
-				/* XXX frag's and QoS frames */
-				len = rs->rs_datalen;
-				if (len >= sizeof (struct ieee80211_frame)) {
-					bus_dma_sync_single(sc->sc_bdev,
-					    bf->bf_skbaddr, len,
-					    BUS_DMA_FROMDEVICE);
-#if 0
-/* XXX revalidate MIC, lookup ni to find VAP */
-					ieee80211_notify_michael_failure(ic,
-					    (struct ieee80211_frame *) skb->data,
-					    sc->sc_splitmic ?
-					        rs->rs_keyix - 32 : rs->rs_keyix
-					);
-#endif
-				}
+				mic_fail = 1;
 			}
 			/*
 			 * Reject error frames if we have no vaps that 
@@ -5772,8 +5755,9 @@
 		/*
 		 * Finished monitor mode handling, now reject
 		 * error frames before passing to other vaps
+		 * Ignore MIC failures here, as we need to recheck them
 		 */
-		if (rs->rs_status != 0) {
+		if (rs->rs_status & ~(HAL_RXERR_MIC | HAL_RXERR_DECRYPT)) {
 			dev_kfree_skb(skb);
 			skb = NULL;
 			goto rx_next;
@@ -5804,6 +5788,27 @@
 				   sc->sc_hwmap[rs->rs_rate].ieeerate,
 				   rs->rs_rssi);
 
+		/* MIC failure. Drop the packet in any case */
+		if (mic_fail) {
+			/* Drop control frames which are reported with mic error */
+		    if ((((struct ieee80211_frame *)skb->data)->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) { 
+				dev_kfree_skb(skb);
+				skb = NULL;
+				mic_fail = 0;
+				goto rx_next;
+			}
+			ni = ieee80211_find_rxnode(ic, 
+				(const struct ieee80211_frame_min *) skb->data);
+			if (ni != NULL) {
+				ieee80211_check_mic(ni, skb);
+				ieee80211_unref_node(&ni);
+			}
+			dev_kfree_skb_any(skb);
+			skb = NULL;
+			mic_fail = 0;
+			goto rx_next;
+ 		}
+
 		/*
 		 * Locate the node for sender, track state, and then
 		 * pass the (referenced) node up to the 802.11 layer
Index: madwifi-ng-r2420-20070602/net80211/ieee80211_crypto_ccmp.c
===================================================================
--- madwifi-ng-r2420-20070602.orig/net80211/ieee80211_crypto_ccmp.c	2007-06-04 13:21:57.936169032 +0200
+++ madwifi-ng-r2420-20070602/net80211/ieee80211_crypto_ccmp.c	2007-06-04 13:21:59.134986784 +0200
@@ -78,7 +78,7 @@
 static int ccmp_encap(struct ieee80211_key *, struct sk_buff *, u_int8_t);
 static int ccmp_decap(struct ieee80211_key *, struct sk_buff *, int);
 static int ccmp_enmic(struct ieee80211_key *, struct sk_buff *, int);
-static int ccmp_demic(struct ieee80211_key *, struct sk_buff *, int);
+static int ccmp_demic(struct ieee80211_key *, struct sk_buff *, int, int);
 
 static const struct ieee80211_cipher ccmp = {
 	.ic_name	= "AES-CCM",
@@ -304,7 +304,7 @@
  * Verify and strip MIC from the frame.
  */
 static int
-ccmp_demic(struct ieee80211_key *k, struct sk_buff *skb, int hdrlen)
+ccmp_demic(struct ieee80211_key *k, struct sk_buff *skb, int hdrlen, int force)
 {
 	return 1;
 }
Index: madwifi-ng-r2420-20070602/net80211/ieee80211_crypto.h
===================================================================
--- madwifi-ng-r2420-20070602.orig/net80211/ieee80211_crypto.h	2007-06-04 13:21:53.000919304 +0200
+++ madwifi-ng-r2420-20070602/net80211/ieee80211_crypto.h	2007-06-04 13:21:59.134986784 +0200
@@ -145,7 +145,7 @@
 	int (*ic_encap)(struct ieee80211_key *, struct sk_buff *, u_int8_t);
 	int (*ic_decap)(struct ieee80211_key *, struct sk_buff *, int);
 	int (*ic_enmic)(struct ieee80211_key *, struct sk_buff *, int);
-	int (*ic_demic)(struct ieee80211_key *, struct sk_buff *, int);
+	int (*ic_demic)(struct ieee80211_key *, struct sk_buff *, int, int);
 };
 extern const struct ieee80211_cipher ieee80211_cipher_none;
 
@@ -163,10 +163,10 @@
  */
 static __inline int
 ieee80211_crypto_demic(struct ieee80211vap *vap, struct ieee80211_key *k,
-	struct sk_buff *skb, int hdrlen)
+	struct sk_buff *skb, int hdrlen, int force)
 {
 	const struct ieee80211_cipher *cip = k->wk_cipher;
-	return (cip->ic_miclen > 0 ? cip->ic_demic(k, skb, hdrlen) : 1);
+	return (cip->ic_miclen > 0 ? cip->ic_demic(k, skb, hdrlen, force) : 1);
 }
 
 /*
Index: madwifi-ng-r2420-20070602/net80211/ieee80211_crypto_none.c
===================================================================
--- madwifi-ng-r2420-20070602.orig/net80211/ieee80211_crypto_none.c	2007-06-04 13:21:53.005918544 +0200
+++ madwifi-ng-r2420-20070602/net80211/ieee80211_crypto_none.c	2007-06-04 13:21:59.134986784 +0200
@@ -52,7 +52,7 @@
 static int none_encap(struct ieee80211_key *, struct sk_buff *, u_int8_t);
 static int none_decap(struct ieee80211_key *, struct sk_buff *, int);
 static int none_enmic(struct ieee80211_key *, struct sk_buff *, int);
-static int none_demic(struct ieee80211_key *, struct sk_buff *, int);
+static int none_demic(struct ieee80211_key *, struct sk_buff *, int, int);
 
 const struct ieee80211_cipher ieee80211_cipher_none = {
 	.ic_name	= "NONE",
@@ -137,7 +137,7 @@
 }
 
 static int
-none_demic(struct ieee80211_key *k, struct sk_buff *skb, int hdrlen)
+none_demic(struct ieee80211_key *k, struct sk_buff *skb, int hdrlen, int force)
 {
 	struct ieee80211vap *vap = k->wk_private;
 
Index: madwifi-ng-r2420-20070602/net80211/ieee80211_crypto_tkip.c
===================================================================
--- madwifi-ng-r2420-20070602.orig/net80211/ieee80211_crypto_tkip.c	2007-06-04 13:21:53.011917632 +0200
+++ madwifi-ng-r2420-20070602/net80211/ieee80211_crypto_tkip.c	2007-06-04 13:21:59.135986632 +0200
@@ -57,7 +57,7 @@
 static int tkip_encap(struct ieee80211_key *, struct sk_buff *, u_int8_t);
 static int tkip_enmic(struct ieee80211_key *, struct sk_buff *, int);
 static int tkip_decap(struct ieee80211_key *, struct sk_buff *, int);
-static int tkip_demic(struct ieee80211_key *, struct sk_buff *, int);
+static int tkip_demic(struct ieee80211_key *, struct sk_buff *, int, int);
 
 static const struct ieee80211_cipher tkip  = {
 	.ic_name	= "TKIP",
@@ -339,7 +339,7 @@
  * Verify and strip MIC from the frame.
  */
 static int
-tkip_demic(struct ieee80211_key *k, struct sk_buff *skb0, int hdrlen)
+tkip_demic(struct ieee80211_key *k, struct sk_buff *skb0, int hdrlen, int force)
 {
 	struct tkip_ctx *ctx = k->wk_private;
 	struct sk_buff *skb;
@@ -355,7 +355,7 @@
 	}
 	wh = (struct ieee80211_frame *) skb0->data;
 	/* NB: skb left pointing at last in chain */
-	if (k->wk_flags & IEEE80211_KEY_SWMIC) {
+	if ((k->wk_flags & IEEE80211_KEY_SWMIC) || force) {
 		struct ieee80211vap *vap = ctx->tc_vap;
 		u8 mic[IEEE80211_WEP_MICLEN];
 		u8 mic0[IEEE80211_WEP_MICLEN];
Index: madwifi-ng-r2420-20070602/net80211/ieee80211_crypto_wep.c
===================================================================
--- madwifi-ng-r2420-20070602.orig/net80211/ieee80211_crypto_wep.c	2007-06-04 13:21:53.016916872 +0200
+++ madwifi-ng-r2420-20070602/net80211/ieee80211_crypto_wep.c	2007-06-04 13:21:59.135986632 +0200
@@ -54,7 +54,7 @@
 static int wep_encap(struct ieee80211_key *, struct sk_buff *, u_int8_t);
 static int wep_decap(struct ieee80211_key *, struct sk_buff *, int);
 static int wep_enmic(struct ieee80211_key *, struct sk_buff *, int);
-static int wep_demic(struct ieee80211_key *, struct sk_buff *, int);
+static int wep_demic(struct ieee80211_key *, struct sk_buff *, int, int);
 
 static const struct ieee80211_cipher wep = {
 	.ic_name	= "WEP",
@@ -244,7 +244,7 @@
  * Verify and strip MIC from the frame.
  */
 static int
-wep_demic(struct ieee80211_key *k, struct sk_buff *skb, int hdrlen)
+wep_demic(struct ieee80211_key *k, struct sk_buff *skb, int hdrlen, int force)
 {
 	return 1;
 }
Index: madwifi-ng-r2420-20070602/net80211/ieee80211_input.c
===================================================================
--- madwifi-ng-r2420-20070602.orig/net80211/ieee80211_input.c	2007-06-04 13:21:58.897022960 +0200
+++ madwifi-ng-r2420-20070602/net80211/ieee80211_input.c	2007-06-04 13:21:59.137986328 +0200
@@ -632,7 +632,7 @@
 		 * Next strip any MSDU crypto bits.
 		 */
 		if (key != NULL &&
-		    !ieee80211_crypto_demic(vap, key, skb, hdrspace)) {
+		    !ieee80211_crypto_demic(vap, key, skb, hdrspace, 0)) {
 			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,
 				ni->ni_macaddr, "data", "%s", "demic error");
 			IEEE80211_NODE_STAT(ni, rx_demicfail);
@@ -3730,6 +3730,47 @@
 }
 #endif
 
+/*
+ * Process a frame w/ hw detected MIC failure. 
+ * The frame will be dropped in any case.
+ */
+void
+ieee80211_check_mic(struct ieee80211_node *ni, struct sk_buff *skb)
+{
+	struct ieee80211vap *vap = ni->ni_vap;
+
+	struct ieee80211_frame *wh;
+	struct ieee80211_key *key;
+	int hdrspace;
+	struct ieee80211com *ic = vap->iv_ic;
+	
+	if (skb->len < sizeof(struct ieee80211_frame_min)) {
+		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,
+		    ni->ni_macaddr, NULL,
+		    "too short (1): len %u", skb->len);
+		vap->iv_stats.is_rx_tooshort++;
+		return;
+	}
+
+	wh = (struct ieee80211_frame *)skb->data;
+		
+	hdrspace = ieee80211_hdrspace(ic, wh);
+	key = ieee80211_crypto_decap(ni, skb, hdrspace);
+	if (key == NULL) {
+		/* NB: stats+msgs handled in crypto_decap */
+		IEEE80211_NODE_STAT(ni, rx_wepfail);
+		return;
+	}
+
+	if (!ieee80211_crypto_demic(vap, key, skb, hdrspace, 1)) {
+		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,
+			ni->ni_macaddr, "data", "%s", "demic error");
+			IEEE80211_NODE_STAT(ni, rx_demicfail);
+	}
+	return;
+}
+EXPORT_SYMBOL(ieee80211_check_mic);
+
 #ifdef IEEE80211_DEBUG
 /*
  * Debugging support.
Index: madwifi-ng-r2420-20070602/net80211/ieee80211_proto.h
===================================================================
--- madwifi-ng-r2420-20070602.orig/net80211/ieee80211_proto.h	2007-06-04 13:21:58.134138936 +0200
+++ madwifi-ng-r2420-20070602/net80211/ieee80211_proto.h	2007-06-04 13:21:59.137986328 +0200
@@ -91,6 +91,7 @@
 void ieee80211_set11gbasicrates(struct ieee80211_rateset *, enum ieee80211_phymode);
 enum ieee80211_phymode ieee80211_get11gbasicrates(struct ieee80211_rateset *);
 void ieee80211_send_pspoll(struct ieee80211_node *);
+void ieee80211_check_mic(struct ieee80211_node *, struct sk_buff *);
 
 /*
  * Return the size of the 802.11 header for a management or data frame.
Index: madwifi-ng-r2420-20070602/net80211/ieee80211_linux.c
===================================================================
--- madwifi-ng-r2420-20070602.orig/net80211/ieee80211_linux.c	2007-06-04 13:21:57.745198064 +0200
+++ madwifi-ng-r2420-20070602/net80211/ieee80211_linux.c	2007-06-04 13:21:59.137986328 +0200
@@ -291,8 +291,8 @@
 	/* TODO: needed parameters: count, keyid, key type, src address, TSC */
 	snprintf(buf, sizeof(buf), "%s(keyid=%d %scast addr=%s)", tag,
 		k->wk_keyix,
-		IEEE80211_IS_MULTICAST(wh->i_addr1) ?  "broad" : "uni",
-		ether_sprintf(wh->i_addr1));
+		IEEE80211_IS_MULTICAST(wh->i_addr2) ?  "broad" : "uni",
+		ether_sprintf(wh->i_addr2));
 	memset(&wrqu, 0, sizeof(wrqu));
 	wrqu.data.length = strlen(buf);
 	wireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);
