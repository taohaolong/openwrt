Index: madwifi-dfs-r3252/ath/if_ath.c
===================================================================
--- madwifi-dfs-r3252.orig/ath/if_ath.c	2008-01-26 06:36:36.889082972 +0100
+++ madwifi-dfs-r3252/ath/if_ath.c	2008-01-26 06:41:35.670109540 +0100
@@ -3082,46 +3082,44 @@
 {
 	struct ath_buf* bf = NULL;
 	ATH_TXBUF_LOCK_ASSERT(sc);
+
 	/* Reserve at least ATH_TXBUF_MGT_RESERVED buffers for management frames */
-	if (ath_get_buffers_available() <= ATH_TXBUF_MGT_RESERVED) {
+	if (!for_management && (ath_get_buffers_available() <= ATH_TXBUF_MGT_RESERVED)) {
 		/* Stop the queue, we are full */
 		DPRINTF(sc, ATH_DEBUG_XMIT, "%s: stopping queuing of additional "
 					    "frames.  Insufficient free "
 					    "buffers.\n", __func__);
 		sc->sc_stats.ast_tx_qstop++;
-		netif_stop_queue(sc->sc_dev);
-		sc->sc_devstopped = 1;
 		ATH_SCHEDULE_TQUEUE(&sc->sc_txtq, NULL);
+		return NULL;
 	}
 
 	/* Only let us go further if management frame, or there are enough */
-	if (for_management || (ath_get_buffers_available() > ATH_TXBUF_MGT_RESERVED)) {
-		bf = STAILQ_FIRST(&sc->sc_txbuf);
-		if (bf) {
-			STAILQ_REMOVE_HEAD(&sc->sc_txbuf, bf_list);
-			/* This should be redundant, unless someone illegally 
-			 * accessed the buffer after returning it. */
+	bf = STAILQ_FIRST(&sc->sc_txbuf);
+	if (bf) {
+		STAILQ_REMOVE_HEAD(&sc->sc_txbuf, bf_list);
+		/* This should be redundant, unless someone illegally 
+		 * accessed the buffer after returning it. */
 #ifdef IEEE80211_DEBUG_REFCNT
-			cleanup_ath_buf_debug(sc, bf, BUS_DMA_TODEVICE, func, line);
+		cleanup_ath_buf_debug(sc, bf, BUS_DMA_TODEVICE, func, line);
 #else
-			cleanup_ath_buf(sc, bf, BUS_DMA_TODEVICE);
+		cleanup_ath_buf(sc, bf, BUS_DMA_TODEVICE);
 #endif
-			atomic_inc(&ath_buf_counter);
+		atomic_inc(&ath_buf_counter);
 #ifdef IEEE80211_DEBUG_REFCNT
-			DPRINTF(sc, ATH_DEBUG_TXBUF, 
-				"[TXBUF=%03d/%03d] %s:%d -> %s:%d took txbuf %p.\n", 
-				ath_get_buffer_count(), ATH_TXBUF,
-				func, line, __func__, __LINE__,
-				bf);
+		DPRINTF(sc, ATH_DEBUG_TXBUF, 
+			"[TXBUF=%03d/%03d] %s:%d -> %s:%d took txbuf %p.\n", 
+			ath_get_buffer_count(), ATH_TXBUF,
+			func, line, __func__, __LINE__,
+			bf);
 #endif
-		}
-		else {
-			DPRINTF(sc, ATH_DEBUG_ANY, 
-				"%s: discard %s, no xmit buffers available.\n", 
-				__func__,
-				for_management ? "management frame" : "frame");
-			sc->sc_stats.ast_tx_nobuf++;
-		}
+	}
+	else {
+		DPRINTF(sc, ATH_DEBUG_ANY, 
+			"%s: discard %s, no xmit buffers available.\n", 
+			__func__,
+			for_management ? "management frame" : "frame");
+		sc->sc_stats.ast_tx_nobuf++;
 	}
 
 	return bf;
@@ -3503,9 +3501,6 @@
 	/* Pass control of the skb to the caller (i.e., resources are their 
 	 * problem). */
 	if (requeue) {
-		/* queue is full, let the kernel backlog the skb */
-		netif_stop_queue(dev);
-		sc->sc_devstopped = 1;
 		/* Stop tracking again we are giving it back*/
 		ieee80211_skb_untrack(skb);
 		return NETDEV_TX_BUSY;
@@ -12871,21 +12866,6 @@
 		ath_get_buffer_count(), ATH_TXBUF,
 		func, line, __func__, __LINE__, bfaddr);
 #endif /* #ifdef IEEE80211_DEBUG_REFCNT */
-	if (sc->sc_devstopped) {
-		++sc->sc_reapcount;
-		if (sc->sc_reapcount > ATH_TXBUF_FREE_THRESHOLD) {
-			if (!ath_radio_silence_required_for_dfs(sc)) {
-				netif_start_queue(sc->sc_dev);
-				DPRINTF(sc, ATH_DEBUG_ANY,
-				    "%s: restarting queue.\n",
-				    __func__);
-			}
-			sc->sc_reapcount = 0;
-			sc->sc_devstopped = 0;
-		}
-		else if (!ath_radio_silence_required_for_dfs(sc))
-			ATH_SCHEDULE_TQUEUE(&sc->sc_txtq, NULL);
-	}
 
 	*bf = NULL;
 }
Index: madwifi-dfs-r3252/ath/if_athvar.h
===================================================================
--- madwifi-dfs-r3252.orig/ath/if_athvar.h	2008-01-26 06:41:42.206482027 +0100
+++ madwifi-dfs-r3252/ath/if_athvar.h	2008-01-26 06:41:46.646735062 +0100
@@ -667,7 +667,6 @@
 	unsigned int	sc_xrgrppoll:1;		/* xr group polls are active */
 	unsigned int	sc_syncbeacon:1;	/* sync/resync beacon timers */
 	unsigned int	sc_hasclrkey:1;		/* CLR key supported */
-	unsigned int	sc_devstopped:1;	/* stopped due to of no tx bufs */
 	unsigned int	sc_stagbeacons:1;	/* use staggered beacons */
 	unsigned int	sc_dfswait:1;		/* waiting on channel for radar detect */
 	unsigned int	sc_ackrate:1;		/* send acks at high bitrate */
