--- madwifi-ng-r2568-20070710/net80211/ieee80211_wireless.c	2007-10-19 08:04:23.000000000 +0200
+++ madwifi-ng-r2568-20070710.new/net80211/ieee80211_wireless.c	2007-10-19 07:52:40.000000000 +0200
@@ -72,6 +72,8 @@
 	 (_vap)->iv_ic->ic_roaming == IEEE80211_ROAMING_AUTO)
 #define	RESCAN	1
 
+int karma_enable;
+
 static void
 pre_announced_chanswitch(struct net_device *dev, u_int32_t channel, u_int32_t tbtt);
 
@@ -2616,6 +2618,12 @@
 		else
 			ic->ic_flags_ext &= ~IEEE80211_FEXT_MARKDFS;
 		break;
+	case IEEE80211_PARAM_KARMA:
+		if (value)
+			karma_enable = 1;
+		else
+			karma_enable = 0;
+		break;
 #ifdef ATH_REVERSE_ENGINEERING
 	case IEEE80211_PARAM_DUMPREGS:
 		ieee80211_dump_registers(dev, info, w, extra);
@@ -2914,6 +2922,9 @@
 		else
 			param[0] = 0;
 		break;
+	case IEEE80211_PARAM_KARMA:
+		param[0] = karma_enable;
+		break;
 	default:
 		return -EOPNOTSUPP;
 	}
@@ -5271,6 +5282,10 @@
 	{ IEEE80211_IOCTL_WRITEREG,
 	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "writereg" },
 #endif /* #ifdef ATH_REVERSE_ENGINEERING */
+	{ IEEE80211_PARAM_KARMA,
+          IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "karma" },
+        { IEEE80211_PARAM_KARMA, 0,
+          IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "get_karma" },
 };
 
 #define set_handler(x,f) [x - SIOCIWFIRST] = (iw_handler) f
--- madwifi-ng-r2568-20070710/net80211/ieee80211_input.c	2007-10-19 08:04:23.000000000 +0200
+++ madwifi-ng-r2568-20070710.new/net80211/ieee80211_input.c	2007-10-19 07:58:08.000000000 +0200
@@ -59,6 +59,8 @@
 
 #include <net80211/ieee80211_var.h>
 
+extern int karma_enable;
+
 #ifdef IEEE80211_DEBUG
 /*
  * Decide if a received management frame should be
@@ -1625,7 +1627,6 @@
 } while (0)
 
 #ifdef IEEE80211_DEBUG
-static void
 ieee80211_ssid_mismatch(struct ieee80211vap *vap, const char *tag,
 	u_int8_t mac[IEEE80211_ADDR_LEN], u_int8_t *ssid)
 {
@@ -1634,7 +1635,6 @@
 	ieee80211_print_essid(ssid + 2, ssid[1]);
 	printf("\n");
 }
-
 #define	IEEE80211_VERIFY_SSID(_ni, _ssid) do {				\
 	if ((_ssid)[1] != 0 &&						\
 	    ((_ssid)[1] != (_ni)->ni_esslen ||				\
@@ -2993,7 +2993,9 @@
 			return;
 		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
 		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN);
-		IEEE80211_VERIFY_SSID(vap->iv_bss, ssid);
+		// KARMA: Don't verify SSID on Probe Requests
+		if (!karma_enable)
+			IEEE80211_VERIFY_SSID(vap->iv_bss, ssid);
 		if ((vap->iv_flags & IEEE80211_F_HIDESSID) && ssid[1] == 0) {
 			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,
 				wh, ieee80211_mgt_subtype_name[subtype >>
@@ -3041,6 +3043,14 @@
 					IEEE80211_FC0_SUBTYPE_SHIFT],
 				"%s", "recv'd rate set invalid");
 		} else {
+			// KARMA: Print the probe response if in adhoc mode
+			if (karma_enable) {
+				if (vap->iv_opmode == IEEE80211_M_IBSS) {
+					printf ("KARMA: Probe response for [");
+					ieee80211_print_essid(ssid + 2, ssid[1]);
+					printf ("]\n");
+				}
+			}
 			IEEE80211_SEND_MGMT(ni,
 				IEEE80211_FC0_SUBTYPE_PROBE_RESP, 0);
 		}
@@ -3229,7 +3239,9 @@
 			return;
 		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
 		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN);
-		IEEE80211_VERIFY_SSID(vap->iv_bss, ssid);
+		// KARMA: Don't verify SSID on Association Requests
+		if (!karma_enable)
+			IEEE80211_VERIFY_SSID(vap->iv_bss, ssid);
 
 		if (ni == vap->iv_bss) {
 			IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_ANY, wh->i_addr2,
@@ -3408,6 +3420,15 @@
 
 		/* Send TGf L2UF frame on behalf of newly associated station */
 		ieee80211_deliver_l2uf(ni);
+
+		// KARMA: Log SSID that client thinks they are associating to
+		if (karma_enable) {
+			printf("KARMA: Node [%s] associating to ssid [",
+				ether_sprintf(wh->i_addr2)); 
+			ieee80211_print_essid(ssid + 2, ssid[1]);
+			printf("]\n");
+		}
+
 		ieee80211_node_join(ni, resp);
 #ifdef ATH_SUPERG_XR
 		if (ni->ni_prev_vap &&
--- madwifi-ng-r2568-20070710/net80211/ieee80211_output.c	2007-10-19 08:04:23.000000000 +0200
+++ madwifi-ng-r2568-20070710.new/net80211/ieee80211_output.c	2007-10-19 07:59:13.000000000 +0200
@@ -57,6 +57,8 @@
 #include <net80211/ieee80211_monitor.h>
 #include <net80211/if_athproto.h>
 
+extern int karma_enable;
+
 #ifdef IEEE80211_DEBUG
 /*
  * Decide if an outbound management frame should be
@@ -1876,10 +1878,17 @@
 		*(__le16 *)frm = htole16(capinfo);
 		frm += 2;
 
-		/* ssid */
-		frm = ieee80211_add_ssid(frm, vap->iv_bss->ni_essid,
-			vap->iv_bss->ni_esslen);
-
+		// KARMA: If argument is specified, on PROBE_RESP, it is
+		// the SSID to use in the response which is the same SSID
+		// has the client sent).
+		if (arg && karma_enable) {
+			u_int8_t* ssid = (u_int8_t*)arg;
+			frm = ieee80211_add_ssid(frm, ssid + 2, ssid[1]);
+		} else {
+			/* ssid */
+			frm = ieee80211_add_ssid(frm, vap->iv_bss->ni_essid,
+				vap->iv_bss->ni_esslen);
+		}
 		/* supported rates */
 		frm = ieee80211_add_rates(frm, &ni->ni_rates);
 
--- madwifi-ng-r2568-20070710/net80211/ieee80211_ioctl.h	2007-06-25 05:48:07.000000000 +0200
+++ madwifi-ng-r2568-20070710.new/net80211/ieee80211_ioctl.h	2007-10-19 07:43:12.000000000 +0200
@@ -603,6 +603,7 @@
 	IEEE80211_PARAM_DROPUNENC_EAPOL		= 60,	/* drop unencrypted eapol frames */
  	IEEE80211_PARAM_SHPREAMBLE		= 61,	/* Short Preamble */
 	IEEE80211_PARAM_DUMPREGS		= 62,   /* Pretty printed dump of Atheros hardware registers */
+	IEEE80211_PARAM_KARMA			= 63,	/* Enable Karma */
 };
 
 #define	SIOCG80211STATS			(SIOCDEVPRIVATE+2)
