diff -ur madwifi.old/ath/if_ath.c madwifi.dev/ath/if_ath.c
--- madwifi.old/ath/if_ath.c	2007-05-15 16:26:02.721036296 +0200
+++ madwifi.dev/ath/if_ath.c	2007-05-16 15:43:23.095362056 +0200
@@ -1711,6 +1711,7 @@
 			} 
 #endif
 			ATH_SCHEDULE_TQUEUE(&sc->sc_txtq, &needmark);
+			sc->sc_tx_start = 0;
 		}
 		if (status & HAL_INT_BMISS) {
 			sc->sc_stats.ast_bmiss++;
@@ -2261,6 +2262,25 @@
 		txq->axq_link = &lastds->ds_link;
 		ath_hal_txstart(ah, txq->axq_qnum);
 		sc->sc_dev->trans_start = jiffies;
+		if ((sc->sc_opmode == HAL_M_IBSS) || (sc->sc_opmode == HAL_M_HOSTAP)) {
+			unsigned long last;
+			ATH_LOCK(sc);
+			last = sc->sc_tx_start;
+			ATH_UNLOCK(sc);
+			if (last) {
+				if (jiffies > last + 2 * HZ) {
+					printk("%s: Tx queue stuck. Resetting hardware...\n", sc->sc_dev->name);
+					ath_reset(sc->sc_dev);
+					ATH_LOCK(sc);
+					sc->sc_tx_start = 0;
+					ATH_UNLOCK(sc);
+				}
+			} else {
+				ATH_LOCK(sc);
+				sc->sc_tx_start = jiffies;
+				ATH_UNLOCK(sc);
+			}
+		}
 	}
 	ATH_TXQ_UNLOCK(txq);
 
@@ -7289,6 +7309,10 @@
 			break;
 		}
 
+		ATH_LOCK(sc);
+		sc->sc_tx_start = 0;
+		ATH_UNLOCK(sc);
+
 #ifdef ATH_SUPERG_FF
 		ds = &bf->bf_desc[bf->bf_numdescff];
 		DPRINTF(sc, ATH_DEBUG_TX_PROC, "%s: frame's last desc: %p\n",
diff -ur madwifi.old/ath/if_athvar.h madwifi.dev/ath/if_athvar.h
--- madwifi.old/ath/if_athvar.h	2007-05-04 23:09:29.000000000 +0200
+++ madwifi.dev/ath/if_athvar.h	2007-05-15 16:26:28.911054808 +0200
@@ -689,6 +689,14 @@
 #endif
 	u_int sc_slottimeconf;			/* manual override for slottime */
 	int16_t sc_channoise; 			/* Measured noise of current channel (dBm) */
+
+	/* 
+	 * Several MiniPCI cards and most SoC revs frequently cease all transmission
+	 * when operating in IBSS mode. The reason for this is unknown and could potentially
+	 * be a hardware bug. This variable contains the timestamp of the last successful
+	 * transmission and is checked when enqueueing new frames
+	 */
+	unsigned long sc_tx_start;
 };
 
 typedef void (*ath_callback) (struct ath_softc *);
