Index: madwifi-trunk-r3280/ath/if_ath.c
===================================================================
--- madwifi-trunk-r3280.orig/ath/if_ath.c	2008-01-28 17:29:22.989895792 +0100
+++ madwifi-trunk-r3280/ath/if_ath.c	2008-01-28 20:00:09.319637124 +0100
@@ -184,7 +184,7 @@
 	struct sk_buff *, int, int, u_int64_t);
 static void ath_setdefantenna(struct ath_softc *, u_int);
 static struct ath_txq *ath_txq_setup(struct ath_softc *, int, int);
-static void ath_rx_tasklet(TQUEUE_ARG);
+static int ath_rx_poll(struct net_device *dev, int *budget);
 static int ath_hardstart(struct sk_buff *, struct net_device *);
 static int ath_mgtstart(struct ieee80211com *, struct sk_buff *);
 #ifdef ATH_SUPERG_COMP
@@ -542,7 +542,6 @@
 	ATH_TXBUF_LOCK_INIT(sc);
 	ATH_RXBUF_LOCK_INIT(sc);
 
-	ATH_INIT_TQUEUE(&sc->sc_rxtq,     ath_rx_tasklet,	dev);
 	ATH_INIT_TQUEUE(&sc->sc_txtq,	  ath_tx_tasklet,	dev);
 	ATH_INIT_TQUEUE(&sc->sc_bmisstq,  ath_bmiss_tasklet,	dev);
 	ATH_INIT_TQUEUE(&sc->sc_bstucktq, ath_bstuck_tasklet,	dev);
@@ -816,6 +815,8 @@
 	dev->set_mac_address = ath_set_mac_address;
 	dev->change_mtu = ath_change_mtu;
 	dev->tx_queue_len = ATH_TXBUF - ATH_TXBUF_MGT_RESERVED;
+	dev->poll = ath_rx_poll;
+	dev->weight = 64;
 #ifdef USE_HEADERLEN_RESV
 	dev->hard_header_len += sizeof(struct ieee80211_qosframe) +
 				sizeof(struct llc) +
@@ -2206,6 +2207,7 @@
 		(status & HAL_INT_GLOBAL)	? " HAL_INT_GLOBAL"	: ""
 		);
 
+	sc->sc_isr = status;
 	status &= sc->sc_imask;			/* discard unasked for bits */
 	/* As soon as we know we have a real interrupt we intend to service, 
 	 * we will check to see if we need an initial hardware TSF reading. 
@@ -2263,7 +2265,14 @@
 		}
 		if (status & (HAL_INT_RX | HAL_INT_RXPHY)) {
 			ath_uapsd_processtriggers(sc, hw_tsf);
-			ATH_SCHEDULE_TQUEUE(&sc->sc_rxtq, &needmark);
+			sc->sc_isr &= ~HAL_INT_RX;
+			if (netif_rx_schedule_prep(dev)) {
+#ifndef ATH_PRECISE_TSF
+				sc->sc_imask &= ~HAL_INT_RX;
+				ath_hal_intrset(ah, sc->sc_imask);
+#endif
+				__netif_rx_schedule(dev);
+			}
 		}
 		if (status & HAL_INT_TX) {
 #ifdef ATH_SUPERG_DYNTURBO
@@ -2289,6 +2298,11 @@
 				}
 			}
 #endif
+			/* disable transmit interrupt */
+			sc->sc_isr &= ~HAL_INT_TX;
+			ath_hal_intrset(ah, sc->sc_imask & ~HAL_INT_TX);
+			sc->sc_imask &= ~HAL_INT_TX;
+
 			ATH_SCHEDULE_TQUEUE(&sc->sc_txtq, &needmark);
 		}
 		if (status & HAL_INT_BMISS) {
@@ -4011,10 +4025,10 @@
 	 *
 	 * XXX Using in_softirq is not right since we might
 	 * be called from other soft irq contexts than
-	 * ath_rx_tasklet.
+	 * ath_rx_poll
 	 */
 	if (!in_softirq())
-		tasklet_disable(&sc->sc_rxtq);
+		netif_poll_disable(dev);
 	netif_stop_queue(dev);
 }
 
@@ -4027,7 +4041,7 @@
 	DPRINTF(sc, ATH_DEBUG_KEYCACHE, "End\n");
 	netif_wake_queue(dev);
 	if (!in_softirq())		/* NB: see above */
-		tasklet_enable(&sc->sc_rxtq);
+		netif_poll_enable(dev);
 }
 
 /*
@@ -6329,13 +6343,12 @@
 	sc->sc_rxotherant = 0;
 }
 
-static void
-ath_rx_tasklet(TQUEUE_ARG data)
+static int
+ath_rx_poll(struct net_device *dev, int *budget)
 {
 #define	PA2DESC(_sc, _pa) \
 	((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \
 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
-	struct net_device *dev = (struct net_device *)data;
 	struct ath_buf *bf;
 	struct ath_softc *sc = dev->priv;
 	struct ieee80211com *ic = &sc->sc_ic;
@@ -6347,8 +6360,11 @@
 	unsigned int len;
 	int type;
 	u_int phyerr;
+	u_int processed = 0, early_stop = 0;
+	u_int rx_limit = dev->quota;
 
 	DPRINTF(sc, ATH_DEBUG_RX_PROC, "invoked\n");
+process_rx_again:
 	do {
 		bf = STAILQ_FIRST(&sc->sc_rxbuf);
 		if (bf == NULL) {		/* XXX ??? can this happen */
@@ -6372,6 +6388,13 @@
 			/* NB: never process the self-linked entry at the end */
 			break;
 		}
+
+		processed++;
+		if (rx_limit-- < 0) {
+			early_stop = 1;
+			break;
+		}
+
 		skb = bf->bf_skb;
 		if (skb == NULL) {
 			EPRINTF(sc, "Dropping; buffer contains NULL skbuff.\n");
@@ -6419,6 +6442,7 @@
 				sc->sc_stats.ast_rx_phyerr++;
 				phyerr = rs->rs_phyerr & 0x1f;
 				sc->sc_stats.ast_rx_phy[phyerr]++;
+				goto rx_next;
 			}
 			if (rs->rs_status & HAL_RXERR_DECRYPT) {
 				/*
@@ -6614,9 +6638,35 @@
 		STAILQ_INSERT_TAIL(&sc->sc_rxbuf, bf, bf_list);
 		ATH_RXBUF_UNLOCK_IRQ(sc);
 	} while (ath_rxbuf_init(sc, bf) == 0);
+	if (!early_stop) {
+		unsigned long flags;
+		/* Check if more data is received while we were
+		 * processing the descriptor chain.
+		 */
+#ifndef ATH_PRECISE_TSF
+		local_irq_save(flags);
+		if (sc->sc_isr & HAL_INT_RX) {
+			u_int64_t hw_tsf = ath_hal_gettsf64(ah);
+			sc->sc_isr &= ~HAL_INT_RX;
+			local_irq_restore(flags);
+			ath_uapsd_processtriggers(sc, hw_tsf);
+			goto process_rx_again;
+		}
+#endif
+		netif_rx_complete(dev);
+
+#ifndef ATH_PRECISE_TSF
+		sc->sc_imask |= HAL_INT_RX;
+		ath_hal_intrset(ah, sc->sc_imask);
+		local_irq_restore(flags);
+#endif
+	}
+
+	*budget -= processed;
 
 	/* rx signal state monitoring */
 	ath_hal_rxmonitor(ah, &sc->sc_halstats, &sc->sc_curchan);
+	return early_stop;
 #undef PA2DESC
 }
 
@@ -8267,12 +8317,24 @@
 {
 	struct net_device *dev = (struct net_device *)data;
 	struct ath_softc *sc = dev->priv;
+	unsigned long flags;
 
+process_tx_again:
 	if (txqactive(sc->sc_ah, 0))
 		ath_tx_processq(sc, &sc->sc_txq[0]);
 	if (txqactive(sc->sc_ah, sc->sc_cabq->axq_qnum))
 		ath_tx_processq(sc, sc->sc_cabq);
 
+	local_irq_save(flags);
+	if (sc->sc_isr & HAL_INT_TX) {
+		sc->sc_isr &= ~HAL_INT_TX;
+		local_irq_restore(flags);
+		goto process_tx_again;
+	}
+	sc->sc_imask |= HAL_INT_TX;
+	ath_hal_intrset(sc->sc_ah, sc->sc_imask);
+	local_irq_restore(flags);
+
 	netif_wake_queue(dev);
 
 	if (sc->sc_softled)
@@ -8288,7 +8350,9 @@
 {
 	struct net_device *dev = (struct net_device *)data;
 	struct ath_softc *sc = dev->priv;
+	unsigned long flags;
 
+process_tx_again:
 	/*
 	 * Process each active queue.
 	 */
@@ -8309,6 +8373,16 @@
 	if (sc->sc_uapsdq && txqactive(sc->sc_ah, sc->sc_uapsdq->axq_qnum))
 		ath_tx_processq(sc, sc->sc_uapsdq);
 
+	local_irq_save(flags);
+	if (sc->sc_isr & HAL_INT_TX) {
+		sc->sc_isr &= ~HAL_INT_TX;
+		local_irq_restore(flags);
+		goto process_tx_again;
+	}
+	sc->sc_imask |= HAL_INT_TX;
+	ath_hal_intrset(sc->sc_ah, sc->sc_imask);
+	local_irq_restore(flags);
+
 	netif_wake_queue(dev);
 
 	if (sc->sc_softled)
@@ -8324,13 +8398,25 @@
 	struct net_device *dev = (struct net_device *)data;
 	struct ath_softc *sc = dev->priv;
 	unsigned int i;
+	unsigned long flags;
 
 	/* Process each active queue. This includes sc_cabq, sc_xrtq and
 	 * sc_uapsdq */
+process_tx_again:
 	for (i = 0; i < HAL_NUM_TX_QUEUES; i++)
 		if (ATH_TXQ_SETUP(sc, i) && txqactive(sc->sc_ah, i))
 			ath_tx_processq(sc, &sc->sc_txq[i]);
 
+	local_irq_save(flags);
+	if (sc->sc_isr & HAL_INT_TX) {
+		sc->sc_isr &= ~HAL_INT_TX;
+		local_irq_restore(flags);
+		goto process_tx_again;
+	}
+	sc->sc_imask |= HAL_INT_TX;
+	ath_hal_intrset(sc->sc_ah, sc->sc_imask);
+	local_irq_restore(flags);
+
 	netif_wake_queue(dev);
 
 	if (sc->sc_softled)
@@ -8405,6 +8491,7 @@
 ath_draintxq(struct ath_softc *sc)
 {
 	struct ath_hal *ah = sc->sc_ah;
+	int npend = 0;
 	unsigned int i;
 
 	/* XXX return value */
@@ -10261,9 +10348,9 @@
 	dev->mtu = mtu;
 	if ((dev->flags & IFF_RUNNING) && !sc->sc_invalid) {
 		/* NB: the rx buffers may need to be reallocated */
-		tasklet_disable(&sc->sc_rxtq);
+		netif_poll_disable(dev);
 		error = ath_reset(dev);
-		tasklet_enable(&sc->sc_rxtq);
+		netif_poll_enable(dev);
 	}
 	ATH_UNLOCK(sc);
 
Index: madwifi-trunk-r3280/ath/if_athvar.h
===================================================================
--- madwifi-trunk-r3280.orig/ath/if_athvar.h	2008-01-28 17:29:22.997896245 +0100
+++ madwifi-trunk-r3280/ath/if_athvar.h	2008-01-28 17:45:06.903383316 +0100
@@ -50,6 +50,10 @@
 #include <asm/io.h>
 #include <linux/list.h>
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define irqs_disabled()			0
+#endif
+
 /*
  * Deduce if tasklets are available.  If not then
  * fall back to using the immediate work queue.
@@ -728,7 +732,6 @@
 	struct ath_buf *sc_rxbufcur;		/* current rx buffer */
 	u_int32_t *sc_rxlink;			/* link ptr in last RX desc */
 	spinlock_t sc_rxbuflock;
-	struct ATH_TQ_STRUCT sc_rxtq;		/* rx intr tasklet */
 	struct ATH_TQ_STRUCT sc_rxorntq;	/* rxorn intr tasklet */
 	u_int8_t sc_defant;			/* current default antenna */
 	u_int8_t sc_rxotherant;			/* RXs on non-default antenna */
@@ -741,6 +744,7 @@
 	u_int sc_txintrperiod;			/* tx interrupt batching */
 	struct ath_txq sc_txq[HAL_NUM_TX_QUEUES];
 	struct ath_txq *sc_ac2q[WME_NUM_AC];	/* WME AC -> h/w qnum */
+	HAL_INT sc_isr;				/* unmasked ISR state */
 	struct ATH_TQ_STRUCT sc_txtq;		/* tx intr tasklet */
 	u_int8_t sc_grppoll_str[GRPPOLL_RATE_STR_LEN];
 	struct ath_descdma sc_bdma;		/* beacon descriptors */
@@ -854,6 +858,8 @@
 #define	ATH_TXBUF_LOCK_CHECK(_sc)
 #endif
 
+#define ATH_DISABLE_INTR		local_irq_disable
+#define ATH_ENABLE_INTR 		local_irq_enable
 
 #define	ATH_RXBUF_LOCK_INIT(_sc)	spin_lock_init(&(_sc)->sc_rxbuflock)
 #define	ATH_RXBUF_LOCK_DESTROY(_sc)
Index: madwifi-trunk-r3280/net80211/ieee80211_input.c
===================================================================
--- madwifi-trunk-r3280.orig/net80211/ieee80211_input.c	2008-01-28 17:29:23.005896702 +0100
+++ madwifi-trunk-r3280/net80211/ieee80211_input.c	2008-01-28 19:52:50.586635164 +0100
@@ -1197,7 +1197,7 @@
 			/* attach vlan tag */
 			struct ieee80211_node *ni_tmp = SKB_CB(skb)->ni;
 			if (vlan_hwaccel_receive_skb(skb, vap->iv_vlgrp, ni->ni_vlan) == NET_RX_DROP) {
-				/* If netif_rx dropped the packet because 
+				/* If netif_receive_skb dropped the packet because
 				 * device was too busy */
 				if (ni_tmp != NULL) {
 					/* node reference was leaked */
@@ -1208,8 +1208,8 @@
 			skb = NULL; /* SKB is no longer ours */
 		} else {
 			struct ieee80211_node *ni_tmp = SKB_CB(skb)->ni;
-			if (netif_rx(skb) == NET_RX_DROP) {
-				/* If netif_rx dropped the packet because 
+			if (netif_receive_skb(skb) == NET_RX_DROP) {
+				/* If netif_receive_skb dropped the packet because
 				 * device was too busy */
 				if (ni_tmp != NULL) {
 					/* node reference was leaked */
@@ -2314,8 +2314,8 @@
 		skb1->protocol = __constant_htons(0x0019);  /* ETH_P_80211_RAW */
 
 		ni_tmp = SKB_CB(skb1)->ni;
-		if (netif_rx(skb1) == NET_RX_DROP) {
-			/* If netif_rx dropped the packet because 
+		if (netif_receive_skb(skb1) == NET_RX_DROP) {
+			/* If netif_receive_skb dropped the packet because
 			 * device was too busy */
 			if (ni_tmp != NULL) {
 				/* node reference was leaked */
Index: madwifi-trunk-r3280/net80211/ieee80211_monitor.c
===================================================================
--- madwifi-trunk-r3280.orig/net80211/ieee80211_monitor.c	2008-01-28 17:29:23.013897159 +0100
+++ madwifi-trunk-r3280/net80211/ieee80211_monitor.c	2008-01-28 17:29:26.430091834 +0100
@@ -584,8 +584,8 @@
 			skb1->protocol = 
 				__constant_htons(0x0019); /* ETH_P_80211_RAW */
 
-			if (netif_rx(skb1) == NET_RX_DROP) {
-				/* If netif_rx dropped the packet because 
+			if (netif_receive_skb(skb1) == NET_RX_DROP) {
+				/* If netif_receive_skb dropped the packet because
 				 * device was too busy, reclaim the ref. in 
 				 * the skb. */
 				if (SKB_CB(skb1)->ni != NULL)
Index: madwifi-trunk-r3280/net80211/ieee80211_skb.c
===================================================================
--- madwifi-trunk-r3280.orig/net80211/ieee80211_skb.c	2008-01-28 17:29:23.017897384 +0100
+++ madwifi-trunk-r3280/net80211/ieee80211_skb.c	2008-01-28 17:29:26.446092748 +0100
@@ -73,7 +73,7 @@
 #undef dev_queue_xmit
 #undef kfree_skb
 #undef kfree_skb_fast
-#undef netif_rx
+#undef netif_receive_skb
 #undef pskb_copy
 #undef skb_clone
 #undef skb_copy
@@ -638,8 +638,8 @@
 		grp, vlan_tag);
 }
 
-int netif_rx_debug(struct sk_buff *skb, const char* func, int line) {
-	return netif_rx(untrack_skb(skb, 0, func, line, __func__, __LINE__));
+int netif_receive_skb_debug(struct sk_buff *skb, const char* func, int line) {
+	return netif_receive_skb(untrack_skb(skb, 0, func, line, __func__, __LINE__));
 }
 
 struct sk_buff * alloc_skb_debug(unsigned int length, gfp_t gfp_mask,
@@ -760,7 +760,7 @@
 }
 
 EXPORT_SYMBOL(vlan_hwaccel_receive_skb_debug);
-EXPORT_SYMBOL(netif_rx_debug);
+EXPORT_SYMBOL(netif_receive_skb_debug);
 EXPORT_SYMBOL(alloc_skb_debug);
 EXPORT_SYMBOL(dev_alloc_skb_debug);
 EXPORT_SYMBOL(skb_clone_debug);
Index: madwifi-trunk-r3280/net80211/ieee80211_skb.h
===================================================================
--- madwifi-trunk-r3280.orig/net80211/ieee80211_skb.h	2008-01-28 17:29:23.029898072 +0100
+++ madwifi-trunk-r3280/net80211/ieee80211_skb.h	2008-01-28 17:29:26.458093432 +0100
@@ -116,7 +116,7 @@
 int  vlan_hwaccel_receive_skb_debug(struct sk_buff *skb, 
 				    struct vlan_group *grp, unsigned short vlan_tag, 
 				    const char* func, int line);
-int netif_rx_debug(struct sk_buff *skb, const char* func, int line);
+int netif_receive_skb_debug(struct sk_buff *skb, const char* func, int line);
 struct sk_buff * alloc_skb_debug(unsigned int length, gfp_t gfp_mask,
 				 const char *func, int line);
 struct sk_buff * dev_alloc_skb_debug(unsigned int length,
@@ -151,7 +151,7 @@
 #undef dev_queue_xmit
 #undef kfree_skb
 #undef kfree_skb_fast
-#undef netif_rx
+#undef netif_receive_skb
 #undef pskb_copy
 #undef skb_clone
 #undef skb_copy
@@ -168,8 +168,8 @@
 	skb_copy_expand_debug(_skb, _newheadroom, _newtailroom, _gfp_mask, __func__, __LINE__)
 #define vlan_hwaccel_receive_skb(_skb, _grp, _tag) \
 	vlan_hwaccel_receive_skb_debug(_skb, _grp, _tag, __func__, __LINE__)
-#define netif_rx(_skb) \
-	netif_rx_debug(_skb, __func__, __LINE__)
+#define netif_receive_skb(_skb) \
+	netif_receive_skb_debug(_skb, __func__, __LINE__)
 #define	alloc_skb(_length, _gfp_mask) \
 	alloc_skb_debug(_length, _gfp_mask, __func__, __LINE__)
 #define	dev_alloc_skb(_length) \
