This patch reflects changes in mdiobus implementation in kernel 2.6.28.
--- a/drivers/net/ar2313/ar2313.c
+++ b/drivers/net/ar2313/ar2313.c
@@ -159,10 +159,10 @@ static void rx_tasklet_func(unsigned lon
 static void rx_tasklet_cleanup(struct net_device *dev);
 static void ar2313_multicast_list(struct net_device *dev);
 
-static int mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum);
-static int mdiobus_write(struct mii_bus *bus, int phy_addr, int regnum, u16 value);
-static int mdiobus_reset(struct mii_bus *bus);
-static int mdiobus_probe (struct net_device *dev);
+static int ar2313_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum);
+static int ar2313_mdiobus_write(struct mii_bus *bus, int phy_addr, int regnum, u16 value);
+static int ar2313_mdiobus_reset(struct mii_bus *bus);
+static int ar2313_mdiobus_probe (struct net_device *dev);
 static void ar2313_adjust_link(struct net_device *dev);
 
 #ifndef ERR
@@ -286,18 +286,22 @@ int __init ar2313_probe(struct platform_
 		   dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
 		   dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5], dev->irq);
 
-	sp->mii_bus.priv = dev;
-	sp->mii_bus.read = mdiobus_read;
-	sp->mii_bus.write = mdiobus_write;
-	sp->mii_bus.reset = mdiobus_reset;
-	sp->mii_bus.name = "ar2313_eth_mii";
-	snprintf(sp->mii_bus.id, MII_BUS_ID_SIZE, "0");
-	sp->mii_bus.irq = kmalloc(sizeof(int), GFP_KERNEL);
-	*sp->mii_bus.irq = PHY_POLL;
+	sp->mii_bus = mdiobus_alloc();
+	if (sp->mii_bus == NULL)
+		return -1;
+
+	sp->mii_bus->priv = dev;
+	sp->mii_bus->read = ar2313_mdiobus_read;
+	sp->mii_bus->write = ar2313_mdiobus_write;
+	sp->mii_bus->reset = ar2313_mdiobus_reset;
+	sp->mii_bus->name = "ar2313_eth_mii";
+	snprintf(sp->mii_bus->id, MII_BUS_ID_SIZE, "0");
+	sp->mii_bus->irq = kmalloc(sizeof(int), GFP_KERNEL);
+	*sp->mii_bus->irq = PHY_POLL;
 
-	mdiobus_register(&sp->mii_bus);
+	mdiobus_register(sp->mii_bus);
 
-	if (mdiobus_probe(dev) != 0) {
+	if (ar2313_mdiobus_probe(dev) != 0) {
 		printk(KERN_ERR "ar2313: mdiobus_probe failed");
 		rx_tasklet_cleanup(dev);
 		ar2313_init_cleanup(dev);
@@ -432,9 +436,12 @@ static void rx_tasklet_cleanup(struct ne
 static int __exit ar2313_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
+	struct ar2313_private *sp = netdev_priv(dev);
 	rx_tasklet_cleanup(dev);
 	ar2313_init_cleanup(dev);
 	unregister_netdev(dev);
+	mdiobus_unregister(sp->mii_bus);
+	mdiobus_free(sp->mii_bus);
 	kfree(dev);
 	return 0;
 }
@@ -619,7 +626,7 @@ static void ar2313_check_link(struct net
 	struct ar2313_private *sp = netdev_priv(dev);
 	u16 phyData;
 
-	phyData = mdiobus_read(&sp->mii_bus, sp->phy, MII_BMSR);
+	phyData = ar2313_mdiobus_read(sp->mii_bus, sp->phy, MII_BMSR);
 	if (sp->phyData != phyData) {
 		if (phyData & BMSR_LSTATUS) {
 			/* link is present, ready link partner ability to deterine
@@ -628,10 +635,10 @@ static void ar2313_check_link(struct net
 			u16 reg;
 
 			sp->link = 1;
-			reg = mdiobus_read(&sp->mii_bus, sp->phy, MII_BMCR);
+			reg = ar2313_mdiobus_read(sp->mii_bus, sp->phy, MII_BMCR);
 			if (reg & BMCR_ANENABLE) {
 				/* auto neg enabled */
-				reg = mdiobus_read(&sp->mii_bus, sp->phy, MII_LPA);
+				reg = ar2313_mdiobus_read(sp->mii_bus, sp->phy, MII_LPA);
 				duplex = (reg & (LPA_100FULL | LPA_10FULL)) ? 1 : 0;
 			} else {
 				/* no auto neg, just read duplex config */
@@ -1320,7 +1327,7 @@ static void ar2313_adjust_link(struct ne
 	((reg << MII_ADDR_REG_SHIFT) | (phy << MII_ADDR_PHY_SHIFT))
 
 static int
-mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)
+ar2313_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)
 {
 	struct net_device *const dev = bus->priv;
 	struct ar2313_private *sp = netdev_priv(dev);
@@ -1332,7 +1339,7 @@ mdiobus_read(struct mii_bus *bus, int ph
 }
 
 static int
-mdiobus_write(struct mii_bus *bus, int phy_addr, int regnum,
+ar2313_mdiobus_write(struct mii_bus *bus, int phy_addr, int regnum,
              u16 value)
 {
 	struct net_device *const dev = bus->priv;
@@ -1346,7 +1353,7 @@ mdiobus_write(struct mii_bus *bus, int p
 	return 0;
 }
 
-static int mdiobus_reset(struct mii_bus *bus)
+static int ar2313_mdiobus_reset(struct mii_bus *bus)
 {
 	struct net_device *const dev = bus->priv;
 
@@ -1355,7 +1362,7 @@ static int mdiobus_reset(struct mii_bus 
 	return 0;
 }
 
-static int mdiobus_probe (struct net_device *dev)
+static int ar2313_mdiobus_probe (struct net_device *dev)
 {
 	struct ar2313_private *const sp = netdev_priv(dev);
 	struct phy_device *phydev = NULL;
@@ -1363,8 +1370,8 @@ static int mdiobus_probe (struct net_dev
 
 	/* find the first (lowest address) PHY on the current MAC's MII bus */
 	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++)
-		if (sp->mii_bus.phy_map[phy_addr]) {
-			phydev = sp->mii_bus.phy_map[phy_addr];
+		if (sp->mii_bus->phy_map[phy_addr]) {
+			phydev = sp->mii_bus->phy_map[phy_addr];
 			break; /* break out with first one found */
 		}
 
--- a/drivers/net/ar2313/ar2313.h
+++ b/drivers/net/ar2313/ar2313.h
@@ -162,7 +162,7 @@ struct ar2313_private {
 	int unloading;
 
 	struct phy_device *phy_dev;
-	struct mii_bus mii_bus;
+	struct mii_bus *mii_bus;
 	int oldduplex;
 };
 
