diff -urN linux.old/arch/mips/ar531x/ar531x.h linux.dev/arch/mips/ar531x/ar531x.h
--- linux.old/arch/mips/ar531x/ar531x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar531x/ar531x.h	2006-12-16 03:51:47.000000000 +0100
@@ -0,0 +1,734 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ */
+
+#ifndef AR531X_H
+#define AR531X_H 1
+
+/*
+ * Address map
+ */
+#define AR5315_SDRAM0           0x00000000      /* DRAM */
+#define AR5315_SPI_READ         0x08000000      /* SPI FLASH */
+#define AR5315_WLAN0            0xB0000000      /* Wireless MMR */
+#define AR5315_PCI              0xB0100000      /* PCI MMR */
+#define AR5315_SDRAMCTL         0xB0300000      /* SDRAM MMR */
+#define AR5315_LOCAL            0xB0400000      /* LOCAL BUS MMR */
+#define AR5315_ENET0            0xB0500000      /* ETHERNET MMR */
+#define AR5315_DSLBASE          0xB1000000      /* RESET CONTROL MMR */
+#define AR5315_UART0            0xB1100003      /* UART MMR */
+#define AR5315_SPI              0xB1300000      /* SPI FLASH MMR */
+#define AR5315_FLASHBT          0xBfc00000      /* ro boot alias to FLASH */
+#define AR5315_RAM1             0x40000000      /* ram alias */
+#define AR5315_PCIEXT           0x80000000      /* pci external */
+#define AR5315_RAM2             0xc0000000      /* ram alias */
+#define AR5315_RAM3             0xe0000000      /* ram alias */
+
+/*
+ * Reset Register
+ */
+#define AR5315_COLD_RESET       (AR5315_DSLBASE + 0x0000)
+
+/* Cold Reset */
+#define RESET_COLD_AHB              0x00000001
+#define RESET_COLD_APB              0x00000002
+#define RESET_COLD_CPU              0x00000004
+#define RESET_COLD_CPUWARM          0x00000008
+#define RESET_SYSTEM                (RESET_COLD_CPU | RESET_COLD_APB | RESET_COLD_AHB)      /* full system */
+
+#define AR5317_RESET_SYSTEM	    0x00000010
+
+/* Warm Reset */
+
+#define AR5315_RESET            (AR5315_DSLBASE + 0x0004)
+
+#define RESET_WARM_WLAN0_MAC        0x00000001      /* warm reset WLAN0 MAC */
+#define RESET_WARM_WLAN0_BB         0x00000002      /* warm reset WLAN0 BaseBand */
+#define RESET_MPEGTS_RSVD           0x00000004      /* warm reset MPEG-TS */
+#define RESET_PCIDMA                0x00000008      /* warm reset PCI ahb/dma */
+#define RESET_MEMCTL                0x00000010      /* warm reset memory controller */
+#define RESET_LOCAL                 0x00000020      /* warm reset local bus */
+#define RESET_I2C_RSVD              0x00000040      /* warm reset I2C bus */
+#define RESET_SPI                   0x00000080      /* warm reset SPI interface */
+#define RESET_UART0                 0x00000100      /* warm reset UART0 */
+#define RESET_IR_RSVD               0x00000200      /* warm reset IR interface */
+#define RESET_EPHY0                 0x00000400      /* cold reset ENET0 phy */
+#define RESET_ENET0                 0x00000800      /* cold reset ENET0 mac */
+
+/*
+ * AHB master arbitration control
+ */
+#define AR5315_AHB_ARB_CTL      (AR5315_DSLBASE + 0x0008)
+
+#define ARB_CPU                     0x00000001      /* CPU, default */
+#define ARB_WLAN                    0x00000002      /* WLAN */
+#define ARB_MPEGTS_RSVD             0x00000004      /* MPEG-TS */
+#define ARB_LOCAL                   0x00000008      /* LOCAL */
+#define ARB_PCI                     0x00000010      /* PCI */
+#define ARB_ETHERNET                0x00000020      /* Ethernet */
+#define ARB_RETRY                   0x00000100      /* retry policy, debug only */
+
+/*
+ * Config Register
+ */
+#define AR5315_ENDIAN_CTL       (AR5315_DSLBASE + 0x000c)
+
+#define CONFIG_AHB                  0x00000001      /* EC - AHB bridge endianess */
+#define CONFIG_WLAN                 0x00000002      /* WLAN byteswap */
+#define CONFIG_MPEGTS_RSVD          0x00000004      /* MPEG-TS byteswap */
+#define CONFIG_PCI                  0x00000008      /* PCI byteswap */
+#define CONFIG_MEMCTL               0x00000010      /* Memory controller endianess */
+#define CONFIG_LOCAL                0x00000020      /* Local bus byteswap */
+#define CONFIG_ETHERNET             0x00000040      /* Ethernet byteswap */
+
+#define CONFIG_MERGE                0x00000200      /* CPU write buffer merge */
+#define CONFIG_CPU                  0x00000400      /* CPU big endian */
+#define CONFIG_PCIAHB               0x00000800
+#define CONFIG_PCIAHB_BRIDGE        0x00001000
+#define CONFIG_SPI                  0x00008000      /* SPI byteswap */
+#define CONFIG_CPU_DRAM             0x00010000
+#define CONFIG_CPU_PCI              0x00020000
+#define CONFIG_CPU_MMR              0x00040000
+#define CONFIG_BIG                  0x00000400      
+
+
+/*
+ * NMI control
+ */
+#define AR5315_NMI_CTL          (AR5315_DSLBASE + 0x0010)
+
+#define NMI_EN  1
+
+/*
+ * Revision Register - Initial value is 0x3010 (WMAC 3.0, AR531X 1.0).
+ */
+#define AR5315_SREV             (AR5315_DSLBASE + 0x0014)
+
+#define REV_MAJ                     0x00f0
+#define REV_MAJ_S                   4
+#define REV_MIN                     0x000f
+#define REV_MIN_S                   0
+#define REV_CHIP                    (REV_MAJ|REV_MIN)
+
+/*
+ * Interface Enable
+ */
+#define AR5315_IF_CTL           (AR5315_DSLBASE + 0x0018)
+
+#define IF_MASK                     0x00000007
+#define IF_DISABLED                 0
+#define IF_PCI                      1
+#define IF_TS_LOCAL                 2
+#define IF_ALL                      3   /* only for emulation with separate pins */
+#define IF_LOCAL_HOST               0x00000008
+#define IF_PCI_HOST                 0x00000010
+#define IF_PCI_INTR                 0x00000020
+#define IF_PCI_CLK_MASK             0x00030000
+#define IF_PCI_CLK_INPUT            0 
+#define IF_PCI_CLK_OUTPUT_LOW       1
+#define IF_PCI_CLK_OUTPUT_CLK       2
+#define IF_PCI_CLK_OUTPUT_HIGH      3
+#define IF_PCI_CLK_SHIFT            16 
+ 
+                
+/* Major revision numbers, bits 7..4 of Revision ID register */
+#define REV_MAJ_AR5311              0x01
+#define REV_MAJ_AR5312              0x04
+#define REV_MAJ_AR5315              0x0B
+
+/*
+ * APB Interrupt control
+ */
+
+#define AR5315_ISR              (AR5315_DSLBASE + 0x0020)
+#define AR5315_IMR              (AR5315_DSLBASE + 0x0024)
+#define AR5315_GISR             (AR5315_DSLBASE + 0x0028)
+
+#define ISR_UART0                   0x0001           /* high speed UART */
+#define ISR_I2C_RSVD                0x0002           /* I2C bus */
+#define ISR_SPI                     0x0004           /* SPI bus */
+#define ISR_AHB                     0x0008           /* AHB error */
+#define ISR_APB                     0x0010           /* APB error */
+#define ISR_TIMER                   0x0020           /* timer */
+#define ISR_GPIO                    0x0040           /* GPIO */
+#define ISR_WD                      0x0080           /* watchdog */
+#define ISR_IR_RSVD                 0x0100           /* IR */
+                                
+#define IMR_UART0                   ISR_UART0
+#define IMR_I2C_RSVD                ISR_I2C_RSVD
+#define IMR_SPI                     ISR_SPI
+#define IMR_AHB                     ISR_AHB
+#define IMR_APB                     ISR_APB
+#define IMR_TIMER                   ISR_TIMER
+#define IMR_GPIO                    ISR_GPIO
+#define IMR_WD                      ISR_WD
+#define IMR_IR_RSVD                 ISR_IR_RSVD
+
+#define GISR_MISC                   0x0001
+#define GISR_WLAN0                  0x0002
+#define GISR_MPEGTS_RSVD            0x0004
+#define GISR_LOCALPCI               0x0008
+#define GISR_WMACPOLL               0x0010
+#define GISR_TIMER                  0x0020
+#define GISR_ETHERNET               0x0040
+
+/*
+ * Interrupt routing from IO to the processor IP bits
+ * Define our inter mask and level
+ */
+#define AR5315_INTR_MISCIO      SR_IBIT3
+#define AR5315_INTR_WLAN0       SR_IBIT4
+#define AR5315_INTR_ENET0       SR_IBIT5
+#define AR5315_INTR_LOCALPCI    SR_IBIT6
+#define AR5315_INTR_WMACPOLL    SR_IBIT7
+#define AR5315_INTR_COMPARE     SR_IBIT8
+
+/*
+ * Timers
+ */
+#define AR5315_TIMER            (AR5315_DSLBASE + 0x0030)
+#define AR5315_RELOAD           (AR5315_DSLBASE + 0x0034)
+#define AR5315_WD               (AR5315_DSLBASE + 0x0038)
+#define AR5315_WDC              (AR5315_DSLBASE + 0x003c)
+
+#define WDC_RESET                   0x00000002               /* reset on watchdog */
+#define WDC_NMI                     0x00000001               /* NMI on watchdog */
+#define WDC_IGNORE_EXPIRATION       0x00000000
+
+/*
+ * Interface Debug
+ */
+#define AR531X_FLASHDBG             (AR531X_RESETTMR + 0x0040)
+#define AR531X_MIIDBG               (AR531X_RESETTMR + 0x0044)
+
+
+/*
+ * CPU Performance Counters
+ */
+#define AR5315_PERFCNT0         (AR5315_DSLBASE + 0x0048)
+#define AR5315_PERFCNT1         (AR5315_DSLBASE + 0x004c)
+
+#define PERF_DATAHIT                0x0001  /* Count Data Cache Hits */
+#define PERF_DATAMISS               0x0002  /* Count Data Cache Misses */
+#define PERF_INSTHIT                0x0004  /* Count Instruction Cache Hits */
+#define PERF_INSTMISS               0x0008  /* Count Instruction Cache Misses */
+#define PERF_ACTIVE                 0x0010  /* Count Active Processor Cycles */
+#define PERF_WBHIT                  0x0020  /* Count CPU Write Buffer Hits */
+#define PERF_WBMISS                 0x0040  /* Count CPU Write Buffer Misses */
+                                
+#define PERF_EB_ARDY                0x0001  /* Count EB_ARdy signal */
+#define PERF_EB_AVALID              0x0002  /* Count EB_AValid signal */
+#define PERF_EB_WDRDY               0x0004  /* Count EB_WDRdy signal */
+#define PERF_EB_RDVAL               0x0008  /* Count EB_RdVal signal */
+#define PERF_VRADDR                 0x0010  /* Count valid read address cycles */
+#define PERF_VWADDR                 0x0020  /* Count valid write address cycles */
+#define PERF_VWDATA                 0x0040  /* Count valid write data cycles */
+
+/*
+ * AHB Error Reporting.
+ */
+#define AR5315_AHB_ERR0         (AR5315_DSLBASE + 0x0050)  /* error  */
+#define AR5315_AHB_ERR1         (AR5315_DSLBASE + 0x0054)  /* haddr  */
+#define AR5315_AHB_ERR2         (AR5315_DSLBASE + 0x0058)  /* hwdata */
+#define AR5315_AHB_ERR3         (AR5315_DSLBASE + 0x005c)  /* hrdata */
+#define AR5315_AHB_ERR4         (AR5315_DSLBASE + 0x0060)  /* status */
+
+#define AHB_ERROR_DET               1   /* AHB Error has been detected,          */
+                                        /* write 1 to clear all bits in ERR0     */
+#define AHB_ERROR_OVR               2   /* AHB Error overflow has been detected  */
+#define AHB_ERROR_WDT               4   /* AHB Error due to wdt instead of hresp */
+
+#define PROCERR_HMAST               0x0000000f
+#define PROCERR_HMAST_DFLT          0
+#define PROCERR_HMAST_WMAC          1
+#define PROCERR_HMAST_ENET          2
+#define PROCERR_HMAST_PCIENDPT      3
+#define PROCERR_HMAST_LOCAL         4
+#define PROCERR_HMAST_CPU           5
+#define PROCERR_HMAST_PCITGT        6
+                                    
+#define PROCERR_HMAST_S             0
+#define PROCERR_HWRITE              0x00000010
+#define PROCERR_HSIZE               0x00000060
+#define PROCERR_HSIZE_S             5
+#define PROCERR_HTRANS              0x00000180
+#define PROCERR_HTRANS_S            7
+#define PROCERR_HBURST              0x00000e00
+#define PROCERR_HBURST_S            9
+
+
+
+/*
+ * Clock Control
+ */
+#define AR5315_PLLC_CTL         (AR5315_DSLBASE + 0x0064)
+#define AR5315_PLLV_CTL         (AR5315_DSLBASE + 0x0068)
+#define AR5315_CPUCLK           (AR5315_DSLBASE + 0x006c)
+#define AR5315_AMBACLK          (AR5315_DSLBASE + 0x0070)
+#define AR5315_SYNCCLK          (AR5315_DSLBASE + 0x0074)
+#define AR5315_DSL_SLEEP_CTL    (AR5315_DSLBASE + 0x0080)
+#define AR5315_DSL_SLEEP_DUR    (AR5315_DSLBASE + 0x0084)
+
+/* PLLc Control fields */
+#define PLLC_REF_DIV_M              0x00000003
+#define PLLC_REF_DIV_S              0
+#define PLLC_FDBACK_DIV_M           0x0000007C
+#define PLLC_FDBACK_DIV_S           2
+#define PLLC_ADD_FDBACK_DIV_M       0x00000080
+#define PLLC_ADD_FDBACK_DIV_S       7
+#define PLLC_CLKC_DIV_M             0x0001c000
+#define PLLC_CLKC_DIV_S             14
+#define PLLC_CLKM_DIV_M             0x00700000
+#define PLLC_CLKM_DIV_S             20
+
+/* CPU CLK Control fields */
+#define CPUCLK_CLK_SEL_M            0x00000003
+#define CPUCLK_CLK_SEL_S            0
+#define CPUCLK_CLK_DIV_M            0x0000000c
+#define CPUCLK_CLK_DIV_S            2
+
+/* AMBA CLK Control fields */
+#define AMBACLK_CLK_SEL_M           0x00000003
+#define AMBACLK_CLK_SEL_S           0
+#define AMBACLK_CLK_DIV_M           0x0000000c
+#define AMBACLK_CLK_DIV_S           2
+
+#if defined(COBRA_EMUL)
+#define AR5315_AMBA_CLOCK_RATE  20000000
+#define AR5315_CPU_CLOCK_RATE   40000000
+#else
+#if defined(DEFAULT_PLL)
+#define AR5315_AMBA_CLOCK_RATE  40000000
+#define AR5315_CPU_CLOCK_RATE   40000000
+#else
+#define AR5315_AMBA_CLOCK_RATE  92000000
+#define AR5315_CPU_CLOCK_RATE   184000000
+#endif /* ! DEFAULT_PLL */
+#endif /* ! COBRA_EMUL */
+
+#define AR5315_UART_CLOCK_RATE  AR5315_AMBA_CLOCK_RATE
+#define AR5315_SDRAM_CLOCK_RATE AR5315_AMBA_CLOCK_RATE
+
+/*
+ * The UART computes baud rate as:
+ *   baud = clock / (16 * divisor)
+ * where divisor is specified as a High Byte (DLM) and a Low Byte (DLL).
+ */
+#define DESIRED_BAUD_RATE           38400
+
+/*
+ * The WATCHDOG value is computed as
+ *  10 seconds * AR531X_WATCHDOG_CLOCK_RATE
+ */
+#define DESIRED_WATCHDOG_SECONDS    10
+#define AR531X_WATCHDOG_TIME \
+        (DESIRED_WATCHDOG_SECONDS * AR531X_WATCHDOG_CLOCK_RATE)
+
+
+#define CLOCKCTL_UART0  0x0010  /* enable UART0 external clock */
+
+
+ /*
+ * Applicable "PCICFG" bits for WLAN(s).  Assoc status and LED mode.
+ */
+#define AR531X_PCICFG               (AR531X_RESETTMR + 0x00b0)
+#define ASSOC_STATUS_M              0x00000003
+#define ASSOC_STATUS_NONE           0
+#define ASSOC_STATUS_PENDING        1   
+#define ASSOC_STATUS_ASSOCIATED     2
+#define LED_MODE_M                  0x0000001c
+#define LED_BLINK_THRESHOLD_M       0x000000e0
+#define LED_SLOW_BLINK_MODE         0x00000100
+
+/*
+ * GPIO
+ */
+
+#define AR5315_GPIO_DI          (AR5315_DSLBASE + 0x0088)
+#define AR5315_GPIO_DO          (AR5315_DSLBASE + 0x0090)
+#define AR5315_GPIO_CR          (AR5315_DSLBASE + 0x0098)
+#define AR5315_GPIO_INT         (AR5315_DSLBASE + 0x00a0)
+
+#define GPIO_CR_M(x)                (1 << (x))                  /* mask for i/o */
+#define GPIO_CR_O(x)                (1 << (x))                  /* output */
+#define GPIO_CR_I(x)                (0 << (x))                  /* input */
+
+#define GPIO_INT(x,Y)               ((x) << (8 * (Y)))          /* interrupt enable */
+#define GPIO_INT_M(Y)               ((0x3F) << (8 * (Y)))       /* mask for int */
+#define GPIO_INT_LVL(x,Y)           ((x) << (8 * (Y) + 6))      /* interrupt level */
+#define GPIO_INT_LVL_M(Y)           ((0x3) << (8 * (Y) + 6))    /* mask for int level */
+
+#define AR5315_RESET_GPIO       5
+#define AR5315_NUM_GPIO         22
+
+    
+/* 
+ *  PCI Clock Control
+ */     
+ 
+#define AR5315_PCICLK           (AR5315_DSLBASE + 0x00a4)
+
+#define PCICLK_INPUT_M              0x3
+#define PCICLK_INPUT_S              0
+                         
+#define PCICLK_PLLC_CLKM            0
+#define PCICLK_PLLC_CLKM1           1
+#define PCICLK_PLLC_CLKC            2
+#define PCICLK_REF_CLK              3 
+
+#define PCICLK_DIV_M                0xc
+#define PCICLK_DIV_S                2
+                         
+#define PCICLK_IN_FREQ              0
+#define PCICLK_IN_FREQ_DIV_6        1
+#define PCICLK_IN_FREQ_DIV_8        2
+#define PCICLK_IN_FREQ_DIV_10       3 
+
+/*
+ * Observation Control Register
+ */
+#define AR5315_OCR              (AR5315_DSLBASE + 0x00b0)
+#define OCR_GPIO0_IRIN              0x0040
+#define OCR_GPIO1_IROUT             0x0080
+#define OCR_GPIO3_RXCLR             0x0200
+
+/* 
+ *  General Clock Control
+ */     
+ 
+#define AR5315_MISCCLK          (AR5315_DSLBASE + 0x00b4)
+#define MISCCLK_PLLBYPASS_EN        0x00000001
+#define MISCCLK_PROCREFCLK          0x00000002
+
+/*
+ * SDRAM Controller
+ *   - No read or write buffers are included.
+ */
+#define AR5315_MEM_CFG          (AR5315_SDRAMCTL + 0x00)
+#define AR5315_MEM_CTRL         (AR5315_SDRAMCTL + 0x0c)
+#define AR5315_MEM_REF          (AR5315_SDRAMCTL + 0x10)
+
+#define SDRAM_DATA_WIDTH_M          0x00006000
+#define SDRAM_DATA_WIDTH_S          13
+
+#define SDRAM_COL_WIDTH_M           0x00001E00
+#define SDRAM_COL_WIDTH_S           9
+
+#define SDRAM_ROW_WIDTH_M           0x000001E0
+#define SDRAM_ROW_WIDTH_S           5
+
+#define SDRAM_BANKADDR_BITS_M       0x00000018
+#define SDRAM_BANKADDR_BITS_S       3
+
+
+/*
+ * SDRAM Memory Refresh (MEM_REF) value is computed as:
+ * MEMCTL_SREFR = (Tr * hclk_freq) / R
+ * where Tr is max. time of refresh of any single row
+ * R is number of rows in the DRAM
+ * For most 133MHz SDRAM parts, Tr=64ms, R=4096 or 8192
+ */
+#if defined(COBRA_EMUL)
+#define AR5315_SDRAM_MEMORY_REFRESH_VALUE  0x96
+#else 
+#if defined(DEFAULT_PLL)
+#define AR5315_SDRAM_MEMORY_REFRESH_VALUE  0x200
+#else
+#define AR5315_SDRAM_MEMORY_REFRESH_VALUE  0x61a
+#endif /* ! DEFAULT_PLL */
+#endif 
+
+#define AR5315_SDRAM_DDR_SDRAM      0   /* Not DDR SDRAM */
+#define AR5315_SDRAM_DATA_WIDTH     16
+#define AR5315_SDRAM_COL_WIDTH      8
+#define AR5315_SDRAM_ROW_WIDTH      12
+
+/*
+ * SPI Flash Interface Registers
+ */
+
+#define AR5315_SPI_CTL      (AR5315_SPI + 0x00)
+#define AR5315_SPI_OPCODE   (AR5315_SPI + 0x04)
+#define AR5315_SPI_DATA     (AR5315_SPI + 0x08)
+
+#define SPI_CTL_START           0x00000100
+#define SPI_CTL_BUSY            0x00010000
+#define SPI_CTL_TXCNT_MASK      0x0000000f
+#define SPI_CTL_RXCNT_MASK      0x000000f0
+#define SPI_CTL_TX_RX_CNT_MASK  0x000000ff
+#define SPI_CTL_SIZE_MASK       0x00060000
+
+#define SPI_CTL_CLK_SEL_MASK    0x03000000
+#define SPI_OPCODE_MASK         0x000000ff
+
+/* 
+ * PCI-MAC Configuration registers 
+ */
+#define PCI_MAC_RC              (AR5315_PCI + 0x4000) 
+#define PCI_MAC_SCR             (AR5315_PCI + 0x4004)
+#define PCI_MAC_INTPEND         (AR5315_PCI + 0x4008)
+#define PCI_MAC_SFR             (AR5315_PCI + 0x400C)
+#define PCI_MAC_PCICFG          (AR5315_PCI + 0x4010)
+#define PCI_MAC_SREV            (AR5315_PCI + 0x4020)
+
+#define PCI_MAC_RC_MAC          0x00000001
+#define PCI_MAC_RC_BB           0x00000002
+
+#define PCI_MAC_SCR_SLMODE_M    0x00030000
+#define PCI_MAC_SCR_SLMODE_S    16        
+#define PCI_MAC_SCR_SLM_FWAKE   0         
+#define PCI_MAC_SCR_SLM_FSLEEP  1         
+#define PCI_MAC_SCR_SLM_NORMAL  2         
+
+#define PCI_MAC_SFR_SLEEP       0x00000001
+
+#define PCI_MAC_PCICFG_SPWR_DN  0x00010000
+
+ 
+
+
+/*
+ * PCI Bus Interface Registers
+ */
+#define AR5315_PCI_1MS_REG      (AR5315_PCI + 0x0008)
+#define AR5315_PCI_1MS_MASK     0x3FFFF         /* # of AHB clk cycles in 1ms */
+
+#define AR5315_PCI_MISC_CONFIG  (AR5315_PCI + 0x000c)
+#define AR5315_PCIMISC_TXD_EN   0x00000001      /* Enable TXD for fragments */
+#define AR5315_PCIMISC_CFG_SEL  0x00000002      /* mem or config cycles */
+#define AR5315_PCIMISC_GIG_MASK 0x0000000C      /* bits 31-30 for pci req */
+#define AR5315_PCIMISC_RST_MODE 0x00000030
+#define AR5315_PCIRST_INPUT     0x00000000      /* 4:5=0 rst is input */
+#define AR5315_PCIRST_LOW       0x00000010      /* 4:5=1 rst to GND */
+#define AR5315_PCIRST_HIGH      0x00000020      /* 4:5=2 rst to VDD */
+#define AR5315_PCIGRANT_EN      0x00000000      /* 6:7=0 early grant en */
+#define AR5315_PCIGRANT_FRAME   0x00000040      /* 6:7=1 grant waits 4 frame */
+#define AR5315_PCIGRANT_IDLE    0x00000080      /* 6:7=2 grant waits 4 idle */
+#define AR5315_PCIGRANT_GAP     0x00000000      /* 6:7=2 grant waits 4 idle */
+#define AR5315_PCICACHE_DIS     0x00001000      /* PCI external access cache disable */
+
+#define AR5315_PCI_OUT_TSTAMP   (AR5315_PCI + 0x0010)
+
+#define AR5315_PCI_UNCACHE_CFG  (AR5315_PCI + 0x0014)
+
+#define AR5315_PCI_IN_EN        (AR5315_PCI + 0x0100)
+#define AR5315_PCI_IN_EN0       0x01            /* Enable chain 0 */
+#define AR5315_PCI_IN_EN1       0x02            /* Enable chain 1 */
+#define AR5315_PCI_IN_EN2       0x04            /* Enable chain 2 */
+#define AR5315_PCI_IN_EN3       0x08            /* Enable chain 3 */
+
+#define AR5315_PCI_IN_DIS       (AR5315_PCI + 0x0104)
+#define AR5315_PCI_IN_DIS0      0x01            /* Disable chain 0 */
+#define AR5315_PCI_IN_DIS1      0x02            /* Disable chain 1 */
+#define AR5315_PCI_IN_DIS2      0x04            /* Disable chain 2 */
+#define AR5315_PCI_IN_DIS3      0x08            /* Disable chain 3 */
+
+#define AR5315_PCI_IN_PTR       (AR5315_PCI + 0x0200)
+
+#define AR5315_PCI_OUT_EN       (AR5315_PCI + 0x0400)
+#define AR5315_PCI_OUT_EN0      0x01            /* Enable chain 0 */
+
+#define AR5315_PCI_OUT_DIS      (AR5315_PCI + 0x0404)
+#define AR5315_PCI_OUT_DIS0     0x01            /* Disable chain 0 */
+
+#define AR5315_PCI_OUT_PTR      (AR5315_PCI + 0x0408)
+
+#define AR5315_PCI_INT_STATUS   (AR5315_PCI + 0x0500)   /* write one to clr */
+#define AR5315_PCI_TXINT        0x00000001      /* Desc In Completed */
+#define AR5315_PCI_TXOK         0x00000002      /* Desc In OK */
+#define AR5315_PCI_TXERR        0x00000004      /* Desc In ERR */
+#define AR5315_PCI_TXEOL        0x00000008      /* Desc In End-of-List */
+#define AR5315_PCI_RXINT        0x00000010      /* Desc Out Completed */
+#define AR5315_PCI_RXOK         0x00000020      /* Desc Out OK */
+#define AR5315_PCI_RXERR        0x00000040      /* Desc Out ERR */
+#define AR5315_PCI_RXEOL        0x00000080      /* Desc Out EOL */
+#define AR5315_PCI_TXOOD        0x00000200      /* Desc In Out-of-Desc */
+#define AR5315_PCI_MASK         0x0000FFFF      /* Desc Mask */
+#define AR5315_PCI_EXT_INT      0x02000000      
+#define AR5315_PCI_ABORT_INT    0x04000000      
+
+#define AR5315_PCI_INT_MASK     (AR5315_PCI + 0x0504)   /* same as INT_STATUS */
+
+#define AR5315_PCI_INTEN_REG    (AR5315_PCI + 0x0508)
+#define AR5315_PCI_INT_DISABLE  0x00            /* disable pci interrupts */
+#define AR5315_PCI_INT_ENABLE   0x01            /* enable pci interrupts */
+
+#define AR5315_PCI_HOST_IN_EN   (AR5315_PCI + 0x0800)
+#define AR5315_PCI_HOST_IN_DIS  (AR5315_PCI + 0x0804)
+#define AR5315_PCI_HOST_IN_PTR  (AR5315_PCI + 0x0810)
+#define AR5315_PCI_HOST_OUT_EN  (AR5315_PCI + 0x0900)
+#define AR5315_PCI_HOST_OUT_DIS (AR5315_PCI + 0x0904)
+#define AR5315_PCI_HOST_OUT_PTR (AR5315_PCI + 0x0908)
+
+
+/*
+ * Local Bus Interface Registers
+ */
+#define AR5315_LB_CONFIG        (AR5315_LOCAL + 0x0000)
+#define AR5315_LBCONF_OE        0x00000001      /* =1 OE is low-true */
+#define AR5315_LBCONF_CS0       0x00000002      /* =1 first CS is low-true */
+#define AR5315_LBCONF_CS1       0x00000004      /* =1 2nd CS is low-true */
+#define AR5315_LBCONF_RDY       0x00000008      /* =1 RDY is low-true */
+#define AR5315_LBCONF_WE        0x00000010      /* =1 Write En is low-true */
+#define AR5315_LBCONF_WAIT      0x00000020      /* =1 WAIT is low-true */
+#define AR5315_LBCONF_ADS       0x00000040      /* =1 Adr Strobe is low-true */
+#define AR5315_LBCONF_MOT       0x00000080      /* =0 Intel, =1 Motorola */
+#define AR5315_LBCONF_8CS       0x00000100      /* =1 8 bits CS, 0= 16bits */
+#define AR5315_LBCONF_8DS       0x00000200      /* =1 8 bits Data S, 0=16bits */
+#define AR5315_LBCONF_ADS_EN    0x00000400      /* =1 Enable ADS */
+#define AR5315_LBCONF_ADR_OE    0x00000800      /* =1 Adr cap on OE, WE or DS */
+#define AR5315_LBCONF_ADDT_MUX  0x00001000      /* =1 Adr and Data share bus */
+#define AR5315_LBCONF_DATA_OE   0x00002000      /* =1 Data cap on OE, WE, DS */
+#define AR5315_LBCONF_16DATA    0x00004000      /* =1 Data is 16 bits wide */
+#define AR5315_LBCONF_SWAPDT    0x00008000      /* =1 Byte swap data */
+#define AR5315_LBCONF_SYNC      0x00010000      /* =1 Bus synchronous to clk */
+#define AR5315_LBCONF_INT       0x00020000      /* =1 Intr is low true */
+#define AR5315_LBCONF_INT_CTR0  0x00000000      /* GND high-Z, Vdd is high-Z */
+#define AR5315_LBCONF_INT_CTR1  0x00040000      /* GND drive, Vdd is high-Z */
+#define AR5315_LBCONF_INT_CTR2  0x00080000      /* GND high-Z, Vdd drive */
+#define AR5315_LBCONF_INT_CTR3  0x000C0000      /* GND drive, Vdd drive */
+#define AR5315_LBCONF_RDY_WAIT  0x00100000      /* =1 RDY is negative of WAIT */
+#define AR5315_LBCONF_INT_PULSE 0x00200000      /* =1 Interrupt is a pulse */
+#define AR5315_LBCONF_ENABLE    0x00400000      /* =1 Falcon respond to LB */
+
+#define AR5315_LB_CLKSEL        (AR5315_LOCAL + 0x0004)
+#define AR5315_LBCLK_EXT        0x0001          /* use external clk for lb */
+
+#define AR5315_LB_1MS           (AR5315_LOCAL + 0x0008)
+#define AR5315_LB1MS_MASK       0x3FFFF         /* # of AHB clk cycles in 1ms */
+
+#define AR5315_LB_MISCCFG       (AR5315_LOCAL + 0x000C)
+#define AR5315_LBM_TXD_EN       0x00000001      /* Enable TXD for fragments */
+#define AR5315_LBM_RX_INTEN     0x00000002      /* Enable LB ints on RX ready */
+#define AR5315_LBM_MBOXWR_INTEN 0x00000004      /* Enable LB ints on mbox wr */
+#define AR5315_LBM_MBOXRD_INTEN 0x00000008      /* Enable LB ints on mbox rd */
+#define AR5315_LMB_DESCSWAP_EN  0x00000010      /* Byte swap desc enable */
+#define AR5315_LBM_TIMEOUT_MASK 0x00FFFF80
+#define AR5315_LBM_TIMEOUT_SHFT 7
+#define AR5315_LBM_PORTMUX      0x07000000
+
+
+#define AR5315_LB_RXTSOFF       (AR5315_LOCAL + 0x0010)
+
+#define AR5315_LB_TX_CHAIN_EN   (AR5315_LOCAL + 0x0100)
+#define AR5315_LB_TXEN_0        0x01
+#define AR5315_LB_TXEN_1        0x02
+#define AR5315_LB_TXEN_2        0x04
+#define AR5315_LB_TXEN_3        0x08
+
+#define AR5315_LB_TX_CHAIN_DIS  (AR5315_LOCAL + 0x0104)
+#define AR5315_LB_TX_DESC_PTR   (AR5315_LOCAL + 0x0200)
+
+#define AR5315_LB_RX_CHAIN_EN   (AR5315_LOCAL + 0x0400)
+#define AR5315_LB_RXEN          0x01
+
+#define AR5315_LB_RX_CHAIN_DIS  (AR5315_LOCAL + 0x0404)
+#define AR5315_LB_RX_DESC_PTR   (AR5315_LOCAL + 0x0408)
+
+#define AR5315_LB_INT_STATUS    (AR5315_LOCAL + 0x0500)
+#define AR5315_INT_TX_DESC      0x0001
+#define AR5315_INT_TX_OK        0x0002
+#define AR5315_INT_TX_ERR       0x0004
+#define AR5315_INT_TX_EOF       0x0008
+#define AR5315_INT_RX_DESC      0x0010
+#define AR5315_INT_RX_OK        0x0020
+#define AR5315_INT_RX_ERR       0x0040
+#define AR5315_INT_RX_EOF       0x0080
+#define AR5315_INT_TX_TRUNC     0x0100
+#define AR5315_INT_TX_STARVE    0x0200
+#define AR5315_INT_LB_TIMEOUT   0x0400
+#define AR5315_INT_LB_ERR       0x0800
+#define AR5315_INT_MBOX_WR      0x1000
+#define AR5315_INT_MBOX_RD      0x2000
+
+/* Bit definitions for INT MASK are the same as INT_STATUS */
+#define AR5315_LB_INT_MASK      (AR5315_LOCAL + 0x0504)
+
+#define AR5315_LB_INT_EN        (AR5315_LOCAL + 0x0508)
+#define AR5315_LB_MBOX          (AR5315_LOCAL + 0x0600)
+
+
+
+/*
+ * IR Interface Registers
+ */
+#define AR5315_IR_PKTDATA                   (AR5315_IR + 0x0000)
+
+#define AR5315_IR_PKTLEN                    (AR5315_IR + 0x07fc) /* 0 - 63 */
+
+#define AR5315_IR_CONTROL                   (AR5315_IR + 0x0800)
+#define AR5315_IRCTL_TX                     0x00000000  /* use as tranmitter */
+#define AR5315_IRCTL_RX                     0x00000001  /* use as receiver   */
+#define AR5315_IRCTL_SAMPLECLK_MASK         0x00003ffe  /* Sample clk divisor mask */
+#define AR5315_IRCTL_SAMPLECLK_SHFT                  1
+#define AR5315_IRCTL_OUTPUTCLK_MASK         0x03ffc000  /* Output clk divisor mask */
+#define AR5315_IRCTL_OUTPUTCLK_SHFT                 14
+
+#define AR5315_IR_STATUS                    (AR5315_IR + 0x0804)
+#define AR5315_IRSTS_RX                     0x00000001  /* receive in progress */
+#define AR5315_IRSTS_TX                     0x00000002  /* transmit in progress */
+
+#define AR5315_IR_CONFIG                    (AR5315_IR + 0x0808)
+#define AR5315_IRCFG_INVIN                  0x00000001  /* invert input polarity */
+#define AR5315_IRCFG_INVOUT                 0x00000002  /* invert output polarity */
+#define AR5315_IRCFG_SEQ_START_WIN_SEL      0x00000004  /* 1 => 28, 0 => 7 */
+#define AR5315_IRCFG_SEQ_START_THRESH       0x000000f0  /*  */
+#define AR5315_IRCFG_SEQ_END_UNIT_SEL       0x00000100  /*  */
+#define AR5315_IRCFG_SEQ_END_UNIT_THRESH    0x00007e00  /*  */
+#define AR5315_IRCFG_SEQ_END_WIN_SEL        0x00008000  /*  */
+#define AR5315_IRCFG_SEQ_END_WIN_THRESH     0x001f0000  /*  */
+#define AR5315_IRCFG_NUM_BACKOFF_WORDS      0x01e00000  /*  */
+
+/*
+ * PCI memory constants: Memory area 1 and 2 are the same size -
+ * (twice the PCI_TLB_PAGE_SIZE). The definition of
+ * CPU_TO_PCI_MEM_SIZE is coupled with the TLB setup routine
+ * sysLib.c/sysTlbInit(), in that it assumes that 2 pages of size
+ * PCI_TLB_PAGE_SIZE are set up in the TLB for each PCI memory space.
+ */
+ 
+#define CPU_TO_PCI_MEM_BASE1    0xE0000000
+#define CPU_TO_PCI_MEM_SIZE1    (2*PCI_TLB_PAGE_SIZE)
+ 
+
+/* TLB attributes for PCI transactions */
+
+#define PCI_MMU_PAGEMASK        0x00003FFF
+#define MMU_PAGE_UNCACHED       0x00000010
+#define MMU_PAGE_DIRTY          0x00000004
+#define MMU_PAGE_VALID          0x00000002
+#define MMU_PAGE_GLOBAL         0x00000001
+#define PCI_MMU_PAGEATTRIB      (MMU_PAGE_UNCACHED|MMU_PAGE_DIRTY|\
+                                 MMU_PAGE_VALID|MMU_PAGE_GLOBAL)
+#define PCI_MEMORY_SPACE1_VIRT  0xE0000000      /* Used for non-prefet  mem   */
+#define PCI_MEMORY_SPACE1_PHYS  0x80000000
+#define PCI_TLB_PAGE_SIZE       0x01000000
+#define TLB_HI_MASK             0xFFFFE000
+#define TLB_LO_MASK             0x3FFFFFFF
+#define PAGEMASK_SHIFT          11
+#define TLB_LO_SHIFT            6
+
+#define PCI_MAX_LATENCY         0xFFF           /* Max PCI latency            */
+
+#define HOST_PCI_DEV_ID         3
+#define HOST_PCI_MBAR0          0x10000000
+#define HOST_PCI_MBAR1          0x20000000
+#define HOST_PCI_MBAR2          0x30000000
+
+#define HOST_PCI_SDRAM_BASEADDR HOST_PCI_MBAR1
+#define PCI_DEVICE_MEM_SPACE    0x800000
+
+#define sysRegRead(phys)	\
+	(*(volatile u32 *)KSEG1ADDR(phys))
+
+#define sysRegWrite(phys, val)	\
+	((*(volatile u32 *)KSEG1ADDR(phys)) = (val))
+
+#endif
diff -urN linux.old/arch/mips/ar531x/ar531xlnx.h linux.dev/arch/mips/ar531x/ar531xlnx.h
--- linux.old/arch/mips/ar531x/ar531xlnx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar531x/ar531xlnx.h	2006-12-16 04:49:36.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ */
+
+/*
+ * This file contains definitions needed in order to compile
+ * AR531X products for linux.  Definitions that are largely
+ * AR531X-specific and independent of operating system belong
+ * in ar531x.h rather than this file.
+ */
+#ifndef _AR531XLNX_H
+#define _AR531XLNX_H
+
+#include "ar531x.h"
+
+/*
+ * Board support data.  The driver is required to locate
+ * and fill-in this information before passing a reference to
+ * this structure as the HAL_BUS_TAG parameter supplied to
+ * ath_hal_attach.
+ */
+struct ar531x_config {
+	const char  *board;	/* board config data */
+	const char	*radio;			/* radio config data */
+	int		unit;			/* unit number [0, 1] */
+	u32		tag;			/* used as devid for now */
+};
+
+#define MIPS_CPU_IRQ_BASE		0x00
+#define AR531X_HIGH_PRIO                0x10
+#define AR531X_MISC_IRQ_BASE		0x20
+#define AR531X_GPIO_IRQ_BASE            0x30
+
+/* Software's idea of interrupts handled by "CPU Interrupt Controller" */
+#define AR531X_IRQ_NONE		MIPS_CPU_IRQ_BASE+0
+#define AR531X_IRQ_MISC_INTRS	MIPS_CPU_IRQ_BASE+2 /* C0_CAUSE: 0x0400 */
+#define AR531X_IRQ_WLAN0_INTRS	MIPS_CPU_IRQ_BASE+3 /* C0_CAUSE: 0x0800 */
+#define AR531X_IRQ_ENET0_INTRS	MIPS_CPU_IRQ_BASE+4 /* C0_CAUSE: 0x1000 */
+#define AR531X_IRQ_LCBUS_PCI	MIPS_CPU_IRQ_BASE+6 /* C0_CAUSE: 0x4000 */
+#define AR531X_IRQ_WLAN0_POLL	MIPS_CPU_IRQ_BASE+6 /* C0_CAUSE: 0x4000 */
+#define AR531X_IRQ_CPU_CLOCK	MIPS_CPU_IRQ_BASE+7 /* C0_CAUSE: 0x8000 */
+
+/* Miscellaneous interrupts, which share IP6 */
+#define AR531X_MISC_IRQ_NONE		AR531X_MISC_IRQ_BASE+0
+#define AR531X_MISC_IRQ_TIMER		AR531X_MISC_IRQ_BASE+1
+#define AR531X_MISC_IRQ_AHB_PROC	AR531X_MISC_IRQ_BASE+2
+#define AR531X_MISC_IRQ_AHB_DMA		AR531X_MISC_IRQ_BASE+3
+#define AR531X_MISC_IRQ_GPIO		AR531X_MISC_IRQ_BASE+4
+#define AR531X_MISC_IRQ_UART0		AR531X_MISC_IRQ_BASE+5
+#define AR531X_MISC_IRQ_UART0_DMA	AR531X_MISC_IRQ_BASE+6
+#define AR531X_MISC_IRQ_WATCHDOG	AR531X_MISC_IRQ_BASE+7
+#define AR531X_MISC_IRQ_LOCAL		AR531X_MISC_IRQ_BASE+8
+#define AR531X_MISC_IRQ_COUNT		9
+
+/* GPIO Interrupts [0..7], share AR531X_MISC_IRQ_GPIO */
+#define AR531X_GPIO_IRQ_NONE            AR531X_MISC_IRQ_BASE+0
+#define AR531X_GPIO_IRQ(n)              AR531X_MISC_IRQ_BASE+(n)+1
+#define AR531X_GPIO_IRQ_COUNT           22
+
+extern struct ar531x_boarddata *ar531x_board_configuration;
+extern char *ar531x_radio_configuration;
+extern char *enet_mac_address_get(int MACUnit);
+
+#define A_DATA_CACHE_INVAL(start, length) \
+        dma_cache_inv((UINT32)(start),(length))
+
+#endif /* _AR531XLNX_H */
diff -urN linux.old/arch/mips/ar531x/devices.c linux.dev/arch/mips/ar531x/devices.c
--- linux.old/arch/mips/ar531x/devices.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar531x/devices.c	2006-12-16 04:46:43.000000000 +0100
@@ -0,0 +1,281 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ */
+
+/*
+ * Platform devices for AR531x SoC.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <ar531x_platform.h>
+
+#include "ar531xlnx.h"
+
+static struct resource ar531x_eth_res[] = {
+	{
+		.name = "eth_membase",
+		.flags = IORESOURCE_MEM,
+		.start = 0xb0500000,
+		.end = 0xb0502000,
+	},
+	{
+		.name = "eth_irq",
+		.flags = IORESOURCE_IRQ,
+		.start = 4,
+		.end = 4,
+	},
+};
+
+static struct ar531x_eth ar531x_eth_data = {
+	.phy = 1,
+	.mac = 0,
+	.reset_base = 0x11000004,
+	.reset_mac = 0x800,
+	.reset_phy = 0x400,
+};
+
+static struct platform_device ar531x_eth = {
+	.id = 0,
+	.name = "ar531x-eth",
+	.dev.platform_data = &ar531x_eth_data,
+	.resource = ar531x_eth_res,
+	.num_resources = ARRAY_SIZE(ar531x_eth_res)
+};
+
+static struct platform_device ar531x_wmac = {
+	.id = 0,
+	.name = "ar531x-wmac",
+	/* FIXME: add resources */
+};
+
+static struct resource ar531x_spiflash_res[] = {
+	{
+		.name = "flash_base",
+		.flags = IORESOURCE_MEM,
+		.start = 0xa8000000,
+		.end = 0xa8400000,
+	},
+	{
+		.name = "flash_regs",
+		.flags = IORESOURCE_MEM,
+		.start = 0x11300000,
+		.end = 0x11300012,
+	},
+};
+
+static struct platform_device ar531x_spiflash = {
+	.id = 0,
+	.name = "spiflash",
+	.resource = ar531x_spiflash_res,
+	.num_resources = ARRAY_SIZE(ar531x_spiflash_res)
+};
+
+static __initdata struct platform_device *ar531x_devs[] = {
+	&ar531x_eth,
+	&ar531x_wmac,
+	&ar531x_spiflash
+};
+
+
+
+static void *flash_regs;
+
+static inline __u32 spiflash_regread32(int reg)
+{
+	volatile __u32 *data = (__u32 *)(flash_regs + reg);
+
+	return (*data);
+}
+
+static inline void spiflash_regwrite32(int reg, __u32 data)
+{
+	volatile __u32 *addr = (__u32 *)(flash_regs + reg);
+
+	*addr = data;
+}
+
+#define SPI_FLASH_CTL      0x00
+#define SPI_FLASH_OPCODE   0x04
+#define SPI_FLASH_DATA     0x08
+
+static __u8 spiflash_probe(void)
+{
+	 __u32 reg;
+
+	do {
+		reg = spiflash_regread32(SPI_FLASH_CTL);
+	} while (reg & SPI_CTL_BUSY);
+
+	spiflash_regwrite32(SPI_FLASH_OPCODE, 0xab);
+
+	reg = (reg & ~SPI_CTL_TX_RX_CNT_MASK) | 4 |
+        	(1 << 4) | SPI_CTL_START;
+
+	spiflash_regwrite32(SPI_FLASH_CTL, reg);
+ 
+	do {
+  		reg = spiflash_regread32(SPI_FLASH_CTL);
+	} while (reg & SPI_CTL_BUSY);
+
+	reg = (__u32) spiflash_regread32(SPI_FLASH_DATA);
+	reg &= 0xff;
+
+	return (u8) reg;
+}
+
+static u8 *find_board_config(void)
+{
+	char *addr;
+	int found = 0;
+
+	for (addr = (char *) (ar531x_spiflash_res[0].end - 0x1000);
+		addr >= (char *) (ar531x_spiflash_res[0].end - 0x30000);
+		addr -= 0x1000) {
+
+		if ( *(int *)addr == 0x35333131) {
+			/* config magic found */
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		printk("WARNING: No board configuration data found!\n");
+		addr = NULL;
+	}
+	
+	return addr;
+}
+
+static void *find_radio_config(char *board_config)
+{
+	int dataFound;
+	u32 radio_config;
+	
+	/* 
+	 * Now find the start of Radio Configuration data, using heuristics:
+	 * Search forward from Board Configuration data by 0x1000 bytes
+	 * at a time until we find non-0xffffffff.
+	 */
+	dataFound = 0;
+	for (radio_config = (u32) board_config + 0x1000;
+	     (radio_config < (u32) ar531x_spiflash_res[0].end);
+	     radio_config += 0x1000) {
+		if (*(int *)radio_config != 0xffffffff) {
+			dataFound = 1;
+			break;
+		}
+	}
+
+	if (!dataFound) { /* AR2316 relocates radio config to new location */
+	    for (radio_config = (u32) board_config + 0xf8;
+	     	(radio_config < (u32) ar531x_spiflash_res[0].end - 0x1000 + 0xf8);
+			 radio_config += 0x1000) {
+			if (*(int *)radio_config != 0xffffffff) {
+				dataFound = 1;
+				break;
+			}
+	    }
+	}
+
+	if (!dataFound) {
+		printk("Could not find Radio Configuration data\n");
+		radio_config = 0;
+	}
+
+	return (u8 *) radio_config;
+}
+
+
+#define STM_8MBIT_SIGNATURE     0x13
+#define STM_16MBIT_SIGNATURE    0x14
+#define STM_32MBIT_SIGNATURE    0x15
+#define STM_64MBIT_SIGNATURE    0x16
+
+
+static void __init ar531x_init_flash(void)
+{
+	u8 sig;
+	u32 flash_size = 0;
+	unsigned int rcfg_size;
+	char *bcfg, *rcfg, *board_config, *radio_config;
+	struct ar531x_config *config;
+	
+	/* probe the flash chip size */
+	flash_regs = ioremap_nocache(ar531x_spiflash_res[1].start, ar531x_spiflash_res[1].end - ar531x_spiflash_res[1].start);
+	sig = spiflash_probe();
+	iounmap(flash_regs);
+
+	switch(sig) {
+		case STM_8MBIT_SIGNATURE:
+			flash_size = 0x00100000;
+			break;
+		case STM_16MBIT_SIGNATURE:
+			flash_size = 0x00200000;
+			break;
+		case STM_32MBIT_SIGNATURE:
+			flash_size = 0x00400000;
+			break;
+		case STM_64MBIT_SIGNATURE:
+			flash_size = 0x00800000;
+			break;
+	}
+
+	if (!flash_size)
+		return;
+	
+	ar531x_spiflash_res[0].end = ar531x_spiflash_res[0].start + flash_size;
+	
+	/* Copy the board and radio data to RAM, because with the new
+	 * spiflash driver, accessing the mapped memory directly is no
+	 * longer safe */
+
+	bcfg = find_board_config();
+	if (!bcfg)
+		return;
+
+	board_config = kmalloc(0x1000, GFP_KERNEL);
+	memcpy(board_config, bcfg, 0x100);
+	ar531x_eth_data.board_config = board_config;
+
+	/* Radio config starts 0x100 bytes after board config, regardless
+	 * of what the physical layout on the flash chip looks like */
+
+	rcfg = find_radio_config(bcfg);
+	if (!rcfg)
+		return;
+	printk("Radio config found at offset 0x%x\n", rcfg - bcfg);
+	radio_config = board_config + 0x100 + ((rcfg - bcfg) & 0xfff);
+	rcfg_size = 0x1000 - ((rcfg - bcfg) & 0xfff);
+	memcpy(radio_config, rcfg, rcfg_size);
+
+	config = (struct ar531x_config *) kzalloc(sizeof(struct ar531x_config), GFP_KERNEL);
+	config->board = board_config;
+	config->radio = radio_config;
+	config->unit = 0;
+	config->tag = (u_int16_t) (sysRegRead(AR5315_SREV) & REV_CHIP);
+	ar531x_wmac.dev.platform_data = config;
+}
+
+static int __init ar531x_register_devices(void)
+{
+	ar531x_init_flash();
+	return platform_add_devices(ar531x_devs, ARRAY_SIZE(ar531x_devs));
+}
+
+
+arch_initcall(ar531x_register_devices);
diff -urN linux.old/arch/mips/ar531x/gpio.c linux.dev/arch/mips/ar531x/gpio.c
--- linux.old/arch/mips/ar531x/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar531x/gpio.c	2006-12-16 04:49:20.000000000 +0100
@@ -0,0 +1,127 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ */
+
+/*
+ * Support for GPIO -- General Purpose Input/Output Pins
+ * XXX: should be rewritten
+ */
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include "ar531xlnx.h"
+
+/* GPIO Interrupt Support */
+
+/* Turn on the specified AR531X_GPIO_IRQ interrupt */
+static unsigned int
+ar531x_gpio_intr_startup(unsigned int irq)
+{
+	ar531x_gpio_intr_enable(irq);
+
+	return 0;
+}
+
+/* Turn off the specified AR531X_GPIO_IRQ interrupt */
+static void
+ar531x_gpio_intr_shutdown(unsigned int irq)
+{
+	ar531x_gpio_intr_disable(irq);
+}
+
+u32 gpioIntMask = 0;
+
+static void ar531x_gpio_intr_set_enabled(unsigned int gpio, int enabled)
+{
+	u32 reg;
+	int intnum = 0;
+	int intlevel = 2;
+   
+	reg = sysRegRead(AR5315_GPIO_CR);
+	reg &= ~(GPIO_CR_M(gpio));
+	reg |= GPIO_CR_I(gpio);
+	sysRegWrite(AR5315_GPIO_CR, reg);
+	(void)sysRegRead(AR5315_GPIO_CR); /* flush write to hardware */
+
+	reg = sysRegRead(AR5315_GPIO_INT);
+
+	reg &= ~(GPIO_INT_M(intnum));
+	reg &= ~(GPIO_INT_LVL_M(intnum));
+
+	if (enabled) {
+		reg |= GPIO_INT_LVL(intlevel, intnum);
+		reg |= GPIO_INT(gpio, intnum);
+	}
+
+	sysRegWrite(AR5315_GPIO_INT, reg);
+	(void)sysRegRead(AR5315_GPIO_INT); /* flush write to hardware */
+}
+
+
+/* Enable the specified AR531X_GPIO_IRQ interrupt */
+static void
+ar531x_gpio_intr_enable(unsigned int irq)
+{
+	int gpio = irq - AR531X_GPIO_IRQ_BASE;
+
+	gpioIntMask |= (1<<gpio);
+	ar531x_gpio_intr_set_enabled(irq, 1);
+}
+
+/* Disable the specified AR531X_GPIO_IRQ interrupt */
+static void
+ar531x_gpio_intr_disable(unsigned int irq)
+{
+	int gpio = irq - AR531X_GPIO_IRQ_BASE;
+
+	gpioIntMask &= (1<<gpio);
+	ar531x_gpio_intr_set_enabled(irq, 0);
+}
+
+
+static void
+ar531x_gpio_intr_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		ar531x_gpio_intr_enable(irq);
+}
+
+int ar531x_gpio_irq_base;
+
+struct hw_interrupt_type ar531x_gpio_intr_controller = {
+	.typename = "AR531X GPIO",
+	.startup = ar531x_gpio_intr_startup,
+	.shutdown = ar531x_gpio_intr_shutdown,
+	.enable = ar531x_gpio_intr_enable,
+	.disable = ar531x_gpio_intr_disable,
+	.ack = ar531x_gpio_intr_disable,
+	.end = ar531x_gpio_intr_end,
+};
+
+void
+ar531x_gpio_intr_init(int irq_base)
+{
+	int i;
+
+	for (i = irq_base; i < irq_base + AR531X_GPIO_IRQ_COUNT; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].chip = &ar531x_gpio_intr_controller;
+	}
+
+	ar531x_gpio_irq_base = irq_base;
+}
+
+
diff -urN linux.old/arch/mips/ar531x/irq.c linux.dev/arch/mips/ar531x/irq.c
--- linux.old/arch/mips/ar531x/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar531x/irq.c	2006-12-17 15:09:04.000000000 +0100
@@ -0,0 +1,312 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ */
+
+/*
+ * Interrupt support for AR531X WiSOC.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/gdb-stub.h>
+
+#include "ar531xlnx.h"
+#include <asm/irq_cpu.h>
+
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+
+static void ar531x_misc_intr_enable(unsigned int irq);
+static void ar531x_misc_intr_disable(unsigned int irq);
+
+
+/* Turn on the specified AR531X_MISC_IRQ interrupt */
+static unsigned int
+ar531x_misc_intr_startup(unsigned int irq)
+{
+	ar531x_misc_intr_enable(irq);
+	return 0;
+}
+
+/* Turn off the specified AR531X_MISC_IRQ interrupt */
+static void
+ar531x_misc_intr_shutdown(unsigned int irq)
+{
+	ar531x_misc_intr_disable(irq);
+}
+
+/* Enable the specified AR531X_MISC_IRQ interrupt */
+static void
+ar531x_misc_intr_enable(unsigned int irq)
+{
+	unsigned int imr;
+
+	imr = sysRegRead(AR5315_IMR);
+	switch(irq)
+	{
+	   case AR531X_MISC_IRQ_TIMER:
+	     imr |= IMR_TIMER;
+	     break;
+
+	   case AR531X_MISC_IRQ_AHB_PROC:
+	     imr |= IMR_AHB;
+	     break;
+
+	   case AR531X_MISC_IRQ_AHB_DMA:
+	     imr |= 0/* ?? */;
+	     break;
+
+	   case	AR531X_MISC_IRQ_GPIO:
+	     imr |= IMR_GPIO;
+	     break;
+
+	   case AR531X_MISC_IRQ_UART0:
+	     imr |= IMR_UART0;
+	     break;
+
+
+	   case	AR531X_MISC_IRQ_WATCHDOG:
+	     imr |= IMR_WD;
+	     break;
+
+	   case AR531X_MISC_IRQ_LOCAL:
+	     imr |= 0/* ?? */;
+	     break;
+
+	}
+	sysRegWrite(AR5315_IMR, imr);
+	imr=sysRegRead(AR5315_IMR); /* flush write buffer */
+	//printk("enable Interrupt irq 0x%x imr 0x%x \n",irq,imr);
+
+}
+
+/* Disable the specified AR531X_MISC_IRQ interrupt */
+static void
+ar531x_misc_intr_disable(unsigned int irq)
+{
+	unsigned int imr;
+
+	imr = sysRegRead(AR5315_IMR);
+	switch(irq)
+	{
+	   case AR531X_MISC_IRQ_TIMER:
+	     imr &= (~IMR_TIMER);
+	     break;
+
+	   case AR531X_MISC_IRQ_AHB_PROC:
+	     imr &= (~IMR_AHB);
+	     break;
+
+	   case AR531X_MISC_IRQ_AHB_DMA:
+	     imr &= 0/* ?? */;
+	     break;
+
+	   case	AR531X_MISC_IRQ_GPIO:
+	     imr &= ~IMR_GPIO;
+	     break;
+
+	   case AR531X_MISC_IRQ_UART0:
+	     imr &= (~IMR_UART0);
+	     break;
+
+	   case	AR531X_MISC_IRQ_WATCHDOG:
+	     imr &= (~IMR_WD);
+	     break;
+
+	   case AR531X_MISC_IRQ_LOCAL:
+	     imr &= ~0/* ?? */;
+	     break;
+
+	}
+	sysRegWrite(AR5315_IMR, imr);
+	sysRegRead(AR5315_IMR); /* flush write buffer */
+}
+
+static void
+ar531x_misc_intr_ack(unsigned int irq)
+{
+	ar531x_misc_intr_disable(irq);
+}
+
+static void
+ar531x_misc_intr_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		ar531x_misc_intr_enable(irq);
+}
+
+struct irq_chip ar531x_misc_intr_controller = {
+	.typename	= "AR531X MISC",
+	.startup	= ar531x_misc_intr_startup,
+	.shutdown	= ar531x_misc_intr_shutdown,
+	.enable		= ar531x_misc_intr_enable,
+	.disable	= ar531x_misc_intr_disable,
+	.ack		= ar531x_misc_intr_ack,
+	.end		= ar531x_misc_intr_end,
+};
+
+/*
+ * Determine interrupt source among interrupts that use IP6
+ */
+void
+ar531x_misc_intr_init(int irq_base)
+{
+	int i;
+
+	for (i = irq_base; i < irq_base + AR531X_MISC_IRQ_COUNT; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].chip = &ar531x_misc_intr_controller;
+	}
+}
+
+/* ARGSUSED */
+irqreturn_t
+spurious_irq_handler(int cpl, void *dev_id)
+{
+    /* 
+    printk("spurious_irq_handler: %d  cause=0x%8.8x  status=0x%8.8x\n",
+	   cpl, cause_intrs, status_intrs); 
+    */
+	return IRQ_NONE;
+}
+
+/* ARGSUSED */
+irqreturn_t
+spurious_misc_handler(int cpl, void *dev_id)
+{
+    /*
+    printk("spurious_misc_handler: 0x%x isr=0x%8.8x imr=0x%8.8x\n",
+	   cpl, ar531x_isr, ar531x_imr);
+    */
+	return IRQ_NONE;
+}
+
+irqreturn_t
+ar531x_ahb_proc_handler(int cpl, void *dev_id)
+{
+    u32 procAddr = -1;
+    u32 proc1 = -1;
+    u32 dmaAddr = -1;
+    u32 dma1 = -1;
+    sysRegWrite(AR5315_AHB_ERR0,AHB_ERROR_DET);
+    sysRegRead(AR5315_AHB_ERR1);
+
+    printk("AHB interrupt: PROCADDR=0x%8.8x  PROC1=0x%8.8x  DMAADDR=0x%8.8x  DMA1=0x%8.8x\n",
+	procAddr, proc1, dmaAddr, dma1);
+	
+    machine_restart("AHB error"); /* Catastrophic failure */
+    return IRQ_HANDLED;
+}
+
+static struct irqaction cascade  = {
+	.handler	= no_action,
+	.flags		= SA_INTERRUPT,
+	.name		= "cascade",
+};
+
+static struct irqaction spurious_irq  = {
+	.handler	= spurious_irq_handler,
+	.flags		= SA_INTERRUPT,
+	.name		= "spurious_irq",
+};
+
+static struct irqaction spurious_misc  = {
+	.handler	= spurious_misc_handler,
+	.flags		= SA_INTERRUPT,
+	.name		= "spurious_misc",
+};
+
+static struct irqaction ar531x_ahb_proc_interrupt  = {
+	.handler	= ar531x_ahb_proc_handler,
+	.flags		= SA_INTERRUPT,
+	.name		= "ar531x_ahb_proc_interrupt",
+};
+
+/*
+ * Called when an interrupt is received, this function
+ * determines exactly which interrupt it was, and it
+ * invokes the appropriate handler.
+ *
+ * Implicitly, we also define interrupt priority by
+ * choosing which to dispatch first.
+ */
+asmlinkage void plat_irq_dispatch(void)
+{
+	int pending = read_c0_status() & read_c0_cause();
+
+	if (pending & CAUSEF_IP3)
+		do_IRQ(AR531X_IRQ_WLAN0_INTRS);
+	else if (pending & CAUSEF_IP4)
+		do_IRQ(AR531X_IRQ_ENET0_INTRS);
+	else if (pending & CAUSEF_IP2) {
+		unsigned int ar531x_misc_intrs = sysRegRead(AR5315_ISR) & sysRegRead(AR5315_IMR);
+
+	    if (ar531x_misc_intrs & ISR_TIMER)
+			do_IRQ(AR531X_MISC_IRQ_TIMER);
+		else if (ar531x_misc_intrs & ISR_AHB)
+			do_IRQ(AR531X_MISC_IRQ_AHB_PROC);
+		else if (ar531x_misc_intrs & ISR_GPIO) {
+#if 0
+			int i;
+			u32 gpioIntPending;
+			
+			gpioIntPending = sysRegRead(AR5315_GPIO_DI) & gpioIntMask;
+			for (i=0; i<AR531X_GPIO_IRQ_COUNT; i++) {
+				if (gpioIntPending & (1 << i))
+					do_IRQ(AR531X_GPIO_IRQ_BASE+i);
+			}
+#endif
+			sysRegWrite(AR5315_ISR, sysRegRead(AR5315_IMR) | ~ISR_GPIO);
+		} else if (ar531x_misc_intrs & ISR_UART0)
+			do_IRQ(AR531X_MISC_IRQ_UART0);
+		else if (ar531x_misc_intrs & ISR_WD)
+			do_IRQ(AR531X_MISC_IRQ_WATCHDOG);
+		else
+			do_IRQ(AR531X_MISC_IRQ_NONE);
+	} else if (pending & CAUSEF_IP7)
+		do_IRQ(AR531X_IRQ_CPU_CLOCK);
+	else
+		do_IRQ(AR531X_IRQ_NONE);
+}
+
+void __init arch_init_irq(void)
+{
+	clear_c0_status(ST0_IM);
+	mips_cpu_irq_init(0);
+
+	/* Initialize interrupt controllers */
+	ar531x_misc_intr_init(AR531X_MISC_IRQ_BASE);
+#if 0
+	ar531x_gpio_intr_init(AR531X_GPIO_IRQ_BASE);
+#endif
+	setup_irq(AR531X_IRQ_MISC_INTRS, &cascade);
+	/*
+	 * AR531X_IRQ_CPU_CLOCK is setup by ar531x_timer_setup.
+	 */
+
+	/* Default "spurious interrupt" handlers */
+	setup_irq(AR531X_IRQ_NONE, &spurious_irq);
+	setup_irq(AR531X_MISC_IRQ_NONE, &spurious_misc);
+	setup_irq(AR531X_MISC_IRQ_AHB_PROC, &ar531x_ahb_proc_interrupt);
+	setup_irq(AR531X_MISC_IRQ_GPIO, &cascade);
+}
diff -urN linux.old/arch/mips/ar531x/Makefile linux.dev/arch/mips/ar531x/Makefile
--- linux.old/arch/mips/ar531x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar531x/Makefile	2006-12-16 03:51:47.000000000 +0100
@@ -0,0 +1,18 @@
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 2003 Atheros Communications, Inc.,  All Rights Reserved.
+# Copyright (C) 2006 FON Technology, SL.
+# Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+# Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+#
+
+# Makefile for Atheros ar531x boards
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+obj-y := setup.o prom.o irq.o devices.o
diff -urN linux.old/arch/mips/ar531x/prom.c linux.dev/arch/mips/ar531x/prom.c
--- linux.old/arch/mips/ar531x/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar531x/prom.c	2006-12-16 04:50:30.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright MontaVista Software Inc
+ * Copyright (C) 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ */
+
+/*
+ * Prom setup file for ar531x
+ */
+
+#include <linux/init.h>
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+
+#include "ar531xlnx.h"
+
+void __init prom_init(void)
+{
+	u32 memsize, memcfg;
+
+    mips_machgroup = MACH_GROUP_AR531X;
+    mips_machtype = MACH_ATHEROS_AP51;
+
+	memcfg = sysRegRead(AR5315_MEM_CFG);
+	memsize   = 1 + ((memcfg & SDRAM_DATA_WIDTH_M) >> SDRAM_DATA_WIDTH_S);
+	memsize <<= 1 + ((memcfg & SDRAM_COL_WIDTH_M) >> SDRAM_COL_WIDTH_S);
+	memsize <<= 1 + ((memcfg & SDRAM_ROW_WIDTH_M) >> SDRAM_ROW_WIDTH_S);
+	memsize <<= 3;
+    add_memory_region(0, memsize, BOOT_MEM_RAM);
+
+    strcpy(arcs_cmdline, "console=ttyS0,9600 rootfstype=squashfs,jffs2");
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+
diff -urN linux.old/arch/mips/ar531x/setup.c linux.dev/arch/mips/ar531x/setup.c
--- linux.old/arch/mips/ar531x/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/ar531x/setup.c	2006-12-16 03:51:47.000000000 +0100
@@ -0,0 +1,198 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 Atheros Communications, Inc.,  All Rights Reserved.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ */
+
+/*
+ * Initialization for ar531x SOC.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/pm.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/types.h>
+#include <linux/string.h>
+
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/serial.h>
+
+#include "ar531xlnx.h"
+
+void
+ar531x_restart(char *command)
+{
+	 for(;;) {
+		 /* 
+		 ** Cold reset does not work,work around is to use the GPIO reset bit.  
+		 */
+		 unsigned int reg;
+
+		 /* AR2317 reset */
+		 sysRegWrite(AR5315_COLD_RESET,AR5317_RESET_SYSTEM);
+
+		 reg = sysRegRead(AR5315_GPIO_DO);
+		 reg &= ~(1 << AR5315_RESET_GPIO);
+		 sysRegWrite(AR5315_GPIO_DO, reg);
+		 (void)sysRegRead(AR5315_GPIO_DO); /* flush write to hardware */
+	 }
+}
+
+void
+ar531x_halt(void)
+{
+	 printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+	 while (1);
+}
+
+void
+ar531x_power_off(void)
+{
+	 ar531x_halt();
+}
+
+char *get_system_type(void)
+{
+	return "Atheros AR5315";
+}
+
+/*
+ * This table is indexed by bits 5..4 of the CLOCKCTL1 register
+ * to determine the predevisor value.
+ */
+static int __initdata CLOCKCTL1_PREDIVIDE_TABLE[4] = {
+    1,
+    2,
+    4,
+    5
+};
+
+static int __initdata PLLC_DIVIDE_TABLE[5] = {
+    2,
+    3,
+    4,
+    6,
+    3
+};
+
+static unsigned int __init
+ar531x_sys_clk(unsigned int clockCtl)
+{
+    unsigned int pllcCtrl,cpuDiv;
+    unsigned int pllcOut,refdiv,fdiv,divby2;
+	unsigned int clkDiv;
+
+    pllcCtrl = sysRegRead(AR5315_PLLC_CTL);
+    refdiv = (pllcCtrl & PLLC_REF_DIV_M) >> PLLC_REF_DIV_S;
+    refdiv = CLOCKCTL1_PREDIVIDE_TABLE[refdiv];
+    fdiv = (pllcCtrl & PLLC_FDBACK_DIV_M) >> PLLC_FDBACK_DIV_S;
+    divby2 = (pllcCtrl & PLLC_ADD_FDBACK_DIV_M) >> PLLC_ADD_FDBACK_DIV_S;
+    divby2 += 1;
+    pllcOut = (40000000/refdiv)*(2*divby2)*fdiv;
+
+
+    /* clkm input selected */
+	switch(clockCtl & CPUCLK_CLK_SEL_M) {
+		case 0:
+		case 1:
+			clkDiv = PLLC_DIVIDE_TABLE[(pllcCtrl & PLLC_CLKM_DIV_M) >> PLLC_CLKM_DIV_S];
+			break;
+		case 2:
+			clkDiv = PLLC_DIVIDE_TABLE[(pllcCtrl & PLLC_CLKC_DIV_M) >> PLLC_CLKC_DIV_S];
+			break;
+		default:
+			pllcOut = 40000000;
+			clkDiv = 1;
+			break;
+	}
+	cpuDiv = (clockCtl & CPUCLK_CLK_DIV_M) >> CPUCLK_CLK_DIV_S;  
+	cpuDiv = cpuDiv * 2 ?: 1;
+	return (pllcOut/(clkDiv * cpuDiv));
+}
+		
+static inline unsigned int ar531x_cpu_frequency(void)
+{
+    return ar531x_sys_clk(sysRegRead(AR5315_CPUCLK));
+}
+
+static inline unsigned int ar531x_apb_frequency(void)
+{
+    return ar531x_sys_clk(sysRegRead(AR5315_AMBACLK));
+}
+
+
+void __init serial_setup(void)
+{
+	struct uart_port s;
+	
+	memset(&s, 0, sizeof(s));
+
+	s.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	s.iotype = UPIO_MEM;
+	s.uartclk = AR5315_UART_CLOCK_RATE;
+	s.irq = AR531X_MISC_IRQ_UART0;
+	s.regshift = 2;
+	s.mapbase = KSEG1ADDR(AR5315_UART0);
+	s.membase = (void __iomem *)s.mapbase;
+
+	early_serial_setup(&s);
+}
+
+void __init plat_timer_setup(struct irqaction *irq)
+{
+	unsigned int count;
+
+	/* Usually irq is timer_irqaction (timer_interrupt) */
+	setup_irq(AR531X_IRQ_CPU_CLOCK, irq);
+
+	/* to generate the first CPU timer interrupt */
+	count = read_c0_count();
+	write_c0_compare(count + 1000);
+}
+
+static void __init
+ar531x_time_init(void)
+{
+	mips_hpt_frequency = ar531x_cpu_frequency() / 2;
+}
+
+void __init plat_mem_setup(void)
+{
+	unsigned int config = read_c0_config();
+
+	/* Clear any lingering AHB errors */
+	write_c0_config(config & ~0x3);
+	sysRegWrite(AR5315_AHB_ERR0,AHB_ERROR_DET);
+	sysRegRead(AR5315_AHB_ERR1);
+	sysRegWrite(AR5315_WDC, WDC_IGNORE_EXPIRATION);
+
+	/* Disable data watchpoints */
+	write_c0_watchlo0(0);
+
+	board_time_init = ar531x_time_init;
+
+	_machine_restart = ar531x_restart;
+	_machine_halt = ar531x_halt;
+	pm_power_off = ar531x_power_off;
+
+	serial_setup();
+}
+
+EXPORT_SYMBOL(get_system_type);
diff -urN linux.old/arch/mips/Kconfig linux.dev/arch/mips/Kconfig
--- linux.old/arch/mips/Kconfig	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/arch/mips/Kconfig	2006-12-16 03:51:47.000000000 +0100
@@ -145,6 +145,19 @@
 	  note that a kernel built with this option selected will not be
 	  able to run on normal units.
 
+config AR531X
+	bool 'Atheros AR531x/AR231x WiSoC (EXPERIMENTAL)'
+	depends on EXPERIMENTAL
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select HAVE_STD_PC_SERIAL_PORT
+	select AR531X_COBRA
+	select AR5315
+	select AP51
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_32BIT_KERNEL
+
 config MIPS_COBALT
 	bool "Cobalt Server"
 	select DMA_NONCOHERENT
@@ -864,6 +877,18 @@
 config MIPS_DISABLE_OBSOLETE_IDE
 	bool
 
+config AR531X_COBRA
+	bool
+
+config AR5315
+	bool
+
+config AR5317
+	bool
+
+config AP51
+	bool
+
 #
 # Endianess selection.  Suffiently obscure so many users don't know what to
 # answer,so we try hard to limit the available choices.  Also the use of a
diff -urN linux.old/arch/mips/Makefile linux.dev/arch/mips/Makefile
--- linux.old/arch/mips/Makefile	2006-12-14 23:53:29.000000000 +0100
+++ linux.dev/arch/mips/Makefile	2006-12-16 04:45:48.000000000 +0100
@@ -267,6 +267,13 @@
 load-$(CONFIG_MIPS_XXS1500)	+= 0xffffffff80100000
 
 #
+# Atheros AR5312/AR2312 WiSoC
+#
+core-$(CONFIG_AR531X)     += arch/mips/ar531x/
+cflags-$(CONFIG_AR531X)   += -Iinclude/asm-mips/mach-atheros
+load-$(CONFIG_AR531X)     += 0xffffffff80041000
+
+#
 # Cobalt Server
 #
 core-$(CONFIG_MIPS_COBALT)	+= arch/mips/cobalt/
diff -urN linux.old/include/asm-mips/bootinfo.h linux.dev/include/asm-mips/bootinfo.h
--- linux.old/include/asm-mips/bootinfo.h	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/include/asm-mips/bootinfo.h	2006-12-16 03:51:47.000000000 +0100
@@ -212,6 +212,19 @@
 #define MACH_GROUP_NEC_EMMA2RH 25	/* NEC EMMA2RH (was 23)		*/
 #define  MACH_NEC_MARKEINS	0	/* NEC EMMA2RH Mark-eins	*/
 
+/*
+ * Valid machtype for group AR531X
+ */
+#define MACH_GROUP_AR531X      23
+#define MACH_ATHEROS_UNUSED     0
+#define MACH_ATHEROS_AP30       1       /* AP30 */
+#define MACH_ATHEROS_AP33       2       /* AP33 */
+#define MACH_ATHEROS_AP38       3       /* AP38 */
+#define MACH_ATHEROS_AP43       4       /* AP43 */
+#define MACH_ATHEROS_AP48       5       /* AP48 */
+#define MACH_ATHEROS_PB32       6       /* PB32 */
+#define MACH_ATHEROS_AP51       7       /* AP51 */
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -urN linux.old/include/asm-mips/mach-atheros/ar531x_platform.h linux.dev/include/asm-mips/mach-atheros/ar531x_platform.h
--- linux.old/include/asm-mips/mach-atheros/ar531x_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/mach-atheros/ar531x_platform.h	2006-12-16 04:27:21.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef __AR531X_PLATFORM_H
+#define __AR531X_PLATFORM_H
+
+struct ar531x_eth {
+	int phy;
+	int mac;
+	u32 reset_base;
+	u32 reset_mac;
+	u32 reset_phy;
+	char *board_config;
+};
+
+#endif /* __AR531X_PLATFORM_H */
+
