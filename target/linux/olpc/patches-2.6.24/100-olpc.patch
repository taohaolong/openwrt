diff -purN linux_2.6.24_org/arch/x86/Kconfig linux_2.6.24_olpc/arch/x86/Kconfig
--- linux_2.6.24_org/arch/x86/Kconfig	2008-02-15 20:11:57.000000000 +0000
+++ linux_2.6.24_olpc/arch/x86/Kconfig	2008-02-15 18:59:21.000000000 +0000
@@ -1415,6 +1415,9 @@ config PCI_GODIRECT
 config PCI_GOANY
 	bool "Any"
 
+config PCI_GOOLPC
+	bool "OLPC"
+
 endchoice
 
 config PCI_BIOS
@@ -1425,7 +1428,7 @@ config PCI_BIOS
 # x86-64 doesn't support PCI BIOS access from long mode so always go direct.
 config PCI_DIRECT
 	bool
-	depends on PCI && (X86_64 || (PCI_GODIRECT || PCI_GOANY) || X86_VISWS)
+	depends on PCI && (X86_64 || (PCI_GODIRECT || PCI_GOANY || PCI_GOOLPC) || X86_VISWS)
 	default y
 
 config PCI_MMCONFIG
@@ -1442,6 +1445,11 @@ config PCI_MMCONFIG
 	bool "Support mmconfig PCI config space access"
 	depends on X86_64 && PCI && ACPI
 
+config PCI_OLPC
+	bool 
+	depends on PCI && PCI_GOOLPC
+	default y
+
 config DMAR
 	bool "Support for DMA Remapping Devices (EXPERIMENTAL)"
 	depends on X86_64 && PCI_MSI && ACPI && EXPERIMENTAL
@@ -1561,6 +1569,21 @@ config K8_NB
 	def_bool y
 	depends on AGP_AMD64 || (X86_64 && (GART_IOMMU || (PCI && NUMA)))
 
+config OLPC
+	bool "OLPC Support"
+	default n
+	help
+	  Add OLPC Support
+
+config OLPC_PM
+	bool "OLPC power management support"
+	default n
+	depends on OLPC
+
+config OPEN_FIRMWARE
+	bool "Support for Open Firmware"
+	default y if OLPC
+
 source "drivers/pcmcia/Kconfig"
 
 source "drivers/pci/hotplug/Kconfig"
diff -purN linux_2.6.24_org/arch/x86/kernel/Makefile_32 linux_2.6.24_olpc/arch/x86/kernel/Makefile_32
--- linux_2.6.24_org/arch/x86/kernel/Makefile_32	2008-02-15 20:11:58.000000000 +0000
+++ linux_2.6.24_olpc/arch/x86/kernel/Makefile_32	2008-02-15 18:59:25.000000000 +0000
@@ -49,6 +49,13 @@ obj-y				+= pcspeaker.o
 
 obj-$(CONFIG_SCx200)		+= scx200_32.o
 
+obj-$(CONFIG_OLPC)		+= olpc.o
+obj-$(CONFIG_OLPC_PM)		+= olpc-pm.o olpc-wakeup.o
+obj-$(CONFIG_OPEN_FIRMWARE)	+= ofw.o
+obj-$(PROM_FS)			+= promfs.o
+
+
+
 # vsyscall_32.o contains the vsyscall DSO images as __initdata.
 # We must build both images before we can assemble it.
 # Note: kbuild does not track this dependency due to usage of .incbin
diff -purN linux_2.6.24_org/arch/x86/kernel/ofw.c linux_2.6.24_olpc/arch/x86/kernel/ofw.c
--- linux_2.6.24_org/arch/x86/kernel/ofw.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/arch/x86/kernel/ofw.c	2008-02-15 18:59:25.000000000 +0000
@@ -0,0 +1,100 @@
+/*
+ * ofw.c - Open Firmware client interface for 32-bit systems.
+ * This code is intended to be portable to any 32-bit Open Firmware
+ * implementation with a standard client interface that can be
+ * called when Linux is running.
+ *
+ * Copyright (C) 2007  Mitch Bradley <wmb@firmworks.com>
+ * Copyright (C) 2007  Andres Salomon <dilinger@debian.org>
+ */
+
+#include <stdarg.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <asm/ofw.h>
+
+
+int (*call_firmware)(int *);
+
+static DEFINE_SPINLOCK(prom_lock);
+
+#define MAXARGS 20
+
+/*
+ * The return value from ofw() in all cases is 0 if the attempt to call the
+ * function succeeded, <0 otherwise.  That return value is from the
+ * gateway function only.  Any results from the called function are returned
+ * via output argument pointers. 
+ *
+ * Here are call templates for all the standard OFW client services:
+ *
+ * ofw("test", 1, 1, namestr, &missing);
+ * ofw("peer", 1, 1, phandle, &sibling_phandle);
+ * ofw("child", 1, 1, phandle, &child_phandle);
+ * ofw("parent", 1, 1, phandle, &parent_phandle);
+ * ofw("instance_to_package", 1, 1, ihandle, &phandle);
+ * ofw("getproplen", 2, 1, phandle, namestr, &proplen);
+ * ofw("getprop", 4, 1, phandle, namestr, bufaddr, buflen, &size);
+ * ofw("nextprop", 3, 1, phandle, previousstr, bufaddr, &flag);
+ * ofw("setprop", 4, 1, phandle, namestr, bufaddr, len, &size);
+ * ofw("canon", 3, 1, devspecstr, bufaddr, buflen, &length);
+ * ofw("finddevice", 1, 1, devspecstr, &phandle);
+ * ofw("instance-to-path", 3, 1, ihandle, bufaddr, buflen, &length);
+ * ofw("package-to-path", 3, 1, phandle, bufaddr, buflen, &length);
+ * ofw("call_method", numin, numout, in0, in1, ..., &out0, &out1, ...);
+ * ofw("open", 1, 1, devspecstr, &ihandle);
+ * ofw("close", 1, 0, ihandle);
+ * ofw("read", 3, 1, ihandle, addr, len, &actual);
+ * ofw("write", 3, 1, ihandle, addr, len, &actual);
+ * ofw("seek", 3, 1, ihandle, pos_hi, pos_lo, &status);
+ * ofw("claim", 3, 1, virtaddr, size, align, &baseaddr);
+ * ofw("release", 2, 0, virtaddr, size);
+ * ofw("boot", 1, 0, bootspecstr);
+ * ofw("enter", 0, 0);
+ * ofw("exit", 0, 0);
+ * ofw("chain", 5, 0, virtaddr, size, entryaddr, argsaddr, len);
+ * ofw("interpret", numin+1, numout+1, cmdstr, in0, ..., &catchres, &out0, ...);
+ * ofw("set-callback", 1, 1, newfuncaddr, &oldfuncaddr);
+ * ofw("set-symbol-lookup", 2, 0, symtovaladdr, valtosymaddr);
+ * ofw("milliseconds", 0, 1, &ms);
+ */
+
+int ofw(char *name, int numargs, int numres, ...)
+{
+	va_list ap;
+	int argarray[MAXARGS+3];
+	int argnum = 3;
+	int retval;
+	int *intp;
+	unsigned long flags;
+
+	if (!call_firmware)
+		return -1;
+	if ((numargs + numres) > MAXARGS)
+		return -1;	/* spit out an error? */
+
+	argarray[0] = (int) name;
+	argarray[1] = numargs;
+	argarray[2] = numres;
+
+	va_start(ap, numres);
+	while (numargs) {
+		argarray[argnum++] = va_arg(ap, int);
+		numargs--;
+	}
+
+	spin_lock_irqsave(&prom_lock, flags);
+	retval = call_firmware(argarray);
+	spin_unlock_irqrestore(&prom_lock, flags);
+
+	if (retval == 0) {
+		while (numres) {
+			intp = va_arg(ap, int *);
+			*intp = argarray[argnum++];
+			numres--;
+		}
+	}
+	va_end(ap);
+	return retval;
+}
+EXPORT_SYMBOL(ofw);
diff -purN linux_2.6.24_org/arch/x86/kernel/olpc.c linux_2.6.24_olpc/arch/x86/kernel/olpc.c
--- linux_2.6.24_org/arch/x86/kernel/olpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/arch/x86/kernel/olpc.c	2008-02-15 18:59:25.000000000 +0000
@@ -0,0 +1,287 @@
+/* Support for the OLPC DCON and OLPC EC access
+ * Copyright (C) 2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+
+#include <asm/olpc.h>
+#include <asm/ofw.h>
+
+/* This is our new multi-purpose structure used to contain the
+ * information about the platform that we detect
+ */
+
+struct olpc_platform_t olpc_platform_info;
+EXPORT_SYMBOL_GPL(olpc_platform_info);
+
+/*********************************************************************
+ *		EC locking and access
+ *********************************************************************/
+
+static DEFINE_SPINLOCK(ec_lock);
+
+/* what the timeout *should* be (in ms) */
+#define EC_BASE_TIMEOUT 20
+
+/* the timeout that bugs in the EC might force us to actually use */
+static int ec_timeout = EC_BASE_TIMEOUT;
+
+static int __init olpc_ec_timeout_set(char *str)
+{
+	if (get_option(&str, &ec_timeout) != 1) {
+		ec_timeout = EC_BASE_TIMEOUT;
+		printk(KERN_ERR "olpc-ec:  invalid argument to "
+				"'olpc_ec_timeout=', ignoring!\n");
+	}
+	printk(KERN_DEBUG "olpc-ec:  using %d ms delay for EC commands.\n",
+			ec_timeout);
+	return 1;
+}
+__setup("olpc_ec_timeout=", olpc_ec_timeout_set);
+
+/*
+ * These *bf_status functions return whether the buffers are full or not.
+ */
+
+static inline unsigned int ibf_status(unsigned int port)
+{
+	return !!(inb(port) & 0x02);
+}
+
+static inline unsigned int obf_status(unsigned int port)
+{
+	return inb(port) & 0x01;
+}
+
+#define wait_on_ibf(p, d) __wait_on_ibf(__LINE__, (p), (d))
+static int __wait_on_ibf(unsigned int line, unsigned int port, int desired)
+{
+	unsigned int timeo;
+	int state = ibf_status(port);
+
+	for (timeo = ec_timeout; state != desired && timeo; timeo--) {
+		mdelay(1);
+		state = ibf_status(port);
+	}
+
+	if ((state == desired) && (ec_timeout > EC_BASE_TIMEOUT) &&
+			timeo < (ec_timeout - EC_BASE_TIMEOUT)) {
+		printk(KERN_WARNING "olpc-ec:  %d: waited %u ms for IBF!\n",
+				line, ec_timeout - timeo);
+	}
+
+	return !(state == desired);
+}
+
+#define wait_on_obf(p, d) __wait_on_obf(__LINE__, (p), (d))
+static int __wait_on_obf(unsigned int line, unsigned int port, int desired)
+{
+	unsigned int timeo;
+	int state = obf_status(port);
+
+	for (timeo = ec_timeout; state != desired && timeo; timeo--) {
+		mdelay(1);
+		state = obf_status(port);
+	}
+
+	if ((state == desired) && (ec_timeout > EC_BASE_TIMEOUT) &&
+			timeo < (ec_timeout - EC_BASE_TIMEOUT)) {
+		printk(KERN_WARNING "olpc-ec:  %d: waited %u ms for OBF!\n",
+				line, ec_timeout - timeo);
+	}
+
+	return !(state == desired);
+}
+
+int olpc_ec_cmd(unsigned char cmd, unsigned char *inbuf, size_t inlen,
+		unsigned char *outbuf,  size_t outlen)
+{
+	unsigned long flags;
+	int ret = -EIO;
+	int i;
+
+	spin_lock_irqsave(&ec_lock, flags);
+
+	/* Clear OBF */
+	for (i = 0; i < 10 && (obf_status(0x6c) == 1); i++)
+		inb(0x68);
+	if (i == 10) {
+		printk(KERN_ERR "olpc-ec:  timeout while attempting to "
+				"clear OBF flag!\n");
+		goto err;
+	}
+
+	if (wait_on_ibf(0x6c, 0)) {
+		printk(KERN_ERR "olpc-ec:  timeout waiting for EC to "
+				"quiesce!\n");
+		goto err;
+	}
+
+restart:
+	/*
+	 * Note that if we time out during any IBF checks, that's a failure;
+	 * we have to return.  There's no way for the kernel to clear that.
+	 *
+	 * If we time out during an OBF check, we can restart the command;
+	 * reissuing it will clear the OBF flag, and we should be alright.
+	 * The OBF flag will sometimes misbehave due to what we believe
+	 * is a hardware quirk..
+	 */
+	printk(KERN_DEBUG "olpc-ec:  running cmd 0x%x\n", cmd);
+	outb(cmd, 0x6c);
+
+	if (wait_on_ibf(0x6c, 0)) {
+		printk(KERN_ERR "olpc-ec:  timeout waiting for EC to read "
+				"command!\n");
+		goto err;
+	}
+
+	if (inbuf && inlen) {
+		/* write data to EC */
+		for (i = 0; i < inlen; i++) {
+			if (wait_on_ibf(0x6c, 0)) {
+				printk(KERN_ERR "olpc-ec:  timeout waiting for"
+						" EC accept data!\n");
+				goto err;
+			}
+			printk(KERN_DEBUG "olpc-ec:  sending cmd arg 0x%x\n",
+					inbuf[i]);
+			outb(inbuf[i], 0x68);
+		}
+	}
+	if (outbuf && outlen) {
+		/* read data from EC */
+		for (i = 0; i < outlen; i++) {
+			if (wait_on_obf(0x6c, 1)) {
+				printk(KERN_ERR "olpc-ec:  timeout waiting for"
+						" EC to provide data!\n");
+				goto restart;
+			}
+			outbuf[i] = inb(0x68);
+			printk(KERN_DEBUG "olpc-ec:  received 0x%x\n",
+					outbuf[i]);
+		}
+	}
+
+	ret = 0;
+err:
+	spin_unlock_irqrestore(&ec_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(olpc_ec_cmd);
+
+/*********************************************************************
+ *		DCON stuff
+ *********************************************************************/
+
+static void __init
+ec_detect(void)
+{
+	olpc_ec_cmd(0x08, NULL, 0, (unsigned char *) &olpc_platform_info.ecver, 1);
+}
+
+/* Check to see if this version of the OLPC board has VSA built
+ * in, and set a flag
+ */
+
+static void __init vsa_detect(void)
+{
+	u16 rev;
+
+	outw(0xFC53, 0xAC1C);
+	outw(0x0003, 0xAC1C);
+
+	rev = inw(0xAC1E);
+
+	if (rev == 0x4132)
+		olpc_platform_info.flags |= OLPC_F_VSA;
+}
+
+static void __init platform_detect(void)
+{
+	size_t propsize;
+	u32 rev;
+
+	if (ofw("getprop", 4, 1, NULL, "board-revision-int", &rev, 4,
+			&propsize) || propsize != 4) {
+		printk(KERN_ERR "ofw: getprop call failed!\n");
+		rev = 0;
+	}
+	olpc_platform_info.boardrev = be32_to_cpu(rev);
+}
+
+static int olpc_dcon_present = -1;
+module_param(olpc_dcon_present, int, 0444);
+
+/* REV_A CMOS map:
+ * bit 440;  DCON present bit
+ */
+
+#define OLPC_CMOS_DCON_OFFSET (440 / 8)
+#define OLPC_CMOS_DCON_MASK   0x01
+
+static int __init olpc_init(void)
+{
+	unsigned char *romsig;
+
+	spin_lock_init(&ec_lock);
+
+	romsig = ioremap(0xffffffc0, 16);
+
+	if (!romsig)
+		return 0;
+
+	if (strncmp(romsig, "CL1   Q", 7))
+		goto unmap;
+	if (strncmp(romsig+6, romsig+13, 3)) {
+		printk(KERN_INFO "OLPC BIOS signature looks invalid. Assuming not OLPC\n");
+		goto unmap;
+	}
+	printk(KERN_INFO "OLPC board with OpenFirmware: %.16s\n", romsig);
+
+	olpc_platform_info.flags |= OLPC_F_PRESENT;
+
+	/* Get the platform revision */
+	platform_detect();
+
+	/* If olpc_dcon_present isn't set by the command line, then
+	 * "detect" it
+	 */
+
+	if (olpc_dcon_present == -1) {
+		/* B1 and greater always has a DCON */
+		if (olpc_board_at_least(olpc_board(0xb1)))
+			olpc_dcon_present = 1;
+	}
+
+	if (olpc_dcon_present)
+		olpc_platform_info.flags |= OLPC_F_DCON;
+
+	/* Get the EC revision */
+	ec_detect();
+
+	/* Check to see if the VSA exists */
+	vsa_detect();
+
+	printk(KERN_INFO "OLPC board revision: %s%X (EC=%x)\n",
+			((olpc_platform_info.boardrev & 0xf) < 8) ? "pre" : "",
+			olpc_platform_info.boardrev >> 4,
+			olpc_platform_info.ecver);
+
+ unmap:
+	iounmap(romsig);
+
+	return 0;
+}
+
+postcore_initcall(olpc_init);
diff -purN linux_2.6.24_org/arch/x86/kernel/olpc-pm.c linux_2.6.24_olpc/arch/x86/kernel/olpc-pm.c
--- linux_2.6.24_org/arch/x86/kernel/olpc-pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/arch/x86/kernel/olpc-pm.c	2008-02-15 18:59:26.000000000 +0000
@@ -0,0 +1,946 @@
+/* olpc-pm.c
+ * © 2006 Red Hat, Inc.
+ * Portions also copyright 2006 Advanced Micro Devices, Inc.
+ * GPLv2
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/suspend.h>
+#include <linux/bootmem.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/mc146818rtc.h>
+#include <asm/io.h>
+
+#include <asm/olpc.h>
+
+/* A few words about accessing the ACPI and PM registers.  Long story short,
+   byte and word accesses of the ACPI and PM registers is broken.  The only
+   way to do it really correctly is to use dword accesses, which we do
+   throughout this code.  For more details, please consult Eratta 17 and 18
+   here:
+
+   http://www.amd.com/files/connectivitysolutions/geode/geode_gx/34472D_CS5536_B1_specupdate.pdf
+*/
+
+#define PM_IRQ 3
+
+#define CS5536_PM_PWRBTN (1 << 8)
+#define CS5536_PM_RTC    (1 << 10)
+#define CS5536_PM_WAK    (1 << 15)
+
+#define GPIO_WAKEUP_EC (1 << 31)
+#define GPIO_WAKEUP_LID (1 << 30)
+
+#define PM_MODE_NORMAL 0
+#define PM_MODE_TEST   1
+#define PM_MODE_MAX    2
+
+/* These, and the battery EC commands, should be in an olpc.h. */
+#define EC_WRITE_SCI_MASK 0x1b
+#define EC_READ_SCI_MASK  0x1c
+
+extern void do_olpc_suspend_lowlevel(void);
+
+static struct {
+	unsigned long address;
+	unsigned short segment;
+} ofw_bios_entry = { 0, __KERNEL_CS };
+
+static int olpc_pm_mode = PM_MODE_NORMAL;
+static unsigned long acpi_base;
+static unsigned long pms_base;
+static int sci_irq;
+static int olpc_lid_flag;
+
+static struct input_dev *pm_inputdev;
+static struct input_dev *lid_inputdev;
+static struct input_dev *ebook_inputdev;
+static struct platform_suspend_ops olpc_pm_ops;
+
+static int gpio_wake_events = 0;
+static int ebook_state = -1;
+static u16 olpc_wakeup_mask = 0;
+
+static unsigned int test_timeout = 0;
+static char *wackup_source = "none";
+
+struct platform_device olpc_powerbutton_dev = {
+	.name = "powerbutton",
+	.id = -1,
+};
+
+struct platform_device olpc_lid_dev = {
+	.name = "lid",
+	.id = -1,
+};
+
+static void __init init_ebook_state(void)
+{
+	if (olpc_ec_cmd(0x2a, NULL, 0, (unsigned char *) &ebook_state, 1)) {
+		printk(KERN_WARNING "olpc-pm:  failed to get EBOOK state!\n");
+		ebook_state = 0;
+	}
+	ebook_state &= 1;
+
+	/* the input layer needs to know what value to default to as well */
+	input_report_switch(ebook_inputdev, SW_TABLET_MODE, ebook_state);
+	input_sync(ebook_inputdev);
+}
+
+static void (*battery_callback)(unsigned long);
+static DEFINE_SPINLOCK(battery_callback_lock);
+
+/* propagate_events is non-NULL if run from workqueue,
+   NULL when called at init time to flush SCI queue */
+static void process_sci_queue(struct work_struct *propagate_events)
+{
+	unsigned char data = 0;
+	unsigned char battery_events = 0;
+	int ret;
+
+	do {
+		ret = olpc_ec_cmd(0x84, NULL, 0, &data, 1);
+		if (!ret) {
+			printk(KERN_DEBUG "olpc-pm:  SCI 0x%x received\n",
+					data);
+
+			if (wackup_source && !strcmp(wackup_source, "sci")) {
+				/*
+				 * XXX: in order for this to not be racy, we
+				 * need assurance that we will never get
+				 * preempted by olpc_do_sleep here!
+				 */
+				switch (data) {
+				case EC_SCI_SRC_EMPTY:
+					wackup_source = "empty sci";
+					break;
+				case EC_SCI_SRC_GAME:
+					wackup_source = "key press";
+					break;
+				case EC_SCI_SRC_BATTERY:
+					wackup_source = "battery";
+					break;
+				case EC_SCI_SRC_BATSOC:
+					wackup_source = "battery state change";
+					break;
+				case EC_SCI_SRC_BATERR:
+					wackup_source = "battery error";
+					break;
+				case EC_SCI_SRC_EBOOK:
+					wackup_source = "ebook";
+					break;
+				case EC_SCI_SRC_WLAN:
+					wackup_source = "wlan packet";
+					break;
+				case EC_SCI_SRC_ACPWR:
+					wackup_source = "ac power";
+					break;
+				default:
+					wackup_source = "unknown";
+				}
+			}
+
+			if (data & (EC_SCI_SRC_BATERR | EC_SCI_SRC_BATSOC |
+					EC_SCI_SRC_BATTERY | EC_SCI_SRC_ACPWR))
+				battery_events |= data;
+			else if (data == EC_SCI_SRC_EBOOK) {
+				ebook_state = !ebook_state;
+				if (propagate_events) {
+					input_report_switch(ebook_inputdev,
+						SW_TABLET_MODE, ebook_state);
+					input_sync(ebook_inputdev);
+				}
+			}
+		}
+	} while (data && !ret);
+
+	if (battery_events && battery_callback && propagate_events) {
+		void (*cbk)(unsigned long);
+		
+		/* Older EC versions didn't distinguish between AC and battery
+		   events */
+		if (olpc_platform_info.ecver < 0x51)
+			battery_events = EC_SCI_SRC_BATTERY | EC_SCI_SRC_ACPWR;
+
+		spin_lock(&battery_callback_lock);
+		cbk = battery_callback;
+		spin_unlock(&battery_callback_lock);
+
+		cbk(battery_events);
+	}
+
+	if (ret)
+		printk(KERN_WARNING "Failed to clear SCI queue!\n");
+}
+
+static DECLARE_WORK(sci_work, process_sci_queue);
+
+void olpc_register_battery_callback(void (*f)(unsigned long))
+{
+	spin_lock(&battery_callback_lock);
+	battery_callback = f;
+	spin_unlock(&battery_callback_lock);
+}
+EXPORT_SYMBOL_GPL(olpc_register_battery_callback);
+
+void olpc_deregister_battery_callback(void)
+{
+	spin_lock(&battery_callback_lock);
+	battery_callback = NULL;
+	spin_unlock(&battery_callback_lock);
+	cancel_work_sync(&sci_work);
+}
+EXPORT_SYMBOL_GPL(olpc_deregister_battery_callback);
+
+
+static int olpc_pm_interrupt(int irq, void *id)
+{
+	uint32_t sts, gpe = 0;
+
+	sts = inl(acpi_base + PM1_STS);
+	outl(sts | 0xFFFF, acpi_base + PM1_STS);
+
+	if (olpc_board_at_least(olpc_board(0xb2))) {
+		gpe = inl(acpi_base + PM_GPE0_STS);
+		outl(0xFFFFFFFF, acpi_base + PM_GPE0_STS);
+	}
+
+	if (sts & CS5536_PM_PWRBTN) {
+		if (!wackup_source)
+			wackup_source = "power button";
+		printk(KERN_DEBUG "olpm-pm:  PM_PWRBTN %sevent received\n",
+				sts & CS5536_PM_WAK ? "wakeup " : "");
+		if (!(sts & CS5536_PM_WAK)) {
+			input_report_key(pm_inputdev, KEY_POWER, 1);
+			input_sync(pm_inputdev);
+			/* Do we need to delay this? */
+			input_report_key(pm_inputdev, KEY_POWER, 0);
+			input_sync(pm_inputdev);
+		}
+	}
+
+	if (gpe & GPIO_WAKEUP_EC) {
+		geode_gpio_clear(OLPC_GPIO_ECSCI, GPIO_NEGATIVE_EDGE_STS);
+		if (!wackup_source)
+			wackup_source = "sci";
+		schedule_work(&sci_work);
+	}
+
+	if (gpe & GPIO_WAKEUP_LID) {
+		/* Disable events */
+		geode_gpio_clear(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);
+			
+		/* Clear the edge */
+			
+		if (olpc_lid_flag)
+			geode_gpio_clear(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_EN);
+		else
+			geode_gpio_clear(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_EN);
+
+		/* Clear the status too */
+		geode_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_STS);
+		geode_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_STS);
+
+		/* The line is high when the LID is open, but SW_LID
+		 * should be high when the LID is closed, so we pass the old
+		 * value of olpc_lid_flag
+		 */
+
+		input_report_switch(lid_inputdev, SW_LID, olpc_lid_flag);
+		input_sync(lid_inputdev);
+		if (!wackup_source)
+			wackup_source = "lid";
+
+		/* Swap the status */
+		olpc_lid_flag = !olpc_lid_flag;
+
+		if (olpc_lid_flag)
+			geode_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_EN);
+		else
+			geode_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_EN);
+
+		/* re-enable the event */
+		geode_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int olpc_ec_mask_set(u8 bits)
+{
+	int ret;
+	u8 byte;
+
+	ret = olpc_ec_cmd(EC_READ_SCI_MASK, NULL, 0, &byte, 1);
+	if (ret) { 
+		printk(KERN_ERR "olpc-pm:  error getting SCI mask: %d\n", ret);
+		return ret;
+	}
+	/* the high bit is unused, if it is ever unset, that is a good sign
+	   sign of EC communication corruption! */
+	WARN_ON(!(byte & 0x80));
+
+	byte |= bits;
+	ret = olpc_ec_cmd(EC_WRITE_SCI_MASK, &byte, 1, NULL, 0);
+	if (ret)
+		printk(KERN_ERR "olpc-pm:  error setting SCI mask: %d\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(olpc_ec_mask_set);
+
+int olpc_ec_mask_unset(u8 bits)
+{
+	int ret;
+	u8 byte;
+
+	ret = olpc_ec_cmd(EC_READ_SCI_MASK, NULL, 0, &byte, 1);
+	if (ret) { 
+		printk(KERN_ERR "olpc-pm:  error getting SCI mask: %d\n", ret);
+		return ret;
+	}
+	/* the high bit is unused, if it is ever unset, that is a good sign
+	   sign of EC communication corruption! */
+	WARN_ON(!(byte & 0x80));
+
+	byte &= ~bits;
+	ret = olpc_ec_cmd(EC_WRITE_SCI_MASK, &byte, 1, NULL, 0);
+	if (ret)
+		printk(KERN_ERR "olpc-pm:  error setting SCI mask: %d\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(olpc_ec_mask_unset);
+
+/*
+ * For now, only support STR.  We also don't support suspending on
+ * B1s, due to difficulties with the cafe FPGA.
+ */
+static int olpc_pm_state_valid(suspend_state_t pm_state)
+{
+        if (pm_state == PM_SUSPEND_MEM && olpc_board_at_least(olpc_board(0xb2)))
+                return 1;
+
+        return 0;
+}
+
+/* This is a catchall function for operations that just don't belong
+ * anywhere else.  Later we will evaluate if these belong in the
+ * individual device drivers or the firmware.
+ * If you add something to this function, please explain yourself with
+ * a comment.
+ */
+
+extern void gxfb_flatpanel_control(int state);
+
+static u32 gpio_wakeup[2];
+static u64 irq_sources[4];
+static u64 mfgpt_irq_msr, mfgpt_nr_msr;
+
+void olpc_fixup_wakeup(void)
+{
+	u32 base = geode_gpio_base();
+	int i;
+
+	/* Enable the flatpanel sequencing as early as possible, because
+	   it takes ~64ms to resume.  This probably belongs in the firmware */
+
+	//gxfb_flatpanel_control(1);
+
+	/* Tell the EC to stop inhibiting SCIs */
+	olpc_ec_cmd(0x34, NULL, 0, NULL, 0);
+
+	/* Restore the interrupt sources */
+	wrmsrl(MSR_PIC_YSEL_LOW, irq_sources[0]);
+	wrmsrl(MSR_PIC_ZSEL_LOW, irq_sources[1]);
+	wrmsrl(MSR_PIC_YSEL_HIGH, irq_sources[2]);
+	wrmsrl(MSR_PIC_ZSEL_HIGH, irq_sources[3]);
+
+	/* Restore the X and Y sources for GPIO */
+	outl(gpio_wakeup[0], base + GPIO_MAP_X);
+	outl(gpio_wakeup[1], base + GPIO_MAP_Y);
+
+	/* Resture the MFGPT MSRs */
+	wrmsrl(MFGPT_IRQ_MSR, mfgpt_irq_msr);
+	wrmsrl(MFGPT_NR_MSR, mfgpt_nr_msr);
+
+	for (i=0;i<2;i++) {
+		/* tell the wireless module to restart USB communication */
+		olpc_ec_cmd(0x24, NULL, 0, NULL, 0);
+	}
+
+	/* Turn all events on */
+	olpc_ec_mask_set(EC_SCI_SRC_ALL);
+}
+
+void olpc_fixup_sleep(void)
+{
+	u32 base = geode_gpio_base();
+	int i;
+
+	/* Save the X and Y sources for GPIO */
+	gpio_wakeup[0] = inl(base + GPIO_MAP_X);
+	gpio_wakeup[1] = inl(base + GPIO_MAP_Y);
+
+	/* Save the Y and Z  unrestricted sources */
+
+	rdmsrl(MSR_PIC_YSEL_LOW, irq_sources[0]);
+	rdmsrl(MSR_PIC_ZSEL_LOW, irq_sources[1]);
+	rdmsrl(MSR_PIC_YSEL_HIGH, irq_sources[2]);
+	rdmsrl(MSR_PIC_ZSEL_HIGH, irq_sources[3]);
+
+	/* Turn off the MFGPT timers on the way down */
+
+	for(i = 0; i < 8; i++) {
+		u32 val = geode_mfgpt_read(i, MFGPT_REG_SETUP);
+
+		if (val & MFGPT_SETUP_SETUP) {
+			val &= ~MFGPT_SETUP_CNTEN;
+			geode_mfgpt_write(i, MFGPT_REG_SETUP, val);
+		}
+	}
+
+	/* Save the MFGPT MSRs */
+	rdmsrl(MFGPT_IRQ_MSR, mfgpt_irq_msr);
+	rdmsrl(MFGPT_NR_MSR, mfgpt_nr_msr);
+
+	if (device_may_wakeup(&olpc_powerbutton_dev.dev))
+		olpc_wakeup_mask |= CS5536_PM_PWRBTN;
+	else
+		olpc_wakeup_mask &= ~(CS5536_PM_PWRBTN);
+
+	if (device_may_wakeup(&olpc_lid_dev.dev)) {
+		geode_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);
+		gpio_wake_events |= GPIO_WAKEUP_LID;
+	} else {
+		geode_gpio_clear(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);
+		gpio_wake_events &= ~(GPIO_WAKEUP_LID);
+	}
+
+	/* We don't want to wake up on superfluous events */
+	olpc_ec_mask_unset(EC_SCI_SRC_BATSOC | EC_SCI_SRC_ACPWR);
+
+	/* 
+	 * Cmd 0x32 tells the EC that we're going into suspend; this was
+	 * added to work around hardware races related to SCI events.  This
+	 * should cause the EC to inhibit further SCIs while MAIN_ON is
+	 * transitioning low.
+	 *
+	 * There's also some sort of EC race whereby the EC gets its
+	 * IBF/OBF flags confused and all future communication (after
+	 * resuming) fails if we suspend too soon after updating
+	 * the EC SCI mask.  Having this command after updating the
+	 * SCI mask allows the EC enough time to finish doing what it's
+	 * doing.
+	 */
+	olpc_ec_cmd(0x32, NULL, 0, NULL, 0);
+}
+
+static int olpc_pm_enter(suspend_state_t pm_state)
+{
+        /* Only STR is supported */
+        if (pm_state != PM_SUSPEND_MEM)
+                return -EINVAL;
+
+	olpc_fixup_sleep();
+
+	/* Set the GPIO wakeup bits */
+	outl(gpio_wake_events, acpi_base + PM_GPE0_EN);
+	outl(0xFFFFFFFF, acpi_base + PM_GPE0_STS);
+
+        /* Save CPU state */
+        do_olpc_suspend_lowlevel();
+
+	olpc_fixup_wakeup();
+
+	/* Restore the SCI wakeup events */
+	outl(gpio_wake_events, acpi_base + PM_GPE0_EN);
+
+	return 0;
+}
+
+int asmlinkage olpc_do_sleep(u8 sleep_state)
+{
+	void *pgd_addr = __va(read_cr3());
+	printk(KERN_ERR "olpc_do_sleep!\n"); /* this needs to remain here so
+					      * that gcc doesn't optimize
+					      * away our __va! */
+	/* FIXME: Set the SCI bits we want to wake up on here */
+
+	/* FIXME:  Set any other SCI events that we might want here */
+
+	outl((olpc_wakeup_mask << 16) | 0xFFFF, acpi_base + PM1_STS);
+
+	wackup_source = NULL;
+
+	/* If we are in test mode, then just return (simulate a successful
+	   suspend/resume).  Otherwise, if we are doing the real thing,
+	   then go for the gusto */
+
+ 	if (olpc_pm_mode != PM_MODE_TEST) {
+		__asm__ __volatile__("movl %0,%%eax" : : "r" (pgd_addr));
+		__asm__("call *(%%edi); cld"
+			: : "D" (&ofw_bios_entry));
+		__asm__ __volatile__("movb $0x34, %al\n\t"
+				     "outb %al, $0x70\n\t"
+				     "movb $0x30, %al\n\t"
+				     "outb %al, $0x71\n\t");
+
+	}
+	else if (test_timeout > 0) {
+	  int t;
+
+	  /* Delay N seconds for testing purposes */
+
+	  for(t = 0; t < test_timeout; t++)
+	    mdelay(1000);
+	}
+
+	return 0;
+}
+
+static void olpc_power_off(void)
+{
+	printk(KERN_INFO "OLPC power off sequence...\n");
+
+	/* Enable all of these controls with 0 delay */
+	outl(0x40000000, pms_base + PM_SCLK);
+	outl(0x40000000, pms_base + PM_IN_SLPCTL);
+	outl(0x40000000, pms_base + PM_WKXD);
+	outl(0x40000000, pms_base + PM_WKD);
+
+	/* Clear status bits (possibly unnecessary) */
+	outl(0x0002ffff, pms_base  + PM_SSC);
+	outl(0xffffffff, acpi_base + PM_GPE0_STS);
+
+	/* Write SLP_EN bit to start the machinery */
+	outl(0x00002000, acpi_base + PM1_CNT);
+}
+
+/* This code will slowly disappear as we fixup the issues in the BIOS */
+
+static void __init olpc_fixup_bios(void)
+{
+	unsigned long hi, lo;
+
+	if (olpc_has_vsa()) {
+		/* The VSA aggressively sets up the ACPI and PM register for
+		 * trapping - its not enough to force these values in the BIOS -
+		 * they seem to be changed during PCI init as well.
+		 */
+
+		/* Change the PM registers to decode to the DD */
+
+		rdmsr(0x510100e2, lo, hi);
+		hi |= 0x80000000;
+		wrmsr(0x510100e2, lo, hi);
+
+		/* Change the ACPI registers to decode to the DD */
+
+		rdmsr(0x510100e3, lo, hi);
+		hi |= 0x80000000;
+		wrmsr(0x510100e3, lo, hi);
+	}
+
+	/* GPIO24 controls WORK_AUX */
+
+	geode_gpio_set(OLPC_GPIO_WORKAUX, GPIO_OUTPUT_ENABLE);
+	geode_gpio_set(OLPC_GPIO_WORKAUX, GPIO_OUTPUT_AUX1);
+
+	if (olpc_board_at_least(olpc_board(0xb2))) {
+		/* GPIO10 is connected to the thermal alarm */
+		geode_gpio_set(OLPC_GPIO_THRM_ALRM, GPIO_INPUT_ENABLE);
+		geode_gpio_set(OLPC_GPIO_THRM_ALRM, GPIO_INPUT_AUX1);
+
+		/* Set up to get LID events */
+		geode_gpio_set(OLPC_GPIO_LID, GPIO_INPUT_ENABLE);
+
+		/* Clear edge detection and event enable for now */
+		geode_gpio_clear(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);
+		geode_gpio_clear(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_EN);
+		geode_gpio_clear(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_EN);
+
+		geode_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_STS);
+		geode_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_STS);
+
+		/* Set the LID to cause an PME event on group 6 */
+		geode_gpio_event_pme(OLPC_GPIO_LID, 6);
+
+		/* Set PME group 6 to fire the SCI interrupt */
+		geode_gpio_set_irq(6, sci_irq);
+	}
+
+	geode_gpio_set(OLPC_GPIO_ECSCI, GPIO_INPUT_ENABLE);
+
+	/* Clear pending events */
+
+	geode_gpio_set(OLPC_GPIO_ECSCI, GPIO_NEGATIVE_EDGE_STS);
+	geode_gpio_set(OLPC_GPIO_ECSCI, GPIO_POSITIVE_EDGE_STS);
+
+	//geode_gpio_set(OLPC_GPIO_ECSCI, GPIO_NEGATIVE_EDGE_EN);
+	geode_gpio_set(OLPC_GPIO_ECSCI, GPIO_EVENTS_ENABLE);
+
+	/* Set the SCI to cause a PME event on group 7 */
+	geode_gpio_event_pme(OLPC_GPIO_ECSCI, 7);
+
+	/* And have group 6 also fire the SCI interrupt */
+	geode_gpio_set_irq(7, sci_irq);
+}
+
+/* This provides a control file for setting up testing of the
+   power management system.  For now, there is just one setting:
+   "test" which means that we don't actually enter the power
+   off routine.
+*/
+
+static const char * const pm_states[] = {
+	[PM_MODE_NORMAL]  = "normal",
+	[PM_MODE_TEST]    = "test",
+};
+
+extern struct mutex pm_mutex;
+extern struct kset power_subsys;
+
+static ssize_t control_show(struct kset *s, char *buf)
+{
+	return sprintf(buf, "%s\n", pm_states[olpc_pm_mode]);
+}
+
+static ssize_t control_store(struct kset *s, const char *buf, size_t n)
+{
+	int i, len;
+	char *p;
+
+	p = memchr(buf, '\n', n);
+	len = p ? p - buf : n;
+
+	/* Grab the mutex */
+	mutex_lock(&pm_mutex);
+	
+	for(i = 0; i < PM_MODE_MAX; i++) {
+		if (!strncmp(buf, pm_states[i], len)) {
+			olpc_pm_mode = i;
+			break;
+		}
+	}
+
+	mutex_unlock(&pm_mutex);
+
+	return (i == PM_MODE_MAX) ? -EINVAL : n;
+}
+       
+static ssize_t timeout_show(struct kset *s, char *buf) 
+{
+	return sprintf(buf, "%d\n", test_timeout);
+}
+
+static ssize_t timeout_store(struct kset *s, const char *buf, size_t n)
+{
+	unsigned int t = simple_strtoul(buf, NULL, 0);
+	test_timeout = t;
+
+	return n;
+}
+
+static ssize_t wackup_show(struct kset *s, char *buf)
+{
+	return sprintf(buf, "%s\n", wackup_source ? wackup_source : "none");
+}
+
+static struct subsys_attribute control_attr = {
+	.attr = {
+		.name = "olpc-pm",
+		.mode = 0644,
+	},
+	.show = control_show,
+	.store = control_store,
+};
+
+static struct subsys_attribute test_attr = {
+	.attr = {
+		.name = "test-timeout",
+		.mode = 0644,
+	},
+	.show = timeout_show,
+	.store = timeout_store,
+};
+
+static struct subsys_attribute wackup_attr = {
+	.attr = {
+		.name = "wakeup-source",
+		.mode = 0400,
+	},
+	.show = wackup_show,
+};
+
+static struct attribute * olpc_attributes[] = {
+	&control_attr.attr,
+	&test_attr.attr,
+	&wackup_attr.attr,
+	NULL
+};
+
+static struct attribute_group olpc_attrs = {
+	.attrs = olpc_attributes,
+};
+
+static int __init alloc_inputdevs(void)
+{
+	int ret = -ENOMEM;
+
+	pm_inputdev = input_allocate_device();
+	if (!pm_inputdev)
+		goto err;
+
+	pm_inputdev->name = "OLPC PM";
+	pm_inputdev->phys = "olpc_pm/input0";
+	set_bit(EV_KEY, pm_inputdev->evbit);
+	set_bit(KEY_POWER, pm_inputdev->keybit);
+
+	ret = input_register_device(pm_inputdev);
+	if (ret) {
+		printk(KERN_ERR "olpc-pm:  failed to register PM input device: %d\n", ret);
+		goto err;
+	}
+
+	lid_inputdev = input_allocate_device();
+	if (!lid_inputdev)
+		goto err;
+
+	lid_inputdev->name = "OLPC lid switch";
+	lid_inputdev->phys = "olpc_pm/input1";
+	set_bit(EV_SW, lid_inputdev->evbit);
+	set_bit(SW_LID, lid_inputdev->swbit);
+
+	ret = input_register_device(lid_inputdev);
+	if (ret) {
+		printk(KERN_ERR "olpc-pm:  failed to register lid input device: %d\n", ret);
+		goto err;
+	}
+
+	ebook_inputdev = input_allocate_device();
+	if (!ebook_inputdev)
+		goto err;
+
+	ebook_inputdev->name = "OLPC ebook switch";
+	ebook_inputdev->phys = "olpc_pm/input2";
+	set_bit(EV_SW, ebook_inputdev->evbit);
+	set_bit(SW_TABLET_MODE, ebook_inputdev->swbit);
+
+	ret = input_register_device(ebook_inputdev);
+	if (ret) {
+		printk(KERN_ERR "olpc-pm:  failed to register ebook input device: %d\n", ret);
+		goto err;
+	}
+
+	return ret;
+err:
+	if (ebook_inputdev) {
+		input_unregister_device(ebook_inputdev);
+		ebook_inputdev = NULL;
+	}
+	if (lid_inputdev) {
+		input_unregister_device(lid_inputdev);
+		lid_inputdev = NULL;
+	}
+	if (pm_inputdev) {
+		input_unregister_device(pm_inputdev);
+		pm_inputdev = NULL;
+	}
+
+	return ret;
+}
+
+static int __init olpc_pm_init(void)
+{
+	uint32_t lo, hi;
+	int ret;
+
+	if (!machine_is_olpc())
+		return -ENODEV;
+
+	acpi_base = geode_acpi_base();
+	pms_base = geode_pms_base();
+
+	if (!acpi_base || !pms_base)
+	  return -ENODEV;
+
+	pm_power_off = olpc_power_off;
+
+	ret = alloc_inputdevs();
+	if (ret)
+		return ret;
+
+	rdmsr(0x51400020, lo, hi);
+	sci_irq = (lo >> 20) & 15;
+
+	if (sci_irq) {
+		printk(KERN_INFO "SCI is mapped to IRQ %d\n", sci_irq);
+	} else {
+		/* Zero doesn't mean zero -- it means masked */
+		printk(KERN_INFO "SCI unmapped. Mapping to IRQ 3\n");
+		sci_irq = 3;
+		lo |= 0x00300000;
+		wrmsrl(0x51400020, lo);
+	}
+
+	olpc_fixup_bios();
+
+	lo = inl(pms_base + PM_FSD);
+
+	/* Lock, enable failsafe, 4 seconds */
+	outl(0xc001f400, pms_base + PM_FSD);
+
+	/* Here we set up the SCI events we're interested in during
+	 * real-time.  We have no sleep button, and the RTC doesn't make
+	 * sense, so set up the power button
+	 */
+
+	outl(inl(acpi_base) | ((CS5536_PM_PWRBTN) << 16), acpi_base);
+
+	if (olpc_board_at_least(olpc_board(0xb2))) {
+		gpio_wake_events |= GPIO_WAKEUP_LID;
+
+		/* Get the current value of the GPIO, and set up the edges */
+		olpc_lid_flag = geode_gpio_isset(OLPC_GPIO_LID, GPIO_READ_BACK);
+
+		/* Watch for the opposite edge */
+
+		if (olpc_lid_flag)
+			geode_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_EN);
+		else
+			geode_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_EN);
+
+		/* Enable the event */
+		geode_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);
+	}
+
+	/* Set up the EC SCI */
+
+	gpio_wake_events |= GPIO_WAKEUP_EC;
+
+	outl(gpio_wake_events, acpi_base + PM_GPE0_EN);
+	outl(0xFFFFFFFF, acpi_base + PM_GPE0_STS);
+
+	/* Select level triggered in PIC */
+
+	if (sci_irq < 8) {
+		lo = inb(0x4d0);
+		lo |= 1 << sci_irq;
+		outb(lo, 0x4d0);
+	} else {
+		lo = inb(0x4d1);
+		lo |= 1 << (sci_irq - 8);
+		outb(lo, 0x4d1);
+	}
+	/* Clear pending interrupt */
+	outl(inl(acpi_base) | 0xFFFF, acpi_base);
+	process_sci_queue(0);	/* we just want to flush the queue here */
+	init_ebook_state();
+
+	/* Enable the interrupt */
+
+	ret = request_irq(sci_irq, &olpc_pm_interrupt, 0, "SCI", &acpi_base);
+
+	if (ret) {
+		printk(KERN_ERR "Error registering SCI: %d\n", ret);
+		return ret;
+	}
+
+	ofw_bios_entry.address = 0xF0000 + PAGE_OFFSET;
+	suspend_set_ops(&olpc_pm_ops);
+
+	sysfs_create_group(&power_subsys.kobj, &olpc_attrs);
+
+	return 0;
+}
+
+
+#if defined (CONFIG_RTC_DRV_CMOS) || defined (CONFIG_RTC_DRV_CMOS_MODULE)
+struct resource rtc_platform_resource[2] = {
+	{
+		.flags		= IORESOURCE_IO,
+		.start		= RTC_PORT(0),
+		.end		= RTC_PORT(0) + RTC_IO_EXTENT
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+		.start = 8,
+		.end = 8,
+	},
+};
+
+
+static void rtc_wake_on(struct device *dev)
+{
+	olpc_wakeup_mask |= CS5536_PM_RTC;
+}
+
+static void rtc_wake_off(struct device *dev)
+{
+	olpc_wakeup_mask &= ~(CS5536_PM_RTC);
+}
+
+static struct cmos_rtc_board_info rtc_info = {
+	.rtc_day_alarm = 0,
+	.rtc_mon_alarm = 0,
+	.rtc_century = 0,
+	.wake_on = rtc_wake_on,
+	.wake_off = rtc_wake_off,
+};
+
+struct platform_device olpc_rtc_device = {
+	.name = "rtc_cmos",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(rtc_platform_resource),
+	.dev.platform_data = &rtc_info,
+	.resource = rtc_platform_resource,
+};
+
+static int __init olpc_platform_init(void)
+{
+	rdmsrl(MSR_RTC_DOMA_OFFSET, rtc_info.rtc_day_alarm);
+	rdmsrl(MSR_RTC_MONA_OFFSET, rtc_info.rtc_mon_alarm);
+	rdmsrl(MSR_RTC_CEN_OFFSET, rtc_info.rtc_century);
+
+	(void)platform_device_register(&olpc_rtc_device);
+	device_init_wakeup(&olpc_rtc_device.dev, 1);
+
+	(void)platform_device_register(&olpc_powerbutton_dev);
+	device_init_wakeup(&olpc_powerbutton_dev.dev, 1);
+
+	(void)platform_device_register(&olpc_lid_dev);
+	device_init_wakeup(&olpc_lid_dev.dev, 1);
+
+	return 0;
+}
+arch_initcall(olpc_platform_init);
+#endif /* CONFIG_RTC_DRV_CMOS */
+
+static void olpc_pm_exit(void)
+{
+	/* Clear any pending events, and disable them */
+	outl(0xFFFF, acpi_base+2);
+
+	free_irq(sci_irq, &acpi_base);
+	input_unregister_device(pm_inputdev);
+	input_unregister_device(lid_inputdev);
+	input_unregister_device(ebook_inputdev);
+}
+
+static struct platform_suspend_ops olpc_pm_ops = {
+        .valid = olpc_pm_state_valid,
+        .enter = olpc_pm_enter,
+};
+
+module_init(olpc_pm_init);
+module_exit(olpc_pm_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("AMD Geode power management for OLPC CL1");
diff -purN linux_2.6.24_org/arch/x86/kernel/olpc-sleep.S linux_2.6.24_olpc/arch/x86/kernel/olpc-sleep.S
--- linux_2.6.24_org/arch/x86/kernel/olpc-sleep.S	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/arch/x86/kernel/olpc-sleep.S	2008-02-15 18:59:26.000000000 +0000
@@ -0,0 +1,39 @@
+.text
+
+ENTRY(olpc_sleep_asm)
+olpc_sleep:
+	;; Get the value of PM1_CNT and store it off
+	
+	add 08h, ax
+	mov bx,dx
+	in dx,eax
+	or 2000h, ax
+	mov ax,di
+	
+	;; flush the cache
+	wbinvd
+
+	;; GX2 must disable refresh before going into self-refresh 
+	mov 2000000180xh, ecx
+	rdmsr
+	mov eax, esi
+	and 0FF0000FFh, eax
+	wrmsr
+
+	;; Now, put  the memory into self refresh
+	mov 2004, cx
+	xor edx, edx
+	xor eax, eax
+	mov 04h, al
+	wrmsr
+
+	;; Thats all she wrote - time to go to sleep
+	
+	mov bx, dx
+	movzx di, eax
+	out eax, dx
+
+	;;  
+	
+	
+	
diff -purN linux_2.6.24_org/arch/x86/kernel/olpc-wakeup.S linux_2.6.24_olpc/arch/x86/kernel/olpc-wakeup.S
--- linux_2.6.24_org/arch/x86/kernel/olpc-wakeup.S	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/arch/x86/kernel/olpc-wakeup.S	2008-02-15 18:59:25.000000000 +0000
@@ -0,0 +1,133 @@
+.text
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/page.h>
+
+	.macro writepost,value
+		movb $0x34, %al
+		outb %al, $0x70
+		movb $\value, %al
+		outb %al, $0x71
+	.endm
+	
+ALIGN
+	.align 4096
+
+wakeup_start:
+#	jmp wakeup_start
+
+	cli
+	cld
+
+	# Clear any dangerous flags
+	
+	pushl $0
+	popfl
+		
+	writepost 0x31
+
+	# Set up %cr3
+	movl $swsusp_pg_dir - __PAGE_OFFSET, %eax
+	movl %eax, %cr3
+
+	movl saved_cr4, %eax
+	movl %eax, %cr4
+	
+	movl saved_cr0, %eax
+	movl %eax, %cr0
+	
+	jmp 1f
+1:	
+	ljmpl $__KERNEL_CS,$wakeup_return
+	
+
+.org 0x1000
+
+wakeup_return:
+	movw    $__KERNEL_DS, %ax
+	movw    %ax, %ss
+	movw    %ax, %ds
+	movw    %ax, %es
+	movw    %ax, %fs
+	movw    %ax, %gs
+	
+	lgdt    saved_gdt
+	lidt    saved_idt
+	lldt    saved_ldt
+	ljmp    $(__KERNEL_CS),$1f
+1:
+	movl    %cr3, %eax
+	movl    %eax, %cr3
+	wbinvd
+
+	# Go back to the return point
+	jmp ret_point
+	
+save_registers:
+	sgdt  saved_gdt
+	sidt  saved_idt
+	sldt  saved_ldt
+
+	pushl %edx
+	movl %cr4, %edx
+	movl %edx, saved_cr4
+
+	movl %cr0, %edx
+	movl %edx, saved_cr0
+
+	popl %edx
+		
+	
+        movl %ebx, saved_context_ebx
+        movl %ebp, saved_context_ebp
+        movl %esi, saved_context_esi
+        movl %edi, saved_context_edi
+
+	pushfl
+	popl saved_context_eflags
+	
+        ret
+
+
+restore_registers:
+        movl saved_context_ebp, %ebp
+        movl saved_context_ebx, %ebx
+        movl saved_context_esi, %esi
+        movl saved_context_edi, %edi
+
+	pushl saved_context_eflags
+	popfl
+	
+        ret
+
+	
+ENTRY(do_olpc_suspend_lowlevel)
+	call	save_processor_state
+	call	save_registers
+
+	# This is the stack context we want to remember
+	movl %esp, saved_context_esp
+
+	pushl	$3
+	call	olpc_do_sleep
+	
+	jmp	wakeup_start
+	.p2align 4,,7
+ret_point:
+	movl    saved_context_esp, %esp
+
+	writepost 0x32
+
+	call	restore_registers
+	call	restore_processor_state
+	ret
+
+.data
+ALIGN
+
+saved_gdt:     .long   0,0
+saved_idt:     .long   0,0
+saved_ldt:     .long   0
+saved_cr4:     .long   0
+saved_cr0:     .long   0
+
diff -purN linux_2.6.24_org/arch/x86/kernel/prom.c linux_2.6.24_olpc/arch/x86/kernel/prom.c
--- linux_2.6.24_org/arch/x86/kernel/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/arch/x86/kernel/prom.c	2008-02-15 18:59:26.000000000 +0000
@@ -0,0 +1,478 @@
+/*
+ * Procedures for creating, accessing and interpreting the device tree.
+ *
+ * Paul Mackerras	August 1996.
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ * 
+ *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
+ *    {engebret|bergner}@us.ibm.com 
+ *
+ *  Adapted for sparc64 by David S. Miller davem@davemloft.net
+ *
+ *  Adapter for i386/OLPC by Andres Salomon <dilinger@debian.org>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/module.h>
+#include <asm/prom.h>
+#include <asm/ofw.h>
+
+/*
+ * XXX: This is very much a stub; right now we're keeping 2 device trees
+ * in memory (one for promfs, and one here).  That will not remain
+ * for long!
+ */
+
+static struct device_node *allnodes;
+
+/* use when traversing tree through the allnext, child, sibling,
+ * or parent members of struct device_node.
+ */
+static DEFINE_RWLOCK(devtree_lock);
+
+int of_device_is_compatible(const struct device_node *device,
+			    const char *compat)
+{
+	const char* cp;
+	int cplen, l;
+
+	cp = of_get_property(device, "compatible", &cplen);
+	if (cp == NULL)
+		return 0;
+	while (cplen > 0) {
+		if (strncmp(cp, compat, strlen(compat)) == 0)
+			return 1;
+		l = strlen(cp) + 1;
+		cp += l;
+		cplen -= l;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(of_device_is_compatible);
+
+struct device_node *of_get_parent(const struct device_node *node)
+{
+	struct device_node *np;
+
+	if (!node)
+		return NULL;
+
+	np = node->parent;
+
+	return np;
+}
+EXPORT_SYMBOL(of_get_parent);
+
+struct device_node *of_get_next_child(const struct device_node *node,
+	struct device_node *prev)
+{
+	struct device_node *next;
+
+	next = prev ? prev->sibling : node->child;
+	for (; next != 0; next = next->sibling) {
+		break;
+	}
+
+	return next;
+}
+EXPORT_SYMBOL(of_get_next_child);
+
+struct device_node *of_find_node_by_path(const char *path)
+{
+	struct device_node *np = allnodes;
+
+	for (; np != 0; np = np->allnext) {
+		if (np->full_name != 0 && strcmp(np->full_name, path) == 0)
+			break;
+	}
+
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_path);
+
+struct device_node *of_find_node_by_phandle(phandle handle)
+{
+	struct device_node *np;
+
+	for (np = allnodes; np != 0; np = np->allnext)
+		if (np->node == handle)
+			break;
+
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_phandle);
+
+struct device_node *of_find_node_by_name(struct device_node *from,
+	const char *name)
+{
+	struct device_node *np;
+
+	np = from ? from->allnext : allnodes;
+	for (; np != NULL; np = np->allnext)
+		if (np->name != NULL && strcmp(np->name, name) == 0)
+			break;
+
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_name);
+
+struct device_node *of_find_node_by_type(struct device_node *from,
+	const char *type)
+{
+	struct device_node *np;
+
+	np = from ? from->allnext : allnodes;
+	for (; np != 0; np = np->allnext)
+		if (np->type != 0 && strcmp(np->type, type) == 0)
+			break;
+
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_type);
+
+struct device_node *of_find_compatible_node(struct device_node *from,
+	const char *type, const char *compatible)
+{
+	struct device_node *np;
+
+	np = from ? from->allnext : allnodes;
+	for (; np != 0; np = np->allnext) {
+		if (type != NULL
+		    && !(np->type != 0 && strcmp(np->type, type) == 0))
+			continue;
+		if (of_device_is_compatible(np, compatible))
+			break;
+	}
+
+	return np;
+}
+EXPORT_SYMBOL(of_find_compatible_node);
+
+struct property *of_find_property(const struct device_node *np,
+				  const char *name,
+				  int *lenp)
+{
+	struct property *pp;
+
+	for (pp = np->properties; pp != 0; pp = pp->next) {
+		if (strcasecmp(pp->name, name) == 0) {
+			if (lenp != 0)
+				*lenp = pp->length;
+			break;
+		}
+	}
+	return pp;
+}
+EXPORT_SYMBOL(of_find_property);
+
+/*
+ * Find a property with a given name for a given node
+ * and return the value.
+ */
+const void *of_get_property(const struct device_node *np, const char *name,
+		      int *lenp)
+{
+	struct property *pp = of_find_property(np,name,lenp);
+	return pp ? pp->value : NULL;
+}
+EXPORT_SYMBOL(of_get_property);
+
+int of_getintprop_default(struct device_node *np, const char *name, int def)
+{
+	struct property *prop;
+	int len;
+
+	prop = of_find_property(np, name, &len);
+	if (!prop || len != 4)
+		return def;
+
+	return *(int *) prop->value;
+}
+EXPORT_SYMBOL(of_getintprop_default);
+
+int of_n_addr_cells(struct device_node *np)
+{
+	const int* ip;
+	do {
+		if (np->parent)
+			np = np->parent;
+		ip = of_get_property(np, "#address-cells", NULL);
+		if (ip != NULL)
+			return *ip;
+	} while (np->parent);
+	/* No #address-cells property for the root node, default to 2 */
+	return 2;
+}
+EXPORT_SYMBOL(of_n_addr_cells);
+
+int of_n_size_cells(struct device_node *np)
+{
+	const int* ip;
+	do {
+		if (np->parent)
+			np = np->parent;
+		ip = of_get_property(np, "#size-cells", NULL);
+		if (ip != NULL)
+			return *ip;
+	} while (np->parent);
+	/* No #size-cells property for the root node, default to 1 */
+	return 1;
+}
+EXPORT_SYMBOL(of_n_size_cells);
+
+int of_set_property(struct device_node *dp, const char *name, void *val, int len)
+{
+	return -EIO;
+}
+EXPORT_SYMBOL(of_set_property);
+
+static unsigned int prom_early_allocated;
+
+static void * __init prom_early_alloc(unsigned long size)
+{
+	void *ret;
+
+	ret = kmalloc(size, GFP_KERNEL);
+	if (ret != NULL)
+		memset(ret, 0, size);
+	else
+		printk(KERN_ERR "ACK!  couldn't allocate prom memory!\n");
+
+	prom_early_allocated += size;
+
+	return ret;
+}
+
+static int is_root_node(const struct device_node *dp)
+{
+	if (!dp)
+		return 0;
+
+	return (dp->parent == NULL);
+}
+
+static char * __init build_path_component(struct device_node *dp)
+{
+	int pathlen;
+	char *n, *i;
+
+	if (ofw("package-to-path", 3, 1, dp->node, NULL, 0, &pathlen)) {
+		printk(KERN_ERR "PROM: unable to get path name from OFW!\n");
+		return "ERROR";
+	}
+	n = prom_early_alloc(pathlen + 1);
+	if (ofw("package-to-path", 3, 1, dp->node, n, pathlen+1, &pathlen))
+		printk(KERN_ERR "PROM: unable to get path name from OFW\n");
+
+	if ((i = strrchr(n, '/')))
+		n = ++i;	/* we only want the file name */
+	return n;
+}
+
+static char * __init build_full_name(struct device_node *dp)
+{
+	int len, ourlen, plen;
+	char *n;
+
+	plen = strlen(dp->parent->full_name);
+	ourlen = strlen(dp->path_component_name);
+	len = ourlen + plen + 2;
+
+	n = prom_early_alloc(len);
+	strcpy(n, dp->parent->full_name);
+	if (!is_root_node(dp->parent)) {
+		strcpy(n + plen, "/");
+		plen++;
+	}
+	strcpy(n + plen, dp->path_component_name);
+
+	return n;
+}
+
+static struct property * __init build_one_prop(phandle node, char *prev, char *special_name, void *special_val, int special_len)
+{
+	static struct property *tmp = NULL;
+	struct property *p;
+
+	if (tmp) {
+		p = tmp;
+		memset(p, 0, sizeof(*p) + 32);
+		tmp = NULL;
+	} else {
+		p = prom_early_alloc(sizeof(struct property) + 32);
+	}
+
+	p->name = (char *) (p + 1);
+	if (special_name) {
+		strcpy(p->name, special_name);
+		p->length = special_len;
+		p->value = prom_early_alloc(special_len);
+		memcpy(p->value, special_val, special_len);
+	} else {
+		int fl;
+		if (prev == NULL) {
+			if (ofw("nextprop", 3, 1, node, "", p->name, &fl)) {
+				printk(KERN_ERR "PROM: %s: nextprop failed!\n", __func__);
+				return NULL;
+			}
+		} else {
+			if (ofw("nextprop", 3, 1, node, prev, p->name, &fl)) {
+				printk(KERN_ERR "PROM: %s: nextprop failed!\n", __func__);
+				return NULL;
+			}
+		}
+		if (strlen(p->name) == 0 || fl != 1) {
+			tmp = p;
+			return NULL;
+		}
+		if (ofw("getproplen", 2, 1, node, p->name, &p->length)) {
+			printk(KERN_ERR "PROM: %s: getproplen failed!\n", __func__);
+			return NULL;
+		}
+		if (p->length <= 0) {
+			p->length = 0;
+		} else {
+			p->value = prom_early_alloc(p->length + 1);
+			if (ofw("getprop", 4, 1, node, p->name, p->value, p->length, &p->length)) {
+				printk(KERN_ERR "PROM: %s: getprop failed!\n", __func__);
+				return NULL;
+			}
+			((unsigned char *)p->value)[p->length] = '\0';
+		}
+	}
+	return p;
+}
+
+static struct property * __init build_prop_list(phandle node)
+{
+	struct property *head, *tail;
+
+	head = tail = build_one_prop(node, NULL,
+				     ".node", &node, sizeof(node));
+
+	tail->next = build_one_prop(node, NULL, NULL, NULL, 0);
+	tail = tail->next;
+	while(tail) {
+		tail->next = build_one_prop(node, tail->name,
+					    NULL, NULL, 0);
+		tail = tail->next;
+	}
+
+	return head;
+}
+
+static char * __init get_one_property(phandle node, const char *name)
+{
+	char *buf = "<NULL>";
+	int len;
+
+	if (ofw("getproplen", 2, 1, node, name, &len)) {
+		printk(KERN_ERR "PROM: %s: getproplen failed!\n", __func__);
+		return NULL;
+	}
+	if (len > 0) {
+		buf = prom_early_alloc(len);
+		if (ofw("getprop", 4, 1, node, name, buf, len, &len)) {
+			printk(KERN_ERR "PROM: %s: getprop failed!\n", __func__);
+			return NULL;
+		}
+	}
+
+	return buf;
+}
+
+static struct device_node * __init create_node(phandle node, struct device_node *parent)
+{
+	struct device_node *dp;
+
+	if (!node)
+		return NULL;
+
+	dp = prom_early_alloc(sizeof(*dp));
+	dp->parent = parent;
+
+	kref_init(&dp->kref);
+
+	dp->name = get_one_property(node, "name");
+	dp->type = get_one_property(node, "device_type");
+	dp->node = node;
+
+	dp->properties = build_prop_list(node);
+
+	return dp;
+}
+
+static struct device_node * __init build_tree(struct device_node *parent, phandle node, struct device_node ***nextp)
+{
+	struct device_node *ret = NULL, *prev_sibling = NULL;
+	struct device_node *dp;
+	u32 child;
+
+	while (1) {
+		dp = create_node(node, parent);
+		if (!dp)
+			break;
+
+		if (prev_sibling)
+			prev_sibling->sibling = dp;
+
+		if (!ret)
+			ret = dp;
+		prev_sibling = dp;
+
+		*(*nextp) = dp;
+		*nextp = &dp->allnext;
+
+		dp->path_component_name = build_path_component(dp);
+		dp->full_name = build_full_name(dp);
+
+		if (ofw("child", 1, 1, node, &child)) {
+			printk(KERN_ERR "PROM: %s: fetching child failed!\n", __func__);
+			return NULL;
+		}
+		dp->child = build_tree(dp, child, nextp);
+
+		if (ofw("peer", 1, 1, node, &node)) {
+			printk(KERN_ERR "PROM: %s: fetching peer failed!\n", __func__);
+			return NULL;
+		}
+	}
+
+	return ret;
+}
+
+static phandle root_node;
+
+void __init prom_build_devicetree(void)
+{
+	struct device_node **nextp;
+	u32 child;
+
+	if (ofw("peer", 1, 1, 0, &root_node)) {
+		printk(KERN_ERR "PROM: unable to get root node from OFW!\n");
+		return;
+	}
+
+	allnodes = create_node(root_node, NULL);
+	allnodes->path_component_name = "";
+	allnodes->full_name = "/";
+
+	nextp = &allnodes->allnext;
+	if (ofw("child", 1, 1, allnodes->node, &child)) {
+		printk(KERN_ERR "PROM: unable to get child node from OFW!\n");
+		return;
+	}
+	allnodes->child = build_tree(allnodes, child, &nextp);
+	printk("PROM: Built device tree with %u bytes of memory.\n",
+	       prom_early_allocated);
+}
diff -purN linux_2.6.24_org/arch/x86/pci/olpc.c linux_2.6.24_olpc/arch/x86/pci/olpc.c
--- linux_2.6.24_org/arch/x86/pci/olpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/arch/x86/pci/olpc.c	2008-02-15 18:59:22.000000000 +0000
@@ -0,0 +1,298 @@
+/*
+ * olpcpci.c - Low-level PCI config space access for OLPC systems
+ * without the VSA PCI virtualization software.
+ *
+ * The AMD Geode chipset (GX2 processor, cs5536 I/O companion device)
+ * has some I/O functions (display, southbridge, sound, USB HCIs, etc)
+ * that more or less behave like PCI devices, but the hardware doesn't
+ * directly implement the PCI configuration space headers.  AMD provides
+ * "VSA" (Virtual System Architecture) software that emulates PCI config
+ * space for these devices, by trapping I/O accesses to PCI config register
+ * (CF8/CFC) and running some code in System Management Mode interrupt state.
+ * On the OLPC platform, we don't want to use that VSA code because
+ * (a) it slows down suspend/resume, and (b) recompiling it requires special
+ * compilers that are hard to get.  So instead of letting the complex VSA
+ * code simulate the PCI config registers for the on-chip devices, we
+ * just simulate them the easy way, by inserting the code into the
+ * pci_write_config and pci_read_config path.  Most of the config registers
+ * are read-only anyway, so the bulk of the simulation is just table lookup.
+ */
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <asm/olpc.h>
+#include <asm/geode.h>
+#include "pci.h"
+
+static int is_lx;
+
+/*
+ * In the tables below, the first two line (8 longwords) are the
+ * size masks that are used when the higher level PCI code determines
+ * the size of the region by writing ~0 to a base address register
+ * and reading back the result.
+ *
+ * The following lines are the values that are read during normal
+ * PCI config access cycles, i.e. not after just having written
+ * ~0 to a base address register.
+ */
+
+static const u32 lxnb_hdr[] = {  /* dev 1 function 0 - devfn = 8 */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+
+    0x281022 ,  0x2200005 ,  0x6000021 ,   0x80f808 ,  /* AMD Vendor ID */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,  /* No virtual registers, hence no BAR for them */
+         0x0 ,        0x0 ,        0x0 ,   0x28100b ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+};
+
+static const u32 gxnb_hdr[] = {  /* dev 1 function 0 - devfn = 8 */
+  0xfffffffd ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+
+    0x28100b ,  0x2200005 ,  0x6000021 ,   0x80f808 ,  /* NSC Vendor ID */
+      0xac1d ,        0x0 ,        0x0 ,        0x0 ,  /* I/O BAR - base of virtual registers */
+         0x0 ,        0x0 ,        0x0 ,   0x28100b ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+};
+
+static const u32 lxfb_hdr[] = {  /* dev 1 function 1 - devfn = 9 */
+  0xff800008 , 0xffffc000 , 0xffffc000 , 0xffffc000 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+
+  0x20811022 ,  0x2200003 ,  0x3000000 ,        0x0 , /* AMD Vendor ID */
+  0xfd000000 , 0xfe000000 , 0xfe004000 , 0xfe008000 , /* FB, GP, VG, DF */
+  0xfe00c000 ,        0x0 ,        0x0 ,   0x30100b , /* VIP */
+         0x0 ,        0x0 ,        0x0 ,      0x10e , /* INTA, IRQ14 for graphics accel */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+       0x3d0 ,      0x3c0 ,    0xa0000 ,        0x0 , /* VG IO, VG IO, EGA FB, MONO FB */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+};
+
+static const u32 gxfb_hdr[] = {  /* dev 1 function 1 - devfn = 9 */
+  0xff800008 , 0xffffc000 , 0xffffc000 , 0xffffc000 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+
+    0x30100b ,  0x2200003 ,  0x3000000 ,        0x0 , /* NSC Vendor ID */
+  0xfd000000 , 0xfe000000 , 0xfe004000 , 0xfe008000 , /* FB, GP, VG, DF */
+         0x0 ,        0x0 ,        0x0 ,   0x30100b ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+       0x3d0 ,      0x3c0 ,    0xa0000 ,        0x0 , /* VG IO, VG IO, EGA FB, MONO FB */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+};
+
+static const u32 aes_hdr[] = {	/* dev 1 function 2 - devfn = 0xa */
+  0xffffc000 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+
+  0x20821022 ,  0x2a00006 , 0x10100000 ,        0x8 , /* NSC Vendor ID */
+  0xfe010000 ,        0x0 ,        0x0 ,        0x0 , /* AES registers */
+         0x0 ,        0x0 ,        0x0 , 0x20821022 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+};
+
+
+static const u32 isa_hdr[] = {  /* dev f function 0 - devfn = 78 */
+  0xfffffff9 , 0xffffff01 , 0xffffffc1 , 0xffffffe1 ,
+  0xffffff81 , 0xffffffc1 ,        0x0 ,        0x0 ,
+
+  0x20901022 ,  0x2a00049 ,  0x6010003 ,   0x802000 ,
+      0x18b1 ,     0x1001 ,     0x1801 ,     0x1881 , /* SMB-8   GPIO-256  MFGPT-64  IRQ-32 */
+      0x1401 ,     0x1841 ,        0x0 , 0x20901022 , /* PMS-128 ACPI-64 */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,     0xaa5b , /* interrupt steering */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+};
+
+static const u32 ac97_hdr[] = {  /* dev f function 3 - devfn = 7b */
+  0xffffff81 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+
+  0x20931022 ,  0x2a00041 ,  0x4010001 ,        0x0 ,
+      0x1481 ,        0x0 ,        0x0 ,        0x0 , /* I/O BAR-128 */
+         0x0 ,        0x0 ,        0x0 , 0x20931022 ,
+         0x0 ,        0x0 ,        0x0 ,      0x205 , /* IntB , IRQ5 */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+};
+
+static const u32 ohci_hdr[] = {  /* dev f function 4 - devfn = 7c */
+  0xfffff000 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+
+  0x20941022 ,  0x2300006 ,  0xc031002 ,        0x0 ,
+  0xfe01a000 ,        0x0 ,        0x0 ,        0x0 , /* MEMBAR-1000 */
+         0x0 ,        0x0 ,        0x0 , 0x20941022 ,
+         0x0 ,       0x40 ,        0x0 ,      0x40a , /* CapPtr  INT-D, IRQ A */
+  0xc8020001 ,        0x0 ,        0x0 ,        0x0 , /* Capabilities - 40 is R/O, 44 is mask 8103 (power control) */
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+};
+
+static const u32 ehci_hdr[] = {  /* dev f function 4 - devfn = 7d */
+  0xfffff000 ,        0x0 ,        0x0 ,        0x0 ,
+         0x0 ,        0x0 ,        0x0 ,        0x0 ,
+
+  0x20951022 ,  0x2300006 ,  0xc032002 ,        0x0 ,
+  0xfe01b000 ,        0x0 ,        0x0 ,        0x0 , /* MEMBAR-1000 */
+         0x0 ,        0x0 ,        0x0 , 0x20951022 ,
+         0x0 ,       0x40 ,        0x0 ,      0x40a , /* CapPtr  INT-D, IRQ A */
+  0xc8020001 ,        0x0 ,        0x0 ,        0x0 , /* Capabilities - 40 is R/O, 44 is mask 8103 (power control) */
+#if 0
+         0x1 , 0x40080000 ,        0x0 ,        0x0 , /* EECP - see section 2.1.7 of EHCI spec */
+#endif
+  0x01000001 , 0x00000000 ,        0x0 ,        0x0 , /* EECP - see section 2.1.7 of EHCI spec */
+      0x2020 ,        0x0 ,        0x0 ,        0x0 , /* (EHCI page 8) 60 SBRN (R/O), 61 FLADJ (R/W), PORTWAKECAP  */
+};
+
+static u32 ff_loc    = ~0;
+static u32 zero_loc  =  0;
+
+static int bar_probing = 0;       /* Set after a write of ~0 to a BAR */
+
+#define NB_SLOT 0x1      /* Northbridge - GX chip - Device 1 */
+#define SB_SLOT 0xf      /* Southbridge - CS5536 chip - Device F */
+#define SIMULATED(bus, devfn)  (((bus) == 0) && ((PCI_SLOT(devfn) == NB_SLOT) || (PCI_SLOT(devfn) == SB_SLOT)))
+
+static u32 *hdr_addr(const u32 *hdr, int reg)
+{
+	u32 addr;
+
+	/*
+	 * This is a little bit tricky.  The header maps consist of
+	 * 0x20 bytes of size masks, followed by 0x70 bytes of header data.
+	 * In the normal case, when not probing a BAR's size, we want
+	 * to access the header data, so we add 0x20 to the reg offset,
+	 * thus skipping the size mask area.
+	 * In the BAR probing case, we want to access the size mask for
+	 * the BAR, so we subtract 0x10 (the config header offset for
+	 * BAR0), and don't skip the size mask area.
+	 */
+
+	addr = (u32)hdr + reg + (bar_probing ? -0x10 : 0x20);
+
+	bar_probing = 0;
+	return (u32 *)addr;
+}
+
+static int pci_olpc_read(unsigned int seg, unsigned int bus,
+		unsigned int devfn, int reg, int len, u32 *value)
+{
+	u32 *addr;
+
+	/* Use the hardware mechanism for non-simulated devices */
+	if (!SIMULATED(bus, devfn))
+		return pci_conf1_read(seg, bus, devfn, reg, len, value);
+
+	/*
+	 * No device has config registers past 0x70, so we save table space
+	 * by not storing entries for the nonexistent registers
+	 */
+	if (reg >= 0x70)
+		addr = &zero_loc;
+	else {
+		switch (devfn) {
+			case  0x8:
+				addr = hdr_addr(is_lx ? lxnb_hdr : gxnb_hdr, reg);
+				break;
+			case  0x9:
+				addr = hdr_addr(is_lx ? lxfb_hdr : gxfb_hdr, reg);
+				break;
+			case  0xa:
+				addr = is_lx ? hdr_addr(aes_hdr, reg) : &ff_loc;
+				break;
+			case 0x78:
+				addr = hdr_addr(isa_hdr, reg);
+				break;
+			case 0x7b:
+				addr = hdr_addr(ac97_hdr, reg);
+				break;
+			case 0x7c:
+				addr = hdr_addr(ohci_hdr, reg);
+				break;
+			case 0x7d:
+				addr = hdr_addr(ehci_hdr, reg);
+				break;
+			default:
+				addr = &ff_loc;
+				break;
+		}
+	}
+	switch (len) {
+		case 1:
+			*value = *(u8 *) addr;
+			break;
+		case 2:
+			*value = *(u16 *) addr;
+			break;
+		case 4:
+			*value = *addr;
+			break;
+		default:
+			BUG();
+	}
+
+	return 0;
+}
+
+static int pci_olpc_write(unsigned int seg, unsigned int bus,
+		unsigned int devfn, int reg, int len, u32 value)
+{
+	/* Use the hardware mechanism for non-simulated devices */
+	if (!SIMULATED(bus, devfn))
+		return pci_conf1_write(seg, bus, devfn, reg, len, value);
+
+	/* XXX we may want to extend this to simulate EHCI power management */
+
+	/*
+	 * Mostly we just discard writes, but if the write is a size probe
+	 * (i.e. writing ~0 to a BAR), we remember it and arrange to return
+	 * the appropriate size mask on the next read.  This is cheating
+	 * to some extent, because it depends on the fact that the next
+	 * access after such a write will always be a read to the same BAR.
+	 */
+
+	if ((reg >= 0x10) && (reg < 0x2c)) {
+		/* Write is to a BAR */
+		if (value == ~0)
+			bar_probing = 1;
+	} else {
+		/*
+		 * No warning on writes to ROM BAR, CMD, LATENCY_TIMER,
+		 * CACHE_LINE_SIZE, or PM registers.
+		 */
+		if ((reg != 0x30) && (reg != 0x04) && (reg != 0x0d) &&
+		    (reg != 0x0c) && (reg != 0x44))
+			printk(KERN_WARNING "OLPC PCI: Config write to devfn %x reg %x value %x\n", devfn, reg, value);
+	}
+
+	return 0;
+}
+
+static struct pci_raw_ops pci_olpc_conf = {
+	.read =		pci_olpc_read,
+	.write =	pci_olpc_write,
+};
+
+void __init pci_olpc_init(void)
+{
+	if (!machine_is_olpc() || olpc_has_vsa())
+		return;
+
+	printk(KERN_INFO "PCI: Using configuration type OLPC\n");
+	raw_pci_ops = &pci_olpc_conf;
+	is_lx = is_geode_lx();
+}
diff -purN linux_2.6.24_org/Documentation/kernel-parameters.txt linux_2.6.24_olpc/Documentation/kernel-parameters.txt
--- linux_2.6.24_org/Documentation/kernel-parameters.txt	2008-02-15 20:12:29.000000000 +0000
+++ linux_2.6.24_olpc/Documentation/kernel-parameters.txt	2008-02-15 18:59:54.000000000 +0000
@@ -1244,6 +1244,13 @@ and is between 256 and 4096 characters. 
 
 	nr_uarts=	[SERIAL] maximum number of UARTs to be registered.
 
+	olpc_ec_timeout=	[OLPC] ms delay when issuing EC commands
+			Rather than timing out after 20 ms if an EC
+			command is not properly ACKed, override the length
+			of the timeout.  We have interrupts disabled while
+			waiting for the ACK, so if this is set too high
+			interrupts *may* be lost!
+
 	opl3=		[HW,OSS]
 			Format: <io>
 
diff -purN linux_2.6.24_org/drivers/base/dd.c linux_2.6.24_olpc/drivers/base/dd.c
--- linux_2.6.24_org/drivers/base/dd.c	2008-02-15 20:11:29.000000000 +0000
+++ linux_2.6.24_olpc/drivers/base/dd.c	2008-02-15 18:58:46.000000000 +0000
@@ -293,7 +293,6 @@ static void __device_release_driver(stru
 	if (drv) {
 		driver_sysfs_remove(dev);
 		sysfs_remove_link(&dev->kobj, "driver");
-		klist_remove(&dev->knode_driver);
 
 		if (dev->bus)
 			blocking_notifier_call_chain(&dev->bus->bus_notifier,
@@ -306,6 +305,7 @@ static void __device_release_driver(stru
 			drv->remove(dev);
 		devres_release_all(dev);
 		dev->driver = NULL;
+		klist_remove(&dev->knode_driver);
 		put_driver(drv);
 	}
 }
diff -purN linux_2.6.24_org/drivers/char/vt_ioctl.c linux_2.6.24_olpc/drivers/char/vt_ioctl.c
--- linux_2.6.24_org/drivers/char/vt_ioctl.c	2008-02-15 20:11:48.000000000 +0000
+++ linux_2.6.24_olpc/drivers/char/vt_ioctl.c	2008-02-15 18:59:11.000000000 +0000
@@ -38,6 +38,9 @@
 char vt_dont_switch;
 extern struct tty_driver *console_driver;
 
+/* Add a notifier chain to inform drivers of a VT_TEXT/VT_GRAPHICS switch */
+RAW_NOTIFIER_HEAD(console_notifier_list);
+
 #define VT_IS_IN_USE(i)	(console_driver->ttys[i] && console_driver->ttys[i]->count)
 #define VT_BUSY(i)	(VT_IS_IN_USE(i) || i == fg_console || vc_cons[i].d == sel_cons)
 
@@ -492,6 +495,14 @@ int vt_ioctl(struct tty_struct *tty, str
 		vc->vc_mode = (unsigned char) arg;
 		if (console != fg_console)
 			return 0;
+
+		/* Notify listeners if the current fg_console has switched */
+
+		raw_notifier_call_chain(&console_notifier_list,
+			(arg == KD_TEXT) ?
+			CONSOLE_EVENT_SWITCH_TEXT :
+			CONSOLE_EVENT_SWITCH_GRAPHICS, 0);
+
 		/*
 		 * explicitly blank/unblank the screen if switching modes
 		 */
diff -purN linux_2.6.24_org/drivers/i2c/busses/scx200_acb.c linux_2.6.24_olpc/drivers/i2c/busses/scx200_acb.c
--- linux_2.6.24_org/drivers/i2c/busses/scx200_acb.c	2008-02-15 20:11:33.000000000 +0000
+++ linux_2.6.24_olpc/drivers/i2c/busses/scx200_acb.c	2008-02-15 18:58:49.000000000 +0000
@@ -46,6 +46,10 @@ static int base[MAX_DEVICES] = { 0x820, 
 module_param_array(base, int, NULL, 0);
 MODULE_PARM_DESC(base, "Base addresses for the ACCESS.bus controllers");
 
+static unsigned int smbclk = 0x70;
+module_param(smbclk, uint, 0);
+MODULE_PARM_DESC(smbclk, "Specify the SMB_CLK value");
+
 #define POLL_TIMEOUT	(HZ/5)
 
 enum scx200_acb_state {
@@ -108,6 +112,7 @@ struct scx200_acb_iface {
 #define ACBADDR		(iface->base + 4)
 #define ACBCTL2		(iface->base + 5)
 #define    ACBCTL2_ENABLE	0x01
+#define ACBCTL3        (iface->base + 6)
 
 /************************************************************************/
 
@@ -392,11 +397,13 @@ static __init int scx200_acb_probe(struc
 {
 	u8 val;
 
-	/* Disable the ACCESS.bus device and Configure the SCL
-	   frequency: 16 clock cycles */
-	outb(0x70, ACBCTL2);
+	/* Disable the ACCESS.bus device and Configure the SCL */
+
+	outb((smbclk & 0x7F) << 1, ACBCTL2);
+
+	outb((smbclk >> 7) & 0xFF, ACBCTL3);
 
-	if (inb(ACBCTL2) != 0x70) {
+	if (inb(ACBCTL2) != ((smbclk & 0x7F) << 1)) {
 		pr_debug(NAME ": ACBCTL2 readback failed\n");
 		return -ENXIO;
 	}
diff -purN linux_2.6.24_org/drivers/input/keyboard/atkbd.c linux_2.6.24_olpc/drivers/input/keyboard/atkbd.c
--- linux_2.6.24_org/drivers/input/keyboard/atkbd.c	2008-02-15 20:11:51.000000000 +0000
+++ linux_2.6.24_olpc/drivers/input/keyboard/atkbd.c	2008-02-15 18:59:14.000000000 +0000
@@ -63,12 +63,25 @@ static int atkbd_extra;
 module_param_named(extra, atkbd_extra, bool, 0);
 MODULE_PARM_DESC(extra, "Enable extra LEDs and keys on IBM RapidAcces, EzKey and similar keyboards");
 
+#define ATKBD_KEY_UNKNOWN	  0
+#define ATKBD_KEY_NULL		0xFF0000FF
+
+#define ATKBD_SCR_1		0xFF0000FE
+#define ATKBD_SCR_2		0xFF0000FD
+#define ATKBD_SCR_4		0xFF0000FC
+#define ATKBD_SCR_8		0xFF0000FB
+#define ATKBD_SCR_CLICK		0xFF0000FA
+#define ATKBD_SCR_LEFT		0xFF0000F9
+#define ATKBD_SCR_RIGHT		0xFF0000F8
+
+#define ATKBD_SPECIAL		0xFF0000F8
+
 /*
  * Scancode to keycode tables. These are just the default setting, and
  * are loadable via an userland utility.
  */
 
-static unsigned char atkbd_set2_keycode[512] = {
+static unsigned int atkbd_set2_keycode[512] = {
 
 #ifdef CONFIG_KEYBOARD_ATKBD_HP_KEYCODES
 
@@ -87,11 +100,17 @@ static unsigned char atkbd_set2_keycode[
 	 82, 83, 80, 76, 77, 72,  1, 69, 87, 78, 81, 74, 55, 73, 70, 99,
 
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	217,100,255,  0, 97,165,  0,  0,156,  0,  0,  0,  0,  0,  0,125,
+
+	217,100,ATKBD_KEY_NULL,  0, 97,165,  0,  0,
+	156,  0,  0,  0,  0,  0,  0,125,
+
 	173,114,  0,113,  0,  0,  0,126,128,  0,  0,140,  0,  0,  0,127,
 	159,  0,115,  0,164,  0,  0,116,158,  0,172,166,  0,  0,  0,142,
 	157,  0,  0,  0,  0,  0,  0,  0,155,  0, 98,  0,  0,163,  0,  0,
-	226,  0,  0,  0,  0,  0,  0,  0,  0,255, 96,  0,  0,  0,143,  0,
+
+	226,  0,  0,  0,  0,  0,  0,  0,
+	  0,ATKBD_KEY_NULL, 96,  0,  0,  0,143,  0,
+
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,107,  0,105,102,  0,  0,112,
 	110,111,108,112,106,103,  0,119,  0,118,109,  0, 99,104,119,  0,
 
@@ -150,19 +169,6 @@ static unsigned char atkbd_unxlate_table
 #define ATKBD_RET_HANGEUL	0xf2
 #define ATKBD_RET_ERR		0xff
 
-#define ATKBD_KEY_UNKNOWN	  0
-#define ATKBD_KEY_NULL		255
-
-#define ATKBD_SCR_1		254
-#define ATKBD_SCR_2		253
-#define ATKBD_SCR_4		252
-#define ATKBD_SCR_8		251
-#define ATKBD_SCR_CLICK		250
-#define ATKBD_SCR_LEFT		249
-#define ATKBD_SCR_RIGHT		248
-
-#define ATKBD_SPECIAL		248
-
 #define ATKBD_LED_EVENT_BIT	0
 #define ATKBD_REP_EVENT_BIT	1
 
@@ -174,7 +180,7 @@ static unsigned char atkbd_unxlate_table
 #define ATKBD_XL_HANJA		0x20
 
 static struct {
-	unsigned char keycode;
+	unsigned int keycode;
 	unsigned char set2;
 } atkbd_scroll_keys[] = {
 	{ ATKBD_SCR_1,     0xc5 },
@@ -200,7 +206,7 @@ struct atkbd {
 	char phys[32];
 
 	unsigned short id;
-	unsigned char keycode[512];
+	unsigned int keycode[512];
 	unsigned char set;
 	unsigned char translated;
 	unsigned char extra;
@@ -351,7 +357,7 @@ static irqreturn_t atkbd_interrupt(struc
 	unsigned int code = data;
 	int scroll = 0, hscroll = 0, click = -1, add_release_event = 0;
 	int value;
-	unsigned char keycode;
+	unsigned int keycode;
 
 #ifdef ATKBD_DEBUG
 	printk(KERN_DEBUG "atkbd.c: Received %02x flags %02x\n", data, flags);
@@ -856,9 +862,11 @@ static void atkbd_set_keycode_table(stru
 						atkbd->keycode[i | 0x80] = atkbd_scroll_keys[j].keycode;
 		}
 	} else if (atkbd->set == 3) {
-		memcpy(atkbd->keycode, atkbd_set3_keycode, sizeof(atkbd->keycode));
+		for (i = 0; i < ARRAY_SIZE(atkbd_set3_keycode); i++)
+			atkbd->keycode[i] = atkbd_set3_keycode[i];
 	} else {
-		memcpy(atkbd->keycode, atkbd_set2_keycode, sizeof(atkbd->keycode));
+		for (i = 0; i < ARRAY_SIZE(atkbd_set2_keycode); i++)
+			atkbd->keycode[i] = atkbd_set2_keycode[i];
 
 		if (atkbd->scroll)
 			for (i = 0; i < ARRAY_SIZE(atkbd_scroll_keys); i++)
@@ -930,8 +938,8 @@ static void atkbd_set_device_attrs(struc
 	}
 
 	input_dev->keycode = atkbd->keycode;
-	input_dev->keycodesize = sizeof(unsigned char);
-	input_dev->keycodemax = ARRAY_SIZE(atkbd_set2_keycode);
+	input_dev->keycodesize = sizeof(unsigned int);
+	input_dev->keycodemax = ARRAY_SIZE(atkbd->keycode);
 
 	for (i = 0; i < 512; i++)
 		if (atkbd->keycode[i] && atkbd->keycode[i] < ATKBD_SPECIAL)
@@ -1022,6 +1030,10 @@ static int atkbd_connect(struct serio *s
 	return err;
 }
 
+#ifdef CONFIG_OLPC
+#include <asm/olpc.h>
+#endif
+
 /*
  * atkbd_reconnect() tries to restore keyboard into a sane state and is
  * most likely called on resume.
@@ -1032,6 +1044,12 @@ static int atkbd_reconnect(struct serio 
 	struct atkbd *atkbd = serio_get_drvdata(serio);
 	struct serio_driver *drv = serio->drv;
 
+#ifdef CONFIG_OLPC
+	if (olpc_board_at_least(olpc_board_pre(0xb3)))
+		if (serio->dev.power.power_state.event != PM_EVENT_ON)
+			return 0;
+#endif
+
 	if (!atkbd || !drv) {
 		printk(KERN_DEBUG "atkbd: reconnect request, but serio is disconnected, ignoring...\n");
 		return -1;
diff -purN linux_2.6.24_org/drivers/input/mouse/Kconfig linux_2.6.24_olpc/drivers/input/mouse/Kconfig
--- linux_2.6.24_org/drivers/input/mouse/Kconfig	2008-02-15 20:11:51.000000000 +0000
+++ linux_2.6.24_olpc/drivers/input/mouse/Kconfig	2008-02-15 18:59:14.000000000 +0000
@@ -96,6 +96,16 @@ config MOUSE_PS2_TOUCHKIT
 
 	  If unsure, say N.
 
+config MOUSE_PS2_OLPC
+	bool "OLPC PS/2 mouse protocol extension" if EMBEDDED
+	default n
+	depends on MOUSE_PS2 && OLPC
+	---help---
+	  Say Y here if you have an OLPC PS/2 touchpad connected to
+	  your system.
+
+	  If unsure, say N.
+
 config MOUSE_SERIAL
 	tristate "Serial mouse"
 	select SERIO
diff -purN linux_2.6.24_org/drivers/input/mouse/Makefile linux_2.6.24_olpc/drivers/input/mouse/Makefile
--- linux_2.6.24_org/drivers/input/mouse/Makefile	2008-02-15 20:11:51.000000000 +0000
+++ linux_2.6.24_olpc/drivers/input/mouse/Makefile	2008-02-15 18:59:14.000000000 +0000
@@ -24,3 +24,4 @@ psmouse-$(CONFIG_MOUSE_PS2_LOGIPS2PP)	+=
 psmouse-$(CONFIG_MOUSE_PS2_LIFEBOOK)	+= lifebook.o
 psmouse-$(CONFIG_MOUSE_PS2_TRACKPOINT)	+= trackpoint.o
 psmouse-$(CONFIG_MOUSE_PS2_TOUCHKIT)	+= touchkit_ps2.o
+psmouse-$(CONFIG_MOUSE_PS2_OLPC)	+= olpc.o
diff -purN linux_2.6.24_org/drivers/input/mouse/olpc.c linux_2.6.24_olpc/drivers/input/mouse/olpc.c
--- linux_2.6.24_org/drivers/input/mouse/olpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/input/mouse/olpc.c	2008-02-15 18:59:14.000000000 +0000
@@ -0,0 +1,837 @@
+/*
+ * OLPC touchpad PS/2 mouse driver
+ *
+ * Copyright (c) 2006-2008 One Laptop Per Child
+ * Authors:
+ *   Zephaniah E. Hull
+ *   Andres Salomon <dilinger@laptop.org>
+ *
+ * This driver is partly based on the ALPS driver, which is:
+ *
+ * Copyright (c) 2003 Neil Brown <neilb@cse.unsw.edu.au>
+ * Copyright (c) 2003-2005 Peter Osterlund <petero2@telia.com>
+ * Copyright (c) 2004 Dmitry Torokhov <dtor@mail.ru>
+ * Copyright (c) 2005 Vojtech Pavlik <vojtech@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * The touchpad on the OLPC is fairly wide, with the entire area usable
+ * as a tablet (Pen Tablet/PT), and the center 1/3rd also usable as a
+ * touchpad (Glide Sensor/GS).  The spec from ALPS is available from
+ * <http://wiki.laptop.org/go/Touch_Pad/Tablet>.  It refers to this
+ * device as HGPK (Hybrid GS, PT, and Keymatrix).
+ *
+ * Earlier version of the device had simultaneous reporting; however, that
+ * was removed.  Instead, the device now reports packets in one mode, and
+ * tells the driver when a mode switch needs to happen.
+ */
+
+#define DEBUG
+#include <linux/input.h>
+#include <linux/serio.h>
+#include <linux/libps2.h>
+#include <linux/delay.h>
+#include <asm/olpc.h>
+
+#include "psmouse.h"
+#include "olpc.h"
+
+static int tpdebug;
+module_param(tpdebug, int, 0644);
+
+static int ignore_delta = 60;
+module_param(ignore_delta, int, 0644);
+MODULE_PARM_DESC(ignore_delta, "ignore packets that cause an X or Y delta larger than this value.");
+
+/*
+ * With older hardware, a finger-up event is sometimes not sent.  If it's been
+ * more than 50mS since the last packet, we can safely assume that there was
+ * a finger-up event that we never received.
+ */
+static void hgpk_fingerup_hack(struct psmouse *psmouse, struct hgpk_packet *p)
+{
+	struct hgpk_data *priv = psmouse->private;
+	struct timeval now_tv;
+	s64 now_ns;
+
+	if (psmouse->model >= HGPK_MODEL_C)
+		return;
+
+	if (p->gs_down || p->pt_down) {
+		do_gettimeofday(&now_tv);
+		now_ns = timeval_to_ns(&now_tv);
+
+		if (priv->late && now_ns >= priv->late) {
+			struct input_dev *pt = psmouse->dev;
+			struct input_dev *gs = priv->gs;
+
+			input_report_key(pt, BTN_TOUCH, 0);
+			input_report_key(gs, BTN_TOUCH, 0);
+			input_sync(pt);
+			input_sync(gs);
+			hgpk_dbg(psmouse, "Missing finger-up packet detected, "
+					"working around buggy hardware.\n");
+		}
+		priv->late = now_ns + (50 * NSEC_PER_MSEC);
+	} else
+		priv->late = 0;
+}
+
+/*
+ * C and D series touchpads send an extra finger-up packet to ensure we've
+ * seen it.  That's all well and good, but for some uncomprehensible reason
+ * they sometimes also get stuck in a state where they also send an
+ * extra finger-down packet with coordinates of x=0, y=0.  This royally
+ * screws relative positioning; end users see it as the touchpad jumping
+ * around when they first put their finger down.  This works around that.
+ *
+ * *Sigh*. ALPS..
+ */
+static void hgpk_fingerdown_hack(struct psmouse *psmouse, struct hgpk_packet *p)
+{
+	if (psmouse->model < HGPK_MODEL_C)
+		return;
+
+	/* we only care about x=0, y=0 packets */
+	if (p->x != 0 || p->y != 0)
+		return;
+
+	/*
+	 * if we're a gs_down packet but we were not previously down,
+	 * we're going to assume that this is one of those spurious packets
+	 * that needs to be worked around.
+	 */
+	if (p->gs_down && !test_bit(BTN_TOUCH, p->dev->key)) {
+		hgpk_dbg(psmouse, "spurious GS finger-down packet\n");
+		p->gs_down = 0;
+	} else if (p->pt_down && !test_bit(BTN_TOUCH, p->dev->key)) {
+		hgpk_dbg(psmouse, "spurious PT finger-down packet\n");
+		p->pt_down = 0;
+	}
+}
+
+/*
+ * In general, we have lots of calibration problems that manifest
+ * themselves as jumpy mouse pointers.  Miscalibration, capacitance issues
+ * with the hardware, etc; these make the touchpad detect errant packets
+ * at random places all over the place.  Since we don't expect large deltas
+ * to ever actually be useful, we'll large axis changes that go over our
+ * threshold.
+ */
+static void hgpk_big_delta_hack(struct psmouse *psmouse, struct hgpk_packet *p)
+{
+	struct hgpk_data *priv = psmouse->private;
+	struct input_dev *dev = p->dev;
+
+	/* afaik, this happens on all hardware */
+
+	/* ignore finger-up packets */
+	if (!p->pt_down && !p->gs_down)
+		goto done;
+
+	/* ensure that we're not a finger-down packet */
+	if ((p->pt_down && !test_bit(BTN_TOUCH, dev->key)) || 
+			(p->gs_down && !test_bit(BTN_TOUCH, dev->key)))
+		goto done;
+
+	if (abs(dev->abs[ABS_X] - p->x) > ignore_delta ||
+			abs(dev->abs[ABS_Y] - p->y) > ignore_delta) {
+		hgpk_dbg(psmouse, "axis change (%d,%d) => (%d,%d) is over "
+				"delta threshold\n", dev->abs[ABS_X],
+				dev->abs[ABS_Y], p->x, p->y);
+		input_report_key(dev, BTN_TOUCH, 0);
+		input_sync(dev);
+
+
+		/* two in a row is a pretty good indicator of miscalibration */
+		if (priv->axis_errors++) {
+			/* wait 2s for finger removal, and then recalibrate */
+			queue_delayed_work(kpsmoused_wq, &priv->recalib_wq,
+					msecs_to_jiffies(2000));
+			priv->axis_errors = 0;
+		}
+		return;
+	}
+done:
+	priv->axis_errors = 0;	
+}
+
+/*
+ * This is my favorite touchpad hardware bug.  I'm entirely not sure what
+ * triggers it (I've seen it triggered while the laptop was left on overnight,
+ * but my cat could have very well been using it/sleeping on it).  However,
+ * the touchpad will randomly get stuck in a state where it constantly spews
+ * packets without a finger being on it.  A recalibration will fix it, but
+ * without that it will go on for days (auto-recalibration doesn't catch it,
+ * either).  The packets tend to either have the same coordinates, or be
+ * 1px away from each other; ie, (283,139,6) -> (284,139,5) -> (285,139,5) ->
+ * (286,139,6) -> (286,139,6) -> etc.  We have a number of workarounds here..
+ */
+static void hgpk_spewing_hack(struct psmouse *psmouse, struct hgpk_packet *p)
+{
+	struct hgpk_data *priv = psmouse->private;
+	struct input_dev *dev = p->dev;
+	int repeat_axes;
+
+	if (psmouse->model < HGPK_MODEL_C)
+		return;
+
+	/* ignore 0, 0 packets */
+	if (p->x == 0 && p->y == 0)
+		return;
+
+	/* PT packets don't count */
+	if (p->pt_down) {
+		priv->repeat_pkts = 0;
+		return;
+	}
+
+	/* 
+	 * If we see 2s+ worth of packets that have at least 2 axis deltas of
+	 * only 1px, that's a good indication that we're spewing packets.
+	 * We're going to ignore z=15, though; that's pretty indicative of
+	 * an actual finger on the touchpad just staying still.
+	 */
+	if (p->z == 0 || p->z == 15)
+		goto next_hack;
+	repeat_axes = abs(p->x - dev->abs[ABS_X]) < 2 ? 1 : 0;
+	repeat_axes += abs(p->y - dev->abs[ABS_Y]) < 2 ? 1 : 0;
+	repeat_axes += abs(p->z - dev->abs[ABS_PRESSURE]) < 2 ? 1 : 0;
+	if (repeat_axes > 1) {
+		priv->repeat_pkts++;
+		/* we get 1 packet about every 24mS */
+		if (priv->repeat_pkts > 83) {
+			queue_delayed_work(kpsmoused_wq, &priv->recalib_wq, 0);
+			priv->repeat_pkts = 0;
+		}
+	}
+	else
+		priv->repeat_pkts = 0;
+	return;
+
+next_hack:
+	/*
+	 * 10s of y and z not changing is another kind of miscalibration.
+	 */
+	repeat_axes = (p->y == dev->abs[ABS_Y]) ? 1 : 0;
+	repeat_axes += (p->z == dev->abs[ABS_PRESSURE]) ? 1 : 0;
+	if (repeat_axes > 1) {
+		priv->repeat_pkts++;
+		if (priv->repeat_pkts > 416) {
+			queue_delayed_work(kpsmoused_wq, &priv->recalib_wq, 0);
+			priv->repeat_pkts = 0;
+		}
+	}
+	else
+		priv->repeat_pkts = 0;
+}
+
+/*
+ * HGPK Advanced Mode - single-mode format
+ *
+ * byte 0(PT):  1    1    0    0    1    1     1     1
+ * byte 0(GS):  1    1    1    1    1    1     1     1
+ * byte 1:      0   x6   x5   x4   x3   x2    x1    x0
+ * byte 2(PT):  0    0   x9   x8   x7    ? pt-dsw    0
+ * byte 2(GS):  0  x10   x9   x8   x7    ? gs-dsw pt-dsw
+ * byte 3:      0   y9   y8   y7    1    0   swr   swl
+ * byte 4:      0   y6   y5   y4   y3   y2    y1    y0
+ * byte 5:      0   z6   z5   z4   z3   z2    z1    z0
+ *
+ * ?'s are not defined in the protocol spec, may vary between models.
+ *
+ * swr/swl are the left/right buttons.
+ *
+ * pt-dsw/gs-dsw indicate that the pt/gs sensor is detecting a
+ * pen/finger
+ */
+
+static int hgpk_validate_byte(unsigned char *packet, int pktcnt)
+{
+	BUG_ON(pktcnt < 1);
+
+	if (packet[0] != HGPK_PT && packet[0] != HGPK_GS)
+		return -1;
+
+	/* bytes 2 - 6 should have 0 in the highest bit */
+	if (pktcnt >= 2 && pktcnt <= 6 && (packet[pktcnt - 1] & 0x80))
+		return -1;
+
+	return 0;
+}
+
+static void hgpk_decode_packet(struct psmouse *psmouse, struct hgpk_packet *p)
+{
+	unsigned char *packet = psmouse->packet;
+
+	BUG_ON(psmouse->pktcnt < 6);
+	
+	p->left = packet[3] & 1;
+	p->right = !!(packet[3] & 2);
+	p->x = packet[1] | ((packet[2] & 0x78) << 4);
+	p->y = packet[4] | ((packet[3] & 0x70) << 3);
+	p->z = packet[5];
+
+	if (packet[0] == HGPK_GS) {
+		p->pt_down = !!(packet[2] & 1);
+		p->gs_down = !!(packet[2] & 2);
+		p->dev = ((struct hgpk_data *) psmouse->private)->gs;
+		if (p->pt_down) {
+			/* we miss spurious PT finger-downs if pt_down is set */
+			p->mode_switch = HGPK_PT;
+			p->pt_down = 0;
+		} else {
+			p->mode_switch = 0;
+		}
+	} else if (packet[0] == HGPK_PT) {
+		p->pt_down = !!(packet[2] & 2);
+		p->gs_down = 0;
+		p->dev = psmouse->dev;
+		p->mode_switch = !p->pt_down ? HGPK_GS : 0;
+	}
+
+	if (tpdebug) {
+		hgpk_dbg(psmouse, "l=%d r=%d p=%d g=%d x=%d y=%d z=%d m=%x\n",
+				p->left, p->right, p->pt_down, p->gs_down,
+				p->x, p->y, p->z, p->mode_switch);
+	}
+}
+
+static void hgpk_process_packet_gspt(struct psmouse *psmouse)
+{
+	struct hgpk_data *priv = psmouse->private;
+	struct input_dev *pt = psmouse->dev;
+	struct input_dev *gs = priv->gs;
+	struct hgpk_packet pkt;
+
+	hgpk_decode_packet(psmouse, &pkt);	
+
+	hgpk_fingerup_hack(psmouse, &pkt);
+	hgpk_fingerdown_hack(psmouse, &pkt);
+	hgpk_big_delta_hack(psmouse, &pkt);
+	hgpk_spewing_hack(psmouse, &pkt);
+
+	input_report_key(pt, BTN_LEFT, pkt.left);
+	input_report_key(pt, BTN_RIGHT, pkt.right);
+	input_report_key(pt, BTN_TOUCH, pkt.pt_down);
+
+	input_report_key(gs, BTN_LEFT, pkt.left);
+	input_report_key(gs, BTN_RIGHT, pkt.right);
+	input_report_key(gs, BTN_TOUCH, pkt.gs_down);
+
+	input_report_abs(pkt.dev, ABS_X, pkt.x);
+	input_report_abs(pkt.dev, ABS_Y, pkt.y);
+	input_report_abs(pkt.dev, ABS_PRESSURE, pkt.z);
+
+	input_sync(pt);
+	input_sync(gs);
+
+	if (priv->recalib_window) {
+		if (time_before(jiffies, priv->recalib_window)) {
+			/* 
+			 * ugh, got a packet inside our recalibration
+			 * window, schedule another recalibration.
+			 */
+			hgpk_dbg(psmouse, "packet inside calibration window, "
+					"queueing another recalibration\n");
+			queue_delayed_work(kpsmoused_wq, &priv->recalib_wq,
+					msecs_to_jiffies(1000));
+		}
+		priv->recalib_window = 0;
+	}
+
+	if (psmouse->model != HGPK_MODEL_A) {
+		if (priv->pending_mode && (!pkt.mode_switch  || 
+				priv->current_mode == pkt.mode_switch)) {
+			priv->pending_mode = 0;
+			cancel_delayed_work(&priv->switch_wq);
+		}
+		else if (priv->pending_mode != pkt.mode_switch) {
+			priv->pending_mode = pkt.mode_switch;
+
+			/* allow for spurious mode_switch packets by delaying */
+			queue_delayed_work(kpsmoused_wq, &priv->switch_wq,
+					msecs_to_jiffies(50));
+		}
+	}
+}
+
+static psmouse_ret_t hgpk_process_byte(struct psmouse *psmouse)
+{
+	if (hgpk_validate_byte(psmouse->packet, psmouse->pktcnt)) {
+		hgpk_dbg(psmouse, "%s: (%d) %02x %02x %02x %02x %02x %02x\n",
+				__func__, psmouse->pktcnt, psmouse->packet[0],
+				psmouse->packet[1], psmouse->packet[2],
+				psmouse->packet[3], psmouse->packet[4],
+				psmouse->packet[5]);
+		return PSMOUSE_BAD_DATA;
+	}
+
+	if (psmouse->pktcnt == 6) {
+		hgpk_process_packet_gspt(psmouse);
+		return PSMOUSE_FULL_PACKET;
+	}
+
+	return PSMOUSE_GOOD_DATA;
+}
+
+static int hgpk_force_recalibrate(struct psmouse *psmouse)
+{
+	struct ps2dev *ps2dev = &psmouse->ps2dev;
+	struct hgpk_data *priv = psmouse->private;
+	struct input_dev *pt = psmouse->dev;
+	struct input_dev *gs = priv->gs;
+
+	/* C-series touchpads added the recalibrate command */
+	if (psmouse->model < HGPK_MODEL_C)
+		return 0;
+
+	if (ps2_command(ps2dev, NULL, 0xf5) ||
+			ps2_command(ps2dev, NULL, 0xf5) ||
+			ps2_command(ps2dev, NULL, 0xe6) ||
+			ps2_command(ps2dev, NULL, 0xf5))
+		return -1;
+
+	/* send a finger-up event so the cursor doesn't jump around */
+	input_report_key(pt, BTN_TOUCH, 0);
+	input_report_key(gs, BTN_TOUCH, 0);
+	input_sync(pt);
+	input_sync(gs);
+
+	/* according to ALPS, 150mS is required for recalibration */
+	msleep(150);
+
+	/*
+	 * XXX: If a finger is down during this delay, recalibration will
+	 * detect capacitance incorrectly.  This is a hardware bug, and
+	 * we may need to work around that here.
+	 */
+
+	if (ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE))
+		return -1;
+
+	/*
+	 * After we recalibrate, we shouldn't get any packets for 2s.  If
+	 * we do, it's likely that someone's finger was on the touchpad.
+	 * If someone's finger *was* on the touchpad, it's probably
+	 * miscalibrated.  So, we should schedule another recalibration
+	 */
+	priv->recalib_window = jiffies +  msecs_to_jiffies(2000);
+
+	return 0;
+}
+
+static enum hgpk_model_t hgpk_get_model(struct psmouse *psmouse)
+{
+	struct ps2dev *ps2dev = &psmouse->ps2dev;
+	unsigned char param[3];
+
+ 	/* E7, E7, E7, E9 gets us a 3 byte identifier */
+	if (ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE21) ||
+			ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE21) ||
+			ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE21) ||
+			ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))
+		return -EIO;
+
+	hgpk_dbg(psmouse, "ID: %02x %02x %02x", param[0], param[1], param[2]);
+
+	/* HGPK signature: 0x67, 0x00, 0x<model> */
+	if (param[0] != 0x67 || param[1] != 0x00)
+		return -ENODEV;
+	
+	hgpk_info(psmouse, "OLPC touchpad revision 0x%x\n", param[2]);
+	return param[2];
+}
+
+/*
+ * Touchpad should be disabled before calling this!
+ */
+static int hgpk_new_mode(struct psmouse *psmouse, int mode)
+{
+	struct ps2dev *ps2dev = &psmouse->ps2dev;
+	struct hgpk_data *priv = psmouse->private;
+
+	/*
+	 * PT mode: F2, F2, F2, E7
+	 * GS mode: F2, F2, F2, E6
+	 */
+	if (ps2_command(ps2dev, NULL, 0xF2) ||
+			ps2_command(ps2dev, NULL, 0xF2) ||
+			ps2_command(ps2dev, NULL, 0xF2))
+		return -EIO;
+
+	if (mode == HGPK_GS) {
+		if (ps2_command(ps2dev, NULL, 0xE6))
+			return -EIO;
+	} else {
+		if (ps2_command(ps2dev, NULL, 0xE7))
+			return -EIO;
+	}
+
+	if (ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE))
+		return -EIO;
+
+	/* tell the irq handler to stop ignoring packets */
+	psmouse_set_state(psmouse, PSMOUSE_ACTIVATED);
+
+	priv->current_mode = mode;
+	priv->pending_mode = 0;
+	if (tpdebug)
+		hgpk_warn(psmouse, "Switched to mode 0x%x successful.\n", mode);
+
+	return 0;
+}
+
+static int hgpk_advanced_mode(struct psmouse *psmouse)
+{
+	struct ps2dev *ps2dev = &psmouse->ps2dev;
+
+	/* Switch to 'Advanced mode.', four disables in a row. */
+	if (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||
+			ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||
+			ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||
+			ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))
+		return -1;
+	
+	return hgpk_new_mode(psmouse, HGPK_GS);
+}
+
+/*
+ * This kills power to the touchpad; according to ALPS, current consumption
+ * goes down to 50uA after running this.  To turn power back on, we drive
+ * MS-DAT low.
+ */
+static int hgpk_toggle_power(struct psmouse *psmouse, int enable)
+{
+	struct ps2dev *ps2dev = &psmouse->ps2dev;
+	int timeo;
+
+	/* Added on D-series touchpads */
+	if (psmouse->model < HGPK_MODEL_D)
+		return 0;
+
+	if (enable) {
+		psmouse_set_state(psmouse, PSMOUSE_INITIALIZING);
+
+		/*
+		 * Sending a byte will drive MS-DAT low; this will wake up
+		 * the controller.  Once we get an ACK back from it, it
+		 * means we can continue with the touchpad re-init.  ALPS
+		 * tells us that 1s should be long enough, so set that as
+		 * the upper bound.
+		 */
+		for (timeo = 20; timeo > 0; timeo--) {
+			if (!ps2_sendbyte(&psmouse->ps2dev,
+					PSMOUSE_CMD_DISABLE, 20))
+				break;
+			msleep(50);
+		}
+
+		psmouse_reset(psmouse);
+
+		if (hgpk_advanced_mode(psmouse)) {
+			hgpk_err(psmouse, "Failed to reinit touchpad!\n");
+			return -1;
+		}
+	} else {
+		hgpk_dbg(psmouse, "Powering off touchpad.\n");
+		psmouse_set_state(psmouse, PSMOUSE_IGNORE);
+
+		if (ps2_command(ps2dev, NULL, 0xec) ||
+				ps2_command(ps2dev, NULL, 0xec) ||
+				ps2_command(ps2dev, NULL, 0xea))
+			return -1;
+		/* probably won't see an ACK, the touchpad will be off */
+		ps2_sendbyte(&psmouse->ps2dev, 0xec, 20);
+	}
+      
+	return 0;
+}
+
+/*
+ * poll the touchpad for current motion packet.
+ * Used in resync.
+ * Note: We can't poll, so always return failure.
+ */
+static int hgpk_poll(struct psmouse *psmouse)
+{
+	return -1;
+}
+
+static int hgpk_reconnect(struct psmouse *psmouse)
+{
+	if (olpc_board_at_least(olpc_board(0xb2)))
+		if (psmouse->ps2dev.serio->dev.power.power_state.event != PM_EVENT_ON)
+			return 0;
+
+	psmouse_reset(psmouse);
+
+	if (hgpk_advanced_mode(psmouse)) {
+		hgpk_err(psmouse, "failed to reenable advanced mode.\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static ssize_t hgpk_show_powered(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct serio *serio = to_serio_port(dev);
+	struct psmouse *psmouse;
+	struct hgpk_data *priv;
+	int retval;
+
+	retval = serio_pin_driver(serio);
+	if (retval)
+		return retval;
+
+        psmouse = serio_get_drvdata(serio);
+	priv = psmouse->private;
+
+	retval = sprintf(buf, "%d\n", priv->powered);
+	serio_unpin_driver(serio);
+	return retval;
+}
+
+static ssize_t hgpk_set_powered(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct serio *serio = to_serio_port(dev);
+	struct psmouse *psmouse;
+	struct hgpk_data *priv;
+	unsigned long val;
+	int retval;
+
+	if (*buf == '1')
+		val = 1;
+	else if (*buf == '0')
+		val = 0;
+	else
+		return -EINVAL;
+
+	retval = serio_pin_driver(serio);
+	if (retval)
+		return retval;
+
+/*
+ * FUCK IT.  I don't fucking care.  locking in psmouse is fucking retarded!
+	retval = mutex_lock_interruptible(&psmouse_mutex);
+	if (retval)
+		goto out_unpin;
+*/
+
+	psmouse = serio_get_drvdata(serio);
+	priv = psmouse->private;
+
+	if (val == priv->powered)
+		goto done;
+
+	retval = hgpk_toggle_power(psmouse, val);
+	if (!retval)
+		priv->powered = val;
+
+done:
+	serio_unpin_driver(serio);
+	return retval ? retval : count;
+}
+
+static DEVICE_ATTR(powered, S_IWUSR | S_IRUGO, hgpk_show_powered,
+		hgpk_set_powered);
+
+static void hgpk_disconnect(struct psmouse *psmouse)
+{
+	struct hgpk_data *priv = psmouse->private;
+	
+	device_remove_file(&psmouse->ps2dev.serio->dev, &dev_attr_powered);
+	psmouse_reset(psmouse);
+	flush_scheduled_work();
+	input_unregister_device(priv->gs);
+	kfree(priv);
+}
+
+static void hgpk_mode_switch(struct work_struct *work)
+{
+	struct delayed_work *w = container_of(work, struct delayed_work, work);
+	struct hgpk_data *priv = container_of(w, struct hgpk_data, switch_wq);
+	struct psmouse *psmouse = priv->psmouse;
+	struct ps2dev *ps2dev = &psmouse->ps2dev;
+	int pending_mode;
+
+	if (tpdebug)
+		hgpk_dbg(psmouse, "Starting mode switch to 0x%x. [%lu]\n",
+				priv->pending_mode, jiffies);
+
+	if (priv->pending_mode == priv->current_mode) {
+		priv->pending_mode = 0;
+		hgpk_dbg(psmouse, "Already in target mode, no-op.\n");
+		return;
+	}
+
+	/* tell the irq handler to ignore any further packets */
+	psmouse_set_state(psmouse, PSMOUSE_INITIALIZING);
+	priv->late = 0;
+
+	if (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))
+		goto bad;
+
+	/*
+	 * ALPS tells us that it may take up to 20msec for the disable to
+	 * take effect; however, ps2_command() will wait up to 200msec for
+	 * the ACK to come back (and I'm assuming that by the time the
+	 * hardware sends back its ACK, it has stopped sending bytes).
+	 */
+	pending_mode = priv->pending_mode;
+
+	if (hgpk_new_mode(psmouse, priv->pending_mode))
+		goto bad;
+
+	/*
+	 * Deal with a potential race condition.
+	 *
+	 * If there is a brief tap of a stylus or a fingernail that
+	 * triggers a mode switch to PT mode, and the stylus/fingernail is
+	 * lifted after the DISABLE above, but before we reenable in the
+	 * new mode then we can get stuck in PT mode.
+	 */
+	if (pending_mode == HGPK_PT) {
+		priv->pending_mode = HGPK_GS;
+		queue_delayed_work(kpsmoused_wq, &priv->switch_wq,
+				msecs_to_jiffies(50));
+	}
+
+	return;
+bad:
+	hgpk_warn(psmouse, "Failure to switch modes, resetting device...\n");
+	hgpk_reconnect(psmouse);
+}
+
+static void hgpk_recalib_work(struct work_struct *work)
+{
+	struct delayed_work *w = container_of(work, struct delayed_work, work);
+	struct hgpk_data *priv = container_of(w, struct hgpk_data, recalib_wq);
+	struct psmouse *psmouse = priv->psmouse;
+
+	if (tpdebug)
+		hgpk_dbg(psmouse, "Recalibrating touchpad..\n");
+
+	if (hgpk_force_recalibrate(psmouse))
+		hgpk_err(psmouse, "Recalibration failed!\n");
+}
+
+int olpc_init(struct psmouse *psmouse)
+{
+	struct hgpk_data *priv;
+	struct input_dev *pt = psmouse->dev;
+	struct input_dev *gs;
+
+	priv = kzalloc(sizeof(struct hgpk_data), GFP_KERNEL);
+	gs = input_allocate_device();
+	if (!priv || !gs)
+		goto init_fail;
+
+	psmouse->private = priv;
+	priv->gs = gs;
+	priv->psmouse = psmouse;
+	priv->powered = 1;
+
+	psmouse_reset(psmouse);
+
+	if (hgpk_advanced_mode(psmouse)) {
+		hgpk_err(psmouse, "failed to enable advanced mode\n");
+		goto init_fail;
+	}
+
+	/* Unset things that psmouse-base sets that we don't have */
+	pt->evbit[0] &= ~BIT(EV_REL);
+	pt->keybit[LONG(BTN_MOUSE)] &= ~BIT(BTN_MIDDLE);
+	pt->relbit[0] &= ~(BIT(REL_X) | BIT(REL_Y));
+
+	/* Set all the things we *do* have */
+	set_bit(EV_KEY, pt->evbit);
+	set_bit(EV_ABS, pt->evbit);
+
+	set_bit(BTN_LEFT, pt->keybit);
+	set_bit(BTN_RIGHT, pt->keybit);
+	set_bit(BTN_TOUCH, pt->keybit);
+
+	input_set_abs_params(pt, ABS_X, 2, 1000, 0, 0);
+	input_set_abs_params(pt, ABS_Y, 0, 717, 0, 0);
+        input_set_abs_params(pt, ABS_PRESSURE, 0, 127, 0, 0);
+
+	snprintf(priv->phys, sizeof(priv->phys),
+		"%s/input1", psmouse->ps2dev.serio->phys);
+	gs->phys = priv->phys;
+	gs->name = "OLPC ALPS GlideSensor";
+	gs->id.bustype = BUS_I8042;
+	gs->id.vendor  = 0x0002;
+	gs->id.product = PSMOUSE_OLPC;
+	gs->id.version = psmouse->model;
+
+	set_bit(EV_KEY, gs->evbit);
+	set_bit(EV_ABS, gs->evbit);
+
+	set_bit(BTN_LEFT, gs->keybit);
+	set_bit(BTN_RIGHT, gs->keybit);
+	set_bit(BTN_TOUCH, gs->keybit);
+
+	input_set_abs_params(gs, ABS_X, 350, 512, 0, 0);
+	input_set_abs_params(gs, ABS_Y, 70, 325, 0, 0);
+	input_set_abs_params(gs, ABS_PRESSURE, 0, 15, 0, 0);
+
+	if (input_register_device(gs)) {
+		hgpk_err(psmouse, "Failed to register GlideSensor\n");
+		goto init_fail;
+	}
+
+	psmouse->protocol_handler = hgpk_process_byte;
+	psmouse->poll = hgpk_poll;
+	psmouse->disconnect = hgpk_disconnect;
+	psmouse->reconnect = hgpk_reconnect;
+	psmouse->pktsize = 6;
+
+	/* Disable the idle resync. */
+	psmouse->resync_time = 0;
+	/* Reset after a lot of bad bytes. */
+	psmouse->resetafter = 1024;
+
+	INIT_DELAYED_WORK(&priv->switch_wq, hgpk_mode_switch);
+	INIT_DELAYED_WORK(&priv->recalib_wq, hgpk_recalib_work);
+
+	if (device_create_file(&psmouse->ps2dev.serio->dev,
+			&dev_attr_powered)) {
+		hgpk_err(psmouse, "Failed to create sysfs attribute\n");
+		goto attr_fail;
+	}
+
+
+	return 0;
+
+attr_fail:
+	input_unregister_device(gs);
+	gs = NULL;
+init_fail:
+	input_free_device(gs);
+	kfree(priv);
+	return -1;
+}
+
+int olpc_detect(struct psmouse *psmouse, int set_properties)
+{
+	int version;
+
+	version = hgpk_get_model(psmouse);
+	if (version < 0)
+		return version;
+
+	if (set_properties) {
+		psmouse->vendor = "ALPS";
+		psmouse->name = "PenTablet";
+		psmouse->model = version;
+	}
+	return 0;
+}
diff -purN linux_2.6.24_org/drivers/input/mouse/olpc.h linux_2.6.24_olpc/drivers/input/mouse/olpc.h
--- linux_2.6.24_org/drivers/input/mouse/olpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/input/mouse/olpc.h	2008-02-15 18:59:14.000000000 +0000
@@ -0,0 +1,78 @@
+/*
+ * OLPC touchpad PS/2 mouse driver
+ *
+ * Copyright (c) 2006 One Laptop Per Child, inc.
+ *
+ * This driver is partly based on the ALPS driver.
+ * Copyright (c) 2003 Peter Osterlund <petero2@telia.com>
+ * Copyright (c) 2005 Vojtech Pavlik <vojtech@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef _OLPC_H
+#define _OLPC_H
+
+enum hgpk_model_t {
+	HGPK_MODEL_PreA = 0x0a, /* pre-B1s */
+	HGPK_MODEL_A = 0x14,    /* found on B1s, PT disabled in hardware */
+	HGPK_MODEL_B = 0x28,	/* B2s, has capacitance issues */
+	HGPK_MODEL_C = 0x3c,
+	HGPK_MODEL_D = 0x50,    /* C1, mass production */
+};
+
+#define HGPK_GS		0xff       /* The GlideSensor */
+#define HGPK_PT		0xcf       /* The PenTablet */
+
+struct hgpk_packet {
+	struct input_dev *dev;
+	int x, y, z;
+	unsigned char mode_switch;
+	unsigned int pt_down:1, gs_down:1;
+	unsigned int left:1, right:1;
+};
+
+struct hgpk_data {
+	struct input_dev *gs;		/* GlideSensor */
+	struct psmouse *psmouse;
+	char name[32];			/* Name */
+	char phys[32];			/* Phys */
+	int pending_mode;
+	int current_mode;
+	s64 late;
+	int axis_errors;
+	int repeat_pkts;
+	int powered;
+	unsigned long recalib_window;
+	struct delayed_work switch_wq;
+	struct delayed_work recalib_wq;
+};
+
+#define hgpk_dbg(psmouse, format, arg...)		\
+	dev_dbg(&(psmouse)->ps2dev.serio->dev, format, ## arg)
+#define hgpk_err(psmouse, format, arg...)		\
+	dev_err(&(psmouse)->ps2dev.serio->dev, format, ## arg)
+#define hgpk_info(psmouse, format, arg...)		\
+	dev_info(&(psmouse)->ps2dev.serio->dev, format, ## arg)
+#define hgpk_warn(psmouse, format, arg...)		\
+	dev_warn(&(psmouse)->ps2dev.serio->dev, format, ## arg)
+#define hgpk_notice(psmouse, format, arg...)		\
+	dev_notice(&(psmouse)->ps2dev.serio->dev, format, ## arg)
+
+#ifdef CONFIG_MOUSE_PS2_OLPC
+int olpc_detect(struct psmouse *psmouse, int set_properties);
+int olpc_init(struct psmouse *psmouse);
+#else
+inline int olpc_detect(struct psmouse *psmouse, int set_properties)
+{
+	return -ENOSYS;
+}
+inline int olpc_init(struct psmouse *psmouse)
+{
+	return -ENOSYS;
+}
+#endif
+
+#endif
diff -purN linux_2.6.24_org/drivers/input/mouse/psmouse-base.c linux_2.6.24_olpc/drivers/input/mouse/psmouse-base.c
--- linux_2.6.24_org/drivers/input/mouse/psmouse-base.c	2008-02-15 20:11:51.000000000 +0000
+++ linux_2.6.24_olpc/drivers/input/mouse/psmouse-base.c	2008-02-15 18:59:14.000000000 +0000
@@ -26,6 +26,7 @@
 #include "synaptics.h"
 #include "logips2pp.h"
 #include "alps.h"
+#include "olpc.h"
 #include "lifebook.h"
 #include "trackpoint.h"
 #include "touchkit_ps2.h"
@@ -103,7 +104,7 @@ static struct attribute_group psmouse_at
  */
 static DEFINE_MUTEX(psmouse_mutex);
 
-static struct workqueue_struct *kpsmoused_wq;
+struct workqueue_struct *kpsmoused_wq;
 
 struct psmouse_protocol {
 	enum psmouse_type type;
@@ -221,7 +222,7 @@ static inline void __psmouse_set_state(s
  * is not a concern.
  */
 
-static void psmouse_set_state(struct psmouse *psmouse, enum psmouse_state new_state)
+void psmouse_set_state(struct psmouse *psmouse, enum psmouse_state new_state)
 {
 	serio_pause_rx(psmouse->ps2dev.serio);
 	__psmouse_set_state(psmouse, new_state);
@@ -320,7 +321,7 @@ static irqreturn_t psmouse_interrupt(str
 			goto out;
 		}
 
-		if (psmouse->packet[1] == PSMOUSE_RET_ID) {
+		if (psmouse->packet[1] == PSMOUSE_RET_ID || psmouse->packet[1] == PSMOUSE_RET_BAT) {
 			__psmouse_set_state(psmouse, PSMOUSE_IGNORE);
 			serio_reconnect(serio);
 			goto out;
@@ -631,8 +632,21 @@ static int psmouse_extensions(struct psm
 		}
 	}
 
+/*
+ * Try OLPC touchpad.
+ */
 	if (max_proto > PSMOUSE_IMEX) {
+		if (olpc_detect(psmouse, set_properties) == 0) {
+			if (!set_properties || olpc_init(psmouse) == 0)
+				return PSMOUSE_OLPC;
+/*
+ * Init failed, try basic relative protocols
+ */
+			max_proto = PSMOUSE_IMEX;
+		}
+	}
 
+	if (max_proto > PSMOUSE_IMEX) {
 		if (genius_detect(psmouse, set_properties) == 0)
 			return PSMOUSE_GENPS;
 
@@ -763,6 +777,14 @@ static const struct psmouse_protocol psm
 		.detect		= touchkit_ps2_detect,
 	},
 #endif
+#ifdef CONFIG_MOUSE_PS2_OLPC
+	{
+		.type		= PSMOUSE_OLPC,
+		.name		= "OLPC",
+		.alias		= "olpc",
+		.detect		= olpc_detect,
+	},
+#endif
 	{
 		.type		= PSMOUSE_CORTRON,
 		.name		= "CortronPS/2",
diff -purN linux_2.6.24_org/drivers/input/mouse/psmouse.h linux_2.6.24_olpc/drivers/input/mouse/psmouse.h
--- linux_2.6.24_org/drivers/input/mouse/psmouse.h	2008-02-15 20:11:51.000000000 +0000
+++ linux_2.6.24_olpc/drivers/input/mouse/psmouse.h	2008-02-15 18:59:14.000000000 +0000
@@ -88,6 +88,7 @@ enum psmouse_type {
 	PSMOUSE_LIFEBOOK,
 	PSMOUSE_TRACKPOINT,
 	PSMOUSE_TOUCHKIT_PS2,
+	PSMOUSE_OLPC,
 	PSMOUSE_CORTRON,
 	PSMOUSE_AUTO		/* This one should always be last */
 };
@@ -95,7 +96,9 @@ enum psmouse_type {
 int psmouse_sliced_command(struct psmouse *psmouse, unsigned char command);
 int psmouse_reset(struct psmouse *psmouse);
 void psmouse_set_resolution(struct psmouse *psmouse, unsigned int resolution);
+void psmouse_set_state(struct psmouse *psmouse, enum psmouse_state new_state);
 
+extern struct workqueue_struct *kpsmoused_wq;
 
 struct psmouse_attribute {
 	struct device_attribute dattr;
diff -purN linux_2.6.24_org/drivers/input/serio/i8042.c linux_2.6.24_olpc/drivers/input/serio/i8042.c
--- linux_2.6.24_org/drivers/input/serio/i8042.c	2008-02-15 20:11:51.000000000 +0000
+++ linux_2.6.24_olpc/drivers/input/serio/i8042.c	2008-02-15 18:59:14.000000000 +0000
@@ -874,6 +874,11 @@ static long i8042_panic_blink(long count
 #undef DELAY
 
 #ifdef CONFIG_PM
+
+#ifdef CONFIG_OLPC
+#include <asm/olpc.h>
+#endif
+
 /*
  * Here we try to restore the original BIOS settings. We only want to
  * do that once, when we really suspend, not when we taking memory
@@ -884,8 +889,15 @@ static long i8042_panic_blink(long count
 static int i8042_suspend(struct platform_device *dev, pm_message_t state)
 {
 	if (dev->dev.power.power_state.event != state.event) {
+#ifdef CONFIG_OLPC
+		/* Anything newer than B2 remains powered; no reset needed */
+		if (!olpc_board_at_least(olpc_board_pre(0xb3))) {
+#endif
 		if (state.event == PM_EVENT_SUSPEND)
 			i8042_controller_reset();
+#ifdef CONFIG_OLPC
+		}
+#endif
 
 		dev->dev.power.power_state = state;
 	}
@@ -908,9 +920,15 @@ static int i8042_resume(struct platform_
 	if (dev->dev.power.power_state.event == PM_EVENT_ON)
 		return 0;
 
+#ifdef CONFIG_OLPC
+	if (!olpc_board_at_least(olpc_board_pre(0xb3))) {
+#endif
 	error = i8042_controller_check();
 	if (error)
 		return error;
+#ifdef CONFIG_OLPC
+	}
+#endif
 
 	error = i8042_controller_selftest();
 	if (error)
diff -purN linux_2.6.24_org/drivers/input/serio/serio.c linux_2.6.24_olpc/drivers/input/serio/serio.c
--- linux_2.6.24_org/drivers/input/serio/serio.c	2008-02-15 20:11:51.000000000 +0000
+++ linux_2.6.24_olpc/drivers/input/serio/serio.c	2008-02-15 18:59:14.000000000 +0000
@@ -910,11 +910,22 @@ static int serio_uevent(struct device *d
 #endif /* CONFIG_HOTPLUG */
 
 #ifdef CONFIG_PM
+
+#ifdef CONFIG_OLPC
+#include <asm/olpc.h>
+#endif
+
 static int serio_suspend(struct device *dev, pm_message_t state)
 {
 	if (dev->power.power_state.event != state.event) {
+#ifdef CONFIG_OLPC
+		if (!olpc_board_at_least(olpc_board_pre(0xb3))) {
+#endif
 		if (state.event == PM_EVENT_SUSPEND)
 			serio_cleanup(to_serio_port(dev));
+#ifdef CONFIG_OLPC
+		}
+#endif
 
 		dev->power.power_state = state;
 	}
diff -purN linux_2.6.24_org/drivers/Kconfig linux_2.6.24_olpc/drivers/Kconfig
--- linux_2.6.24_org/drivers/Kconfig	2008-02-15 20:11:21.000000000 +0000
+++ linux_2.6.24_olpc/drivers/Kconfig	2008-02-15 18:58:34.000000000 +0000
@@ -94,6 +94,8 @@ source "drivers/auxdisplay/Kconfig"
 
 source "drivers/kvm/Kconfig"
 
+source "drivers/sysprof/Kconfig"
+
 source "drivers/uio/Kconfig"
 
 source "drivers/virtio/Kconfig"
diff -purN linux_2.6.24_org/drivers/Makefile linux_2.6.24_olpc/drivers/Makefile
--- linux_2.6.24_org/drivers/Makefile	2008-02-15 20:11:24.000000000 +0000
+++ linux_2.6.24_olpc/drivers/Makefile	2008-02-15 18:58:43.000000000 +0000
@@ -23,6 +23,8 @@ obj-y				+= char/
 
 obj-$(CONFIG_CONNECTOR)		+= connector/
 
+obj-$(CONFIG_SYSPROF)		+= sysprof/
+
 # i810fb and intelfb depend on char/agp/
 obj-$(CONFIG_FB_I810)           += video/i810/
 obj-$(CONFIG_FB_INTEL)          += video/intelfb/
diff -purN linux_2.6.24_org/drivers/media/video/cafe_ccic.c linux_2.6.24_olpc/drivers/media/video/cafe_ccic.c
--- linux_2.6.24_org/drivers/media/video/cafe_ccic.c	2008-02-15 20:11:25.000000000 +0000
+++ linux_2.6.24_olpc/drivers/media/video/cafe_ccic.c	2008-02-15 18:58:44.000000000 +0000
@@ -372,6 +372,10 @@ static int cafe_smbus_write_data(struct 
 	rval = value | ((command << TWSIC1_ADDR_SHIFT) & TWSIC1_ADDR);
 	cafe_reg_write(cam, REG_TWSIC1, rval);
 	spin_unlock_irqrestore(&cam->dev_lock, flags);
+	mdelay(2); /* It'll probably take about 900µs anyway, and the
+		      CAFÉ is apparently quite sensitive to being poked
+		      at this point. If we can work out precisely what's
+		      going on and reduce this delay, it would be nice. */
 
 	/*
 	 * Time to wait for the write to complete.  THIS IS A RACY
@@ -907,8 +911,6 @@ static int cafe_cam_configure(struct caf
 	struct v4l2_format fmt;
 	int ret, zero = 0;
 
-	if (cam->state != S_IDLE)
-		return -EINVAL;
 	fmt.fmt.pix = cam->pix_format;
 	ret = __cafe_cam_cmd(cam, VIDIOC_INT_INIT, &zero);
 	if (ret == 0)
@@ -2237,14 +2239,18 @@ static int cafe_pci_suspend(struct pci_d
 	int ret;
 	enum cafe_state cstate;
 
+	mutex_lock(&cam->s_mutex);
 	ret = pci_save_state(pdev);
-	if (ret)
+	if (ret) {
+		cam_warn(cam, "Unable to save PCI state\n");
 		return ret;
+	}
 	cstate = cam->state; /* HACK - stop_dma sets to idle */
 	cafe_ctlr_stop_dma(cam);
 	cafe_ctlr_power_down(cam);
 	pci_disable_device(pdev);
 	cam->state = cstate;
+	/* hold mutex until restore */
 	return 0;
 }
 
@@ -2263,16 +2269,18 @@ static int cafe_pci_resume(struct pci_de
 		cam_warn(cam, "Unable to re-enable device on resume!\n");
 		return ret;
 	}
+	/* we're still holding mutex from suspend */
 	cafe_ctlr_init(cam);
 	cafe_ctlr_power_down(cam);
 
-	mutex_lock(&cam->s_mutex);
-	if (cam->users > 0) {
-		cafe_ctlr_power_up(cam);
-		__cafe_cam_reset(cam);
-	}
-	mutex_unlock(&cam->s_mutex);
-
+ 	if (cam->users > 0) {
+ 		cafe_ctlr_power_up(cam);
+ 		__cafe_cam_reset(cam);
+ 	}
+	else
+		cafe_ctlr_power_down(cam);
+ 	mutex_unlock(&cam->s_mutex);
+ 
 	set_bit(CF_CONFIG_NEEDED, &cam->flags);
 	if (cam->state == S_SPECREAD)
 		cam->state = S_IDLE;  /* Don't bother restarting */
diff -purN linux_2.6.24_org/drivers/misc/Kconfig linux_2.6.24_olpc/drivers/misc/Kconfig
--- linux_2.6.24_org/drivers/misc/Kconfig	2008-02-15 20:11:42.000000000 +0000
+++ linux_2.6.24_olpc/drivers/misc/Kconfig	2008-02-15 18:58:52.000000000 +0000
@@ -219,6 +219,11 @@ config THINKPAD_ACPI_BAY
 
 	  If you are not sure, say Y here.
 
+config EEPROM_93CX6
+	tristate "EEPROM 93CX6 support"
+	---help---
+	  This is a driver for the EEPROM chipsets 93c46 and 93c66.
+	  The driver supports both read as well as write commands.
 
 config ATMEL_SSC
 	tristate "Device driver for Atmel SSC peripheral"
diff -purN linux_2.6.24_org/drivers/mmc/card/block.c linux_2.6.24_olpc/drivers/mmc/card/block.c
--- linux_2.6.24_org/drivers/mmc/card/block.c	2008-02-15 20:11:13.000000000 +0000
+++ linux_2.6.24_olpc/drivers/mmc/card/block.c	2008-02-15 18:58:17.000000000 +0000
@@ -237,6 +237,13 @@ static int mmc_blk_issue_rq(struct mmc_q
 		if (brq.data.blocks > card->host->max_blk_count)
 			brq.data.blocks = card->host->max_blk_count;
 
+		if (mmc_card_sd(card) && !card->host->ios.clock) {
+			printk(KERN_ERR "%s: I/O to stopped card\n",
+			       req->rq_disk->disk_name);
+			goto cmd_err;
+		}
+		mmc_set_data_timeout(&brq.data, card);
+
 		/*
 		 * If the host doesn't support multiple block writes, force
 		 * block writes to single block. SD cards are excepted from
diff -purN linux_2.6.24_org/drivers/mmc/host/sdhci.c linux_2.6.24_olpc/drivers/mmc/host/sdhci.c
--- linux_2.6.24_org/drivers/mmc/host/sdhci.c	2008-02-15 20:11:13.000000000 +0000
+++ linux_2.6.24_olpc/drivers/mmc/host/sdhci.c	2008-02-15 18:58:17.000000000 +0000
@@ -441,6 +441,12 @@ static void sdhci_prepare_data(struct sd
 			break;
 	}
 
+	/*
+	 * There's an off-by-one error in the hw that we need to
+	 * compensate for.
+	 */
+	count++;
+
 	if (count >= 0xF) {
 		printk(KERN_WARNING "%s: Too large timeout requested!\n",
 			mmc_hostname(host->mmc));
@@ -728,19 +734,17 @@ static void sdhci_set_power(struct sdhci
 	if (!(host->chip->quirks & SDHCI_QUIRK_SINGLE_POWER_WRITE))
 		writeb(0, host->ioaddr + SDHCI_POWER_CONTROL);
 
-	pwr = SDHCI_POWER_ON;
-
 	switch (1 << power) {
 	case MMC_VDD_165_195:
-		pwr |= SDHCI_POWER_180;
+		pwr = SDHCI_POWER_180;
 		break;
 	case MMC_VDD_29_30:
 	case MMC_VDD_30_31:
-		pwr |= SDHCI_POWER_300;
+		pwr = SDHCI_POWER_300;
 		break;
 	case MMC_VDD_32_33:
 	case MMC_VDD_33_34:
-		pwr |= SDHCI_POWER_330;
+		pwr = SDHCI_POWER_330;
 		break;
 	default:
 		BUG();
@@ -748,6 +752,10 @@ static void sdhci_set_power(struct sdhci
 
 	writeb(pwr, host->ioaddr + SDHCI_POWER_CONTROL);
 
+	pwr |= SDHCI_POWER_ON;
+
+	writeb(pwr, host->ioaddr + SDHCI_POWER_CONTROL);
+
 out:
 	host->power = power;
 }
diff -purN linux_2.6.24_org/drivers/mtd/nand/cafe_nand.c linux_2.6.24_olpc/drivers/mtd/nand/cafe_nand.c
--- linux_2.6.24_org/drivers/mtd/nand/cafe_nand.c	2008-02-15 20:11:46.000000000 +0000
+++ linux_2.6.24_olpc/drivers/mtd/nand/cafe_nand.c	2008-02-15 18:58:57.000000000 +0000
@@ -11,6 +11,7 @@
 #undef DEBUG
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
 #include <linux/rslib.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
@@ -52,6 +53,7 @@
 
 struct cafe_priv {
 	struct nand_chip nand;
+	struct mtd_partition *parts;
 	struct pci_dev *pdev;
 	void __iomem *mmio;
 	struct rs_control *rs;
@@ -84,6 +86,10 @@ static unsigned int numtimings;
 static int timing[3];
 module_param_array(timing, int, &numtimings, 0644);
 
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probes[] = { "RedBoot", NULL };
+#endif
+
 /* Hrm. Why isn't this already conditional on something in the struct device? */
 #define cafe_dev_dbg(dev, args...) do { if (debug) dev_dbg(dev, ##args); } while(0)
 
@@ -620,7 +626,9 @@ static int __devinit cafe_nand_probe(str
 {
 	struct mtd_info *mtd;
 	struct cafe_priv *cafe;
+	struct mtd_partition *parts;
 	uint32_t ctrl;
+	int nr_parts;
 	int err = 0;
 
 	/* Very old versions shared the same PCI ident for all three
@@ -787,7 +795,18 @@ static int __devinit cafe_nand_probe(str
 		goto out_irq;
 
 	pci_set_drvdata(pdev, mtd);
+
+	/* We register the whole device first, separate from the partitions */
 	add_mtd_device(mtd);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	nr_parts = parse_mtd_partitions(mtd, part_probes, &parts, 0);
+	if (nr_parts > 0) {
+		cafe->parts = parts;
+		dev_info(&cafe->pdev->dev, "%d RedBoot partitions found\n", nr_parts);
+		add_mtd_partitions(mtd, parts, nr_parts);
+	}
+#endif
 	goto out;
 
  out_irq:
diff -purN linux_2.6.24_org/drivers/mtd/redboot.c linux_2.6.24_olpc/drivers/mtd/redboot.c
--- linux_2.6.24_org/drivers/mtd/redboot.c	2008-02-15 20:11:46.000000000 +0000
+++ linux_2.6.24_olpc/drivers/mtd/redboot.c	2008-02-15 18:58:58.000000000 +0000
@@ -59,16 +59,31 @@ static int parse_redboot_partitions(stru
 	static char nullstring[] = "unallocated";
 #endif
 
+	if ( directory < 0 ) {
+		offset = master->size + directory * master->erasesize;
+		while (master->block_isbad && 
+		       master->block_isbad(master, offset)) {
+			if (!offset) {
+			nogood:
+				printk(KERN_NOTICE "Failed to find a non-bad block to check for RedBoot partition table\n");
+				return -EIO;
+			}
+			offset -= master->erasesize;
+		}
+	} else {
+		offset = directory * master->erasesize;
+		while (master->block_isbad && 
+		       master->block_isbad(master, offset)) {
+			offset += master->erasesize;
+			if (offset == master->size)
+				goto nogood;
+		}
+	}
 	buf = vmalloc(master->erasesize);
 
 	if (!buf)
 		return -ENOMEM;
 
-	if ( directory < 0 )
-		offset = master->size + directory*master->erasesize;
-	else
-		offset = directory*master->erasesize;
-
 	printk(KERN_NOTICE "Searching for RedBoot partition table in %s at offset 0x%lx\n",
 	       master->name, offset);
 
diff -purN linux_2.6.24_org/drivers/net/forcedeth.c linux_2.6.24_olpc/drivers/net/forcedeth.c
--- linux_2.6.24_org/drivers/net/forcedeth.c	2008-02-15 20:11:19.000000000 +0000
+++ linux_2.6.24_olpc/drivers/net/forcedeth.c	2008-02-15 18:58:33.000000000 +0000
@@ -3559,11 +3559,13 @@ static int nv_request_irq(struct net_dev
 	}
 	if (ret != 0 && np->msi_flags & NV_MSI_CAPABLE) {
 		if ((ret = pci_enable_msi(np->pci_dev)) == 0) {
+			pci_intx(np->pci_dev, 0);
 			np->msi_flags |= NV_MSI_ENABLED;
 			dev->irq = np->pci_dev->irq;
 			if (request_irq(np->pci_dev->irq, handler, IRQF_SHARED, dev->name, dev) != 0) {
 				printk(KERN_INFO "forcedeth: request_irq failed %d\n", ret);
 				pci_disable_msi(np->pci_dev);
+				pci_intx(np->pci_dev, 1);
 				np->msi_flags &= ~NV_MSI_ENABLED;
 				dev->irq = np->pci_dev->irq;
 				goto out_err;
@@ -3606,6 +3608,7 @@ static void nv_free_irq(struct net_devic
 		free_irq(np->pci_dev->irq, dev);
 		if (np->msi_flags & NV_MSI_ENABLED) {
 			pci_disable_msi(np->pci_dev);
+			pci_intx(np->pci_dev, 1);
 			np->msi_flags &= ~NV_MSI_ENABLED;
 		}
 	}
diff -purN linux_2.6.24_org/drivers/pci/quirks.c linux_2.6.24_olpc/drivers/pci/quirks.c
--- linux_2.6.24_org/drivers/pci/quirks.c	2008-02-15 20:11:33.000000000 +0000
+++ linux_2.6.24_olpc/drivers/pci/quirks.c	2008-02-15 18:58:50.000000000 +0000
@@ -1359,6 +1359,17 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260b, quirk_intel_pcie_pm);
 
 /*
+ * According to Tom Sylla, the Geode does not support PCI power management
+ * transition, so we shouldn't need the D3hot delay.
+ */
+static void __init quirk_geode_pci_pm(struct pci_dev *dev)
+{
+	pci_pm_d3_delay = 0;
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5530_LEGACY, quirk_geode_pci_pm);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_ISA, quirk_geode_pci_pm);
+
+/*
  * Toshiba TC86C001 IDE controller reports the standard 8-byte BAR0 size
  * but the PIO transfers won't work if BAR0 falls at the odd 8 bytes.
  * Re-allocate the region if needed...
diff -purN linux_2.6.24_org/drivers/power/ds2760_battery.c linux_2.6.24_olpc/drivers/power/ds2760_battery.c
--- linux_2.6.24_org/drivers/power/ds2760_battery.c	2008-02-15 20:11:45.000000000 +0000
+++ linux_2.6.24_olpc/drivers/power/ds2760_battery.c	2008-02-15 18:58:56.000000000 +0000
@@ -409,6 +409,7 @@ static int ds2760_battery_suspend(struct
 	struct ds2760_device_info *di = platform_get_drvdata(pdev);
 
 	di->charge_status = POWER_SUPPLY_STATUS_UNKNOWN;
+	power_supply_changed(&di->bat);
 
 	return 0;
 }
diff -purN linux_2.6.24_org/drivers/power/olpc_battery.c linux_2.6.24_olpc/drivers/power/olpc_battery.c
--- linux_2.6.24_org/drivers/power/olpc_battery.c	2008-02-15 20:11:45.000000000 +0000
+++ linux_2.6.24_olpc/drivers/power/olpc_battery.c	2008-02-15 18:58:56.000000000 +0000
@@ -14,12 +14,13 @@
 #include <linux/power_supply.h>
 #include <linux/jiffies.h>
 #include <linux/sched.h>
+#include <asm/io.h>
 #include <asm/olpc.h>
 
 
 #define EC_BAT_VOLTAGE	0x10	/* uint16_t,	*9.76/32,    mV   */
 #define EC_BAT_CURRENT	0x11	/* int16_t,	*15.625/120, mA   */
-#define EC_BAT_ACR	0x12
+#define EC_BAT_ACR	0x12	/* int16_t	*416.667    µAh  */
 #define EC_BAT_TEMP	0x13	/* uint16_t,	*100/256,   °C  */
 #define EC_AMB_TEMP	0x14	/* uint16_t,	*100/256,   °C  */
 #define EC_BAT_STATUS	0x15	/* uint8_t,	bitmask */
@@ -84,6 +85,8 @@ static struct power_supply olpc_ac = {
 	.get_property = olpc_ac_get_prop,
 };
 
+static char bat_serial[17]; /* Ick */
+
 /*********************************************************************
  *		Battery properties
  *********************************************************************/
@@ -94,6 +97,7 @@ static int olpc_bat_get_property(struct 
 	int ret = 0;
 	int16_t ec_word;
 	uint8_t ec_byte;
+	uint64_t ser_buf;
 
 	ret = olpc_ec_cmd(EC_BAT_STATUS, NULL, 0, &ec_byte, 1);
 	if (ret)
@@ -127,8 +131,8 @@ static int olpc_bat_get_property(struct 
 				val->intval = POWER_SUPPLY_STATUS_FULL;
 			else /* Not _necessarily_ true but EC doesn't tell all yet */
 				val->intval = POWER_SUPPLY_STATUS_CHARGING;
-			break;
 		}
+		break;
 	case POWER_SUPPLY_PROP_PRESENT:
 		val->intval = !!(ec_byte & BAT_STAT_PRESENT);
 		break;
@@ -249,6 +253,22 @@ static int olpc_bat_get_property(struct 
 		ec_word = be16_to_cpu(ec_word);
 		val->intval = ec_word * 100 / 256;
 		break;
+	case POWER_SUPPLY_PROP_ACCUM_CURRENT:
+		ret = olpc_ec_cmd(EC_BAT_ACR, NULL, 0, (void *)&ec_word, 2);
+		if (ret)
+			return ret;
+
+		ec_word = be16_to_cpu(ec_word);
+		val->intval = (uint16_t)ec_word;
+		break;
+	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
+		ret = olpc_ec_cmd(EC_BAT_SERIAL, NULL, 0, (void *)&ser_buf, 8);
+		if (ret)
+			return ret;
+
+		sprintf(bat_serial, "%016llx", (long long)be64_to_cpu(ser_buf));
+		val->strval = bat_serial;
+		break;
 	default:
 		ret = -EINVAL;
 		break;
@@ -268,7 +288,51 @@ static enum power_supply_property olpc_b
 	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
 	POWER_SUPPLY_PROP_TEMP,
 	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+	POWER_SUPPLY_PROP_ACCUM_CURRENT,
 	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+};
+
+/* EEPROM reading goes completely around the power_supply API, sadly */
+
+#define EEPROM_START	0x20
+#define EEPROM_END	0x80
+#define EEPROM_SIZE	(EEPROM_END - EEPROM_START)
+
+static ssize_t olpc_bat_eeprom_read(struct kobject *kobj, char *buf, loff_t off,
+		size_t count)
+{
+	uint8_t ec_byte;
+	int ret, end;
+
+	if (off >= EEPROM_SIZE)
+		return 0;
+	if (off + count > EEPROM_SIZE)
+		count = EEPROM_SIZE - off;
+
+	end = EEPROM_START + off + count;
+	for (ec_byte = EEPROM_START + off; ec_byte < end; ec_byte++) {
+		ret = olpc_ec_cmd(EC_BAT_EEPROM, &ec_byte, 1,
+				&buf[ec_byte - EEPROM_START], 1);
+		if (ret) {
+			printk(KERN_ERR "olpc-battery:  EC command "
+					"EC_BAT_EEPROM @ 0x%x failed -"
+					" %d!\n", ec_byte, ret);
+			return -EIO;
+		}
+	}
+
+	return count;
+}
+
+static struct bin_attribute olpc_bat_eeprom = {
+	.attr = {
+		.name = "eeprom",
+		.mode = S_IRUGO, 
+		.owner = THIS_MODULE,
+	},
+	.size = 0,
+	.read = olpc_bat_eeprom_read,
 };
 
 /*********************************************************************
@@ -299,7 +363,7 @@ static int __init olpc_bat_init(void)
 
 	if (!olpc_platform_info.ecver)
 		return -ENXIO;
-	if (olpc_platform_info.ecver < 0x43) {
+	if (olpc_platform_info.ecver < 0x44) {
 		printk(KERN_NOTICE "OLPC EC version 0x%02x too old for battery driver.\n", olpc_platform_info.ecver);
 		return -ENXIO;
 	}
@@ -324,9 +388,15 @@ static int __init olpc_bat_init(void)
 	if (ret)
 		goto battery_failed;
 
+	ret = device_create_bin_file(olpc_bat.dev, &olpc_bat_eeprom);
+	if (ret)
+		goto eeprom_failed;
+
 	olpc_register_battery_callback(&olpc_battery_trigger_uevent);
 	goto success;
 
+eeprom_failed:
+	power_supply_unregister(&olpc_bat);
 battery_failed:
 	power_supply_unregister(&olpc_ac);
 ac_failed:
@@ -338,6 +408,7 @@ success:
 static void __exit olpc_bat_exit(void)
 {
 	olpc_deregister_battery_callback();
+	device_remove_bin_file(olpc_bat.dev, &olpc_bat_eeprom);
 	power_supply_unregister(&olpc_bat);
 	power_supply_unregister(&olpc_ac);
 	platform_device_unregister(bat_pdev);
diff -purN linux_2.6.24_org/drivers/power/power_supply_sysfs.c linux_2.6.24_olpc/drivers/power/power_supply_sysfs.c
--- linux_2.6.24_org/drivers/power/power_supply_sysfs.c	2008-02-15 20:11:45.000000000 +0000
+++ linux_2.6.24_olpc/drivers/power/power_supply_sysfs.c	2008-02-15 18:58:56.000000000 +0000
@@ -114,9 +114,11 @@ static struct device_attribute power_sup
 	POWER_SUPPLY_ATTR(time_to_empty_avg),
 	POWER_SUPPLY_ATTR(time_to_full_now),
 	POWER_SUPPLY_ATTR(time_to_full_avg),
+	POWER_SUPPLY_ATTR(accum_current),
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_ATTR(model_name),
 	POWER_SUPPLY_ATTR(manufacturer),
+	POWER_SUPPLY_ATTR(serial_number),
 };
 
 static ssize_t power_supply_show_static_attrs(struct device *dev,
diff -purN linux_2.6.24_org/drivers/serial/serial_core.c linux_2.6.24_olpc/drivers/serial/serial_core.c
--- linux_2.6.24_org/drivers/serial/serial_core.c	2008-02-15 20:11:33.000000000 +0000
+++ linux_2.6.24_olpc/drivers/serial/serial_core.c	2008-02-15 18:58:51.000000000 +0000
@@ -2013,6 +2013,7 @@ int uart_suspend_port(struct uart_driver
 int uart_resume_port(struct uart_driver *drv, struct uart_port *port)
 {
 	struct uart_state *state = drv->state + port->line;
+	struct ktermios termios;
 
 	mutex_lock(&state->mutex);
 
@@ -2035,20 +2036,6 @@ int uart_resume_port(struct uart_driver 
 	 * Re-enable the console device after suspending.
 	 */
 	if (uart_console(port)) {
-		struct ktermios termios;
-
-		/*
-		 * First try to use the console cflag setting.
-		 */
-		memset(&termios, 0, sizeof(struct ktermios));
-		termios.c_cflag = port->cons->cflag;
-
-		/*
-		 * If that's unset, use the tty termios setting.
-		 */
-		if (state->info && state->info->tty && termios.c_cflag == 0)
-			termios = *state->info->tty->termios;
-
 		port->ops->set_termios(port, &termios, NULL);
 		console_start(port->cons);
 	}
diff -purN linux_2.6.24_org/drivers/sysprof/config.h linux_2.6.24_olpc/drivers/sysprof/config.h
--- linux_2.6.24_org/drivers/sysprof/config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/sysprof/config.h	2008-02-15 18:58:59.000000000 +0000
@@ -0,0 +1,23 @@
+/* config.h.  Generated by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Look for global separate debug info in this path */
+#define DEBUGDIR "/usr/local/lib/debug"
+
+/* Define to 1 if you have the `iberty' library (-liberty). */
+/* #undef HAVE_LIBIBERTY */
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "sysprof"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "sysprof 1.0.8"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "sysprof"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.0.8"
diff -purN linux_2.6.24_org/drivers/sysprof/Kconfig linux_2.6.24_olpc/drivers/sysprof/Kconfig
--- linux_2.6.24_org/drivers/sysprof/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/sysprof/Kconfig	2008-02-15 18:58:59.000000000 +0000
@@ -0,0 +1,12 @@
+
+menu "Sysprof"
+
+config SYSPROF
+	tristate "Sysprof support"
+	help
+	 Say M here to include the sysprof-module.
+
+	 Sysprof is a sampling profiler that uses a kernel module,
+	 sysprof-module, to generate stacktraces which are then interpreted by
+	 the userspace program "sysprof".
+endmenu
diff -purN linux_2.6.24_org/drivers/sysprof/Makefile linux_2.6.24_olpc/drivers/sysprof/Makefile
--- linux_2.6.24_org/drivers/sysprof/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/sysprof/Makefile	2008-02-15 18:58:59.000000000 +0000
@@ -0,0 +1 @@
+obj-$(CONFIG_SYSPROF)	+= sysprof-module.o
diff -purN linux_2.6.24_org/drivers/sysprof/sysprof-module.c linux_2.6.24_olpc/drivers/sysprof/sysprof-module.c
--- linux_2.6.24_org/drivers/sysprof/sysprof-module.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/sysprof/sysprof-module.c	2008-02-15 18:58:59.000000000 +0000
@@ -0,0 +1,271 @@
+/* -*- c-basic-offset: 8 -*- */
+
+/* Sysprof -- Sampling, systemwide CPU profiler
+ * Copyright 2004, Red Hat, Inc.
+ * Copyright 2004, 2005, Soeren Sandmann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef CONFIG_SMP
+# define __SMP__
+#endif
+#include <asm/atomic.h>
+#include <linux/kernel.h>  /* Needed for KERN_ALERT */
+#include <linux/module.h>  /* Needed by all modules */
+#include <linux/sched.h>
+
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/poll.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <linux/profile.h>
+
+#include "sysprof-module.h"
+
+#include "config.h"
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#include <linux/config.h>
+#endif
+
+#if !CONFIG_PROFILING
+# error Sysprof needs a kernel with profiling support compiled in.
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+# error Sysprof needs a Linux 2.6.11 kernel or later
+#endif
+#include <linux/kallsyms.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Soeren Sandmann (sandmann@daimi.au.dk)");
+
+#define SAMPLES_PER_SECOND (200)
+#define INTERVAL ((HZ <= SAMPLES_PER_SECOND)? 1 : (HZ / SAMPLES_PER_SECOND))
+#define N_TRACES 256
+
+static SysprofStackTrace	stack_traces[N_TRACES];
+static SysprofStackTrace *	head = &stack_traces[0];
+static SysprofStackTrace *	tail = &stack_traces[0];
+DECLARE_WAIT_QUEUE_HEAD (wait_for_trace);
+DECLARE_WAIT_QUEUE_HEAD (wait_for_exit);
+
+/* Macro the names of the registers that are used on each architecture */
+#if defined(CONFIG_X86_64)
+# define REG_FRAME_PTR rbp
+# define REG_INS_PTR rip
+# define REG_STACK_PTR rsp
+#elif defined(CONFIG_X86)
+# define REG_FRAME_PTR ebp
+# define REG_INS_PTR eip
+# define REG_STACK_PTR esp
+#else
+# error Sysprof only supports the i386 and x86-64 architectures
+#endif
+
+typedef struct userspace_reader userspace_reader;
+struct userspace_reader
+{
+	struct task_struct *task;
+	unsigned long cache_address;
+	unsigned long *cache;
+};
+
+typedef struct StackFrame StackFrame;
+struct StackFrame {
+	unsigned long next;
+	unsigned long return_address;
+};
+
+struct work_struct work;
+
+static int
+read_frame (void *frame_pointer, StackFrame *frame)
+{
+#if 0
+	/* This is commented out because we seem to be called with
+	 * (current_thread_info()->addr_limit.seg)) == 0
+	 * which means access_ok() _always_ fails.
+	 *
+	 * Not sure why (or if) this isn't the case for oprofile
+	 */
+	if (!access_ok(VERIFY_READ, frame_pointer, sizeof(StackFrame)))
+		return 1;
+#endif
+
+	if (__copy_from_user_inatomic (
+		    frame, frame_pointer, sizeof (StackFrame)))
+		return 1;
+	
+	return 0;
+}
+
+DEFINE_PER_CPU(int, n_samples);
+
+static int
+timer_notify (struct pt_regs *regs)
+{
+	SysprofStackTrace *trace = head;
+	int i;
+	int is_user;
+	static atomic_t in_timer_notify = ATOMIC_INIT(1);
+	int n;
+
+	n = ++get_cpu_var(n_samples);
+	put_cpu_var(n_samples);
+
+	if (n % INTERVAL != 0)
+		return 0;
+
+	/* 0: locked, 1: unlocked */
+	
+	if (!atomic_dec_and_test(&in_timer_notify))
+		goto out;
+	
+	is_user = user_mode(regs);
+
+	if (!current || current->pid == 0)
+		goto out;
+	
+	if (is_user && current->state != TASK_RUNNING)
+		goto out;
+
+	if (!is_user)
+	{
+		/* kernel */
+		
+		trace->pid = current->pid;
+		trace->truncated = 0;
+		trace->n_addresses = 1;
+
+		/* 0x1 is taken by sysprof to mean "in kernel" */
+		trace->addresses[0] = (void *)0x1;
+	}
+	else
+	{
+		StackFrame *frame_pointer;
+		StackFrame frame;
+		memset(trace, 0, sizeof (SysprofStackTrace));
+		
+		trace->pid = current->pid;
+		trace->truncated = 0;
+
+		i = 0;
+		
+		trace->addresses[i++] = (void *)regs->REG_INS_PTR;
+		
+		frame_pointer = (void *)regs->REG_FRAME_PTR;
+	
+		while (read_frame (frame_pointer, &frame) == 0		&&
+		       i < SYSPROF_MAX_ADDRESSES			&&
+		       (unsigned long)frame_pointer >= regs->REG_STACK_PTR)
+		{
+			trace->addresses[i++] = (void *)frame.return_address;
+			frame_pointer = (StackFrame *)frame.next;
+		}
+		
+		trace->n_addresses = i;
+
+		if (i == SYSPROF_MAX_ADDRESSES)
+			trace->truncated = 1;
+		else
+			trace->truncated = 0;
+	}
+	
+	if (head++ == &stack_traces[N_TRACES - 1])
+		head = &stack_traces[0];
+	
+	wake_up (&wait_for_trace);
+
+out:
+	atomic_inc(&in_timer_notify);
+	return 0;
+}
+
+static int
+procfile_read(char *buffer, 
+	      char **buffer_location, 
+	      off_t offset, 
+	      int buffer_len,
+	      int *eof,
+	      void *data)
+{
+	if (head == tail)
+		return -EWOULDBLOCK;
+	
+	*buffer_location = (char *)tail;
+
+	BUG_ON(tail->pid == 0);
+	
+	if (tail++ == &stack_traces[N_TRACES - 1])
+		tail = &stack_traces[0];
+	
+	return sizeof (SysprofStackTrace);
+}
+
+struct proc_dir_entry *trace_proc_file;
+static unsigned int
+procfile_poll(struct file *filp, poll_table *poll_table)
+{
+	if (head != tail)
+		return POLLIN | POLLRDNORM;
+	
+	poll_wait(filp, &wait_for_trace, poll_table);
+
+	if (head != tail)
+		return POLLIN | POLLRDNORM;
+	
+	return 0;
+}
+
+int
+init_module(void)
+{
+	static struct file_operations fops;
+
+	trace_proc_file =
+		create_proc_entry ("sysprof-trace", S_IFREG | S_IRUGO, &proc_root);
+	
+	if (!trace_proc_file)
+		return 1;
+
+	fops = *trace_proc_file->proc_fops;
+	fops.poll = procfile_poll;
+	
+	trace_proc_file->read_proc = procfile_read;
+	trace_proc_file->proc_fops = &fops;
+	trace_proc_file->size = sizeof (SysprofStackTrace);
+
+	register_timer_hook (timer_notify);
+	
+	printk(KERN_ALERT "sysprof: loaded (%s)\n", PACKAGE_VERSION);
+	
+	return 0;
+}
+
+void
+cleanup_module(void)
+{
+	unregister_timer_hook (timer_notify);
+	
+	remove_proc_entry("sysprof-trace", &proc_root);
+
+	printk(KERN_ALERT "sysprof: unloaded\n");
+}
+
diff -purN linux_2.6.24_org/drivers/sysprof/sysprof-module.h linux_2.6.24_olpc/drivers/sysprof/sysprof-module.h
--- linux_2.6.24_org/drivers/sysprof/sysprof-module.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/sysprof/sysprof-module.h	2008-02-15 18:58:59.000000000 +0000
@@ -0,0 +1,37 @@
+/* Sysprof -- Sampling, systemwide CPU profiler
+ * Copyright 2004, Red Hat, Inc.
+ * Copyright 2004, 2005, Soeren Sandmann
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef SYSPROF_MODULE_H
+#define SYSPROF_MODULE_H
+
+typedef struct SysprofStackTrace SysprofStackTrace;
+
+#define SYSPROF_MAX_ADDRESSES 512
+
+struct SysprofStackTrace
+{
+    int	pid;		/* -1 if in kernel */
+    int truncated;
+    int n_addresses;	/* note: this can be 1 if the process was compiled
+			 * with -fomit-frame-pointer or is otherwise weird
+			 */
+    void *addresses[SYSPROF_MAX_ADDRESSES];
+};
+
+#endif
diff -purN linux_2.6.24_org/drivers/usb/core/driver.c linux_2.6.24_olpc/drivers/usb/core/driver.c
--- linux_2.6.24_org/drivers/usb/core/driver.c	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/core/driver.c	2008-02-15 18:58:14.000000000 +0000
@@ -1062,8 +1062,15 @@ static int usb_suspend_both(struct usb_d
 				break;
 		}
 	}
-	if (status == 0)
+	if (status == 0) {
+
+		/* Non-root devices don't need to do anything for FREEZE
+		 * or PRETHAW. */
+		if (udev->parent && (msg.event == PM_EVENT_FREEZE ||
+				msg.event == PM_EVENT_PRETHAW))
+			goto done;
 		status = usb_suspend_device(udev, msg);
+	}
 
 	/* If the suspend failed, resume interfaces that did get suspended */
 	if (status != 0) {
diff -purN linux_2.6.24_org/drivers/usb/core/quirks.c linux_2.6.24_olpc/drivers/usb/core/quirks.c
--- linux_2.6.24_org/drivers/usb/core/quirks.c	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/core/quirks.c	2008-02-15 18:58:12.000000000 +0000
@@ -45,6 +45,9 @@ static const struct usb_device_id usb_qu
 	/* SKYMEDI USB_DRIVE */
 	{ USB_DEVICE(0x1516, 0x8628), .driver_info = USB_QUIRK_RESET_RESUME },
 
+	/* Philips PSC805 audio device */
+	{ USB_DEVICE(0x0471, 0x0155), .driver_info = USB_QUIRK_RESET_RESUME },
+
 	{ }  /* terminating entry must be last */
 };
 
diff -purN linux_2.6.24_org/drivers/usb/core/usb.h linux_2.6.24_olpc/drivers/usb/core/usb.h
--- linux_2.6.24_org/drivers/usb/core/usb.h	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/core/usb.h	2008-02-15 18:58:14.000000000 +0000
@@ -41,6 +41,7 @@ extern void usb_host_cleanup(void);
 extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
+extern int usb_reset_suspended_device(struct usb_device *udev);
 extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
 extern int usb_external_resume_device(struct usb_device *udev);
diff -purN linux_2.6.24_org/drivers/usb/host/ehci-hcd.c linux_2.6.24_olpc/drivers/usb/host/ehci-hcd.c
--- linux_2.6.24_org/drivers/usb/host/ehci-hcd.c	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/host/ehci-hcd.c	2008-02-15 18:58:12.000000000 +0000
@@ -653,9 +653,16 @@ static irqreturn_t ehci_irq (struct usb_
 
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status & STS_IAA) {
-		COUNT (ehci->stats.reclaim);
-		ehci->reclaim_ready = 1;
-		bh = 1;
+		if (!ehci->reclaim) {
+			printk(KERN_WARNING "%s would set reclaim_ready with nothing to reclaim!\n", __func__);
+printk(KERN_DEBUG "%s: USBCMD: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->command));
+printk(KERN_DEBUG "%s: USBSTS: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->status));
+			WARN_ON(1);
+		} else {
+			COUNT (ehci->stats.reclaim);
+			ehci->reclaim_ready = 1;
+			bh = 1;
+		}
 	}
 
 	/* remote wakeup [4.3.1] */
diff -purN linux_2.6.24_org/drivers/usb/host/ehci-hub.c linux_2.6.24_olpc/drivers/usb/host/ehci-hub.c
--- linux_2.6.24_org/drivers/usb/host/ehci-hub.c	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/host/ehci-hub.c	2008-02-15 18:58:12.000000000 +0000
@@ -132,10 +132,15 @@ static int ehci_bus_suspend (struct usb_
 		ehci_quiesce (ehci);
 		hcd->state = HC_STATE_QUIESCING;
 	}
+printk(KERN_DEBUG "%s: USBCMD: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->command));
+printk(KERN_DEBUG "%s: USBSTS: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->status));
+
 	ehci->command = ehci_readl(ehci, &ehci->regs->command);
 	if (ehci->reclaim)
 		ehci->reclaim_ready = 1;
 	ehci_work(ehci);
+printk(KERN_DEBUG "%s: USBCMD: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->command));
+printk(KERN_DEBUG "%s: USBSTS: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->status));
 
 	/* Unlike other USB host controller types, EHCI doesn't have
 	 * any notion of "global" or bus-wide suspend.  The driver has
@@ -175,6 +180,9 @@ static int ehci_bus_suspend (struct usb_
 	ehci_halt (ehci);
 	hcd->state = HC_STATE_SUSPENDED;
 
+printk(KERN_DEBUG "%s: USBCMD: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->command));
+printk(KERN_DEBUG "%s: USBSTS: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->status));
+
 	/* allow remote wakeup */
 	mask = INTR_MASK;
 	if (!device_may_wakeup(&hcd->self.root_hub->dev))
@@ -195,6 +203,18 @@ static int ehci_bus_resume (struct usb_h
 	u32			temp;
 	u32			power_okay;
 	int			i;
+#ifdef CONFIG_OLPC
+	u32 lo;
+	static void __iomem *usb_ehc_addr;
+
+	rdmsrl(0x51200009, lo);
+	usb_ehc_addr = ioremap(lo, 256);
+	writel(readl(usb_ehc_addr+0x54) | 0x1000, usb_ehc_addr+0x54);
+	writel(readl(usb_ehc_addr+0x58) | 0x1000, usb_ehc_addr+0x58);
+	writel(readl(usb_ehc_addr+0x5C) | 0x1000, usb_ehc_addr+0x5C);
+	writel(readl(usb_ehc_addr+0x60) | 0x1000, usb_ehc_addr+0x60);
+	iounmap(usb_ehc_addr);
+#endif
 
 	if (time_before (jiffies, ehci->next_statechange))
 		msleep(5);
diff -purN linux_2.6.24_org/drivers/usb/host/ehci-pci.c linux_2.6.24_olpc/drivers/usb/host/ehci-pci.c
--- linux_2.6.24_org/drivers/usb/host/ehci-pci.c	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/host/ehci-pci.c	2008-02-15 18:58:12.000000000 +0000
@@ -247,6 +247,9 @@ static int ehci_pci_suspend(struct usb_h
 		rc = -EINVAL;
 		goto bail;
 	}
+printk(KERN_DEBUG "%s: USBCMD: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->command));
+printk(KERN_DEBUG "%s: USBSTS: 0x%x\n", __func__, ehci_readl(ehci, &ehci->regs->status));
+
 	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
 	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
 
diff -purN linux_2.6.24_org/drivers/usb/host/ehci-q.c linux_2.6.24_olpc/drivers/usb/host/ehci-q.c
--- linux_2.6.24_org/drivers/usb/host/ehci-q.c	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/host/ehci-q.c	2008-02-15 18:58:12.000000000 +0000
@@ -177,7 +177,7 @@ static int qtd_copy_status (
 			if (QTD_CERR (token))
 				status = -EPIPE;
 			else {
-				ehci_dbg (ehci, "devpath %s ep%d%s 3strikes\n",
+				printk(KERN_ERR "devpath %s ep%d%s 3strikes\n",
 					urb->dev->devpath,
 					usb_pipeendpoint (urb->pipe),
 					usb_pipein (urb->pipe) ? "in" : "out");
@@ -973,6 +973,11 @@ static void end_unlink_async (struct ehc
 	struct ehci_qh		*qh = ehci->reclaim;
 	struct ehci_qh		*next;
 
+	if (!qh) {
+		printk(KERN_CRIT "%s with ehci->reclaim == NULL!\n", __func__);
+		WARN_ON(1);
+		return;
+	}
 	timer_action_done (ehci, TIMER_IAA_WATCHDOG);
 
 	// qh->hw_next = cpu_to_hc32(qh->qh_dma);
diff -purN linux_2.6.24_org/drivers/usb/host/ohci-pci.c linux_2.6.24_olpc/drivers/usb/host/ohci-pci.c
--- linux_2.6.24_org/drivers/usb/host/ohci-pci.c	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/host/ohci-pci.c	2008-02-15 18:58:12.000000000 +0000
@@ -317,6 +317,8 @@ static int ohci_pci_resume (struct usb_h
 	/* FIXME: we should try to detect loss of VBUS power here */
 	prepare_for_handover(hcd);
 
+	/* Force the PM core to resume the root hub */
+	hcd_to_bus(hcd)->root_hub->dev.power.prev_state.event = PM_EVENT_ON;
 	return 0;
 }
 
diff -purN linux_2.6.24_org/drivers/usb/storage/usb.c linux_2.6.24_olpc/drivers/usb/storage/usb.c
--- linux_2.6.24_org/drivers/usb/storage/usb.c	2008-02-15 20:11:09.000000000 +0000
+++ linux_2.6.24_olpc/drivers/usb/storage/usb.c	2008-02-15 18:58:11.000000000 +0000
@@ -244,7 +244,7 @@ static int storage_pre_reset(struct usb_
 	return 0;
 }
 
-static int storage_post_reset(struct usb_interface *iface)
+static void storage_post_reset(struct usb_interface *iface, int reset_resume)
 {
 	struct us_data *us = usb_get_intfdata(iface);
 
@@ -256,8 +256,10 @@ static int storage_post_reset(struct usb
 	/* FIXME: Notify the subdrivers that they need to reinitialize
 	 * the device */
 
-	mutex_unlock(&us->dev_mutex);
-	return 0;
+	/* If this is a reset-resume then the pre_reset routine wasn't
+	 * called, so we don't need to unlock the mutex. */
+	if (!reset_resume)
+		mutex_unlock(&us->dev_mutex);
 }
 
 /*
diff -purN linux_2.6.24_org/drivers/video/fbmem.c linux_2.6.24_olpc/drivers/video/fbmem.c
--- linux_2.6.24_org/drivers/video/fbmem.c	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/fbmem.c	2008-02-15 18:58:42.000000000 +0000
@@ -820,6 +820,53 @@ static void try_to_load(int fb)
 #endif /* CONFIG_KMOD */
 
 int
+fb_powerup(struct fb_info *info)
+{
+	int ret = 0;
+
+	if (!info || info->state == FBINFO_STATE_RUNNING)
+		return 0;
+
+	if (info->fbops->fb_powerup)
+		ret = info->fbops->fb_powerup(info);
+
+	if (!ret) {
+		acquire_console_sem();
+		fb_set_suspend(info, 0);
+		release_console_sem();
+	}
+
+	return ret;
+}
+
+int
+fb_powerdown(struct fb_info *info)
+{
+	int ret = 0;
+
+	if (!info || info->state == FBINFO_STATE_SUSPENDED)
+		return 0;
+
+	/* Tell everybody that the fbdev is going down */
+	acquire_console_sem();
+	fb_set_suspend(info, 1);
+	release_console_sem();
+
+	if (info->fbops->fb_powerdown)
+		ret = info->fbops->fb_powerdown(info);
+
+	/* If the power down failed, then un-notify */
+
+	if (ret) {
+		acquire_console_sem();
+		fb_set_suspend(info, 0);
+		release_console_sem();
+	}
+
+	return ret;
+}
+
+int
 fb_pan_display(struct fb_info *info, struct fb_var_screeninfo *var)
 {
 	struct fb_fix_screeninfo *fix = &info->fix;
diff -purN linux_2.6.24_org/drivers/video/geode/display_gx.c linux_2.6.24_olpc/drivers/video/geode/display_gx.c
--- linux_2.6.24_org/drivers/video/geode/display_gx.c	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/display_gx.c	2008-02-15 18:58:41.000000000 +0000
@@ -11,26 +11,44 @@
  *   Free Software Foundation; either version 2 of the License, or * (at your
  *   option) any later version.
  */
+
+#include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <linux/fb.h>
 #include <linux/delay.h>
 #include <asm/io.h>
 #include <asm/div64.h>
 #include <asm/delay.h>
+#include <asm/olpc.h>
 
 #include "geodefb.h"
 #include "display_gx.h"
 
-#ifdef CONFIG_FB_GEODE_GX_SET_FBSIZE
-unsigned int gx_frame_buffer_size(void)
+static inline void rmwl(u32 val, u32 *reg)
 {
-	return CONFIG_FB_GEODE_GX_FBSIZE;
+	u32 in = readl(reg);
+	if (in != val)
+		writel(val, reg);
 }
-#else
+
 unsigned int gx_frame_buffer_size(void)
 {
 	unsigned int val;
 
+#ifdef CONFIG_OLPC
+	if (machine_is_olpc() && !olpc_has_vsa()) {
+		u32 hi,lo;	
+		rdmsr(GLIU0_P2D_RO0, lo, hi);
+
+		/* Top page number */
+		val = ((hi & 0xff) << 12) | ((lo & 0xfff00000) >> 20);  
+
+		val -= (lo & 0x000fffff); /* Subtract bottom page number */
+		val += 1;		  /* Adjust page count */
+		return (val << 12);
+	}
+#endif
+
 	/* FB size is reported by a virtual register */
 	/* Virtual register class = 0x02 */
 	/* VG_MEM_SIZE(512Kb units) = 0x00 */
@@ -41,7 +59,6 @@ unsigned int gx_frame_buffer_size(void)
 	val = (unsigned int)(inw(0xAC1E)) & 0xFFl;
 	return (val << 19);
 }
-#endif
 
 int gx_line_delta(int xres, int bpp)
 {
@@ -63,23 +80,23 @@ static void gx_set_mode(struct fb_info *
 	gcfg = readl(par->dc_regs + DC_GENERAL_CFG);
 	dcfg = readl(par->dc_regs + DC_DISPLAY_CFG);
 
-	/* Disable the timing generator. */
-	dcfg &= ~(DC_DCFG_TGEN);
-	writel(dcfg, par->dc_regs + DC_DISPLAY_CFG);
-
-	/* Wait for pending memory requests before disabling the FIFO load. */
-	udelay(100);
-
-	/* Disable FIFO load and compression. */
-	gcfg &= ~(DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);
-	writel(gcfg, par->dc_regs + DC_GENERAL_CFG);
-
-	/* Setup DCLK and its divisor. */
-	par->vid_ops->set_dclk(info);
-
-	/*
-	 * Setup new mode.
-	 */
+	/* Programming the clock is costly and ugly, so avoid if if we can */
+
+	if (par->curdclk != info->var.pixclock) {
+		/* Disable the timing generator. */
+		dcfg &= ~(DC_DCFG_TGEN);
+		writel(dcfg, par->dc_regs + DC_DISPLAY_CFG);
+
+		/* Wait for pending memory requests before disabling the FIFO load. */
+		udelay(100);
+
+		/* Disable FIFO load and compression. */
+		gcfg &= ~(DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);
+		writel(gcfg, par->dc_regs + DC_GENERAL_CFG);
+
+		/* Setup DCLK and its divisor. */
+		par->vid_ops->set_dclk(info);
+	}
 
 	/* Clear all unused feature bits. */
 	gcfg &= DC_GCFG_YUVM | DC_GCFG_VDSE;
@@ -90,12 +107,13 @@ static void gx_set_mode(struct fb_info *
 	gcfg |= (6 << DC_GCFG_DFHPEL_POS) | (5 << DC_GCFG_DFHPSL_POS) | DC_GCFG_DFLE;
 
 	/* Framebuffer start offset. */
-	writel(0, par->dc_regs + DC_FB_ST_OFFSET);
+	rmwl(0, par->dc_regs + DC_FB_ST_OFFSET);
 
 	/* Line delta and line buffer length. */
-	writel(info->fix.line_length >> 3, par->dc_regs + DC_GFX_PITCH);
-	writel(((info->var.xres * info->var.bits_per_pixel/8) >> 3) + 2,
-	       par->dc_regs + DC_LINE_SIZE);
+	rmwl(info->fix.line_length >> 3, par->dc_regs + DC_GFX_PITCH);
+
+	rmwl(((info->var.xres * info->var.bits_per_pixel/8) >> 3) + 2,
+	     par->dc_regs + DC_LINE_SIZE);
 
 
 	/* Enable graphics and video data and unmask address lines. */
@@ -134,17 +152,16 @@ static void gx_set_mode(struct fb_info *
 	vblankend = vsyncend + info->var.upper_margin;
 	vtotal = vblankend;
 
-	writel((hactive - 1)     | ((htotal - 1) << 16),    par->dc_regs + DC_H_ACTIVE_TIMING);
-	writel((hblankstart - 1) | ((hblankend - 1) << 16), par->dc_regs + DC_H_BLANK_TIMING);
-	writel((hsyncstart - 1)  | ((hsyncend - 1) << 16),  par->dc_regs + DC_H_SYNC_TIMING);
-
-	writel((vactive - 1)     | ((vtotal - 1) << 16),    par->dc_regs + DC_V_ACTIVE_TIMING);
-	writel((vblankstart - 1) | ((vblankend - 1) << 16), par->dc_regs + DC_V_BLANK_TIMING);
-	writel((vsyncstart - 1)  | ((vsyncend - 1) << 16),  par->dc_regs + DC_V_SYNC_TIMING);
+	rmwl((hactive - 1)     | ((htotal - 1) << 16),    par->dc_regs + DC_H_ACTIVE_TIMING);
+	rmwl((hblankstart - 1) | ((hblankend - 1) << 16), par->dc_regs + DC_H_BLANK_TIMING);
+	rmwl((hsyncstart - 1)  | ((hsyncend - 1) << 16),  par->dc_regs + DC_H_SYNC_TIMING);
+	rmwl((vactive - 1)     | ((vtotal - 1) << 16),    par->dc_regs + DC_V_ACTIVE_TIMING);
+	rmwl((vblankstart - 1) | ((vblankend - 1) << 16), par->dc_regs + DC_V_BLANK_TIMING);
+	rmwl((vsyncstart - 1)  | ((vsyncend - 1) << 16),  par->dc_regs + DC_V_SYNC_TIMING);
 
 	/* Write final register values. */
-	writel(dcfg, par->dc_regs + DC_DISPLAY_CFG);
-	writel(gcfg, par->dc_regs + DC_GENERAL_CFG);
+	rmwl(dcfg, par->dc_regs + DC_DISPLAY_CFG);
+	rmwl(gcfg, par->dc_regs + DC_GENERAL_CFG);
 
 	par->vid_ops->configure_display(info);
 
diff -purN linux_2.6.24_org/drivers/video/geode/display_gx.h linux_2.6.24_olpc/drivers/video/geode/display_gx.h
--- linux_2.6.24_org/drivers/video/geode/display_gx.h	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/display_gx.h	2008-02-15 18:58:41.000000000 +0000
@@ -20,6 +20,9 @@ extern struct geode_dc_ops gx_dc_ops;
 #define GLD_MSR_CONFIG   0xC0002001
 #define GLD_MSR_CONFIG_DM_FP 0x40
 
+/* Used for memory dection on the OLPC */
+#define GLIU0_P2D_RO0 0x10000029
+
 /* Display controller registers */
 
 #define DC_UNLOCK 0x00
diff -purN linux_2.6.24_org/drivers/video/geode/geodefb.h linux_2.6.24_olpc/drivers/video/geode/geodefb.h
--- linux_2.6.24_org/drivers/video/geode/geodefb.h	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/geodefb.h	2008-02-15 18:58:41.000000000 +0000
@@ -12,6 +12,10 @@
 #ifndef __GEODEFB_H__
 #define __GEODEFB_H__
 
+#define FB_POWER_STATE_OFF      0
+#define FB_POWER_STATE_SUSPEND  1
+#define FB_POWER_STATE_ON       2
+
 struct geodefb_info;
 
 struct geode_dc_ops {
@@ -21,18 +25,24 @@ struct geode_dc_ops {
 
 struct geode_vid_ops {
 	void (*set_dclk)(struct fb_info *);
+	unsigned int (*get_dclk)(struct fb_info *);
 	void (*configure_display)(struct fb_info *);
 	int  (*blank_display)(struct fb_info *, int blank_mode);
 };
 
 struct geodefb_par {
 	int enable_crt;
+	int fbactive;  /* True if the current console is in KD_GRAPHICS mode */
 	int panel_x; /* dimensions of an attached flat panel, non-zero => enable panel */
 	int panel_y;
+	unsigned int curdclk;  /* Used by GX to avoid unnessesary clock switching */
 	void __iomem *dc_regs;
 	void __iomem *vid_regs;
+	void __iomem *gp_regs;
 	struct geode_dc_ops  *dc_ops;
 	struct geode_vid_ops *vid_ops;
+
+	int state;
 };
 
 #endif /* !__GEODEFB_H__ */
diff -purN linux_2.6.24_org/drivers/video/geode/geode_regs.h linux_2.6.24_olpc/drivers/video/geode/geode_regs.h
--- linux_2.6.24_org/drivers/video/geode/geode_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/video/geode/geode_regs.h	2008-02-15 18:58:41.000000000 +0000
@@ -0,0 +1,255 @@
+/* This header file defines the registers and suspend/resume
+   structures for the Geode GX and LX.   The lxfb driver defines
+   _GEODELX_ before including this file, which will unlock the
+   extra registers that are only valid for LX.
+*/
+
+#ifndef _GEODE_REGS_H_
+#define _GEODE_REGS_H_
+
+/* MSRs */
+
+#define GX_VP_MSR_PAD_SELECT    0xC0002011
+#define LX_VP_MSR_PAD_SELECT    0x48000011
+
+#define GEODE_MSR_GLCP_DOTPLL   0x4c000015
+
+#define GLCP_DOTPLL_RESET    (1 << 0)
+#define GLCP_DOTPLL_BYPASS   (1 << 15)
+#define GLCP_DOTPLL_HALFPIX  (1 << 24)
+#define GLCP_DOTPLL_LOCK     (1 << 25)
+
+/* Registers */
+#define VP_FP_START          0x400
+
+
+#ifdef _GEODELX_
+
+#define GP_REG_SIZE  0x7C
+#define DC_REG_SIZE  0xF0
+#define VP_REG_SIZE  0x158
+#define FP_REG_SIZE  0x70
+
+#else
+
+#define GP_REG_SIZE 0x50
+#define DC_REG_SIZE 0x90
+#define VP_REG_SIZE 0x138
+#define FP_REG_SIZE 0x70
+
+#endif
+
+#define DC_PAL_SIZE 0x105
+#define VP_COEFF_COUNT 512
+#define DC_HFILT_SIZE 256
+#define DC_VFILT_SIZE 256
+
+struct geoderegs {
+
+	struct {
+		u64 padsel;
+		u64 dotpll;
+
+#ifdef _GEODELX_
+		u64 dfglcfg;
+		u64 dcspare;
+#else
+		u64 rstpll;
+#endif
+	} msr;
+
+	union {
+		unsigned char b[GP_REG_SIZE];
+		struct {
+			u32 dst_offset;         /* 0x00 */
+			u32 src_offset;         /* 0x04 */
+			u32 stride;             /* 0x08 */
+			u32 wid_height;         /* 0x0C */
+			u32 src_color_fg;       /* 0x10 */
+			u32 src_color_bg;       /* 0x14 */
+			u32 pat_color_0;        /* 0x18 */
+			u32 pat_color_1;        /* 0x1C */
+			u32 pat_color_2;        /* 0x20 */
+			u32 pat_color_3;        /* 0x24 */
+			u32 pat_color_4;        /* 0x28 */
+			u32 pat_color_5;        /* 0x2C */
+			u32 pat_data_0;         /* 0x30 */
+			u32 pat_data_1;         /* 0x34 */
+			u32 raster_mode;        /* 0x38 */
+			u32 vector_mode;        /* 0x3C */
+			u32 blt_mode;           /* 0x40 */
+			u32 blit_status;        /* 0x4C */
+			u32 hst_src;            /* 0x48 */
+			u32 base_offset;        /* 0x4C */
+
+#ifdef _GEODELX_
+			u32 cmd_top;            /* 0x50 */
+			u32 cmd_bot;            /* 0x54 */
+			u32 cmd_read;           /* 0x58 */
+			u32 cmd_write;          /* 0x5C */
+			u32 ch3_offset;         /* 0x60 */
+			u32 ch3_mode_str;       /* 0x64 */
+			u32 ch3_width;          /* 0x68 */
+			u32 ch3_hsrc;           /* 0x6C */
+			u32 lut_index;          /* 0x70 */
+			u32 lut_data;           /* 0x74 */
+			u32 int_cntrl;          /* 0x78 */
+#endif
+		} r;
+	} gp;
+
+	union {
+		unsigned char b[DC_REG_SIZE];
+
+		struct {
+			u32 unlock;             /* 0x00 */
+			u32 gcfg;               /* 0x04 */
+			u32 dcfg;               /* 0x08 */
+			u32 arb;                /* 0x0C */
+			u32 fb_st_offset;       /* 0x10 */
+			u32 cb_st_offset;       /* 0x14 */
+			u32 curs_st_offset;     /* 0x18 */
+			u32 icon_st_offset;     /* 0x1C */
+			u32 vid_y_st_offset;    /* 0x20 */
+			u32 vid_u_st_offset;    /* 0x24 */
+			u32 vid_v_st_offset;    /* 0x28 */
+			u32 dctop;              /* 0x2c */
+			u32 line_size;          /* 0x30 */
+			u32 gfx_pitch;          /* 0x34 */
+			u32 vid_yuv_pitch;      /* 0x38 */
+			u32 rsvd2;              /* 0x3C */
+			u32 h_active_timing;    /* 0x40 */
+			u32 h_blank_timing;     /* 0x44 */
+			u32 h_sync_timing;      /* 0x48 */
+			u32 rsvd3;              /* 0x4C */
+			u32 v_active_timing;    /* 0x50 */
+			u32 v_blank_timing;     /* 0x54 */
+			u32 v_sync_timing;      /* 0x58 */
+			u32 fbactive;           /* 0x5C */
+			u32 dc_cursor_x;        /* 0x60 */
+			u32 dc_cursor_y;        /* 0x64 */
+			u32 dc_icon_x;          /* 0x68 */
+			u32 dc_line_cnt;        /* 0x6C */
+			u32 rsvd5;              /* 0x70 - palette address */
+			u32 rsvd6;              /* 0x74 - palette data */
+			u32 dfifo_diag;         /* 0x78 */
+			u32 cfifo_diag;         /* 0x7C */
+			u32 dc_vid_ds_delta;    /* 0x80 */
+			u32 gliu0_mem_offset;   /* 0x84 */
+			u32 dv_ctl;             /* 0x88 - added by LX */
+			u32 dv_acc;             /* 0x8C */
+
+#ifdef _GEODELX_
+			u32 gfx_scale;
+			u32 irq_filt_ctl;
+			u32 filt_coeff1;
+			u32 filt_coeff2;
+			u32 vbi_event_ctl;
+			u32 vbi_odd_ctl;
+			u32 vbi_hor;
+			u32 vbi_ln_odd;
+			u32 vbi_ln_event;
+			u32 vbi_pitch;
+			u32 clr_key;
+			u32 clr_key_mask;
+			u32 clr_key_x;
+			u32 clr_key_y;
+			u32 irq;
+			u32 rsvd8;
+			u32 genlk_ctrl;
+			u32 vid_even_y_st_offset;    /* 0xD8 */
+			u32 vid_even_u_st_offset;    /* 0xDC */
+			u32 vid_even_v_st_offset;    /* 0xE0 */
+			u32 v_active_even_timing;    /* 0xE4 */
+			u32 v_blank_even_timing;     /* 0xE8 */
+			u32 v_sync_even_timing;      /* 0xEC */
+#endif
+		} r;
+	} dc;
+
+	union {
+		unsigned char b[VP_REG_SIZE];
+
+		struct {
+			u64 vcfg;               /* 0x00 */
+			u64 dcfg;               /* 0x08 */
+			u64 vx;                 /* 0x10 */
+			u64 vy;                 /* 0x18 */
+			u64 vs;                 /* 0x20 */
+			u64 vck;                /* 0x28 */
+			u64 vcm;                /* 0x30 */
+			u64 rsvd1;              /* 0x38 - Gamma address*/
+			u64 rsvd2;              /* 0x40 - Gamma data*/
+			u64 slr;                /* 0x48 - LX only*/
+			u64 misc;               /* 0x50 */
+			u64 ccs;                /* 0x58 */
+			u64 vys;		/* 0x60 */
+			u64 vxs;		/* 0x68 */
+			u64 rsvd4;              /* 0x70 */
+			u64 vdc;                /* 0x78 */
+			u64 vco;                /* 0x80 */
+			u64 crc;                /* 0x88 */
+			u64 crc32;              /* 0x90 */
+			u64 vde;                /* 0x98 */
+			u64 cck;                /* 0xA0 */
+			u64 ccm;                /* 0xA8 */
+			u64 cc1;                /* 0xB0 */
+			u64 cc2;                /* 0xB8 */
+			u64 a1x;                /* 0xC0 */
+			u64 a1y;                /* 0xC8 */
+			u64 a1c;                /* 0xD0 */
+			u64 a1t;                /* 0xD8 */
+			u64 a2x;                /* 0xE0 */
+			u64 a2y;                /* 0xE8 */
+			u64 a2c;                /* 0xF0 */
+			u64 a2t;                /* 0xF8 */
+			u64 a3x;                /* 0x100 */
+			u64 a3y;                /* 0x108 */
+			u64 a3c;                /* 0x110 */
+			u64 a3t;                /* 0x118 */
+			u64 vrr;                /* 0x120 */
+			u64 awt;                /* 0x128 */
+			u64 vtm;                /* 0x130 */
+#ifdef _GEODELX_
+			u64 vye;                /* 0x138 */
+			u64 a1ye;               /* 0x140 */
+			u32 a2ye;               /* 0x148 */
+			u32 a3ye;	        /* 0x150 */
+#endif
+		} r;
+	} vp;
+
+	union {
+		unsigned char b[FP_REG_SIZE];
+
+		struct {
+			u64 pt1;                /* 0x400 */
+			u64 pt2;                /* 0x408 */
+			u64 pm;                 /* 0x410 */
+			u64 dfc;                /* 0x418 */
+			u64 blfsr;              /* 0x420 */
+			u64 rlfsr;              /* 0x428 */
+			u64 fmi;                /* 0x430 */
+			u64 fmd;                /* 0x438 */
+			u64 rsvd;               /* 0x440 */
+			u64 dca;                /* 0x448 */
+			u64 dmd;                /* 0x450 */
+			u64 crc;                /* 0x458 */
+			u64 fbb;                /* 0x460 */
+			u64 crc32;              /* 0x468 */
+		} r;
+	} fp;
+
+	u32 pal[DC_PAL_SIZE];
+	u32 gamma[256];
+
+#ifdef _GEODELX_
+
+	u32 hcoeff[DC_HFILT_SIZE * 2];
+	u32 vcoeff[DC_VFILT_SIZE];
+
+	u32 vp_coeff[VP_COEFF_COUNT];
+#endif
+};
+
+#endif
diff -purN linux_2.6.24_org/drivers/video/geode/gxfb_core.c linux_2.6.24_olpc/drivers/video/geode/gxfb_core.c
--- linux_2.6.24_org/drivers/video/geode/gxfb_core.c	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/gxfb_core.c	2008-02-15 18:58:41.000000000 +0000
@@ -30,12 +30,31 @@
 #include <linux/fb.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/notifier.h>
+#include <linux/vt_kern.h>
+#include <linux/console.h>
+#include <asm/uaccess.h>
+#include <asm/olpc.h>
 
 #include "geodefb.h"
 #include "display_gx.h"
 #include "video_gx.h"
 
+#define FBIOSGAMMA		_IOW('F', 0x20, void *)
+#define FBIOGGAMMA		_IOW('F', 0x21, void *)
+
+#ifdef DEBUG
+
+#define FBIODUMPGP		_IOW('F', 0x22, void *)
+#define FBIODUMPDC		_IOW('F', 0x23, void *)
+#define FBIODUMPVP		_IOW('F', 0x24, void *)
+#define FBIODUMPFP		_IOW('F', 0x25, void *)
+
+#endif
+
 static char *mode_option;
+static int noclear;
+struct fb_info *gxfb_info;
 
 /* Modes relevant to the GX (taken from modedb.c) */
 static const struct fb_videomode gx_modedb[] __initdata = {
@@ -103,8 +122,20 @@ static const struct fb_videomode gx_mode
 	{ NULL, 85, 1600, 1200, 4357, 304, 64, 46, 1, 192, 3,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1200x900-75 - CRT timings for the OLPC mode */
+	{ NULL, 75, 1200, 900, 8049, 104, 240, 29, 54, 136, 3,
+	  0, FB_VMODE_NONINTERLACED, 0 }
 };
 
+#ifdef CONFIG_OLPC
+static const struct fb_videomode gx_dcon_modedb[] __initdata = {
+	/* The only mode the DCON has is 1200x900 */
+	{ NULL, 50, 1200, 900, 17460, 24, 8, 4, 5, 8, 3,
+	  0, FB_VMODE_NONINTERLACED, 0 }
+};
+#endif
+
+
 static int gxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	if (var->xres > 1600 || var->yres > 1200)
@@ -137,7 +168,7 @@ static int gxfb_check_var(struct fb_var_
 	return 0;
 }
 
-static int gxfb_set_par(struct fb_info *info)
+int gxfb_set_par(struct fb_info *info)
 {
 	struct geodefb_par *par = info->par;
 
@@ -204,16 +235,26 @@ static int gxfb_blank(int blank_mode, st
 	return par->vid_ops->blank_display(info, blank_mode);
 }
 
+static int fbsize;
+
 static int __init gxfb_map_video_memory(struct fb_info *info, struct pci_dev *dev)
 {
 	struct geodefb_par *par = info->par;
-	int fb_len;
 	int ret;
 
 	ret = pci_enable_device(dev);
 	if (ret < 0)
 		return ret;
 
+	ret = pci_request_region(dev, 1, "gxfb (graphics processor)");
+	if (ret < 0)
+		return ret;
+
+	par->gp_regs = ioremap(pci_resource_start(dev, 1),
+				pci_resource_len(dev, 1));
+	if (!par->gp_regs)
+		return -ENOMEM;
+
 	ret = pci_request_region(dev, 3, "gxfb (video processor)");
 	if (ret < 0)
 		return ret;
@@ -232,36 +273,118 @@ static int __init gxfb_map_video_memory(
 	ret = pci_request_region(dev, 0, "gxfb (framebuffer)");
 	if (ret < 0)
 		return ret;
-	if ((fb_len = gx_frame_buffer_size()) < 0)
-		return -ENOMEM;
+
+	/* If the fbsize wasn't specified then try to probe it */
+
+	if (!fbsize) {
+		fbsize = gx_frame_buffer_size();
+		if (fbsize == 0)
+			return -ENOMEM;
+	}
+
 	info->fix.smem_start = pci_resource_start(dev, 0);
-	info->fix.smem_len = fb_len;
+	info->fix.smem_len = fbsize;
 	info->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);
 	if (!info->screen_base)
 		return -ENOMEM;
 
-	/* Set the 16MB aligned base address of the graphics memory region
+	/* Set the 16MiB aligned base address of the graphics memory region
 	 * in the display controller */
 
 	writel(info->fix.smem_start & 0xFF000000,
 			par->dc_regs + DC_GLIU0_MEM_OFFSET);
 
-	dev_info(&dev->dev, "%d Kibyte of video memory at 0x%lx\n",
+	dev_info(&dev->dev, "%d KiB of video memory at 0x%lx\n",
 		 info->fix.smem_len / 1024, info->fix.smem_start);
 
 	return 0;
 }
 
+static int gxfb_ioctl( struct fb_info *info, unsigned int cmd,
+		       unsigned long arg)
+{
+	unsigned int gamma[GXFB_GAMMA_DWORDS];
+	int ret = -EINVAL;
+	struct geodefb_par *par = info->par;
+	int i;
+
+	switch(cmd) {
+	case FBIOSGAMMA:
+		/* Read the gamma information from the user - 256 dwords */
+
+		if (copy_from_user(gamma, (void * __user) arg, GXFB_GAMMA_SIZE))
+			return -EFAULT;
+
+		writel(0, par->vid_regs + GX_GAR);
+
+		/* Sequential writes to the data register will increment the
+		   address automatically  */
+
+		for(i = 0; i < GXFB_GAMMA_DWORDS; i++)
+			writel(gamma[i] & 0xFFFFFF, par->vid_regs + GX_GDR);
+
+		writel(readl(par->vid_regs + GX_MISC) & ~GX_MISC_GAM_EN,
+		       par->vid_regs + GX_MISC);
+
+		ret = 0;
+		break;
+
+	case FBIOGGAMMA:
+		if (readl(par->vid_regs + GX_MISC) & GX_MISC_GAM_EN)
+			return -EINVAL;
+
+		memset(gamma, 0, GXFB_GAMMA_SIZE);
+		writel(0, par->vid_regs + GX_GAR);
+
+		for(i = 0; i < GXFB_GAMMA_DWORDS;i++)
+			gamma[i] = readl(par->vid_regs + GX_GDR);
+
+		if (copy_to_user((void * __user) arg, gamma, GXFB_GAMMA_SIZE))
+			ret = -EFAULT;
+		else
+			ret = 0;
+
+		break;
+
+#ifdef DEBUG
+	case FBIODUMPGP:
+		ret = 0;
+		dump_regs(info, 0);
+		break;
+		
+	case FBIODUMPDC:
+		ret = 0;
+		dump_regs(info, 1);
+		break;
+
+	case FBIODUMPVP:
+		ret = 0;
+		dump_regs(info, 2);
+		break;
+
+	case FBIODUMPFP:
+		ret = 0;
+		dump_regs(info, 3);
+		break;
+#endif
+	}
+
+	return ret;
+}
+
 static struct fb_ops gxfb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_check_var	= gxfb_check_var,
 	.fb_set_par	= gxfb_set_par,
 	.fb_setcolreg	= gxfb_setcolreg,
 	.fb_blank       = gxfb_blank,
+	.fb_ioctl       = gxfb_ioctl,
 	/* No HW acceleration for now. */
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
+	.fb_powerdown   = gxfb_powerdown,
+	.fb_powerup     = gxfb_powerup,
 };
 
 static struct fb_info * __init gxfb_init_fbinfo(struct device *dev)
@@ -303,23 +426,86 @@ static struct fb_info * __init gxfb_init
 	return info;
 }
 
-static int __init gxfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static int gxfb_console_notify(struct notifier_block *self,
+				unsigned long action, void *data)
+{
+	if (gxfb_info != NULL) {
+		struct geodefb_par *par = gxfb_info->par;
+		par->fbactive = (action == CONSOLE_EVENT_SWITCH_TEXT) ? 0 : 1;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block gxfb_console_notifier = {
+	.notifier_call = gxfb_console_notify
+};
+
+#ifdef CONFIG_PM
+
+static int gxfb_suspend(struct pci_dev *pdev,  pm_message_t state)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+	struct geodefb_par *par = info->par;
+
+	if (pdev->dev.power.power_state.event == state.event)
+		return 0;
+
+	if (state.event == PM_EVENT_SUSPEND) {
+	 
+		acquire_console_sem();
+		gxfb_powerdown(info);
+
+		par->state = FB_POWER_STATE_OFF;
+		fb_set_suspend(info, 1);
+		
+		release_console_sem();
+	}
+
+	pdev->dev.power.power_state = state;
+	return 0;
+}
+
+static int gxfb_resume(struct pci_dev *pdev)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+
+	acquire_console_sem();
+	
+	/* Turn the engine completely on */
+
+	if (gxfb_powerup(info))
+	  printk(KERN_ERR "gxfb:  Powerup failed\n");
+
+	fb_set_suspend(info, 0);
+	release_console_sem();
+
+	pdev->dev.power.power_state = PMSG_ON;
+        return 0;
+}
+#endif
+
+static int __init gxfb_probe(struct pci_dev *pdev,
+			     const struct pci_device_id *id)
 {
 	struct geodefb_par *par;
-	struct fb_info *info;
 	int ret;
 	unsigned long val;
 
-	info = gxfb_init_fbinfo(&pdev->dev);
-	if (!info)
+	struct fb_videomode *modedb_ptr;
+	int modedb_size;
+
+	gxfb_info = gxfb_init_fbinfo(&pdev->dev);
+	if (gxfb_info == NULL)
 		return -ENOMEM;
-	par = info->par;
+
+	par = gxfb_info->par;
 
 	/* GX display controller and GX video device. */
 	par->dc_ops  = &gx_dc_ops;
 	par->vid_ops = &gx_vid_ops;
 
-	if ((ret = gxfb_map_video_memory(info, pdev)) < 0) {
+	if ((ret = gxfb_map_video_memory(gxfb_info, pdev)) < 0) {
 		dev_err(&pdev->dev, "failed to map frame buffer or controller registers\n");
 		goto err;
 	}
@@ -333,32 +519,60 @@ static int __init gxfb_probe(struct pci_
 	else
 		par->enable_crt = 1;
 
-	ret = fb_find_mode(&info->var, info, mode_option,
-			   gx_modedb, ARRAY_SIZE(gx_modedb), NULL, 16);
+	/* Get the current dotclock */
+
+	par->curdclk = (par->vid_ops->get_dclk) ? par->vid_ops->get_dclk(gxfb_info) : 0;
+
+	/* We need to determine a display mode right now, so we will
+	 * check to see if the DCON was previously detected by the BIOS
+	 * and use that to make our mode database decision.
+	 */
+
+	modedb_ptr = (struct fb_videomode *) gx_modedb;
+	modedb_size = ARRAY_SIZE(gx_modedb);
+
+#ifdef CONFIG_OLPC
+	if (olpc_has_dcon()) {
+		modedb_ptr = (struct fb_videomode *) gx_dcon_modedb;
+		modedb_size = ARRAY_SIZE(gx_dcon_modedb);
+	}
+#endif
+
+	ret = fb_find_mode(&gxfb_info->var, gxfb_info, mode_option,
+			   modedb_ptr, modedb_size, NULL, 16);
+
 	if (ret == 0 || ret == 4) {
 		dev_err(&pdev->dev, "could not find valid video mode\n");
 		ret = -EINVAL;
 		goto err;
 	}
 
+	/* Clear the screen of garbage, unless noclear was specified,
+	 * in which case we assume the user knows what he is doing */
+
+	if (!noclear)
+		memset_io(gxfb_info->screen_base, 0, gxfb_info->fix.smem_len);
+
+	gxfb_check_var(&gxfb_info->var, gxfb_info);
+	gxfb_set_par(gxfb_info);
+
+	/* We are powered up */
+	par->state = FB_POWER_STATE_ON;
 
-	/* Clear the frame buffer of garbage. */
-        memset_io(info->screen_base, 0, info->fix.smem_len);
 
-	gxfb_check_var(&info->var, info);
-	gxfb_set_par(info);
+	console_event_register(&gxfb_console_notifier);
 
-	if (register_framebuffer(info) < 0) {
+	if (register_framebuffer(gxfb_info) < 0) {
 		ret = -EINVAL;
 		goto err;
 	}
-	pci_set_drvdata(pdev, info);
-	printk(KERN_INFO "fb%d: %s frame buffer device\n", info->node, info->fix.id);
+	pci_set_drvdata(pdev, gxfb_info);
+	printk(KERN_INFO "fb%d: %s frame buffer device\n", gxfb_info->node, gxfb_info->fix.id);
 	return 0;
 
   err:
-	if (info->screen_base) {
-		iounmap(info->screen_base);
+	if (gxfb_info->screen_base) {
+		iounmap(gxfb_info->screen_base);
 		pci_release_region(pdev, 0);
 	}
 	if (par->vid_regs) {
@@ -370,8 +584,9 @@ static int __init gxfb_probe(struct pci_
 		pci_release_region(pdev, 2);
 	}
 
-	if (info)
-		framebuffer_release(info);
+	if (gxfb_info)
+		framebuffer_release(gxfb_info);
+
 	return ret;
 }
 
@@ -397,9 +612,7 @@ static void gxfb_remove(struct pci_dev *
 }
 
 static struct pci_device_id gxfb_id_table[] = {
-	{ PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_GX_VIDEO,
-	  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,
-	  0xff0000, 0 },
+	{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_GX_VIDEO) },
 	{ 0, }
 };
 
@@ -410,22 +623,30 @@ static struct pci_driver gxfb_driver = {
 	.id_table	= gxfb_id_table,
 	.probe		= gxfb_probe,
 	.remove		= gxfb_remove,
+#ifdef CONFIG_PM
+	.suspend        = gxfb_suspend,
+	.resume         = gxfb_resume
+#endif
 };
 
 #ifndef MODULE
-static int __init gxfb_setup(char *options)
-{
+static int __init gxfb_setup(char *options) {
 
 	char *opt;
 
 	if (!options || !*options)
 		return 0;
 
-	while ((opt = strsep(&options, ",")) != NULL) {
+	while((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
 
-		mode_option = opt;
+		if (!strncmp(opt, "fbsize:", 7))
+			fbsize = simple_strtoul(opt+7, NULL, 0);
+		else if (!strcmp(opt, "noclear"))
+			noclear = 1;
+		else
+			mode_option = opt;
 	}
 
 	return 0;
@@ -444,7 +665,6 @@ static int __init gxfb_init(void)
 #endif
 	return pci_register_driver(&gxfb_driver);
 }
-
 static void __exit gxfb_cleanup(void)
 {
 	pci_unregister_driver(&gxfb_driver);
@@ -456,5 +676,8 @@ module_exit(gxfb_cleanup);
 module_param(mode_option, charp, 0);
 MODULE_PARM_DESC(mode_option, "video mode (<x>x<y>[-<bpp>][@<refr>])");
 
+module_param(fbsize, int, 0);
+MODULE_PARM_DESC(fbsize, "video memory size");
+
 MODULE_DESCRIPTION("Framebuffer driver for the AMD Geode GX");
 MODULE_LICENSE("GPL");
diff -purN linux_2.6.24_org/drivers/video/geode/Kconfig linux_2.6.24_olpc/drivers/video/geode/Kconfig
--- linux_2.6.24_org/drivers/video/geode/Kconfig	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/Kconfig	2008-02-15 18:58:41.000000000 +0000
@@ -38,26 +38,6 @@ config FB_GEODE_GX
 
 	  If unsure, say N.
 
-config FB_GEODE_GX_SET_FBSIZE
-	bool "Manually specify the Geode GX framebuffer size"
-	depends on FB_GEODE_GX
-	default n
-	---help---
-	  If you want to manually specify the size of your GX framebuffer,
-	  say Y here, otherwise say N to dynamically probe it.
-
-	  Say N unless you know what you are doing.
-
-config FB_GEODE_GX_FBSIZE
-	hex "Size of the GX framebuffer, in bytes"
-	depends on FB_GEODE_GX_SET_FBSIZE
-	default "0x1600000"
-	---help---
-	  Specify the size of the GX framebuffer.  Normally, you will
-	  want this to be MB aligned.  Common values are 0x80000 (8MB)
-	  and 0x1600000 (16MB).  Don't change this unless you know what
-	  you are doing
-
 config FB_GEODE_GX1
 	tristate "AMD Geode GX1 framebuffer support (EXPERIMENTAL)"
 	depends on FB && FB_GEODE && EXPERIMENTAL
diff -purN linux_2.6.24_org/drivers/video/geode/lxfb_core.c linux_2.6.24_olpc/drivers/video/geode/lxfb_core.c
--- linux_2.6.24_org/drivers/video/geode/lxfb_core.c	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/lxfb_core.c	2008-02-15 18:58:41.000000000 +0000
@@ -21,7 +21,8 @@
 #include <linux/fb.h>
 #include <linux/init.h>
 #include <linux/pci.h>
-#include <linux/uaccess.h>
+#include <asm/uaccess.h>
+#include <asm/olpc.h>
 
 #include "lxfb.h"
 
@@ -35,186 +36,84 @@ static int fbsize;
  */
 
 const struct fb_videomode geode_modedb[] __initdata = {
-	/* 640x480-60 */
-	{ NULL, 60, 640, 480, 39682, 48, 8, 25, 2, 88, 2,
+	/* 640x480-60 VESA */
+	{ NULL, 60, 640, 480, 39682,  48, 16, 33, 10, 96, 2,
+	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 640x480-75 VESA */
+	{ NULL, 75, 640, 480, 31746, 120, 16, 16, 01, 64, 3,
+	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 640x480-85 VESA */
+	{ NULL, 85, 640, 480, 27777, 80, 56, 25, 01, 56, 3,
+	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 800x600-60 VESA */
+	{ NULL, 60, 800, 600, 25000, 88, 40, 23, 01, 128, 4,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 800x600-75 VESA */
+	{ NULL, 75, 800, 600, 20202, 160, 16, 21, 01, 80, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 800x600-85 VESA */
+	{ NULL, 85, 800, 600, 17761, 152, 32, 27, 01, 64, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1024x768-60 VESA */
+	{ NULL, 60, 1024, 768, 15384, 160, 24, 29, 3, 136, 6,
+	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1024x768-75 VESA */
+	{ NULL, 75, 1024, 768, 12690, 176, 16, 28, 1, 96, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1024x768-85 VESA */
+	{ NULL, 85, 1024, 768, 10582, 208, 48, 36, 1, 96, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x960-60 VESA */
+	{ NULL, 60, 1280, 960, 9259, 312, 96, 36, 1, 112, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x960-85 VESA */
+	{ NULL, 85, 1280, 960, 6734, 224, 64, 47, 1, 160, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x1024-60 VESA */
+	{ NULL, 60, 1280, 1024, 9259, 248, 48, 38, 1, 112, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x1024-75 VESA */
+	{ NULL, 75, 1280, 1024, 7407, 248, 16, 38, 1, 144, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x1024-85 VESA */
+	{ NULL, 85, 1280, 1024, 6349, 224, 64, 44, 1, 160, 3,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x400-70 */
-	{ NULL, 70, 640, 400, 39770, 40, 8, 28, 5, 96, 2,
-	  FB_SYNC_HOR_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-70 */
-	{ NULL, 70, 640, 480, 35014, 88, 24, 15, 2, 64, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-72 */
-	{ NULL, 72, 640, 480, 32102, 120, 16, 20, 1, 40, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-75 */
-	{ NULL, 75, 640, 480, 31746, 120, 16, 16, 1, 64, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-85 */
-	{ NULL, 85, 640, 480, 27780, 80, 56, 25, 1, 56, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-90 */
-	{ NULL, 90, 640, 480, 26392, 96, 32, 22, 1, 64, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-100 */
-	{ NULL, 100, 640, 480, 23167, 104, 40, 25, 1, 64, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-60 */
-	{ NULL, 60, 640, 480, 39682, 48, 16, 25, 10, 88, 2,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-56 */
-	{ NULL, 56, 800, 600, 27901, 128, 24, 22, 1, 72, 2,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-60 */
-	{ NULL, 60, 800, 600, 25131, 72, 32, 23, 1, 136, 4,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-70 */
-	{ NULL, 70, 800, 600, 21873, 120, 40, 21, 4, 80, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-72 */
-	{ NULL, 72, 800, 600, 20052, 64, 56, 23, 37, 120, 6,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-75 */
-	{ NULL, 75, 800, 600, 20202, 160, 16, 21, 1, 80, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-85 */
-	{ NULL, 85, 800, 600, 17790, 152, 32, 27, 1, 64, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-90 */
-	{ NULL, 90, 800, 600, 16648, 128, 40, 28, 1, 88, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-100 */
-	{ NULL, 100, 800, 600, 14667, 136, 48, 27, 1, 88, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-60 */
-	{ NULL, 60, 800, 600, 25131, 88, 40, 23, 1, 128, 4,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-60 */
-	{ NULL, 60, 1024, 768, 15385, 160, 24, 29, 3, 136, 6,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-70 */
-	{ NULL, 70, 1024, 768, 13346, 144, 24, 29, 3, 136, 6,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-72 */
-	{ NULL, 72, 1024, 768, 12702, 168, 56, 29, 4, 112, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-75 */
-	{ NULL, 75, 1024, 768, 12703, 176, 16, 28, 1, 96, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-85 */
-	{ NULL, 85, 1024, 768, 10581, 208, 48, 36, 1, 96, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-90 */
-	{ NULL, 90, 1024, 768, 9981, 176, 64, 37, 1, 112, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-100 */
-	{ NULL, 100, 1024, 768, 8825, 184, 72, 42, 1, 112, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-60 */
-	{ NULL, 60, 1024, 768, 15385, 160, 24, 29, 3, 136, 6,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-60 */
-	{ NULL, 60, 1152, 864, 12251, 184, 64, 27, 1, 120, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-70 */
-	{ NULL, 70, 1152, 864, 10254, 192, 72, 32, 8, 120, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-72 */
-	{ NULL, 72, 1152, 864, 9866, 200, 72, 33, 7, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-75 */
-	{ NULL, 75, 1152, 864, 9259, 256, 64, 32, 1, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-85 */
-	{ NULL, 85, 1152, 864, 8357, 200, 72, 37, 3, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-90 */
-	{ NULL, 90, 1152, 864, 7719, 208, 80, 42, 9, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-100 */
-	{ NULL, 100, 1152, 864, 6947, 208, 80, 48, 3, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-60 */
-	{ NULL, 60, 1152, 864, 12251, 184, 64, 27, 1, 120, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-60 */
-	{ NULL, 60, 1280, 1024, 9262, 248, 48, 38, 1, 112, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-70 */
-	{ NULL, 70, 1280, 1024, 7719, 224, 88, 38, 6, 136, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-72 */
-	{ NULL, 72, 1280, 1024, 7490, 224, 88, 39, 7, 136, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-75 */
-	{ NULL, 75, 1280, 1024, 7409, 248, 16, 38, 1, 144, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-85 */
-	{ NULL, 85, 1280, 1024, 6351, 224, 64, 44, 1, 160, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-90 */
-	{ NULL, 90, 1280, 1024, 5791, 240, 96, 51, 12, 144, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-100 */
-	{ NULL, 100, 1280, 1024, 5212, 240, 96, 57, 6, 144, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-60 */
-	{ NULL, 60, 1280, 1024, 9262, 248, 48, 38, 1, 112, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-60 */
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1600x1200-60 VESA */
 	{ NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-70 */
-	{ NULL, 70, 1600, 1200, 5291, 304, 64, 46, 1, 192, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-72 */
-	{ NULL, 72, 1600, 1200, 5053, 288, 112, 47, 13, 176, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-75 */
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1600x1200-75 VESA */
 	{ NULL, 75, 1600, 1200, 4938, 304, 64, 46, 1, 192, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-85 */
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1600x1200-85 VESA */
 	{ NULL, 85, 1600, 1200, 4357, 304, 64, 46, 1, 192, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-90 */
-	{ NULL, 90, 1600, 1200, 3981, 304, 128, 60, 1, 176, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-100 */
-	{ NULL, 100, 1600, 1200, 3563, 304, 128, 67, 1, 176, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-60 */
-	{ NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-60 */
-	{ NULL, 60, 1920, 1440, 4273, 344, 128, 56, 1, 208, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-70 */
-	{ NULL, 70, 1920, 1440, 3593, 360, 152, 55, 8, 208, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-72 */
-	{ NULL, 72, 1920, 1440, 3472, 360, 152, 68, 4, 208, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-75 */
-	{ NULL, 75, 1920, 1440, 3367, 352, 144, 56, 1, 224, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-85 */
-	{ NULL, 85, 1920, 1440, 2929, 368, 152, 68, 1, 216, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1200x900-75 - CRT timings for the OLPC mode */
+	{ NULL, 75, 1200, 900, 8049, 104, 240, 29, 54, 136, 3,
+	  0, FB_VMODE_NONINTERLACED, 0 }
 };
 
+#ifdef CONFIG_OLPC
+const struct fb_videomode olpc_dcon_modedb[] __initdata = {
+	/* The only mode the DCON has is 1200x900 */
+	{ NULL, 50, 1200, 900, 17460, 24, 8, 4, 5, 8, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, 0 }
+};
+#endif
+
 static int lxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	if (var->xres > 1920 || var->yres > 1440)
@@ -255,8 +154,7 @@ static int lxfb_set_par(struct fb_info *
 		fb_alloc_cmap(&info->cmap, 1<<info->var.bits_per_pixel, 0);
 	}
 
-	info->fix.line_length = lx_get_pitch(info->var.xres,
-		info->var.bits_per_pixel);
+	info->fix.line_length = lx_get_pitch(info->var.xres, info->var.bits_per_pixel);
 
 	lx_set_mode(info);
 	return 0;
@@ -371,24 +269,61 @@ static int __init lxfb_map_video_memory(
 	writel(info->fix.smem_start & 0xFF000000,
 	       par->dc_regs + DC_PHY_MEM_OFFSET);
 
-	writel(0, par->dc_regs + DC_UNLOCK);
-
 	dev_info(&dev->dev, "%d KB of video memory at 0x%lx\n",
 		 info->fix.smem_len / 1024, info->fix.smem_start);
 
 	return 0;
 }
 
+static int lxfb_set_gamma(struct fb_info *info, void * __user data)
+{
+	unsigned int gamma[LXFB_GAMMA_DWORDS];
+
+	if (copy_from_user(gamma, data, LXFB_GAMMA_SIZE))
+		return -EFAULT;
+
+	lx_set_gamma(info, gamma, LXFB_GAMMA_SIZE);
+	return 0;
+}
+
+static int lxfb_get_gamma(struct fb_info *info, void * __user data)
+{
+	unsigned int gamma[LXFB_GAMMA_DWORDS];
+	memset(gamma, 0, sizeof(gamma));
+
+	lx_get_gamma(info, gamma, LXFB_GAMMA_DWORDS);
+
+	return copy_to_user(data, gamma, LXFB_GAMMA_SIZE) ?
+		-EFAULT : 0;
+}
+
+static int lxfb_ioctl( struct fb_info *info, unsigned int cmd,
+		       unsigned long arg)
+{
+	switch(cmd) {
+	case FBIOSGAMMA:
+		return lxfb_set_gamma(info, (void * __user) arg);
+
+	case FBIOGGAMMA:
+		return lxfb_get_gamma(info, (void * __user) arg);
+	}
+
+	return -ENOTTY;
+}
+
 static struct fb_ops lxfb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_check_var	= lxfb_check_var,
 	.fb_set_par	= lxfb_set_par,
 	.fb_setcolreg	= lxfb_setcolreg,
 	.fb_blank       = lxfb_blank,
+	.fb_ioctl       = lxfb_ioctl,
 	/* No HW acceleration for now. */
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
+	.fb_powerdown	= lx_shutdown,
+	.fb_powerup	= lx_powerup,
 };
 
 static struct fb_info * __init lxfb_init_fbinfo(struct device *dev)
@@ -431,6 +366,45 @@ static struct fb_info * __init lxfb_init
 	return info;
 }
 
+#ifdef CONFIG_PM
+
+static int lxfb_suspend(struct pci_dev *pdev,  pm_message_t state)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+
+	if (pdev->dev.power.power_state.event == state.event)
+		return 0;
+
+	if (state.event == PM_EVENT_SUSPEND) {
+
+		acquire_console_sem();
+		lx_shutdown(info);
+		fb_set_suspend(info, 1);
+		release_console_sem();
+	}
+
+	pdev->dev.power.power_state = state;
+	return 0;
+}
+
+static int lxfb_resume(struct pci_dev *pdev)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+
+	acquire_console_sem();
+
+	/* Turn the engine completely on */
+
+	lx_powerup(info);
+	fb_set_suspend(info, 0);
+	release_console_sem();
+
+	pdev->dev.power.power_state = PMSG_ON;
+        return 0;
+}
+
+#endif
+
 static int __init lxfb_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *id)
 {
@@ -467,6 +441,13 @@ static int __init lxfb_probe(struct pci_
 	modedb_ptr = (struct fb_videomode *) geode_modedb;
 	modedb_size = ARRAY_SIZE(geode_modedb);
 
+#ifdef CONFIG_OLPC
+	if (olpc_has_dcon()) {
+		modedb_ptr = (struct fb_videomode *) olpc_dcon_modedb;
+		modedb_size = ARRAY_SIZE(olpc_dcon_modedb);
+	}
+#endif
+
 	ret = fb_find_mode(&info->var, info, mode_option,
 			   modedb_ptr, modedb_size, NULL, 16);
 
@@ -556,6 +537,10 @@ static struct pci_driver lxfb_driver = {
 	.id_table	= lxfb_id_table,
 	.probe		= lxfb_probe,
 	.remove		= lxfb_remove,
+#ifdef CONFIG_PM
+	.suspend        = lxfb_suspend,
+	.resume         = lxfb_resume
+#endif
 };
 
 #ifndef MODULE
diff -purN linux_2.6.24_org/drivers/video/geode/lxfb.h linux_2.6.24_olpc/drivers/video/geode/lxfb.h
--- linux_2.6.24_org/drivers/video/geode/lxfb.h	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/lxfb.h	2008-02-15 18:58:41.000000000 +0000
@@ -25,10 +25,23 @@ void lx_set_mode(struct fb_info *);
 void lx_get_gamma(struct fb_info *, unsigned int *, int);
 void lx_set_gamma(struct fb_info *, unsigned int *, int);
 unsigned int lx_framebuffer_size(void);
+int lx_shutdown(struct fb_info *);
+int lx_powerup(struct fb_info *);
 int lx_blank_display(struct fb_info *, int);
 void lx_set_palette_reg(struct fb_info *, unsigned int, unsigned int,
 			unsigned int, unsigned int);
 
+
+
+/* ioctl() defines */
+
+#define FBIOSGAMMA              _IOW('F', 0x20, void *)
+#define FBIOGGAMMA              _IOW('F', 0x21, void *)
+
+/* General definitions */
+#define LXFB_GAMMA_DWORDS 256 /* number of dwords in the gamma ram */
+#define LXFB_GAMMA_SIZE (LXFB_GAMMA_DWORDS * sizeof(unsigned int))
+
 /* MSRS */
 
 #define MSR_LX_GLD_CONFIG    0x48002001
@@ -127,7 +140,7 @@ void lx_set_palette_reg(struct fb_info *
 
 #define DC_GFX_SCALE       0x90
 #define DC_IRQ_FILT_CTL    0x94
-
+#define DC_IRQFILT_H_FILT_SEL              0x00000400
 
 #define DC_IRQ               0xC8
 #define  DC_IRQ_MASK         (1 << 0)
diff -purN linux_2.6.24_org/drivers/video/geode/lxfb_ops.c linux_2.6.24_olpc/drivers/video/geode/lxfb_ops.c
--- linux_2.6.24_org/drivers/video/geode/lxfb_ops.c	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/lxfb_ops.c	2008-02-15 18:58:41.000000000 +0000
@@ -11,11 +11,15 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/fb.h>
-#include <linux/uaccess.h>
-#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <asm/olpc.h>
 
 #include "lxfb.h"
 
+#define _GEODELX_
+#include "geode_regs.h"
+
 /* TODO
  * Support panel scaling
  * Add acceleration
@@ -290,6 +294,19 @@ unsigned int lx_framebuffer_size(void)
 {
 	unsigned int val;
 
+#ifdef CONFIG_OLPC
+	 if (machine_is_olpc() && !olpc_has_vsa()) {
+		u32 hi,lo;
+		rdmsr(MSR_LX_GLIU0_P2D_RO0, lo, hi);
+
+		/* Top page number */
+		val = ((hi & 0xff) << 12) | ((lo & 0xfff00000) >> 20);
+		val -= (lo & 0x000fffff); /* Subtract bottom page number */
+		val += 1;                 /* Adjust page count */
+		return (val << 12);
+	}
+#endif
+
 	/* The frame buffer size is reported by a VSM in VSA II */
 	/* Virtual Register Class    = 0x02                     */
 	/* VG_MEM_SIZE (1MB units)   = 0x00                     */
@@ -301,6 +318,34 @@ unsigned int lx_framebuffer_size(void)
 	return (val << 20);
 }
 
+void lx_set_gamma(struct fb_info *info, unsigned int *gamma, int len)
+{
+	int i;
+	struct lxfb_par *par = info->par;
+
+	writel(0, par->df_regs + DF_PAR);
+
+	/* Sequential writes to the data register will increment the
+	   address automatically  */
+
+	for(i = 0; i < len; i++)
+		writel(gamma[i] & 0xFFFFFF, par->df_regs + DF_PDR);
+
+	writel(readl(par->df_regs + DF_MISC) & ~DF_MISC_GAM_BYPASS,
+	       par->df_regs + DF_MISC);
+}
+
+void lx_get_gamma(struct fb_info *info, unsigned int *gamma, int len)
+{
+	int i;
+	struct lxfb_par *par = info->par;
+
+	writel(0, par->df_regs + DF_PAR);
+
+	for(i = 0; i < len;i++)
+		gamma[i] = readl(par->df_regs + DF_PDR);
+}
+
 void lx_set_mode(struct fb_info *info)
 {
 	struct lxfb_par *par = info->par;
@@ -313,6 +358,7 @@ void lx_set_mode(struct fb_info *info)
 	int vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal;
 
 	/* Unlock the DC registers */
+	readl(par->dc_regs + DC_UNLOCK);
 	writel(DC_UNLOCK_CODE, par->dc_regs + DC_UNLOCK);
 
 	lx_graphics_disable(info);
@@ -483,54 +529,408 @@ void lx_set_palette_reg(struct fb_info *
 	writel(val, par->dc_regs + DC_PAL_DATA);
 }
 
+static int lx_blank_mode = FB_BLANK_UNBLANK;
+
 int lx_blank_display(struct fb_info *info, int blank_mode)
 {
 	struct lxfb_par *par = info->par;
-	u32 dcfg, fp_pm;
-	int blank, hsync, vsync;
+	u32 dcfg, val;
+
+	if (blank_mode == lx_blank_mode)
+		return 0;
+
+	writel(DC_UNLOCK_CODE, par->dc_regs + DC_UNLOCK);
+
+	if (lx_blank_mode == FB_BLANK_POWERDOWN) {
+		val = readl(par->df_regs + DF_FP_PM);
+		writel(val | DF_FP_PM_P, par->df_regs + DF_FP_PM);
+		val = readl(par->df_regs + DF_MISC) & ~DF_MISC_DAC_PWRDN;
+		writel(val, par->df_regs + DF_MISC);
+
+		val = readl(par->dc_regs + DC_GENERAL_CFG) | DC_GCFG_DFLE;
+		writel(val, par->dc_regs + DC_GENERAL_CFG);
+
+		val = readl(par->dc_regs + DC_DISPLAY_CFG) | DC_DCFG_TGEN;
+		writel(val, par->dc_regs + DC_DISPLAY_CFG);
+	}
+
+	dcfg = readl(par->df_regs + DF_DISPLAY_CFG);
 
 	/* CRT power saving modes. */
 	switch (blank_mode) {
 	case FB_BLANK_UNBLANK:
-		blank = 0; hsync = 1; vsync = 1;
+		dcfg |= DF_DCFG_CRT_EN | DF_DCFG_HSYNC_EN | DF_DCFG_VSYNC_EN;
+		dcfg |= DF_DCFG_DAC_BL_EN;
 		break;
 	case FB_BLANK_NORMAL:
-		blank = 1; hsync = 1; vsync = 1;
+		dcfg |= DF_DCFG_CRT_EN | DF_DCFG_HSYNC_EN | DF_DCFG_VSYNC_EN;
+		dcfg |= DF_DCFG_DAC_BL_EN;
 		break;
 	case FB_BLANK_VSYNC_SUSPEND:
-		blank = 1; hsync = 1; vsync = 0;
+		dcfg |= DF_DCFG_CRT_EN | DF_DCFG_HSYNC_EN | DF_DCFG_DAC_BL_EN;
+		dcfg &= ~DF_DCFG_VSYNC_EN;
 		break;
 	case FB_BLANK_HSYNC_SUSPEND:
-		blank = 1; hsync = 0; vsync = 1;
+		dcfg |= DF_DCFG_CRT_EN | DF_DCFG_VSYNC_EN | DF_DCFG_DAC_BL_EN;
+		dcfg &= ~DF_DCFG_HSYNC_EN;
 		break;
 	case FB_BLANK_POWERDOWN:
-		blank = 1; hsync = 0; vsync = 0;
+		dcfg &= ~DF_DCFG_DAC_BL_EN;
+		dcfg &= ~(DF_DCFG_CRT_EN | DF_DCFG_HSYNC_EN | DF_DCFG_VSYNC_EN);
 		break;
 	default:
+		writel(0, par->dc_regs + DC_UNLOCK);
 		return -EINVAL;
 	}
 
-	dcfg = readl(par->df_regs + DF_DISPLAY_CFG);
-	dcfg &= ~(DF_DCFG_DAC_BL_EN
-		  | DF_DCFG_HSYNC_EN | DF_DCFG_VSYNC_EN);
-	if (!blank)
-		dcfg |= DF_DCFG_DAC_BL_EN;
-	if (hsync)
-		dcfg |= DF_DCFG_HSYNC_EN;
-	if (vsync)
-		dcfg |= DF_DCFG_VSYNC_EN;
-	writel(dcfg, par->df_regs + DF_DISPLAY_CFG);
+	/* Turn off the engine when we are in power down mode */
+	if (blank_mode == FB_BLANK_POWERDOWN) {
+		val = readl(par->df_regs + DF_MISC) | DF_MISC_DAC_PWRDN;
+		writel(val, par->df_regs + DF_MISC);
+
+		val = readl(par->dc_regs + DC_DISPLAY_CFG);
+		val &= ~DC_DCFG_TGEN;
+		writel(val, par->dc_regs + DC_DISPLAY_CFG);
+
+		udelay(1000);
+
+		val = readl(par->dc_regs + DC_GENERAL_CFG) & ~DC_GCFG_DFLE;
+		writel(val, par->dc_regs + DC_GENERAL_CFG);
+
+		val = readl(par->df_regs + DF_FP_PM);
+		writel(val & ~DF_FP_PM_P, par->df_regs + DF_FP_PM);
+	}
 
+	writel(0, par->dc_regs + DC_UNLOCK);
+
+	lx_blank_mode = blank_mode;
+	return 0;
+}
+
+static struct geoderegs saved_regs;
+
+static void lx_save_regs(struct fb_info *info, struct geoderegs *regs)
+{
+	struct lxfb_par *par = info->par;
+	int i;
+	u32 filt;
+
+	/* Wait for the command buffer to empty */
+	while(!(readl(par->gp_regs + 0x44) & (1 << 4)));
+
+	/* Unlock the DC */
+	writel(DC_UNLOCK_CODE, par->dc_regs + DC_UNLOCK);
+
+	rdmsrl(MSR_LX_DF_PADSEL, regs->msr.padsel);
+	rdmsrl(MSR_LX_GLCP_DOTPLL, regs->msr.dotpll);
+	rdmsrl(MSR_LX_DF_GLCONFIG, regs->msr.dfglcfg);
+	rdmsrl(MSR_LX_DC_SPARE, regs->msr.dcspare);
+
+	writel(0x4758, par->dc_regs + 0x00);
+
+	memcpy(regs->gp.b, par->gp_regs, GP_REG_SIZE);
+	memcpy(regs->dc.b, par->dc_regs, DC_REG_SIZE);
+	memcpy(regs->vp.b, par->df_regs, VP_REG_SIZE);
+	memcpy(regs->fp.b, par->df_regs + VP_FP_START, FP_REG_SIZE);
+
+	/* Save the palette */
+	writel(0, par->dc_regs + 0x70);
 	/* Power on/off flat panel */
+	for(i = 0; i < DC_PAL_SIZE; i++)
+		regs->pal[i] = readl(par->dc_regs + 0x74);
 
-	if (par->output & OUTPUT_PANEL) {
-		fp_pm = readl(par->df_regs + DF_FP_PM);
-		if (blank_mode == FB_BLANK_POWERDOWN)
-			fp_pm &= ~DF_FP_PM_P;
-		else
-			fp_pm |= DF_FP_PM_P;
-		writel(fp_pm, par->df_regs + DF_FP_PM);
+	/* save the filter coefficients */
+
+	filt = readl(par->dc_regs + 0x94);
+	filt |= DC_IRQFILT_H_FILT_SEL;
+
+	for(i = 0; i < DC_HFILT_SIZE; i++) {
+		writel((filt & 0xFFFFFF00) | i, par->dc_regs + 0x94);
+		regs->hcoeff[i << 1] = readl(par->dc_regs + 0x98);
+		regs->hcoeff[(i << 1) + 1] = readl(par->dc_regs + 0x9c);
+	}
+
+	filt &= ~DC_IRQFILT_H_FILT_SEL;
+
+	for(i = 0; i < DC_VFILT_SIZE; i++) {
+		writel((filt & 0xFFFFFF00) | i, par->dc_regs + 0x94);
+		regs->vcoeff[i] = readl(par->dc_regs + 0x98);
 	}
 
+	/* Save the vg filter coefficients */
+	for(i = 0; i < VP_COEFF_COUNT; i++)
+		regs->vp_coeff[i] =
+			readl(par->df_regs + 0x1000 + (i << 2));
+
+	/* Save the VP gamma */
+
+	writel(0, par->df_regs + 0x38);
+
+	for(i = 0; i <= 0xFF; i++)
+		regs->gamma[i] = readl(par->df_regs + 0x40);
+}
+
+static void lx_restore_dc(struct lxfb_par *par, struct geoderegs *regs)
+{
+	u32 filt;
+	int i;
+
+	/* Unlock the registers */
+	writel(DC_UNLOCK_CODE, par->dc_regs + 0x00);
+
+	/* Restore the framebuffer offset */
+	writel(regs->dc.r.gliu0_mem_offset, par->dc_regs + 0x84);
+
+	/* Blank the configuration registers while we restore */
+	writel(0, par->dc_regs + 0x04);
+	writel(0, par->dc_regs + 0x08);
+
+	/* Restore the bulk of the registers */
+
+	writel(regs->dc.r.arb, par->dc_regs + 0x0C);
+	writel(regs->dc.r.fb_st_offset, par->dc_regs + 0x10);
+	writel(regs->dc.r.cb_st_offset, par->dc_regs + 0x14);
+	writel(regs->dc.r.curs_st_offset, par->dc_regs + 0x18);
+
+	/* skip 0x1c */
+
+	writel(regs->dc.r.vid_y_st_offset, par->dc_regs + 0x20);
+	writel(regs->dc.r.vid_u_st_offset, par->dc_regs + 0x24);
+	writel(regs->dc.r.vid_v_st_offset, par->dc_regs + 0x28);
+
+	writel(regs->dc.r.dctop, par->dc_regs + 0x2c);
+	writel(regs->dc.r.line_size, par->dc_regs + 0x30);
+	writel(regs->dc.r.gfx_pitch, par->dc_regs + 0x34);
+	writel(regs->dc.r.vid_yuv_pitch, par->dc_regs + 0x38);
+	writel(regs->dc.r.h_active_timing, par->dc_regs + 0x40);
+	writel(regs->dc.r.h_blank_timing, par->dc_regs + 0x44);
+	writel(regs->dc.r.h_sync_timing, par->dc_regs + 0x48);
+	writel(regs->dc.r.v_active_timing, par->dc_regs + 0x50);
+	writel(regs->dc.r.v_blank_timing, par->dc_regs + 0x54);
+	writel(regs->dc.r.v_sync_timing, par->dc_regs + 0x58);
+	writel(regs->dc.r.fbactive, par->dc_regs + 0x5c);
+	writel(regs->dc.r.dc_cursor_x, par->dc_regs + 0x60);
+	writel(regs->dc.r.dc_cursor_y, par->dc_regs + 0x64);
+
+	/* skip 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c */
+
+	writel(regs->dc.r.dc_vid_ds_delta, par->dc_regs + 0x80);
+
+	/* 0x84 was written above */
+
+	writel(regs->dc.r.dv_ctl | 0x01, par->dc_regs + 0x88);
+	writel(regs->dc.r.gfx_scale, par->dc_regs + 0x90);
+	writel(regs->dc.r.irq_filt_ctl, par->dc_regs + 0x94);
+
+	/* skip 0x98, 0x9c */
+
+	writel(regs->dc.r.vbi_event_ctl, par->dc_regs + 0xA0);
+	writel(regs->dc.r.vbi_odd_ctl, par->dc_regs + 0xA4);
+	writel(regs->dc.r.vbi_hor, par->dc_regs + 0xA8);
+	writel(regs->dc.r.vbi_ln_odd, par->dc_regs + 0xAC);
+	writel(regs->dc.r.vbi_ln_event, par->dc_regs + 0xB0);
+	writel(regs->dc.r.vbi_pitch, par->dc_regs + 0xB4);
+	writel(regs->dc.r.clr_key, par->dc_regs + 0xB8);
+	writel(regs->dc.r.clr_key_mask, par->dc_regs + 0xBC);
+	writel(regs->dc.r.clr_key_x, par->dc_regs + 0xC0);
+	writel(regs->dc.r.clr_key_y, par->dc_regs + 0xC4);
+	writel(regs->dc.r.irq, par->dc_regs + 0xC8);
+	writel(regs->dc.r.genlk_ctrl, par->dc_regs + 0xD4);
+	writel(regs->dc.r.vid_even_y_st_offset, par->dc_regs + 0xD8);
+	writel(regs->dc.r.vid_even_u_st_offset, par->dc_regs + 0xDC);
+	writel(regs->dc.r.vid_even_v_st_offset, par->dc_regs + 0xE0);
+	writel(regs->dc.r.v_active_even_timing, par->dc_regs + 0xE4);
+	writel(regs->dc.r.v_blank_even_timing, par->dc_regs + 0xE8);
+	writel(regs->dc.r.v_sync_even_timing, par->dc_regs + 0xEC);
+
+	/* Restore the palette */
+	writel(0, par->dc_regs + 0x70);
+
+	for(i = 0; i < DC_PAL_SIZE; i++)
+		writel(regs->pal[i], par->dc_regs + 0x74);
+
+	/* Restore the horizontal filter coefficients */
+	filt = readl(par->dc_regs + 0x94);
+	filt |= DC_IRQFILT_H_FILT_SEL;
+
+	for(i = 0; i < DC_HFILT_SIZE; i++) {
+		writel(((filt & 0xFFFFFF00) | i), par->dc_regs + 0x94);
+		writel(regs->hcoeff[i << 1], par->dc_regs + 0x98);
+		writel(regs->hcoeff[(i << 1) + 1], par->dc_regs + 0x9c);
+	}
+
+	filt &= ~DC_IRQFILT_H_FILT_SEL;
+
+	for(i = 0; i < DC_VFILT_SIZE; i++) {
+		writel(((filt & 0xFFFFFF00) | i), par->dc_regs + 0x94);
+		writel(regs->vcoeff[i], par->dc_regs + 0x98);
+	}
+
+	/* Turn on the dotpll */
+	lx_set_dotpll((u32) (regs->msr.dotpll >> 32));
+
+	/* Restore MSRs */
+	wrmsrl(MSR_LX_DC_SPARE, regs->msr.dcspare);
+
+	/* Restore the configuration registers */
+
+	writel(regs->dc.r.dcfg, par->dc_regs + 0x08);
+	writel(regs->dc.r.gcfg, par->dc_regs + 0x04);
+
+	/* Lock the DC again */
+	writel(0, par->dc_regs + 0x00);
+}
+
+static void lx_restore_vp(struct lxfb_par *par, struct geoderegs *regs)
+{
+	u32 val;
+	int i;
+
+	/* Restore MSRs */
+
+	wrmsrl(MSR_LX_DF_GLCONFIG, regs->msr.dfglcfg);
+	wrmsrl(MSR_LX_DF_PADSEL, regs->msr.padsel);
+
+	/* Restore the registers */
+
+	writel((u32) regs->vp.r.vx, par->df_regs + 0x10);
+	writel((u32) regs->vp.r.vy, par->df_regs + 0x18);
+	writel((u32) regs->vp.r.vs, par->df_regs + 0x20);
+	writel((u32) regs->vp.r.vck, par->df_regs + 0x28);
+	writel((u32) regs->vp.r.vcm, par->df_regs + 0x30);
+	/* skip 0x38 and 0x40 */
+	writel((u32) regs->vp.r.slr, par->df_regs + 0x48);
+	writel((u32) regs->vp.r.misc, par->df_regs + 0x50);
+	/* skip 0x58 */
+	writel((u32) regs->vp.r.vys, par->df_regs + 0x60);
+	writel((u32) regs->vp.r.vxs, par->df_regs + 0x68);
+	writel((u32) regs->vp.r.vde, par->df_regs + 0x98);
+	writel((u32) regs->vp.r.cck, par->df_regs + 0xA0);
+	writel((u32) regs->vp.r.ccm, par->df_regs + 0xA8);
+	writel((u32) regs->vp.r.cc1, par->df_regs + 0xB0);
+	writel((u32) regs->vp.r.cc2, par->df_regs + 0xB8);
+	writel((u32) regs->vp.r.a1x, par->df_regs + 0xC0);
+	writel((u32) regs->vp.r.a1y, par->df_regs + 0xC8);
+	writel((u32) regs->vp.r.a1c, par->df_regs + 0xD0);
+	writel((u32) regs->vp.r.a1t, par->df_regs + 0xD8);
+	writel((u32) regs->vp.r.a2x, par->df_regs + 0xE0);
+	writel((u32) regs->vp.r.a2y, par->df_regs + 0xE8);
+	writel((u32) regs->vp.r.a2c, par->df_regs + 0xF0);
+	writel((u32) regs->vp.r.a2t, par->df_regs + 0xF8);
+	writel((u32) regs->vp.r.a3x, par->df_regs + 0x100);
+	writel((u32) regs->vp.r.a3y, par->df_regs + 0x108);
+	writel((u32) regs->vp.r.a3c, par->df_regs + 0x110);
+	writel((u32) regs->vp.r.a3t, par->df_regs + 0x118);
+	writel((u32) regs->vp.r.vrr, par->df_regs + 0x120);
+	writel((u32) regs->vp.r.vye, par->df_regs + 0x138);
+	writel((u32) regs->vp.r.a1ye, par->df_regs + 0x140);
+	writel((u32) regs->vp.r.a2ye, par->df_regs + 0x148);
+	writel((u32) regs->vp.r.a3ye, par->df_regs + 0x150);
+
+	/* Panel */
+
+	writel((u32) regs->fp.r.pt1, par->df_regs + 0x400);
+	writel((u32) regs->fp.r.pt2, par->df_regs + 0x408);
+	writel((u32) regs->fp.r.dfc, par->df_regs + 0x418);
+
+	/* Restore panel power */
+
+	val = readl(par->df_regs + 0x410);
+
+	if (regs->fp.r.pm & (1 << 24)) {
+		if (!(val & 0x09))
+                       writel(regs->fp.r.pm, par->df_regs + 0x410);
+	}
+	else {
+		if (!(val & 0x05))
+			writel(regs->fp.r.pm, par->df_regs + 0x410);
+	}
+
+	/* Restore the vp palette */
+
+	writel(0, par->df_regs + 0x38);
+
+	for(i = 0; i <= 0xFF; i++)
+		writel((u32) regs->gamma[i], par->df_regs + 0x40);
+
+	/* Restore filter coefficients */
+
+	for(i = 0; i < VP_COEFF_COUNT; i++)
+		writel(regs->vp_coeff[i],
+		       par->df_regs + 0x1000 + (i << 2));
+
+	/* Restore the configuration registers */
+
+	writel((u32) regs->vp.r.dcfg, par->df_regs + 0x08);
+	writel((u32) regs->vp.r.vcfg, par->df_regs + 0x00);
+}
+
+static void lx_restore_gp(struct lxfb_par *par, struct geoderegs *regs)
+{
+	writel(regs->gp.r.dst_offset, par->gp_regs + 0x00);
+	writel(regs->gp.r.src_offset, par->gp_regs + 0x04);
+	writel(regs->gp.r.stride, par->gp_regs + 0x08);
+	writel(regs->gp.r.wid_height, par->gp_regs + 0x0C);
+	writel(regs->gp.r.src_color_fg, par->gp_regs + 0x10);
+	writel(regs->gp.r.src_color_bg, par->gp_regs + 0x14);
+	writel(regs->gp.r.pat_color_0, par->gp_regs + 0x18);
+	writel(regs->gp.r.pat_color_1, par->gp_regs + 0x1C);
+	writel(regs->gp.r.pat_color_2, par->gp_regs + 0x20);
+	writel(regs->gp.r.pat_color_3, par->gp_regs + 0x24);
+	writel(regs->gp.r.pat_color_4, par->gp_regs + 0x28);
+	writel(regs->gp.r.pat_color_5, par->gp_regs + 0x2C);
+	writel(regs->gp.r.pat_data_0, par->gp_regs + 0x30);
+	writel(regs->gp.r.pat_data_1, par->gp_regs + 0x34);
+
+	/* Writing to these registers would cause a blt to happen */
+	/* 0x38, 0x3c, 0x40 */
+
+	/* Status register (0x44) is read only */
+
+	writel(regs->gp.r.hst_src, par->gp_regs + 0x48);
+	writel(regs->gp.r.base_offset, par->gp_regs + 0x4c);
+	writel(regs->gp.r.cmd_top, par->gp_regs + 0x50);
+	writel(regs->gp.r.cmd_bot, par->gp_regs + 0x54);
+	writel(regs->gp.r.cmd_read, par->gp_regs + 0x58);
+	writel(regs->gp.r.cmd_write, par->gp_regs + 0x5C);
+	writel(regs->gp.r.ch3_offset, par->gp_regs + 0x60);
+	writel(regs->gp.r.ch3_mode_str, par->gp_regs + 0x64);
+	writel(regs->gp.r.ch3_width, par->gp_regs + 0x6C);
+	writel(regs->gp.r.ch3_hsrc, par->gp_regs + 0x70);
+
+	writel(regs->gp.r.int_cntrl, par->gp_regs + 0x70);
+}
+
+static void lx_restore_regs(struct fb_info *info, struct geoderegs *regs)
+{
+	struct lxfb_par *par = info->par;
+
+	lx_restore_gp(par, regs);
+	lx_restore_vp(par, regs);
+	lx_restore_dc(par, regs);
+}
+
+static int lx_power_on = 1;
+
+int lx_shutdown(struct fb_info *info)
+{
+	if (lx_power_on == 0)
+		return 0;
+
+	lx_save_regs(info, &saved_regs);
+	lx_graphics_disable(info);
+
+	lx_power_on = 0;
+	return 0;
+}
+
+int lx_powerup(struct fb_info *info)
+{
+	if (lx_power_on == 1)
+		return 0;
+
+	lx_restore_regs(info, &saved_regs);
+
+	lx_power_on = 1;
 	return 0;
 }
diff -purN linux_2.6.24_org/drivers/video/geode/Makefile linux_2.6.24_olpc/drivers/video/geode/Makefile
--- linux_2.6.24_org/drivers/video/geode/Makefile	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/Makefile	2008-02-15 18:58:41.000000000 +0000
@@ -5,5 +5,5 @@ obj-$(CONFIG_FB_GEODE_GX)  += gxfb.o
 obj-$(CONFIG_FB_GEODE_LX)  += lxfb.o
 
 gx1fb-objs := gx1fb_core.o display_gx1.o video_cs5530.o
-gxfb-objs  := gxfb_core.o display_gx.o video_gx.o
+gxfb-objs  := gxfb_core.o display_gx.o video_gx.o suspend_gx.o
 lxfb-objs  := lxfb_core.o lxfb_ops.o
diff -purN linux_2.6.24_org/drivers/video/geode/suspend_gx.c linux_2.6.24_olpc/drivers/video/geode/suspend_gx.c
--- linux_2.6.24_org/drivers/video/geode/suspend_gx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/video/geode/suspend_gx.c	2008-02-15 18:58:41.000000000 +0000
@@ -0,0 +1,272 @@
+#include <linux/fb.h>
+#include <asm/io.h>
+#include <asm/msr.h>
+
+#include "geodefb.h"
+#include "video_gx.h"
+
+void gx_set_dotpll(struct fb_info *info, struct geoderegs *regs)
+{
+	int timeout = 1000;
+
+	u64 rstpll, dotpll;
+	
+	rdmsrl(MSR_GLCP_SYS_RSTPLL, rstpll);
+	rdmsrl(MSR_GLCP_DOTPLL, dotpll);
+
+	dotpll &= 0x00000000ffffffffull;
+	dotpll |= regs->msr.dotpll & 0xffffffff00000000ull;
+	
+	dotpll |= MSR_GLCP_DOTPLL_DOTRESET;
+	dotpll &= ~MSR_GLCP_DOTPLL_BYPASS;
+	
+	wrmsrl(MSR_GLCP_DOTPLL, dotpll);
+
+	rstpll |= (regs->msr.rstpll & 
+		   ( MSR_GLCP_SYS_RSTPLL_DOTPREDIV2  |
+		     MSR_GLCP_SYS_RSTPLL_DOTPREMULT2 |
+		     MSR_GLCP_SYS_RSTPLL_DOTPOSTDIV3));
+	
+	wrmsrl(MSR_GLCP_SYS_RSTPLL, rstpll);
+	dotpll &= ~(MSR_GLCP_DOTPLL_DOTRESET);
+	wrmsrl(MSR_GLCP_DOTPLL, dotpll);
+
+	do {
+		rdmsrl(MSR_GLCP_DOTPLL, dotpll);
+	} while (timeout-- && !(dotpll & MSR_GLCP_DOTPLL_LOCK));
+}
+
+/* FIXME: Make sure nothing is read to clear */
+
+void gx_save_regs(struct fb_info *info, struct geoderegs *regs)
+{
+	struct geodefb_par *par = info->par;
+	int i;
+
+	/* Wait for the BLT engine to stop being busy */
+	while(readl(par->gp_regs + 0x44) & 0x05);
+
+	rdmsrl(GX_VP_MSR_PAD_SELECT, regs->msr.padsel);
+	rdmsrl(MSR_GLCP_DOTPLL, regs->msr.dotpll);
+	rdmsrl(MSR_GLCP_SYS_RSTPLL, regs->msr.rstpll);
+
+	writel(0x4758, par->dc_regs + 0x00);
+
+	memcpy(regs->gp.b, par->gp_regs, GP_REG_SIZE);
+	memcpy(regs->dc.b, par->dc_regs, DC_REG_SIZE);
+	memcpy(regs->vp.b, par->vid_regs, VP_REG_SIZE);
+	memcpy(regs->fp.b, par->vid_regs + 0x400, FP_REG_SIZE);
+
+	/* Save the palettes */
+	writel(0, par->dc_regs + 0x70);
+
+	for(i = 0; i < DC_PAL_SIZE; i++) 
+		regs->pal[i] = readl(par->dc_regs + 0x74);
+	
+	writel(0, par->vid_regs + 0x38);
+
+	for(i = 0; i < 0xFF; i++)
+		regs->gamma[i] = readl(par->vid_regs + 0x40);       	
+}
+
+void gx_restore_regs(struct fb_info *info, struct geoderegs *regs)
+{
+	struct geodefb_par *par = info->par;
+	u32 val, i;
+
+	/* DOTPLL */
+	gx_set_dotpll(info, regs);
+
+	/* GP */
+
+	writel(regs->gp.r.dst_offset, par->gp_regs + 0x00);
+	writel(regs->gp.r.src_offset, par->gp_regs + 0x04);
+	writel(regs->gp.r.stride, par->gp_regs + 0x08);
+	writel(regs->gp.r.wid_height, par->gp_regs + 0x0C);
+	writel(regs->gp.r.src_color_fg, par->gp_regs + 0x10);
+	writel(regs->gp.r.src_color_bg, par->gp_regs + 0x14);
+	writel(regs->gp.r.pat_color_0, par->gp_regs + 0x18);
+	writel(regs->gp.r.pat_color_1, par->gp_regs + 0x1C);
+	writel(regs->gp.r.pat_color_2, par->gp_regs + 0x20);
+	writel(regs->gp.r.pat_color_3, par->gp_regs + 0x24);
+	writel(regs->gp.r.pat_color_4, par->gp_regs + 0x28);
+	writel(regs->gp.r.pat_color_5, par->gp_regs + 0x2C);
+	writel(regs->gp.r.pat_data_0, par->gp_regs + 0x30);
+	writel(regs->gp.r.pat_data_1, par->gp_regs + 0x34);
+
+	/* Don't write the raster / vector / blt mode regs */
+	/* status register is read only */
+
+	writel(regs->gp.r.hst_src, par->gp_regs + 0x48);
+	writel(regs->gp.r.base_offset, par->gp_regs + 0x4c);
+	
+	/* DC */
+	
+	/* Write the unlock value */
+	writel(0x4758, par->dc_regs + 0x00);
+
+	writel(0, par->dc_regs + 0x70);
+	
+	for(i = 0; i < DC_PAL_SIZE; i++)
+		writel(regs->pal[i], par->dc_regs + 0x74);
+
+	/* Write the gcfg register without the enables */
+	writel(regs->dc.r.gcfg & ~0x0F, par->dc_regs + 0x04);
+	
+	/* Write the vcfg register without the enables */
+	writel(regs->dc.r.dcfg & ~0x19, par->dc_regs + 0x08);
+	
+	/* Write the rest of the active registers */
+
+	writel(regs->dc.r.fb_st_offset, par->dc_regs + 0x10);
+	writel(regs->dc.r.cb_st_offset, par->dc_regs + 0x14);
+	writel(regs->dc.r.curs_st_offset, par->dc_regs + 0x18);
+	writel(regs->dc.r.icon_st_offset, par->dc_regs + 0x1C);
+	writel(regs->dc.r.vid_y_st_offset, par->dc_regs + 0x20);
+	writel(regs->dc.r.vid_u_st_offset, par->dc_regs + 0x24);
+	writel(regs->dc.r.vid_v_st_offset, par->dc_regs + 0x28);
+	writel(regs->dc.r.line_size, par->dc_regs + 0x30);
+	writel(regs->dc.r.gfx_pitch, par->dc_regs + 0x34);
+	writel(regs->dc.r.vid_yuv_pitch, par->dc_regs + 0x38);
+	writel(regs->dc.r.h_active_timing, par->dc_regs + 0x40);
+	writel(regs->dc.r.h_blank_timing, par->dc_regs + 0x44);
+	writel(regs->dc.r.h_sync_timing, par->dc_regs + 0x48);
+	writel(regs->dc.r.v_active_timing, par->dc_regs + 0x50);
+	writel(regs->dc.r.v_blank_timing, par->dc_regs + 0x54);
+	writel(regs->dc.r.v_sync_timing, par->dc_regs + 0x58);
+	writel(regs->dc.r.dc_cursor_x, par->dc_regs + 0x60);
+	writel(regs->dc.r.dc_cursor_y, par->dc_regs + 0x64);
+	writel(regs->dc.r.dc_icon_x, par->dc_regs + 0x68);
+	
+	/* Don't write the line_cnt or diag registers */
+
+	writel(regs->dc.r.dc_vid_ds_delta, par->dc_regs + 0x80);
+	writel(regs->dc.r.gliu0_mem_offset, par->dc_regs + 0x84);
+	writel(regs->dc.r.dv_acc, par->dc_regs + 0x8C);
+	
+	/* VP */
+
+	/* MSR */
+	wrmsrl(GX_VP_MSR_PAD_SELECT, regs->msr.padsel);
+
+	writel(0, par->vid_regs + 0x38);
+	
+	for(i = 0; i < 0xFF; i++)
+		writel((u32) regs->gamma[i], par->vid_regs + 0x40);   
+
+	/* Don't enable video yet */
+	writel((u32) regs->vp.r.vcfg & ~0x01, par->vid_regs + 0x00);
+
+	/* Don't enable the CRT yet */
+	writel((u32) regs->vp.r.dcfg & ~0x0F, par->vid_regs + 0x08);
+
+	/* Write the rest of the VP registers */
+
+	writel((u32) regs->vp.r.vx, par->vid_regs + 0x10);
+	writel((u32) regs->vp.r.vy, par->vid_regs + 0x18);
+	writel((u32) regs->vp.r.vs, par->vid_regs + 0x20);
+	writel((u32) regs->vp.r.vck, par->vid_regs + 0x28);
+	writel((u32) regs->vp.r.vcm, par->vid_regs + 0x30);
+	writel((u32) regs->vp.r.misc, par->vid_regs + 0x50);
+	writel((u32) regs->vp.r.ccs, par->vid_regs + 0x58);
+	writel((u32) regs->vp.r.vdc, par->vid_regs + 0x78);
+	writel((u32) regs->vp.r.vco, par->vid_regs + 0x80);
+	writel((u32) regs->vp.r.crc, par->vid_regs + 0x88);
+	writel((u32) regs->vp.r.vde, par->vid_regs + 0x98);
+	writel((u32) regs->vp.r.cck, par->vid_regs + 0xA0);
+	writel((u32) regs->vp.r.ccm, par->vid_regs + 0xA8);
+	writel((u32) regs->vp.r.cc1, par->vid_regs + 0xB0);
+	writel((u32) regs->vp.r.cc2, par->vid_regs + 0xB8);
+	writel((u32) regs->vp.r.a1x, par->vid_regs + 0xC0);
+	writel((u32) regs->vp.r.a1y, par->vid_regs + 0xC8);
+	writel((u32) regs->vp.r.a1c, par->vid_regs + 0xD0);
+	writel((u32) regs->vp.r.a1t, par->vid_regs + 0xD8);
+	writel((u32) regs->vp.r.a2x, par->vid_regs + 0xE0);
+	writel((u32) regs->vp.r.a2y, par->vid_regs + 0xE8);
+	writel((u32) regs->vp.r.a2c, par->vid_regs + 0xF0);
+	writel((u32) regs->vp.r.a2t, par->vid_regs + 0xF8);
+	writel((u32) regs->vp.r.a3x, par->vid_regs + 0x100);
+	writel((u32) regs->vp.r.a3y, par->vid_regs + 0x108);
+	writel((u32) regs->vp.r.a3c, par->vid_regs + 0x110);
+	writel((u32) regs->vp.r.a3t, par->vid_regs + 0x118);
+	writel((u32) regs->vp.r.vrr, par->vid_regs + 0x120);
+	
+	
+	/* FP registers */
+	
+	writel((u32) regs->fp.r.pt1, par->vid_regs + 0x400);
+	writel((u32) regs->fp.r.pt2, par->vid_regs + 0x408);
+
+	writel((u32) regs->fp.r.dfc, par->vid_regs + 0x418);
+	writel(regs->fp.r.blfsr, par->vid_regs + 0x420);
+	writel(regs->fp.r.rlfsr, par->vid_regs + 0x428);
+	writel(regs->fp.r.fmi, par->vid_regs + 0x430);
+	writel(regs->fp.r.fmd, par->vid_regs + 0x438);
+	writel(regs->fp.r.dca, par->vid_regs + 0x448);
+	writel(regs->fp.r.dmd, par->vid_regs + 0x450);
+	writel(regs->fp.r.crc, par->vid_regs + 0x458);
+	writel(regs->fp.r.fbb, par->vid_regs + 0x460);
+	
+	/* Final enables */
+
+	val = readl(par->vid_regs + 0x410);
+
+	/* Control the panel */
+	if (regs->fp.r.pm & (1 << 24)) {
+
+		if (!(val & 0x09))
+			writel(regs->fp.r.pm, par->vid_regs + 0x410);
+	}
+	else {
+		if (!(val & 0x05))
+			writel(regs->fp.r.pm, par->vid_regs + 0x410);
+	}
+       	
+	/* Turn everything on */
+
+	writel(regs->dc.r.gcfg, par->dc_regs + 0x04);
+	writel((u32) regs->vp.r.vcfg, par->vid_regs + 0x00);
+	writel((u32) regs->vp.r.dcfg, par->vid_regs + 0x08);
+	writel(regs->dc.r.dcfg, par->dc_regs + 0x08);
+}
+
+
+#ifdef DEBUG
+
+void dump_regs(struct fb_info *info, int mode) {
+
+	struct geodefb_par *par = info->par;
+	u32 val;
+	int i;
+
+	if (mode == 0) {
+		for(i = 0; i < GP_REG_SIZE; i += 4) {
+			val = readl(par->gp_regs + i);
+		}
+	}
+
+	if (mode == 1) {
+		writel(0x4758, par->dc_regs + 0x00);
+
+		for(i = 0; i < DC_REG_SIZE; i += 4) {
+			val = readl(par->dc_regs + i);
+			printk("DC%x: %x\n", i, val);
+		}
+	}
+
+	if (mode == 2) {
+		for(i = 0; i < VP_REG_SIZE; i += 8) {
+			val = readl(par->vid_regs + i);
+			printk("VP%x: %x\n", i, val);
+		}
+	}
+
+	if (mode == 3) {
+		for(i = 0; i < FP_REG_SIZE; i += 8) {
+			val = readl(par->vid_regs + 0x400 + i);
+			printk("FP%x: %x\n", i, val);
+		}
+	}
+}
+
+#endif
diff -purN linux_2.6.24_org/drivers/video/geode/video_gx.c linux_2.6.24_olpc/drivers/video/geode/video_gx.c
--- linux_2.6.24_org/drivers/video/geode/video_gx.c	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/video_gx.c	2008-02-15 18:58:41.000000000 +0000
@@ -16,10 +16,14 @@
 #include <asm/io.h>
 #include <asm/delay.h>
 #include <asm/msr.h>
+#include <asm/olpc.h>
 
 #include "geodefb.h"
 #include "video_gx.h"
+#include "display_gx.h"
 
+/* This structure is used to store the saved registers during suspend */
+static struct geoderegs gx_saved_regs;
 
 /*
  * Tables of register settings for various DOTCLKs.
@@ -58,7 +62,7 @@ static const struct gx_pll_entry gx_pll_
 	{ 13888, POSTDIV3,	    0x000007E1 },	/*  72.0000 */
 	{ 13426, PREMULT2,	    0x00000F4A },	/*  74.4810 */
 	{ 13333, 0,		    0x00000052 },	/*  75.0000 */
-	{ 12698, 0,		    0x00000056 },	/*  78.7500 */
+	{ 12698, 0,		    0x00000056 },       /*  78.7500 */
 	{ 12500, POSTDIV3|PREMULT2, 0x00000709 },	/*  80.0000 */
 	{ 11135, PREMULT2,	    0x00000262 },	/*  89.8000 */
 	{ 10582, 0,		    0x000002D2 },	/*  94.5000 */
@@ -117,8 +121,9 @@ static const struct gx_pll_entry gx_pll_
 	{  4357, 0, 0x0000057D },	/* 229.5000 */
 };
 
-static void gx_set_dclk_frequency(struct fb_info *info)
+void gx_set_dclk_frequency(struct fb_info *info)
 {
+	struct geodefb_par *par = info->par;
 	const struct gx_pll_entry *pll_table;
 	int pll_table_len;
 	int i, best_i;
@@ -173,115 +178,169 @@ static void gx_set_dclk_frequency(struct
 	do {
 		rdmsrl(MSR_GLCP_DOTPLL, dotpll);
 	} while (timeout-- && !(dotpll & MSR_GLCP_DOTPLL_LOCK));
+
+	par->curdclk = pll_table[best_i].dotpll_value;
 }
 
-static void
-gx_configure_tft(struct fb_info *info)
+/* Find out the current clock - we will use this information to avoid
+   re-programming it if we don't need to */
+
+unsigned int gx_get_dclk(struct fb_info *info)
 {
-	struct geodefb_par *par = info->par;
-	unsigned long val;
-	unsigned long fp;
+	const struct gx_pll_entry *pll_table;
+	int pll_table_len;
+	u64 dotpll;
+	int i;
 
-	/* Set up the DF pad select MSR */
+	if (cpu_data(0).x86_mask == 1) {
+		pll_table = gx_pll_table_14MHz;
+		pll_table_len = ARRAY_SIZE(gx_pll_table_14MHz);
+	} else {
+		pll_table = gx_pll_table_48MHz;
+		pll_table_len = ARRAY_SIZE(gx_pll_table_48MHz);
+	}
 
-	rdmsrl(GX_VP_MSR_PAD_SELECT, val);
-	val &= ~GX_VP_PAD_SELECT_MASK;
-	val |= GX_VP_PAD_SELECT_TFT;
-	wrmsrl(GX_VP_MSR_PAD_SELECT, val);
+	rdmsrl(MSR_GLCP_DOTPLL, dotpll);
 
-	/* Turn off the panel */
+	for(i = 0; i < pll_table_len; i++) {
+		if (pll_table[i].dotpll_value == (u32) (dotpll >> 32))
+			break;
+	}
+
+	return (i == pll_table_len) ? 0 : pll_table[i].pixclock;
+}
 
-	fp = readl(par->vid_regs + GX_FP_PM);
-	fp &= ~GX_FP_PM_P;
-	writel(fp, par->vid_regs + GX_FP_PM);
 
-	/* Set timing 1 */
+#define CMP(val, mask, res) (((val) & (mask)) == (res))
 
-	fp = readl(par->vid_regs + GX_FP_PT1);
-	fp &= GX_FP_PT1_VSIZE_MASK;
-	fp |= info->var.yres << GX_FP_PT1_VSIZE_SHIFT;
-	writel(fp, par->vid_regs + GX_FP_PT1);
+static void
+gx_configure_tft(struct fb_info *info) {
 
-	/* Timing 2 */
-	/* Set bits that are always on for TFT */
+	struct geodefb_par *par = info->par;
+	u32 val, fp = 0, fp1, fp2, sync = 0;
 
-	fp = 0x0F100000;
+	/* Set up the DF pad select MSR */
 
-	/* Add sync polarity */
+	rdmsrl(GX_VP_MSR_PAD_SELECT, val);
+
+	if ((val & GX_VP_PAD_SELECT_MASK) != GX_VP_PAD_SELECT_TFT) {
+		val &= ~GX_VP_PAD_SELECT_MASK;
+		val |= GX_VP_PAD_SELECT_TFT;
+		wrmsrl(GX_VP_MSR_PAD_SELECT, val);
+	}
 
 	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
-		fp |= GX_FP_PT2_VSP;
+		sync |= GX_FP_PT2_VSP;
 
 	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
-		fp |= GX_FP_PT2_HSP;
+		sync |= GX_FP_PT2_HSP;
 
-	writel(fp, par->vid_regs + GX_FP_PT2);
+	/* We only need to turn off the panel if something changed */
 
-	/*  Set the dither control */
-	writel(0x70, par->vid_regs + GX_FP_DFC);
+	fp1 = readl(par->vid_regs + GX_FP_PT1);
+	fp2 = readl(par->vid_regs + GX_FP_PT2);
+
+	if (!CMP(fp1, GX_FP_PT1_VSIZE_MASK, info->var.yres << GX_FP_PT1_VSIZE_SHIFT) ||
+	    (fp2 != (0x0F100000 | sync))) {
+
+		/* Turn off the panel */
+
+#ifdef NOTUSED
+		/* Do we really need to turn off the panel? */
+		/* Possibly - we have a glitch somewhere */
 
-	/* Enable the FP data and power (in case the BIOS didn't) */
+		fp = readl(par->vid_regs + GX_FP_PM);
+		fp &= ~GX_FP_PM_P;
+		writel(fp, par->vid_regs + GX_FP_PM);
+#endif
 
-	fp = readl(par->vid_regs + GX_DCFG);
-	fp |= GX_DCFG_FP_PWR_EN | GX_DCFG_FP_DATA_EN;
-	writel(fp, par->vid_regs + GX_DCFG);
+		/* Timing 1 */
+		fp1 &= GX_FP_PT1_VSIZE_MASK;
+		fp1 |= info->var.yres << GX_FP_PT1_VSIZE_SHIFT;
+		writel(fp, par->vid_regs + GX_FP_PT1);
 
-	/* Unblank the panel */
+		/* Timing 2 */
+		writel(0x0F100000 | sync, par->vid_regs + GX_FP_PT2);
+	}
+
+	/*  Set the dither control */
+	if (readl(par->vid_regs + GX_FP_DFC) != 0x70) {
+		writel(0x70, par->vid_regs + GX_FP_DFC);
+	}
+
+	/* Turn on the panel */
 
 	fp = readl(par->vid_regs + GX_FP_PM);
-	fp |= GX_FP_PM_P;
-	writel(fp, par->vid_regs + GX_FP_PM);
+
+	if (!(fp & 0x09))
+		writel(fp | GX_FP_PM_P, par->vid_regs + GX_FP_PM);
 }
 
+#define DCFG_DEFAULT_VAL GX_DCFG_CRT_SYNC_SKW_DFLT | GX_DCFG_HSYNC_EN | GX_DCFG_VSYNC_EN | \
+GX_DCFG_CRT_EN | GX_DCFG_DAC_BL_EN
+
 static void gx_configure_display(struct fb_info *info)
 {
 	struct geodefb_par *par = info->par;
-	u32 dcfg, misc;
+	u32 dcfg, misc, sync = 0;
 
 	/* Set up the MISC register */
-
 	misc = readl(par->vid_regs + GX_MISC);
 
-	/* Power up the DAC */
-	misc &= ~(GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN);
+	/* We leave gamma enabled if it was already enabled.
+	   Although the hardware enables it without setting
+	   up the gamma table, the BIOS or bootloader ought
+	   to have either disabled it or loaded a table by now */
 
-	/* Disable gamma correction */
-	misc |= GX_MISC_GAM_EN;
 
-	writel(misc, par->vid_regs + GX_MISC);
 
-	/* Write the display configuration */
-	dcfg = readl(par->vid_regs + GX_DCFG);
+	if (par->enable_crt) {
+		/* Power up the CRT DACs */
+		if (misc & ( GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN)) {
+			misc &= ~(GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN);
+			writel(misc, par->vid_regs + GX_MISC);
+		}
 
-	/* Disable hsync and vsync */
-	dcfg &= ~(GX_DCFG_VSYNC_EN | GX_DCFG_HSYNC_EN);
-	writel(dcfg, par->vid_regs + GX_DCFG);
+		if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+			sync |= GX_DCFG_CRT_HSYNC_POL;
 
-	/* Clear bits from existing mode. */
-	dcfg &= ~(GX_DCFG_CRT_SYNC_SKW_MASK
-		  | GX_DCFG_CRT_HSYNC_POL   | GX_DCFG_CRT_VSYNC_POL
-		  | GX_DCFG_VSYNC_EN        | GX_DCFG_HSYNC_EN);
+		if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+			sync |= GX_DCFG_CRT_VSYNC_POL;
+	}
+	else {
+		/* Turn off the CRT DACs in FP mode - we don't need them */
+		if ((misc & (GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN))) {
+			misc |= (GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN);
+			writel(misc, par->vid_regs + GX_MISC);
+		}
+	}
 
-	/* Set default sync skew.  */
-	dcfg |= GX_DCFG_CRT_SYNC_SKW_DFLT;
+	/* Write the display configuration */
+	dcfg = readl(par->vid_regs + GX_DCFG);
 
-	/* Enable hsync and vsync. */
-	dcfg |= GX_DCFG_HSYNC_EN | GX_DCFG_VSYNC_EN;
+	if (!CMP(dcfg, DCFG_DEFAULT_VAL | GX_DCFG_CRT_HSYNC_POL | GX_DCFG_CRT_VSYNC_POL,
+		 DCFG_DEFAULT_VAL | sync)) {
 
-	/* Sync polarities. */
-	if (info->var.sync & FB_SYNC_HOR_HIGH_ACT)
-		dcfg |= GX_DCFG_CRT_HSYNC_POL;
-	if (info->var.sync & FB_SYNC_VERT_HIGH_ACT)
-		dcfg |= GX_DCFG_CRT_VSYNC_POL;
+		/* Disable hsync and vsync */
+		dcfg &= ~(GX_DCFG_VSYNC_EN | GX_DCFG_HSYNC_EN);
+		writel(dcfg, par->vid_regs + GX_DCFG);
 
-	/* Enable the display logic */
-	/* Set up the DACS to blank normally */
+		/* Clear bits from existing mode. */
+		dcfg &= ~(GX_DCFG_CRT_SYNC_SKW_MASK
+			  | GX_DCFG_CRT_HSYNC_POL   | GX_DCFG_CRT_VSYNC_POL
+			  | GX_DCFG_VSYNC_EN        | GX_DCFG_HSYNC_EN);
 
-	dcfg |= GX_DCFG_CRT_EN | GX_DCFG_DAC_BL_EN;
+		/* Set default sync skew.  */
+		dcfg |= GX_DCFG_CRT_SYNC_SKW_DFLT;
 
-	/* Enable the external DAC VREF? */
+		/* Enable hsync and vsync. */
+		dcfg |= GX_DCFG_HSYNC_EN | GX_DCFG_VSYNC_EN;
 
-	writel(dcfg, par->vid_regs + GX_DCFG);
+		/* Enable the display logic */
+		dcfg |= GX_DCFG_CRT_EN | GX_DCFG_DAC_BL_EN;
+
+		writel(dcfg, par->vid_regs + GX_DCFG);
+	}
 
 	/* Set up the flat panel (if it is enabled) */
 
@@ -289,6 +348,100 @@ static void gx_configure_display(struct 
 		gx_configure_tft(info);
 }
 
+int gxfb_powerdown(struct fb_info *info) 
+{
+	struct geodefb_par *par = info->par;
+
+	/* We're already suspended */
+
+	if (par->state != FB_POWER_STATE_ON)
+		return 0;
+
+	/* Save the registers */
+	gx_save_regs(info, &gx_saved_regs);
+
+	/* Shut down the engine */
+
+	writel(gx_saved_regs.vp.r.vcfg & ~0x01, par->vid_regs + GX_VCFG);
+	writel(gx_saved_regs.vp.r.dcfg & ~0x0F, par->vid_regs + GX_DCFG);
+
+	/* Turn off the flat panel unless we are attached to a DCON */
+	if (!olpc_has_dcon())
+		writel(gx_saved_regs.fp.r.pm & ~GX_FP_PM_P, par->vid_regs + GX_FP_PM);
+
+	writel(0x4758, par->dc_regs + DC_UNLOCK);
+
+	writel(gx_saved_regs.dc.r.gcfg & ~0x0F,
+	       par->dc_regs + DC_GENERAL_CFG);
+
+	writel(gx_saved_regs.dc.r.dcfg & ~0x19,
+	       par->dc_regs + DC_DISPLAY_CFG);
+	
+	par->state = FB_POWER_STATE_SUSPEND;
+
+	return 0;
+}
+
+int gxfb_powerup(struct fb_info *info)
+{
+	struct geodefb_par *par = info->par;
+	u32 val;
+
+	if (par->state == FB_POWER_STATE_SUSPEND) {
+
+		writel(gx_saved_regs.dc.r.dcfg,
+		       par->dc_regs + DC_DISPLAY_CFG);
+
+		writel(gx_saved_regs.vp.r.vcfg, par->vid_regs + GX_VCFG);
+		writel(gx_saved_regs.vp.r.dcfg, par->vid_regs + GX_DCFG);
+
+		val = readl(par->vid_regs + GX_FP_PM);
+
+		/* power up the panel if it needs it; we don't always power it down */
+		if (!(val & 0x09)) {
+			writel(gx_saved_regs.fp.r.pm, par->vid_regs + GX_FP_PM);
+			mdelay(64);
+		}
+	}
+
+	/* If the panel is currently on its way up, then wait up to 100ms
+	   for it */
+	
+	if (readl(par->vid_regs + GX_FP_PM) & 0x08) {
+		int i;
+		
+		for(i = 0; i < 10; i++) {
+			if (readl(par->vid_regs + GX_FP_PM) & 0x01)
+				break;
+
+			mdelay(10);
+		}
+
+		if (i == 10) 
+			printk(KERN_ERR "gxfb:  Panel power up timed out\n");
+	}
+
+	if (par->state == FB_POWER_STATE_ON)
+		return 0;
+	
+	switch(par->state) {
+	case FB_POWER_STATE_OFF:
+		gx_restore_regs(info, &gx_saved_regs);
+		break;
+
+	case FB_POWER_STATE_SUSPEND:
+		/* Do this because it will turn on the FIFO which will
+	   	   start the line count */
+		writel(gx_saved_regs.dc.r.gcfg,
+		       par->dc_regs + DC_GENERAL_CFG);
+		writel(0x0, par->dc_regs + DC_UNLOCK);
+		break;
+	}
+
+	par->state = FB_POWER_STATE_ON;
+	return 0;
+}
+
 static int gx_blank_display(struct fb_info *info, int blank_mode)
 {
 	struct geodefb_par *par = info->par;
@@ -315,6 +468,7 @@ static int gx_blank_display(struct fb_in
 	default:
 		return -EINVAL;
 	}
+
 	dcfg = readl(par->vid_regs + GX_DCFG);
 	dcfg &= ~(GX_DCFG_DAC_BL_EN
 		  | GX_DCFG_HSYNC_EN | GX_DCFG_VSYNC_EN);
@@ -326,7 +480,7 @@ static int gx_blank_display(struct fb_in
 		dcfg |= GX_DCFG_VSYNC_EN;
 	writel(dcfg, par->vid_regs + GX_DCFG);
 
-	/* Power on/off flat panel. */
+	/* Power on/off flat panel */
 
 	if (par->enable_crt == 0) {
 		fp_pm = readl(par->vid_regs + GX_FP_PM);
@@ -340,8 +494,37 @@ static int gx_blank_display(struct fb_in
 	return 0;
 }
 
+extern struct fb_info *gxfb_info;
+
+/* This function controls the flatpanel power sequencing - this is used
+   by the OLPC power management engine to enable the FP sequencing much
+   earlier in the resume process
+*/
+
+void gxfb_flatpanel_control(int state)
+{
+	struct geodefb_par *par = gxfb_info->par;
+	u32 val, fp = readl(par->vid_regs + GX_FP_PM);
+	val  = fp;
+
+	/* Turn on the panel if it isn't aleady */
+
+	if (state) {
+		if (!(val & 0x01))
+			val |= GX_FP_PM_P;
+	}
+	else {
+		if (!(val & 0x02))
+			val &= ~GX_FP_PM_P;
+	}
+
+	if (val != fp)
+		writel(val, par->vid_regs + GX_FP_PM);
+}
+
 struct geode_vid_ops gx_vid_ops = {
 	.set_dclk	   = gx_set_dclk_frequency,
+	.get_dclk          = gx_get_dclk,
 	.configure_display = gx_configure_display,
 	.blank_display	   = gx_blank_display,
 };
diff -purN linux_2.6.24_org/drivers/video/geode/video_gx.h linux_2.6.24_olpc/drivers/video/geode/video_gx.h
--- linux_2.6.24_org/drivers/video/geode/video_gx.h	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/geode/video_gx.h	2008-02-15 18:58:41.000000000 +0000
@@ -11,6 +11,8 @@
 #ifndef __VIDEO_GX_H__
 #define __VIDEO_GX_H__
 
+#include "geode_regs.h"
+
 extern struct geode_vid_ops gx_vid_ops;
 
 /* GX Flatpanel control MSR */
@@ -20,6 +22,8 @@ extern struct geode_vid_ops gx_vid_ops;
 
 /* Geode GX video processor registers */
 
+#define GX_VCFG         0x0000
+
 #define GX_DCFG		0x0008
 #  define GX_DCFG_CRT_EN		0x00000001
 #  define GX_DCFG_HSYNC_EN		0x00000002
@@ -42,6 +46,14 @@ extern struct geode_vid_ops gx_vid_ops;
 #define GX_MISC_DAC_PWRDN  0x00000400
 #define GX_MISC_A_PWRDN    0x00000800
 
+/* Gamma correction RAM - address and data registers */
+
+#define GX_GAR 0x038
+#define GX_GDR 0x040
+
+#define GXFB_GAMMA_DWORDS 256 /* number of dwords in the gamma ram */
+#define GXFB_GAMMA_SIZE (GXFB_GAMMA_DWORDS * sizeof(unsigned int))
+
 /* Geode GX flat panel display control registers */
 
 #define GX_FP_PT1 0x0400
@@ -69,4 +81,13 @@ extern struct geode_vid_ops gx_vid_ops;
 #  define MSR_GLCP_DOTPLL_BYPASS		(0x0000000000008000ull)
 #  define MSR_GLCP_DOTPLL_LOCK			(0x0000000002000000ull)
 
+int gxfb_powerdown(struct fb_info *info);
+int gxfb_powerup(struct fb_info *info);
+
+void gx_set_dclk_frequency(struct fb_info *info);
+unsigned int gx_get_dclk(struct fb_info *info);
+
+void gx_save_regs(struct fb_info *info, struct geoderegs *regs);
+void gx_restore_regs(struct fb_info *info, struct geoderegs *regs);
+
 #endif /* !__VIDEO_GX_H__ */
diff -purN linux_2.6.24_org/drivers/video/Kconfig linux_2.6.24_olpc/drivers/video/Kconfig
--- linux_2.6.24_org/drivers/video/Kconfig	2008-02-15 20:11:22.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/Kconfig	2008-02-15 18:58:36.000000000 +0000
@@ -1869,6 +1869,15 @@ config FB_PS3_DEFAULT_SIZE_M
 	  The default value can be overridden on the kernel command line
 	  using the "ps3fb" option (e.g. "ps3fb=9M");
 
+config FB_OLPC_DCON
+	tristate "One Laptop Per Child Display CONtroller support"
+	depends on OLPC
+	select I2C
+	---help---
+	  Add support for the OLPC DCON controller.  This controller is only
+	  available on OLPC platforms.   Unless you have one of these
+	  platforms, you will want to say 'N'.
+
 config FB_XILINX
 	tristate "Xilinx frame buffer support"
 	depends on FB && XILINX_VIRTEX
diff -purN linux_2.6.24_org/drivers/video/Makefile linux_2.6.24_olpc/drivers/video/Makefile
--- linux_2.6.24_org/drivers/video/Makefile	2008-02-15 20:11:22.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/Makefile	2008-02-15 18:58:36.000000000 +0000
@@ -111,6 +111,7 @@ obj-$(CONFIG_FB_PNX4008_DUM_RGB)  += pnx
 obj-$(CONFIG_FB_IBM_GXT4500)	  += gxt4500.o
 obj-$(CONFIG_FB_PS3)		  += ps3fb.o
 obj-$(CONFIG_FB_SM501)            += sm501fb.o
+obj-$(CONFIG_FB_OLPC_DCON)	  += olpc_dcon.o
 obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
 obj-$(CONFIG_FB_OMAP)             += omap/
 
diff -purN linux_2.6.24_org/drivers/video/modedb.c linux_2.6.24_olpc/drivers/video/modedb.c
--- linux_2.6.24_org/drivers/video/modedb.c	2008-02-15 20:11:23.000000000 +0000
+++ linux_2.6.24_olpc/drivers/video/modedb.c	2008-02-15 18:58:41.000000000 +0000
@@ -33,6 +33,8 @@ const char *fb_mode_option;
      *  Standard video mode definitions (taken from XFree86)
      */
 
+#define DEFAULT_MODEDB_INDEX	0
+
 static const struct fb_videomode modedb[] = {
     {
 	/* 640x400 @ 70 Hz, 31.5 kHz hsync */
@@ -508,7 +510,8 @@ int fb_find_mode(struct fb_var_screeninf
     }
 
     if (!default_mode)
-	default_mode = &db[0];
+	    default_mode = (db == modedb) ?
+		    &modedb[DEFAULT_MODEDB_INDEX] : &db[0];
 
     if (!default_bpp)
 	default_bpp = 8;
diff -purN linux_2.6.24_org/drivers/video/olpc_dcon.c linux_2.6.24_olpc/drivers/video/olpc_dcon.c
--- linux_2.6.24_org/drivers/video/olpc_dcon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/video/olpc_dcon.c	2008-02-15 18:58:42.000000000 +0000
@@ -0,0 +1,946 @@
+/*
+ * Mainly by David Woodhouse, somewhat modified by Jordan Crouse
+ *
+ * Copyright © 2006-2007  Red Hat, Inc.
+ * Copyright © 2006-2007  Advanced Micro Devices, Inc.
+ *
+ * This program is free software.  You can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/i2c-id.h>
+#include <linux/pci.h>
+#include <linux/vt_kern.h>
+#include <linux/pci_ids.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/backlight.h>
+#include <linux/device.h>
+#include <linux/notifier.h>
+#include <asm/uaccess.h>
+#include <linux/ctype.h>
+#include <linux/reboot.h>
+#include <asm/tsc.h>
+#include <asm/olpc.h>
+#include <asm/geode.h>
+
+#include "olpc_dcon.h"
+
+/* Module definitions */
+
+static int resumeline = 898;
+module_param(resumeline, int, 0444);
+
+static int noinit;
+module_param(noinit, int, 0444);
+
+/* Default off since it doesn't work on DCON ASIC in B-test OLPC board */
+static int useaa = 1;
+module_param(useaa, int, 0444);
+
+/* I2C structures */
+
+static struct i2c_driver dcon_driver;
+static struct i2c_client *dcon_client;
+
+/* Platform devices */
+static struct platform_device *dcon_device;
+
+/* Backlight device */
+static struct backlight_device *dcon_bl_dev;
+
+/* Base address of the GPIO registers */
+static unsigned long gpio_base;
+
+static struct fb_info *fbinfo;
+
+/* Current source, initialized at probe time */
+static int dcon_source;
+
+/* Desired source */
+static int dcon_pending;
+
+/* Current output type */
+static int dcon_output = DCON_OUTPUT_COLOR;
+
+/* Current sleep status (not yet implemented) */
+static int dcon_sleep_val = DCON_ACTIVE;
+
+/* Shadow register for the DCON_REG_MODE register */
+static unsigned short dcon_disp_mode;
+
+/* Variables used during switches */
+static int dcon_switched;
+
+static DECLARE_WAIT_QUEUE_HEAD(dcon_wait_queue);
+
+static unsigned short normal_i2c[] = { 0x0D, I2C_CLIENT_END };
+I2C_CLIENT_INSMOD;
+
+#define dcon_write(reg,val) i2c_smbus_write_word_data(dcon_client,reg,val)
+#define dcon_read(reg) i2c_smbus_read_word_data(dcon_client,reg)
+
+/* The current backlight value - this saves us some smbus traffic */
+static int bl_val = -1;
+
+/* ===== API functions - these are called by a variety of users ==== */
+
+static int dcon_request_irq(void);
+
+static int dcon_hw_init(struct i2c_client *client, int is_init)
+{
+	uint16_t ver;
+	int rc = 0;
+
+	ver = i2c_smbus_read_word_data(client, DCON_REG_ID);
+	if ((ver >> 8) != 0xDC) {
+		printk(KERN_ERR "olpc-dcon:  DCON ID not 0xDCxx: 0x%04x "
+				"instead.\n", ver);
+		rc = -ENXIO;
+		goto err;
+	}
+
+	if (is_init) {
+		printk(KERN_INFO "olpc-dcon:  Discovered DCON version %x\n",
+				ver & 0xFF);
+		if ((rc = dcon_request_irq())) {
+			printk(KERN_ERR "olpc-dcon:  Unable to grab IRQ.\n");
+			goto err;
+		}
+	}
+
+	if (ver < 0xdc02 && !noinit) {
+		/* Initialize the DCON registers */
+
+		/* Start with work-arounds for DCON ASIC */
+		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
+		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
+		i2c_smbus_write_word_data(client, 0x4b, 0x00cc);
+		i2c_smbus_write_word_data(client, 0x0b, 0x007a);
+		i2c_smbus_write_word_data(client, 0x36, 0x025c);
+		i2c_smbus_write_word_data(client, 0x37, 0x025e);
+		
+		/* Initialise SDRAM */
+
+		i2c_smbus_write_word_data(client, 0x3b, 0x002b);
+		i2c_smbus_write_word_data(client, 0x41, 0x0101);
+		i2c_smbus_write_word_data(client, 0x42, 0x0101);
+	}
+	else if (!noinit) {
+		/* SDRAM setup/hold time */
+		i2c_smbus_write_word_data(client, 0x3a, 0xc040);
+		i2c_smbus_write_word_data(client, 0x41, 0x0000);
+		i2c_smbus_write_word_data(client, 0x41, 0x0101);
+		i2c_smbus_write_word_data(client, 0x42, 0x0101);
+	}
+
+	/* Colour swizzle, AA, no passthrough, backlight */
+	if (is_init) {
+		dcon_disp_mode = MODE_PASSTHRU | MODE_BL_ENABLE | MODE_CSWIZZLE;
+		if (useaa)
+			dcon_disp_mode |= MODE_COL_AA;
+	}
+	i2c_smbus_write_word_data(client, DCON_REG_MODE, dcon_disp_mode);
+
+
+	/* Set the scanline to interrupt on during resume */
+
+	i2c_smbus_write_word_data(client, DCON_REG_SCAN_INT, resumeline);
+
+err:
+	return rc;
+}
+
+/*
+ * The smbus doesn't always come back due to what is believed to be
+ * hardware (power rail) bugs.  For older models where this is known to
+ * occur, our solution is to attempt to wait for the bus to stabilize;
+ * if it doesn't happen, cut power to the dcon, repower it, and wait
+ * for the bus to stabilize.  Rinse, repeat until we have a working
+ * smbus.  For newer models, we simply BUG(); we want to know if this
+ * still happens despite the power fixes that have been made!
+ */
+static int dcon_bus_stabilize(struct i2c_client *client, int is_powered_down)
+{
+	unsigned long timeout;
+	int x;
+
+power_up:
+	if (is_powered_down) {
+		x = 1;
+		if ((x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0))) {
+			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
+					"to power up: %d!\n", x);
+			return x;
+		}
+		msleep(10); /* we'll be conservative */
+	}
+	
+	/*
+	 * According to HiMax, when powering the DCON up we should hold
+	 * SMB_DATA high for 8 SMB_CLK cycles.  This will force the DCON
+	 * state machine to reset to a (sane) initial state.  Mitch Bradley
+	 * did some testing and discovered that holding for 16 SMB_CLK cycles
+	 * worked a lot more reliably, so that's what we do here.
+	 *
+	 * According to the cs5536 spec, to set GPIO14 to SMB_CLK we must
+	 * simultaneously set AUX1 IN/OUT to GPIO14; ditto for SMB_DATA and
+	 * GPIO15.
+ 	 */
+	geode_gpio_set(OLPC_GPIO_SMB_CLK|OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_VAL);
+	geode_gpio_set(OLPC_GPIO_SMB_CLK|OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_ENABLE);
+	geode_gpio_clear(OLPC_GPIO_SMB_CLK|OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_AUX1);
+	geode_gpio_clear(OLPC_GPIO_SMB_CLK|OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_AUX2);
+	geode_gpio_clear(OLPC_GPIO_SMB_CLK|OLPC_GPIO_SMB_DATA, GPIO_INPUT_AUX1);
+
+	for (x = 0; x < 16; x++) {
+		udelay(5);
+		geode_gpio_clear(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_VAL);
+		udelay(5);
+		geode_gpio_set(OLPC_GPIO_SMB_CLK, GPIO_OUTPUT_VAL);
+	}
+	udelay(5);
+	geode_gpio_set(OLPC_GPIO_SMB_CLK|OLPC_GPIO_SMB_DATA, GPIO_OUTPUT_AUX1);
+	geode_gpio_set(OLPC_GPIO_SMB_CLK|OLPC_GPIO_SMB_DATA, GPIO_INPUT_AUX1);
+
+	for (x = -1, timeout = 50; timeout && x < 0; timeout--) {
+		msleep(1);
+		x = dcon_read(DCON_REG_ID);
+	}
+	if (x < 0) {
+		printk(KERN_ERR "olpc-dcon:  unable to stabilize dcon's "
+				"smbus, reasserting power and praying.\n");
+		BUG_ON(olpc_board_at_least(olpc_board(0xc2)));
+		x = 0;
+		olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0);
+		msleep(100);
+		is_powered_down = 1;
+		goto power_up;	/* argh, stupid hardware.. */
+	}
+
+	if (is_powered_down)
+		return dcon_hw_init(client, 0);
+	return 0;
+}
+
+
+/* Backlight notes - turning off the backlight enable bit in the DCON
+ * doesn't save us any power over just pushing the BL to zero, so we
+ * don't use that bit in this code.
+ */
+
+static int dcon_get_backlight(void)
+{
+	if (dcon_client == NULL)
+		return 0;
+
+	if (bl_val == -1)
+		bl_val = dcon_read(DCON_REG_BRIGHT) & 0x0F;
+
+	return bl_val;
+}
+
+static void dcon_set_backlight(int level)
+{
+	if (dcon_client == NULL)
+		return;
+
+	if (bl_val == (level & 0x0F))
+		return;
+
+	bl_val = level & 0x0F;
+	dcon_write(DCON_REG_BRIGHT, bl_val);
+
+	/* Purposely turn off the backlight when we go to level 0 */
+
+	if (bl_val == 0) {
+	  dcon_disp_mode &= ~MODE_BL_ENABLE;
+	  dcon_write(DCON_REG_MODE, dcon_disp_mode);
+	}
+	else if (!(dcon_disp_mode & MODE_BL_ENABLE)) {
+	  dcon_disp_mode |= MODE_BL_ENABLE;
+	  dcon_write(DCON_REG_MODE, dcon_disp_mode);
+	}
+}
+
+/* Set the output type to either color or mono */
+
+static int dcon_set_output(int arg)
+{
+	if (dcon_output == arg)
+		return 0;
+
+	dcon_output = arg;
+
+	if (arg == DCON_OUTPUT_MONO) {
+		dcon_disp_mode &= ~(MODE_CSWIZZLE | MODE_COL_AA);
+		dcon_disp_mode |= MODE_MONO_LUMA;
+	}
+	else {
+		dcon_disp_mode &= ~(MODE_MONO_LUMA);
+		dcon_disp_mode |= MODE_CSWIZZLE;
+		if (useaa)
+			dcon_disp_mode |= MODE_COL_AA;
+	}
+
+	dcon_write(DCON_REG_MODE, dcon_disp_mode);
+	return 0;
+}
+
+/* For now, this will be really stupid - we need to address how
+ * DCONLOAD works in a sleep and account for it accordingly
+ */
+
+static void dcon_sleep(int state)
+{
+	int x;
+
+	/* Turn off the backlight and put the DCON to sleep */
+
+	if (state == dcon_sleep_val)
+		return;
+
+	if (!olpc_board_at_least(olpc_board(0xc2)))
+		return;
+
+	if (state == DCON_SLEEP) {
+		x = 0;
+		if ((x = olpc_ec_cmd(0x26, (unsigned char *) &x, 1, NULL, 0)))
+			printk(KERN_WARNING "olpc-dcon:  unable to force dcon "
+					"to power down: %d!\n", x);
+		else
+			dcon_sleep_val = state;
+	}
+	else {
+		/* Only re-enable the backlight if the backlight value is set */
+		if (bl_val != 0)
+			dcon_disp_mode |= MODE_BL_ENABLE;
+
+		if ((x=dcon_bus_stabilize(dcon_client, 1)))
+			printk(KERN_WARNING "olpc-dcon:  unable to reinit dcon"
+					" hardware: %d!\n", x);
+		else
+			dcon_sleep_val = state;
+	}
+
+	/* We should turn off some stuff in the framebuffer - but what? */
+}
+
+/* Set the source of the display (CPU or DCON) */
+
+static void dcon_source_switch(struct work_struct *work)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int source = dcon_pending;
+
+	if (dcon_source == source)
+		return;
+
+	dcon_switched = 0;
+
+	switch (source) {
+	case DCON_SOURCE_CPU:
+
+		/* Enable the scanline interrupt bit */
+		if (dcon_write(DCON_REG_MODE, dcon_disp_mode | MODE_SCAN_INT))
+			printk(KERN_ERR "olpc-dcon:  couldn't enable scanline interrupt!\n");
+		else {
+			/* Wait up to one second for the scanline interrupt */
+			wait_event_timeout(dcon_wait_queue, dcon_switched == 1, HZ);
+		}
+
+		if (!dcon_switched)
+			printk(KERN_ERR "olpc-dcon:  Timeout entering CPU mode; expect a screen glitch.\n");
+
+		/*
+		 * Ideally we'd like to disable interrupts here so that the
+		 * fb unblanking and DCON turn on happen at a known time value;
+		 * however, we can't do that right now with fb_blank
+		 * messing with semaphores.
+		 *
+		 * For now, we just hope..
+		 */
+		acquire_console_sem();
+		if (fb_blank(fbinfo, FB_BLANK_UNBLANK)) {
+			release_console_sem();
+			printk(KERN_ERR "olpc-dcon:  Failed to enter CPU mode\n");
+			dcon_pending = DCON_SOURCE_DCON;
+			return;
+		}
+		release_console_sem();
+
+		/* And turn off the DCON */
+		outl(1<<11, gpio_base + GPIOx_OUT_VAL);
+
+		/* Turn off the scanline interrupt */
+		if (dcon_write(DCON_REG_MODE, dcon_disp_mode))
+			printk(KERN_ERR "olpc-dcon:  couldn't disable scanline interrupt!\n");
+
+		printk(KERN_INFO "olpc-dcon: The CPU has control\n");
+		break;
+	case DCON_SOURCE_DCON:
+	{
+		int t;
+
+		add_wait_queue(&dcon_wait_queue, &wait);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+
+		/* Clear GPIO11 (DCONLOAD) - this implies that the DCON is in
+		   control */
+
+		outl(1 << (11 + 16), gpio_base + GPIOx_OUT_VAL);
+
+		t = schedule_timeout(HZ/2);
+		remove_wait_queue(&dcon_wait_queue, &wait);
+		set_current_state(TASK_RUNNING);
+
+		if (!dcon_switched)
+			printk(KERN_ERR "olpc-dcon: Timeout entering DCON mode; expect a screen glitch.\n");
+
+		acquire_console_sem();
+		if (fb_blank(fbinfo, FB_BLANK_POWERDOWN))
+			printk(KERN_ERR "olpc-dcon:  couldn't blank fb!\n");
+		release_console_sem();
+
+		printk(KERN_INFO "olpc-dcon: The DCON has control\n");
+		break;
+	}
+	default:
+		BUG();
+	}
+
+	dcon_source = source;
+}
+
+static DECLARE_WORK(dcon_work, dcon_source_switch);
+
+static int dcon_set_source(int arg)
+{
+	if (arg != DCON_SOURCE_CPU && arg != DCON_SOURCE_DCON)
+		return -EINVAL;
+
+	if (dcon_pending == arg)
+		return 0;
+
+	dcon_pending = arg;
+	if ((dcon_source != arg) && !work_pending(&dcon_work))
+		schedule_work(&dcon_work);
+
+	return 0;
+}
+
+static int dcon_set_source_sync(int arg)
+{
+	int ret = dcon_set_source(arg);
+	if (!ret)
+		flush_scheduled_work();
+	return ret;
+}
+
+static int dconbl_set(struct backlight_device *dev) {
+
+	int level = dev->props.brightness;
+
+	if (dev->props.power != FB_BLANK_UNBLANK)
+		level = 0;
+
+	dcon_set_backlight(level);
+	return 0;
+}
+
+static int dconbl_get(struct backlight_device *dev) {
+	return dcon_get_backlight();
+}
+
+static ssize_t dcon_mode_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%4.4X\n", dcon_disp_mode);
+}
+
+static ssize_t dcon_sleep_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", dcon_sleep_val);
+}
+
+static ssize_t /* __deprecated */ dcon_source_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	printk(KERN_WARNING "olpc-dcon:  using deprecated sysfs 'source' interface; use 'freeze' instead!\n");
+	return sprintf(buf, "%d\n", dcon_source);
+}
+
+static ssize_t dcon_freeze_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", dcon_source == DCON_SOURCE_DCON ? 1 : 0);
+}
+
+static ssize_t dcon_output_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", dcon_output);
+}
+
+static ssize_t dcon_resumeline_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", resumeline);
+}
+
+static int _strtoul(const char *buf, int len, unsigned int *val)
+{
+
+	char *endp;
+	unsigned int output = simple_strtoul(buf, &endp, 0);
+	int size = endp - buf;
+
+	if (*endp && isspace(*endp))
+		size++;
+
+	if (size != len)
+		return -EINVAL;
+
+	*val = output;
+	return 0;
+}
+
+static ssize_t dcon_output_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int output;
+	int rc = -EINVAL;
+
+	if (_strtoul(buf, count, &output))
+		return -EINVAL;
+
+	if (output == DCON_OUTPUT_COLOR || output == DCON_OUTPUT_MONO) {
+		dcon_set_output(output);
+		rc = count;
+	}
+
+	return rc;
+}
+
+static ssize_t /* __deprecated */ dcon_source_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int output;
+	int rc = -EINVAL;
+
+	printk(KERN_WARNING "olpc-dcon:  using deprecated sysfs 'source' interface; use 'freeze' instead!\n");
+	if (_strtoul(buf, count, &output))
+		return -EINVAL;
+
+	dcon_set_source(output);
+	rc = count;
+
+	return rc;
+}
+
+static ssize_t dcon_freeze_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int output;
+	int rc = -EINVAL;
+
+	if (_strtoul(buf, count, &output))
+		return rc;
+
+	dcon_set_source(output ? DCON_SOURCE_DCON : DCON_SOURCE_CPU);
+	rc = count;
+
+	return rc;
+}
+
+static ssize_t dcon_resumeline_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rl;
+	int rc = -EINVAL;
+
+	if (_strtoul(buf, count, &rl))
+		return rc;
+
+	resumeline = rl;
+	dcon_write(DCON_REG_SCAN_INT, resumeline);
+	rc = count;
+
+	return rc;
+}
+
+static ssize_t dcon_sleep_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int output;
+
+	if (_strtoul(buf, count, &output))
+		return -EINVAL;
+
+	dcon_sleep(output ? DCON_SLEEP : DCON_ACTIVE);
+	return count;
+}
+
+static struct device_attribute dcon_device_files[] = {
+	__ATTR(mode, 0444, dcon_mode_show, NULL),
+	__ATTR(sleep, 0644, dcon_sleep_show, dcon_sleep_store),
+	__ATTR(source, 0644, dcon_source_show, dcon_source_store),
+	__ATTR(freeze, 0644, dcon_freeze_show, dcon_freeze_store),
+	__ATTR(output, 0644, dcon_output_show, dcon_output_store),
+	__ATTR(resumeline, 0644, dcon_resumeline_show, dcon_resumeline_store),
+};
+
+static struct backlight_ops dcon_bl_ops = {
+	.get_brightness = dconbl_get,
+	.update_status = dconbl_set
+};
+
+/* List of GPIOs that we care about:
+   (in)  GPIO12   -- DCONBLNK
+   (in)  GPIO[56] -- DCONSTAT[01]
+   (out) GPIO11   -- DCONLOAD
+*/
+
+#define IN_GPIOS ((1<<5) | (1<<6) | (1<<7) | (1<<12))
+#define OUT_GPIOS (1<<11)
+
+static irqreturn_t dcon_interrupt(int, void *);
+
+static int dcon_request_irq(void)
+{
+	unsigned long lo, hi;
+	unsigned char lob;
+
+	rdmsr(MSR_LBAR_GPIO, lo, hi);
+
+	/* Check the mask and whether GPIO is enabled (sanity check) */
+	if (hi != 0x0000f001) {
+		printk(KERN_ERR "GPIO not enabled -- cannot use DCON\n");
+		return -ENODEV;
+	}
+
+	/* Mask off the IO base address */
+	gpio_base = lo & 0x0000ff00;
+
+	/* Turn off the event enable for GPIO7 just to be safe */
+	outl(1 << (16+7), gpio_base + GPIOx_EVNT_EN);
+
+	/* Set the directions for the GPIO pins */
+	outl(OUT_GPIOS | (IN_GPIOS << 16), gpio_base + GPIOx_OUT_EN);
+	outl(IN_GPIOS | (OUT_GPIOS << 16), gpio_base + GPIOx_IN_EN);
+
+	/* Set up the interrupt mappings */
+
+	/* Set the IRQ to pair 2 */
+	geode_gpio_event_irq(OLPC_GPIO_DCON_IRQ, 2);
+
+	/* Enable group 2 to trigger the DCON interrupt */
+	geode_gpio_set_irq(2, DCON_IRQ);
+
+	/* Select edge level for interrupt (in PIC) */
+
+	lob = inb(0x4d0);
+	lob &= ~(1 << DCON_IRQ);
+	outb(lob, 0x4d0);
+
+	/* Register the interupt handler */
+	if (request_irq(DCON_IRQ, &dcon_interrupt, 0, "DCON", &dcon_driver))
+		return -EIO;
+
+	/* Clear INV_EN for GPIO7 (DCONIRQ) */
+	outl((1<<(16+7)), gpio_base + GPIOx_INV_EN);
+
+	/* Enable filter for GPIO12 (DCONBLANK) */
+	outl(1<<(12), gpio_base + GPIOx_IN_FLTR_EN);
+
+	/* Disable filter for GPIO7 */
+	outl(1<<(16+7), gpio_base + GPIOx_IN_FLTR_EN);
+
+	/* Disable event counter for GPIO7 (DCONIRQ) and GPIO12 (DCONBLANK) */
+
+	outl(1<<(16+7), gpio_base + GPIOx_EVNTCNT_EN);
+	outl(1<<(16+12), gpio_base + GPIOx_EVNTCNT_EN);
+
+	/* Add GPIO12 to the Filter Event Pair #7 */
+	outb(12, gpio_base + GPIO_FE7_SEL);
+
+	/* Turn off negative Edge Enable for GPIO12 */
+	outl(1<<(16+12), gpio_base + GPIOx_NEGEDGE_EN);
+
+	/* Enable negative Edge Enable for GPIO7 */
+	outl(1<<7, gpio_base + GPIOx_NEGEDGE_EN);
+
+	/* Zero the filter amount for Filter Event Pair #7 */
+	outw(0, gpio_base + GPIO_FLT7_AMNT);
+
+	/* Clear the negative edge status for GPIO7 and GPIO12 */
+	outl((1<<7) | (1<<12), gpio_base+0x4c);
+
+	/* FIXME:  Clear the posiitive status as well, just to be sure */
+	outl((1<<7) | (1<<12), gpio_base+0x48);
+
+	/* Enable events for GPIO7 (DCONIRQ) and GPIO12 (DCONBLANK) */
+	outl((1<<(7))|(1<<12), gpio_base + GPIOx_EVNT_EN);
+
+	/* Determine the current state by reading the GPIO bit */
+	/* Earlier stages of the boot process have established the state */
+	dcon_source = inl(gpio_base + GPIOx_OUT_VAL) & (1<<11)
+		? DCON_SOURCE_CPU
+		: DCON_SOURCE_DCON;
+	dcon_pending = dcon_source;
+
+	return 0;
+}
+
+static int dcon_reboot_notify(struct notifier_block *nb, unsigned long foo, void *bar)
+{
+	if (dcon_client == NULL)
+		return 0;
+
+	/* Turn off the DCON. Entirely. */
+	dcon_write(DCON_REG_MODE, 0x39);
+	dcon_write(DCON_REG_MODE, 0x32);
+	return 0;
+}
+
+static int dcon_conswitch_notify(struct notifier_block *nb,
+				 unsigned long mode, void *dummy)
+{
+	if (mode == CONSOLE_EVENT_SWITCH_TEXT)
+		dcon_sleep(DCON_ACTIVE);
+
+	return 0;
+}
+
+static struct notifier_block dcon_nb = {
+	.notifier_call = dcon_reboot_notify,
+	.priority = -1,
+};
+
+static struct notifier_block dcon_console_nb = {
+	.notifier_call = dcon_conswitch_notify,
+	.priority = -1,
+};
+
+static int unfreeze_on_panic(struct notifier_block *nb, unsigned long e, void *p)
+{
+	outl(1<<11, gpio_base + GPIOx_OUT_VAL);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block dcon_panic_nb = {
+	.notifier_call = unfreeze_on_panic,
+};
+
+static int dcon_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *client;
+	int rc, i;
+
+	if (!olpc_has_dcon()) {
+		printk("olpc-dcon:  No DCON is attached.\n");
+		return -ENODEV;
+	}
+
+	if (num_registered_fb >= 1)
+		fbinfo = registered_fb[0];
+
+	if (adap->id != I2C_HW_SMBUS_SCX200) {
+		printk(KERN_ERR "olpc-dcon: Invalid I2C bus (%d not %d)\n",
+		       adap->id, I2C_HW_SMBUS_SCX200);
+		return -ENXIO;
+	}
+
+	client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (client == NULL)
+		return -ENOMEM;
+
+	strncpy(client->name, "OLPC-DCON", I2C_NAME_SIZE);
+	client->addr = addr;
+	client->adapter = adap;
+	client->driver = &dcon_driver;
+
+	if ((rc = i2c_attach_client(client)) != 0) {
+		printk(KERN_ERR "olpc-dcon: Unable to attach the I2C client.\n");
+		goto eclient;
+	}
+
+	rc = dcon_hw_init(client, 1);
+	if (rc)
+		goto ei2c;
+
+	/* Add the DCON device */
+
+	dcon_device = platform_device_alloc("dcon", -1);
+
+	if (dcon_device == NULL) {
+		printk(KERN_ERR "dcon:  Unable to create the DCON device\n");
+		rc = -ENOMEM;
+		goto eirq;
+	}
+
+	if ((rc = platform_device_add(dcon_device))) {
+		printk(KERN_ERR "dcon:  Unable to add the DCON device\n");
+		goto edev;
+	}
+
+	for(i = 0; i < ARRAY_SIZE(dcon_device_files); i++)
+		device_create_file(&dcon_device->dev, &dcon_device_files[i]);
+
+	/* Add the backlight device for the DCON */
+
+	dcon_client = client;
+
+	dcon_bl_dev = backlight_device_register("dcon-bl", &dcon_device->dev,
+		NULL, &dcon_bl_ops);
+
+	if (IS_ERR(dcon_bl_dev)) {
+		printk(KERN_INFO "Could not register the backlight device for the DCON (%ld)\n", PTR_ERR(dcon_bl_dev));
+		dcon_bl_dev = NULL;
+	}
+	else {
+		dcon_bl_dev->props.max_brightness = 15;
+		dcon_bl_dev->props.power = FB_BLANK_UNBLANK;
+		dcon_bl_dev->props.brightness = dcon_get_backlight();
+
+		backlight_update_status(dcon_bl_dev);
+	}
+
+	register_reboot_notifier(&dcon_nb);
+	console_event_register(&dcon_console_nb);
+	atomic_notifier_chain_register(&panic_notifier_list, &dcon_panic_nb);
+
+	return 0;
+
+ edev:
+	platform_device_unregister(dcon_device);
+	dcon_device = NULL;
+ eirq:
+	free_irq(DCON_IRQ, &dcon_driver);
+ ei2c:
+	i2c_detach_client(client);
+ eclient:
+	kfree(client);
+
+	return rc;
+}
+
+static int dcon_attach(struct i2c_adapter *adap)
+{
+	int ret;
+
+	ret = i2c_probe(adap, &addr_data, dcon_probe);
+
+	if (dcon_client == NULL)
+		printk(KERN_ERR "olpc-dcon: No DCON found on SMBus\n");
+
+	return ret;
+}
+
+static int dcon_detach(struct i2c_client *client)
+{
+	int rc;
+	dcon_client = NULL;
+
+	unregister_reboot_notifier(&dcon_nb);
+	console_event_unregister(&dcon_console_nb);
+	atomic_notifier_chain_unregister(&panic_notifier_list, &dcon_panic_nb);
+
+	free_irq(DCON_IRQ, &dcon_driver);
+
+	if ((rc = i2c_detach_client(client)) == 0)
+		kfree(i2c_get_clientdata(client));
+
+	if (dcon_bl_dev != NULL)
+		backlight_device_unregister(dcon_bl_dev);
+
+	if (dcon_device != NULL)
+		platform_device_unregister(dcon_device);
+	cancel_work_sync(&dcon_work);
+
+	return rc;
+}
+
+
+#ifdef CONFIG_PM
+static int dcon_suspend(struct i2c_client *client, pm_message_t state)
+{
+	if (dcon_sleep_val != DCON_ACTIVE)
+		return 0;
+
+	/* Set up the DCON to have the source */
+	return dcon_set_source_sync(DCON_SOURCE_DCON);
+}
+
+static int dcon_resume(struct i2c_client *client)
+{
+	if (dcon_sleep_val != DCON_ACTIVE)
+		return 0;
+
+	dcon_bus_stabilize(client, 0);
+
+	return dcon_set_source(DCON_SOURCE_CPU);
+}
+
+#endif
+
+static irqreturn_t dcon_interrupt(int irq, void *id)
+{
+	int status = inl(gpio_base + GPIOx_READ_BACK) >> 5;
+
+	/* Clear the negative edge status for GPIO7 */
+	outl(1 << 7, gpio_base + GPIOx_NEGEDGE_STS);
+
+	switch (status & 3) {
+	case 3:
+		printk(KERN_DEBUG "olpc-dcon: DCONLOAD_MISSED interrupt\n");
+		break;
+	case 2:	/* switch to DCON mode */
+	case 1: /* switch to CPU mode */
+		dcon_switched = 1;
+		wake_up(&dcon_wait_queue);
+		break;
+	case 0:
+		printk(KERN_DEBUG "olpc-dcon: scanline interrupt w/CPU\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct i2c_driver dcon_driver = {
+	.driver = {
+		.name	= "OLPC-DCON",
+	},
+	.id = I2C_DRIVERID_DCON,
+	.attach_adapter = dcon_attach,
+	.detach_client = dcon_detach,
+#ifdef CONFIG_PM
+	.suspend = dcon_suspend,
+	.resume = dcon_resume,
+#endif
+};
+
+
+static int __init olpc_dcon_init(void)
+{
+	i2c_add_driver(&dcon_driver);
+	return 0;
+}
+
+static void __exit olpc_dcon_exit(void)
+{
+	i2c_del_driver(&dcon_driver);
+}
+
+module_init(olpc_dcon_init);
+module_exit(olpc_dcon_exit);
+
+MODULE_LICENSE("GPL");
Binary files linux_2.6.24_org/drivers/video/.olpc_dcon.c.swp and linux_2.6.24_olpc/drivers/video/.olpc_dcon.c.swp differ
diff -purN linux_2.6.24_org/drivers/video/olpc_dcon.h linux_2.6.24_olpc/drivers/video/olpc_dcon.h
--- linux_2.6.24_org/drivers/video/olpc_dcon.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/drivers/video/olpc_dcon.h	2008-02-15 18:58:35.000000000 +0000
@@ -0,0 +1,75 @@
+#ifndef OLPC_DCON_H_
+#define OLPC_DCON_H_
+
+/* DCON registers */
+
+#define DCON_REG_ID		 0
+#define DCON_REG_MODE		 1
+
+#define MODE_PASSTHRU	(1<<0)
+#define MODE_SLEEP	(1<<1)
+#define MODE_SLEEP_AUTO	(1<<2)
+#define MODE_BL_ENABLE	(1<<3)
+#define MODE_BLANK	(1<<4)
+#define MODE_CSWIZZLE	(1<<5)
+#define MODE_COL_AA	(1<<6)
+#define MODE_MONO_LUMA	(1<<7)
+#define MODE_SCAN_INT	(1<<8)
+#define MODE_CLOCKDIV	(1<<9)
+#define MODE_DEBUG	(1<<14)
+#define MODE_SELFTEST	(1<<15)
+
+#define DCON_REG_HRES		2
+#define DCON_REG_HTOTAL		3
+#define DCON_REG_HSYNC_WIDTH	4
+#define DCON_REG_VRES		5
+#define DCON_REG_VTOTAL		6
+#define DCON_REG_VSYNC_WIDTH	7
+#define DCON_REG_TIMEOUT	8
+#define DCON_REG_SCAN_INT	9
+#define DCON_REG_BRIGHT		10
+
+/* GPIO registers (CS5536) */
+
+#define MSR_LBAR_GPIO		0x5140000C
+
+#define GPIOx_OUT_VAL     0x00
+#define GPIOx_OUT_EN      0x04
+#define GPIOx_IN_EN       0x20
+#define GPIOx_INV_EN      0x24
+#define GPIOx_IN_FLTR_EN  0x28
+#define GPIOx_EVNTCNT_EN  0x2C
+#define GPIOx_READ_BACK   0x30
+#define GPIOx_EVNT_EN     0x38
+#define GPIOx_NEGEDGE_EN  0x44
+#define GPIOx_NEGEDGE_STS 0x4C
+#define GPIO_FLT7_AMNT    0xD8
+#define GPIO_MAP_X        0xE0
+#define GPIO_MAP_Y        0xE4
+#define GPIO_FE7_SEL      0xF7
+
+
+/* Status values */
+
+#define DCONSTAT_SCANINT	0
+#define DCONSTAT_SCANINT_DCON	1
+#define DCONSTAT_DISPLAYLOAD	2
+#define DCONSTAT_MISSED		3
+
+/* Source values */
+
+#define DCON_SOURCE_DCON        0
+#define DCON_SOURCE_CPU         1
+
+/* Output values */
+#define DCON_OUTPUT_COLOR       0
+#define DCON_OUTPUT_MONO        1
+
+/* Sleep values */
+#define DCON_ACTIVE             0
+#define DCON_SLEEP              1
+
+/* Interrupt */
+#define DCON_IRQ                6
+
+#endif
diff -purN linux_2.6.24_org/fs/jffs2/nodelist.h linux_2.6.24_olpc/fs/jffs2/nodelist.h
--- linux_2.6.24_org/fs/jffs2/nodelist.h	2008-02-15 20:10:35.000000000 +0000
+++ linux_2.6.24_olpc/fs/jffs2/nodelist.h	2008-02-15 18:57:39.000000000 +0000
@@ -197,7 +197,7 @@ struct jffs2_inode_cache {
 #define RAWNODE_CLASS_XATTR_DATUM	1
 #define RAWNODE_CLASS_XATTR_REF		2
 
-#define INOCACHE_HASHSIZE 128
+#define INOCACHE_HASHSIZE 1024
 
 #define write_ofs(c) ((c)->nextblock->offset + (c)->sector_size - (c)->nextblock->free_size)
 
diff -purN linux_2.6.24_org/fs/Kconfig linux_2.6.24_olpc/fs/Kconfig
--- linux_2.6.24_org/fs/Kconfig	2008-02-15 20:10:31.000000000 +0000
+++ linux_2.6.24_olpc/fs/Kconfig	2008-02-15 18:57:33.000000000 +0000
@@ -1031,6 +1031,37 @@ config HUGETLBFS
 config HUGETLB_PAGE
 	def_bool HUGETLBFS
 
+config PROMFS_FS
+	tristate "PromFS IEEE 1275 file system support"
+	depends on SPARC || PPC || OLPC
+	help
+	  PromFS is a file system interface to various IEEE-1275 compatible
+	  firmwares.  If you have such a firmware (Sparc64, PowerPC, and
+	  some other architectures and embedded systems have such firmwares,
+	  with names like "OpenBoot (tm)" and "OpenFirmware"), say Y here
+	  to be able to access the firmware's device-tree from Linux.
+
+	  The firmware device-tree is available as a virtual file system,
+	  can be mounted under /prom with the command "mount -t promfs
+	  none /prom".
+
+	  To compile PromFS support as a module, choose M here; the module
+	  will be called promfs.  If unsure, choose M.
+
+config RAMFS
+	bool
+	default y
+	---help---
+	  Ramfs is a file system which keeps all files in RAM. It allows
+	  read and write access.
+
+	  It is more of an programming example than a useable file system.  If
+	  you need a file system which lives in RAM with limit checking use
+	  tmpfs.
+
+	  To compile this as a module, choose M here: the module will be called
+	  ramfs.
+
 config CONFIGFS_FS
 	tristate "Userspace-driven configuration filesystem (EXPERIMENTAL)"
 	depends on SYSFS && EXPERIMENTAL
diff -purN linux_2.6.24_org/fs/Makefile linux_2.6.24_olpc/fs/Makefile
--- linux_2.6.24_org/fs/Makefile	2008-02-15 20:10:33.000000000 +0000
+++ linux_2.6.24_olpc/fs/Makefile	2008-02-15 18:57:34.000000000 +0000
@@ -110,6 +110,7 @@ obj-$(CONFIG_ADFS_FS)		+= adfs/
 obj-$(CONFIG_FUSE_FS)		+= fuse/
 obj-$(CONFIG_UDF_FS)		+= udf/
 obj-$(CONFIG_SUN_OPENPROMFS)	+= openpromfs/
+obj-$(CONFIG_PROMFS_FS)		+= promfs/
 obj-$(CONFIG_JFS_FS)		+= jfs/
 obj-$(CONFIG_XFS_FS)		+= xfs/
 obj-$(CONFIG_9P_FS)		+= 9p/
diff -purN linux_2.6.24_org/fs/promfs/Makefile linux_2.6.24_olpc/fs/promfs/Makefile
--- linux_2.6.24_org/fs/promfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/fs/promfs/Makefile	2008-02-15 18:57:33.000000000 +0000
@@ -0,0 +1 @@
+obj-$(CONFIG_PROMFS_FS) += promfs.o
diff -purN linux_2.6.24_org/fs/promfs/promfs.c linux_2.6.24_olpc/fs/promfs/promfs.c
--- linux_2.6.24_org/fs/promfs/promfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/fs/promfs/promfs.c	2008-02-15 18:57:33.000000000 +0000
@@ -0,0 +1,295 @@
+/*
+ * promfs.c - generic inode/dentry functions for IEEE 1275-based filesystems.
+ *
+ * This is based heavily upon prior ieee1275 and other virtual filesystems
+ * implementations; openpromfs, proc_devtree.c, oprofilefs, procfs, ...
+ * 
+ * Copyright (C) 2007 Andres Salomon <dilinger@debian.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+//#include <linux/promfs.h>
+#include <asm/prom.h>
+
+#define PROMFS_MAGIC 0x1f2f3fff
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andres Salomon");
+
+struct promfs_inode
+{
+	struct inode ino;
+	struct property *prop;
+};
+
+static inline struct promfs_inode *to_promfs_inode(struct inode *inode)
+{
+	return container_of(inode, struct promfs_inode, ino);
+}
+
+#if 0
+static DEFINE_SPINLOCK(promfs_lock);
+
+static struct of_node *of_tree = NULL;
+static DEFINE_RWLOCK(of_tree_lock);
+
+void __init of_build_tree(void)
+{
+
+
+}
+#endif
+
+static int promfs_open_file(struct inode *inode, struct file *file)
+{
+	struct promfs_inode *ino;
+
+	ino = to_promfs_inode(inode);
+	if (!ino->prop)
+		return -EIO;
+	file->private_data = ino->prop;
+
+	return 0;
+}
+
+static ssize_t promfs_read_file(struct file *file, char __user *data,
+		size_t len, loff_t *ppos)
+{
+	struct property *prop = (struct property *) file->private_data;
+	return simple_read_from_buffer(data, len, ppos, prop->value,
+			prop->length);
+}
+
+static ssize_t promfs_write_file(struct file *file, char const __user *buf,
+		size_t count, loff_t * offset)
+{
+	/* TODO.... 'cause, y'know, it would be nice. */
+	return -EIO;
+}
+
+static struct file_operations promfs_file_ops = {
+	.open = promfs_open_file,
+	.read = promfs_read_file,
+	.write = promfs_write_file,
+};
+
+static struct kmem_cache *promfs_inode_cachep;
+
+static struct inode *promfs_alloc_inode(struct super_block *sb)
+{
+	struct promfs_inode *pr_ino;
+
+	pr_ino = kmem_cache_alloc(promfs_inode_cachep, GFP_KERNEL);
+	if (!pr_ino)
+		return NULL;
+	pr_ino->prop = NULL;
+
+	return &pr_ino->ino;
+}
+
+static void promfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(promfs_inode_cachep, to_promfs_inode(inode));
+}
+
+static void promfs_read_inode(struct inode *inode)
+{
+	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+}
+
+static int promfs_remount(struct super_block *sb, int *flags, char *data)
+{
+	*flags |= MS_NOATIME;
+	return 0;
+}
+
+static struct super_operations promfs_s_ops = {
+	.alloc_inode = promfs_alloc_inode,
+	.destroy_inode = promfs_destroy_inode,
+	.read_inode = promfs_read_inode,
+	.statfs = simple_statfs,
+	.drop_inode = generic_delete_inode,
+	.remount_fs = promfs_remount,
+};
+
+static struct inode *promfs_get_inode(struct super_block *sb, int mode)
+{
+	struct inode *inode = new_inode(sb);
+
+	if (inode) {
+		inode->i_mode = mode;
+		inode->i_uid = 0;
+		inode->i_gid = 0;
+		inode->i_blocks = 0;
+		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	}
+
+	return inode;
+}
+
+static int promfs_create_file(struct super_block *sb, struct dentry *root,
+		struct property *prop, const struct file_operations *fops)
+{
+	struct dentry *dentry;
+	struct inode *inode;
+	struct promfs_inode *ino;
+
+	dentry = d_alloc_name(root, prop->name);
+	if (!dentry)
+		goto err;
+
+	inode = promfs_get_inode(sb, S_IFREG | 0644);
+	if (!inode)
+		goto err_dput;
+	inode->i_fop = fops;
+	ino = to_promfs_inode(inode);
+	ino->prop = prop;
+	d_add(dentry, inode);
+
+	return 0;
+
+err_dput:
+	dput(dentry);
+err:
+	return -EFAULT;
+}
+
+struct dentry *promfs_create_dir(struct super_block *sb, struct dentry *root,
+		char const *name)
+{
+	struct dentry *dentry;
+	struct inode *inode;
+
+	dentry = d_alloc_name(root, name);
+	if (!dentry)
+		goto err;
+
+	inode = promfs_get_inode(sb, S_IFDIR | 0755);
+	if (!inode)
+		goto err_dput;
+	inode->i_op = &simple_dir_inode_operations;
+	inode->i_fop = &simple_dir_operations;
+	d_add(dentry, inode);
+	return dentry;
+
+err_dput:
+	dput(dentry);
+err:
+	return NULL;
+}
+
+void promfs_populate(struct super_block *sb, struct dentry *root,
+		struct device_node *node)
+{
+	struct dentry *dentry;
+	struct device_node *child;
+	struct property *prop;
+
+	if (!node)
+		return;
+
+	for (child = node->child; child; child = child->sibling) {
+		dentry = promfs_create_dir(sb, root, child->path_component_name);
+		promfs_populate(sb, dentry, child);
+	}
+	for (prop = node->properties; prop; prop = prop->next)
+		promfs_create_file(sb, root, prop, &promfs_file_ops);
+}
+
+static int promfs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct inode *root_inode;
+	struct dentry *root_dentry;
+	struct promfs_inode *inode;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = PROMFS_MAGIC;
+	sb->s_op = &promfs_s_ops;
+	sb->s_time_gran = 1;
+	sb->s_flags |= MS_NOATIME;
+
+	root_inode = promfs_get_inode(sb, S_IFDIR | 0755);
+	if (!root_inode)
+		goto err;
+	root_inode->i_op = &simple_dir_inode_operations;
+	root_inode->i_fop = &simple_dir_operations;
+
+	inode = to_promfs_inode(root_inode);
+
+	root_dentry = d_alloc_root(root_inode);
+	if (!root_dentry)
+		goto err_iput;
+	sb->s_root = root_dentry;
+
+	promfs_populate(sb, root_dentry, of_find_node_by_path("/"));
+	return 0;
+
+err_iput:
+	iput(root_inode);
+err:
+	return -ENOMEM;
+}
+
+static int promfs_get_sb(struct file_system_type *fs_type, int flags,
+		const char *dev_name, void *data, struct vfsmount *mnt)
+{
+	return get_sb_single(fs_type, flags, data, promfs_fill_super, mnt);
+}
+
+static struct file_system_type promfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "promfs",
+	.get_sb = promfs_get_sb,
+	.kill_sb = kill_litter_super,
+};
+
+static void init_once(void *i, struct kmem_cache *cachep, unsigned long fl)
+{
+	struct promfs_inode *inode = (struct promfs_inode *) i;
+	inode_init_once(&inode->ino);
+}
+
+static int __init init_promfs(void)
+{
+	int err;
+
+	prom_build_devicetree();
+	promfs_inode_cachep = kmem_cache_create("promfs_inode_cache",
+			sizeof(struct promfs_inode), 0,
+			SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, init_once, NULL);
+	if (!promfs_inode_cachep)
+		return -ENOMEM;
+
+	err = register_filesystem(&promfs_fs_type);
+	if (err)
+		kmem_cache_destroy(promfs_inode_cachep);
+		
+	return err;
+}
+
+static void __exit exit_promfs(void)
+{
+	unregister_filesystem(&promfs_fs_type);
+	kmem_cache_destroy(promfs_inode_cachep);
+}
+
+module_init(init_promfs);
+module_exit(exit_promfs);
diff -purN linux_2.6.24_org/include/asm-x86/ofw.h linux_2.6.24_olpc/include/asm-x86/ofw.h
--- linux_2.6.24_org/include/asm-x86/ofw.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/include/asm-x86/ofw.h	2008-02-15 18:57:59.000000000 +0000
@@ -0,0 +1,16 @@
+/*
+ * Definitions for Open Firmware client interface on 32-bit system.
+ * OF Cell size is 4. Integer properties are encoded big endian,
+ * as with all OF implementations.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#ifndef _OFW_H
+#define _OFW_H
+
+extern int ofw(char *, int, int, ...); 
+
+#endif
diff -purN linux_2.6.24_org/include/asm-x86/olpc.h linux_2.6.24_olpc/include/asm-x86/olpc.h
--- linux_2.6.24_org/include/asm-x86/olpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/include/asm-x86/olpc.h	2008-02-15 18:57:59.000000000 +0000
@@ -0,0 +1,107 @@
+/* OLPC machine specific definitions */
+
+#ifndef ASM_OLPC_H_
+#define ASM_OLPC_H_
+
+#include <asm/geode.h>
+
+struct olpc_platform_t {
+	int flags;
+	u32 boardrev;
+	int ecver;
+};
+
+#define OLPC_F_PRESENT 0x01
+#define OLPC_F_DCON    0x02
+#define OLPC_F_VSA     0x04
+
+/*
+ * OLPC board IDs contain the major build number within the mask 0x0ff0,
+ * and the minor build number withing 0x000f.  Pre-builds have a minor
+ * number less than 8, and normal builds start at 8.  For example, 0x0B10
+ * is a PreB1, and 0x0C18 is a C1.
+ */
+
+static inline u32 olpc_board(u8 id)
+{
+	return (id << 4) | 0x8;
+}
+
+static inline u32 olpc_board_pre(u8 id)
+{
+	return id << 4;
+}
+
+#ifndef CONFIG_OLPC
+
+static inline int machine_is_olpc(void) { return 0; }
+static inline int olpc_has_dcon(void) { return 0; }
+static inline int olpc_has_vsa(void) { return 0; }
+
+#else
+
+extern struct olpc_platform_t olpc_platform_info;
+
+static inline int
+machine_is_olpc(void)
+{
+	return (olpc_platform_info.flags & OLPC_F_PRESENT) ? 1 : 0;
+}
+
+static inline int
+olpc_has_dcon(void)
+{
+	return (olpc_platform_info.flags & OLPC_F_DCON) ? 1 : 0;
+}
+
+static inline int
+olpc_has_vsa(void)
+{
+	return (olpc_platform_info.flags & OLPC_F_VSA) ? 1 : 0;
+}
+
+static inline int olpc_board_at_least(u32 rev)
+{
+	return olpc_platform_info.boardrev >= rev;
+}
+
+#endif
+
+/* EC functions */
+
+int olpc_ec_cmd(unsigned char cmd, unsigned char *inbuf, size_t inlen,
+		unsigned char *outbuf, size_t outlen);
+
+void olpc_register_battery_callback(void (*f)(unsigned long));
+void olpc_deregister_battery_callback(void);
+
+/* EC commands and responses */
+
+/* SCI source values */
+
+#define EC_SCI_SRC_EMPTY   0x00
+#define EC_SCI_SRC_GAME    0x01
+#define EC_SCI_SRC_BATTERY 0x02
+#define EC_SCI_SRC_BATSOC  0x04
+#define EC_SCI_SRC_BATERR  0x08
+#define EC_SCI_SRC_EBOOK   0x10
+#define EC_SCI_SRC_WLAN    0x20
+#define EC_SCI_SRC_ACPWR   0x40
+#define EC_SCI_SRC_ALL     0x7F
+
+int olpc_ec_mask_set(u8 bits);
+int olpc_ec_mask_unset(u8 bits);
+
+/* GPIO assignments */
+
+#define OLPC_GPIO_MIC_AC     (1 << 1)
+#define OLPC_GPIO_DCON_IRQ   (1 << 7)
+#define OLPC_GPIO_THRM_ALRM  (1 << 10)
+#define OLPC_GPIO_SMB_CLK    (1 << 14)
+#define OLPC_GPIO_SMB_DATA   (1 << 15)
+#define OLPC_GPIO_WORKAUX    (1 << 24)
+#define OLPC_GPIO_LID        (1 << 26)
+#define OLPC_GPIO_ECSCI      (1 << 27)
+
+#endif
+
diff -purN linux_2.6.24_org/include/asm-x86/prom.h linux_2.6.24_olpc/include/asm-x86/prom.h
--- linux_2.6.24_org/include/asm-x86/prom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/include/asm-x86/prom.h	2008-02-15 18:57:59.000000000 +0000
@@ -0,0 +1,108 @@
+#ifndef _I386_PROM_H
+#define _I386_PROM_H
+#ifdef __KERNEL__
+
+
+/*
+ * Definitions for talking to the Open Firmware PROM on
+ * Power Macintosh computers.
+ *
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ *
+ * Updates for PPC64 by Peter Bergner & David Engebretsen, IBM Corp.
+ * Updates for SPARC64 by David S. Miller
+ * Updates for i386/OLPC by Andres Salomon
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <asm/atomic.h>
+
+typedef u32 phandle;
+typedef u32 ihandle;
+
+struct property {
+	char	*name;
+	int	length;
+	void	*value;
+	struct property *next;
+};
+
+struct device_node {
+	const char	*name;
+	const char	*type;
+	phandle	node;
+//        phandle linux_phandle;
+	char	*path_component_name;
+	char	*full_name;
+
+	struct	property *properties;
+	struct  property *deadprops; /* removed properties */
+	struct	device_node *parent;
+	struct	device_node *child;
+	struct	device_node *sibling;
+	struct	device_node *next;	/* next device of same type */
+	struct	device_node *allnext;	/* next in list of all nodes */
+	struct  proc_dir_entry *pde;	/* this node's proc directory */
+	struct  kref kref;
+	unsigned long _flags;
+	void	*data;
+};
+
+/* flag descriptions */
+#define OF_DYNAMIC 1 /* node and properties were allocated via kmalloc */
+
+#define OF_IS_DYNAMIC(x) test_bit(OF_DYNAMIC, &x->_flags)
+#define OF_MARK_DYNAMIC(x) set_bit(OF_DYNAMIC, &x->_flags)
+
+#define OF_BAD_ADDR	((u64)-1)
+
+static inline void set_node_proc_entry(struct device_node *dn, struct proc_dir_entry *de)
+{
+	dn->pde = de;
+}
+
+extern struct device_node *of_find_node_by_name(struct device_node *from,
+	const char *name);
+#define for_each_node_by_name(dn, name) \
+	for (dn = of_find_node_by_name(NULL, name); dn; \
+	     dn = of_find_node_by_name(dn, name))
+extern struct device_node *of_find_node_by_type(struct device_node *from,
+	const char *type);
+#define for_each_node_by_type(dn, type) \
+	for (dn = of_find_node_by_type(NULL, type); dn; \
+	     dn = of_find_node_by_type(dn, type))
+extern struct device_node *of_find_compatible_node(struct device_node *from,
+	const char *type, const char *compat);
+extern struct device_node *of_find_node_by_path(const char *path);
+extern struct device_node *of_find_node_by_phandle(phandle handle);
+extern struct device_node *of_get_parent(const struct device_node *node);
+extern struct device_node *of_get_next_child(const struct device_node *node,
+					     struct device_node *prev);
+extern struct property *of_find_property(const struct device_node *np,
+					 const char *name,
+					 int *lenp);
+//extern struct device_node *of_node_get(struct device_node *node);
+//extern void of_node_put(struct device_node *node);
+extern int of_device_is_compatible(const struct device_node *device,
+				   const char *);
+extern const void *of_get_property(const struct device_node *node,
+			     const char *name,
+			     int *lenp);
+#define get_property(node,name,lenp) of_get_property(node,name,lenp)
+extern int of_set_property(struct device_node *node, const char *name, void *val, int len);
+extern int of_getintprop_default(struct device_node *np,
+				 const char *name,
+				 int def);
+extern int of_n_addr_cells(struct device_node *np);
+extern int of_n_size_cells(struct device_node *np);
+
+extern void prom_build_devicetree(void);
+
+#endif /* __KERNEL__ */
+#endif
diff -purN linux_2.6.24_org/include/linux/battery.h linux_2.6.24_olpc/include/linux/battery.h
--- linux_2.6.24_org/include/linux/battery.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/include/linux/battery.h	2008-02-15 18:58:06.000000000 +0000
@@ -0,0 +1,101 @@
+/*
+ * Driver model for batteries
+ *
+ *	© 2006 David Woodhouse <dwmw2@infradead.org>
+ *
+ * Based on LED Class support, by John Lenz and Richard Purdie:
+ *
+ *	© 2005 John Lenz <lenz@cs.wisc.edu>
+ *	© 2005-2006 Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __LINUX_BATTERY_H__
+#define __LINUX_BATTERY_H__
+
+struct device;
+struct class_device;
+
+/*
+ * Battery Core
+ */
+#define PWRDEV_TYPE_BATTERY	0
+#define PWRDEV_TYPE_AC		1
+
+#define BAT_STAT_PRESENT	(1<<0)
+#define BAT_STAT_LOW		(1<<1)
+#define BAT_STAT_FULL		(1<<2)
+#define BAT_STAT_CHARGING	(1<<3)
+#define BAT_STAT_DISCHARGING	(1<<4)
+#define BAT_STAT_OVERTEMP	(1<<5)
+#define BAT_STAT_CRITICAL	(1<<6)
+#define BAT_STAT_FIRE		(1<<7)
+#define BAT_STAT_CHARGE_DONE	(1<<8)
+
+/* Thou shalt not export any attributes in sysfs except these, and
+   with these units: */
+#define BAT_INFO_STATUS		"status"		/* Not free-form. Use
+							   provided function */
+#define BAT_INFO_TEMP1		"temp1"			/* °C/1000 */
+#define BAT_INFO_TEMP1_NAME	"temp1_name"		/* string */
+
+#define BAT_INFO_TEMP2		"temp2"			/* °C/1000 */
+#define BAT_INFO_TEMP2_NAME	"temp2_name"		/* string */
+
+#define BAT_INFO_VOLTAGE	"voltage"		/* mV */
+#define BAT_INFO_VOLTAGE_DESIGN	"voltage_design"	/* mV */
+
+#define BAT_INFO_CURRENT	"current"		/* mA */
+#define BAT_INFO_CURRENT_NOW	"current_now"		/* mA */
+
+#define BAT_INFO_POWER		"power"			/* mW */
+#define BAT_INFO_POWER_NOW	"power_now"		/* mW */
+
+/* The following capacity/charge properties are represented in either
+   mA or mW. The CAP_UNITS property MUST be provided if any of these are. */
+#define BAT_INFO_RATE		"rate"			/* CAP_UNITS */
+#define BAT_INFO_CAP_LEFT	"capacity_left"		/* CAP_UNITS*h */
+#define BAT_INFO_CAP_DESIGN	"capacity_design"	/* CAP_UNITS*h */
+#define BAT_INFO_CAP_LAST_FULL	"capacity_last_full"	/* CAP_UNITS*h */
+#define BAT_INFO_CAP_LOW	"capacity_low_thresh"	/* CAP_UNITS*h */
+#define BAT_INFO_CAP_WARN	"capacity_warn_thresh"	/* CAP_UNITS*h */
+#define BAT_INFO_CAP_UNITS	"capacity_units"	/* string: must be
+							   either mA or mW */
+	
+#define BAT_INFO_CAP_PCT	"capacity_percentage"	/* integer */
+
+#define BAT_INFO_TIME_EMPTY	"time_to_empty"		/* seconds */
+#define BAT_INFO_TIME_EMPTY_NOW	"time_to_empty_now"	/* seconds */
+#define BAT_INFO_TIME_FULL	"time_to_full"		/* seconds */
+#define BAT_INFO_TIME_FULL_NOW	"time_to_full_now"	/* seconds */
+
+#define BAT_INFO_MANUFACTURER	"manufacturer"		/* string */
+#define BAT_INFO_TECHNOLOGY	"technology"		/* string */
+#define BAT_INFO_MODEL		"model"			/* string */
+#define BAT_INFO_SERIAL		"serial"		/* string */
+#define BAT_INFO_OEM_INFO	"oem_info"		/* string */
+
+#define BAT_INFO_CYCLE_COUNT	"cycle_count"		/* integer */
+#define BAT_INFO_DATE_MFR	"date_manufactured"	/* YYYY[-MM[-DD]] */
+#define BAT_INFO_DATE_FIRST_USE	"date_first_use"	/* YYYY[-MM[-DD]] */
+
+struct battery_dev {
+	int			status_cap;
+	int			id;
+	int			type;
+	const char		*name;
+
+	struct device		*dev;
+};
+
+int battery_device_register(struct device *parent,
+			    struct battery_dev *battery_cdev);
+void battery_device_unregister(struct battery_dev *battery_cdev);
+
+
+ssize_t battery_attribute_show_status(char *buf, unsigned long status);
+ssize_t battery_attribute_show_ac_status(char *buf, unsigned long status);
+#endif /* __LINUX_BATTERY_H__ */
diff -purN linux_2.6.24_org/include/linux/fb.h linux_2.6.24_olpc/include/linux/fb.h
--- linux_2.6.24_org/include/linux/fb.h	2008-02-15 20:10:55.000000000 +0000
+++ linux_2.6.24_olpc/include/linux/fb.h	2008-02-15 18:58:01.000000000 +0000
@@ -666,6 +666,12 @@ struct fb_ops {
 	/* restore saved state */
 	void (*fb_restore_state)(struct fb_info *info);
 
+	/* Shut down the graphics engine to save power */
+	int (*fb_powerdown)(struct fb_info *info);
+
+	/* Power it back up */
+	int (*fb_powerup)(struct fb_info *info);
+
 	/* get capability given var */
 	void (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps,
 			    struct fb_var_screeninfo *var);
@@ -945,6 +951,9 @@ extern int fb_get_color_depth(struct fb_
 extern int fb_get_options(char *name, char **option);
 extern int fb_new_modelist(struct fb_info *info);
 
+extern int fb_powerdown(struct fb_info *info);
+extern int fb_powerup(struct fb_info *info);
+
 extern struct fb_info *registered_fb[FB_MAX];
 extern int num_registered_fb;
 extern struct class *fb_class;
diff -purN linux_2.6.24_org/include/linux/i2c-id.h linux_2.6.24_olpc/include/linux/i2c-id.h
--- linux_2.6.24_org/include/linux/i2c-id.h	2008-02-15 20:10:52.000000000 +0000
+++ linux_2.6.24_olpc/include/linux/i2c-id.h	2008-02-15 18:58:00.000000000 +0000
@@ -125,6 +125,7 @@
 #define I2C_DRIVERID_LM4857 	92 	/* LM4857 Audio Amplifier */
 #define I2C_DRIVERID_VP27SMPX	93	/* Panasonic VP27s tuner internal MPX */
 #define I2C_DRIVERID_CS4270	94	/* Cirrus Logic 4270 audio codec */
+#define I2C_DRIVERID_DCON	95
 
 #define I2C_DRIVERID_I2CDEV	900
 #define I2C_DRIVERID_ARP        902    /* SMBus ARP Client              */
diff -purN linux_2.6.24_org/include/linux/isl_38xx.h linux_2.6.24_olpc/include/linux/isl_38xx.h
--- linux_2.6.24_org/include/linux/isl_38xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/include/linux/isl_38xx.h	2008-02-15 18:58:05.000000000 +0000
@@ -0,0 +1,127 @@
+/*
+ *  Copyright (C) 2002 Intersil Americas Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LINUX_ISL_38XX_H
+#define _LINUX_ISL_38XX_H
+
+#include <asm/io.h>
+
+#define ISL38XX_CB_RX_QSIZE                     8
+#define ISL38XX_CB_TX_QSIZE                     32
+
+/* ISL38XX Access Point Specific definitions */
+#define ISL38XX_MAX_WDS_LINKS                   8
+
+/* ISL38xx Client Specific definitions */
+#define ISL38XX_PSM_ACTIVE_STATE                0
+#define ISL38XX_PSM_POWERSAVE_STATE             1
+
+/* ISL38XX Host Interface Definitions */
+#define ISL38XX_PCI_MEM_SIZE                    0x02000
+#define ISL38XX_MEMORY_WINDOW_SIZE              0x01000
+#define ISL38XX_DEV_FIRMWARE_ADDRES             0x20000
+#define ISL38XX_WRITEIO_DELAY                   10	/* in us */
+#define ISL38XX_RESET_DELAY                     50	/* in ms */
+#define ISL38XX_WAIT_CYCLE                      10	/* in 10ms */
+#define ISL38XX_MAX_WAIT_CYCLES                 10
+
+/* PCI Memory Area */
+#define ISL38XX_HARDWARE_REG                    0x0000
+#define ISL38XX_CARDBUS_CIS                     0x0800
+#define ISL38XX_DIRECT_MEM_WIN                  0x1000
+
+/* Hardware registers */
+#define ISL38XX_DEV_INT_REG                     0x0000
+#define ISL38XX_INT_IDENT_REG                   0x0010
+#define ISL38XX_INT_ACK_REG                     0x0014
+#define ISL38XX_INT_EN_REG                      0x0018
+#define ISL38XX_GEN_PURP_COM_REG_1              0x0020
+#define ISL38XX_GEN_PURP_COM_REG_2              0x0024
+#define ISL38XX_CTRL_BLK_BASE_REG               ISL38XX_GEN_PURP_COM_REG_1
+#define ISL38XX_DIR_MEM_BASE_REG                0x0030
+#define ISL38XX_CTRL_STAT_REG                   0x0078
+
+/* High end mobos queue up pci writes, the following
+ * is used to "read" from after a write to force flush */
+#define ISL38XX_PCI_POSTING_FLUSH		ISL38XX_INT_EN_REG
+
+/**
+ * isl38xx_w32_flush - PCI iomem write helper
+ * @base: (host) memory base address of the device
+ * @val: 32bit value (host order) to write
+ * @offset: byte offset into @base to write value to
+ * 
+ *  This helper takes care of writing a 32bit datum to the
+ *  specified offset into the device's pci memory space, and making sure 
+ *  the pci memory buffers get flushed by performing one harmless read 
+ *  from the %ISL38XX_PCI_POSTING_FLUSH offset.
+ */
+static inline void
+isl38xx_w32_flush(void __iomem *base, u32 val, unsigned long offset)
+{
+	writel(val, base + offset);
+	(void) readl(base + ISL38XX_PCI_POSTING_FLUSH);
+}
+
+/* Device Interrupt register bits */
+#define ISL38XX_DEV_INT_RESET                   0x0001
+#define ISL38XX_DEV_INT_UPDATE                  0x0002
+#define ISL38XX_DEV_INT_WAKEUP                  0x0008
+#define ISL38XX_DEV_INT_SLEEP                   0x0010
+#define ISL38XX_DEV_INT_ABORT                   0x0020
+/* thos two only used in USB */
+#define ISL38XX_DEV_INT_DATA                    0x0040
+#define ISL38XX_DEV_INT_MGMT                    0x0080
+
+#define ISL38XX_DEV_INT_PCIUART_CTS             0x4000
+#define ISL38XX_DEV_INT_PCIUART_DR              0x8000
+
+/* Interrupt Identification/Acknowledge/Enable register bits */
+#define ISL38XX_INT_IDENT_UPDATE                0x0002
+#define ISL38XX_INT_IDENT_INIT                  0x0004
+#define ISL38XX_INT_IDENT_WAKEUP                0x0008
+#define ISL38XX_INT_IDENT_SLEEP                 0x0010
+#define ISL38XX_INT_IDENT_PCIUART_CTS           0x4000
+#define ISL38XX_INT_IDENT_PCIUART_DR            0x8000
+
+#define ISL38XX_INT_SOURCES                     (ISL38XX_INT_IDENT_UPDATE | \
+						 ISL38XX_INT_IDENT_INIT | \
+						 ISL38XX_INT_IDENT_WAKEUP | \
+						 ISL38XX_INT_IDENT_SLEEP | \
+						 ISL38XX_INT_IDENT_PCIUART_CTS | \
+						 ISL38XX_INT_IDENT_PCIUART_DR)
+
+/* Control/Status register bits */
+/* Looks like there are other meaningful bits
+    0x20004400 seen in normal operation,
+    0x200044db at 'timeout waiting for mgmt response'
+*/
+#define ISL38XX_CTRL_STAT_SLEEPMODE             0x00000200
+#define	ISL38XX_CTRL_STAT_CLKRUN		0x00800000
+#define ISL38XX_CTRL_STAT_RESET                 0x10000000
+#define ISL38XX_CTRL_STAT_RAMBOOT               0x20000000
+#define ISL38XX_CTRL_STAT_STARTHALTED           0x40000000
+#define ISL38XX_CTRL_STAT_HOST_OVERRIDE         0x80000000
+
+/* Some flags for the isl hardware registers controlling DMA inside the
+ * chip */
+#define ISL38XX_DMA_STATUS_DONE                 0x00000001
+#define ISL38XX_DMA_STATUS_READY                0x00000002
+#define NET2280_EPA_FIFO_PCI_ADDR               0x20000000
+#define ISL38XX_DMA_MASTER_CONTROL_TRIGGER      0x00000004
+
+#endif /* _LINUX_ISL_38XX_H */
diff -purN linux_2.6.24_org/include/linux/pm.h linux_2.6.24_olpc/include/linux/pm.h
--- linux_2.6.24_org/include/linux/pm.h	2008-02-15 20:11:06.000000000 +0000
+++ linux_2.6.24_olpc/include/linux/pm.h	2008-02-15 18:58:06.000000000 +0000
@@ -178,6 +178,9 @@ struct dev_pm_info {
 	unsigned		can_wakeup:1;
 #ifdef	CONFIG_PM_SLEEP
 	unsigned		should_wakeup:1;
+	pm_message_t		prev_state;
+	void			* saved_state;
+	struct device		* pm_parent;
 	struct list_head	entry;
 #endif
 };
diff -purN linux_2.6.24_org/include/linux/power_supply.h linux_2.6.24_olpc/include/linux/power_supply.h
--- linux_2.6.24_org/include/linux/power_supply.h	2008-02-15 20:10:55.000000000 +0000
+++ linux_2.6.24_olpc/include/linux/power_supply.h	2008-02-15 18:58:01.000000000 +0000
@@ -98,9 +98,11 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
 	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
 	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
+	POWER_SUPPLY_PROP_ACCUM_CURRENT,
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
 };
 
 enum power_supply_type {
@@ -169,9 +171,10 @@ struct power_supply_info {
 
 extern void power_supply_changed(struct power_supply *psy);
 extern int power_supply_am_i_supplied(struct power_supply *psy);
+extern void power_supply_status_changed(struct power_supply *psy);
 
 extern int power_supply_register(struct device *parent,
-				 struct power_supply *psy);
+                                 struct power_supply *psy);
 extern void power_supply_unregister(struct power_supply *psy);
 
 /* For APM emulation, think legacy userspace. */
diff -purN linux_2.6.24_org/include/linux/vt_kern.h linux_2.6.24_olpc/include/linux/vt_kern.h
--- linux_2.6.24_org/include/linux/vt_kern.h	2008-02-15 20:10:55.000000000 +0000
+++ linux_2.6.24_olpc/include/linux/vt_kern.h	2008-02-15 18:58:02.000000000 +0000
@@ -96,4 +96,23 @@ struct vt_spawn_console {
 };
 extern struct vt_spawn_console vt_spawn_con;
 
+/* A notifier list for console events  */
+extern struct raw_notifier_head console_notifier_list;
+
+/* Called when the FG console switches to KD_TEXT mode */
+#define CONSOLE_EVENT_SWITCH_TEXT 0x01
+
+/* Called when the FG console switches to KD_GRAPHICS mode */
+#define CONSOLE_EVENT_SWITCH_GRAPHICS 0x02
+
+static inline int console_event_register(struct notifier_block *n)
+{
+	return raw_notifier_chain_register(&console_notifier_list, n);
+}
+
+static inline int console_event_unregister(struct notifier_block *n)
+{
+	return raw_notifier_chain_unregister(&console_notifier_list, n);
+}
+
 #endif /* _VT_KERN_H */
diff -purN linux_2.6.24_org/include/sound/ac97_codec.h linux_2.6.24_olpc/include/sound/ac97_codec.h
--- linux_2.6.24_org/include/sound/ac97_codec.h	2008-02-15 20:10:44.000000000 +0000
+++ linux_2.6.24_olpc/include/sound/ac97_codec.h	2008-02-15 18:57:45.000000000 +0000
@@ -281,10 +281,12 @@
 /* specific - Analog Devices */
 #define AC97_AD_TEST		0x5a	/* test register */
 #define AC97_AD_TEST2		0x5c	/* undocumented test register 2 */
+#define AC97_AD_HPFD_SHIFT	12	/* High Pass Filter Disable */
 #define AC97_AD_CODEC_CFG	0x70	/* codec configuration */
 #define AC97_AD_JACK_SPDIF	0x72	/* Jack Sense & S/PDIF */
 #define AC97_AD_SERIAL_CFG	0x74	/* Serial Configuration */
 #define AC97_AD_MISC		0x76	/* Misc Control Bits */
+#define AC97_AD_VREFD_SHIFT	2	/* V_REFOUT Disable (AD1888) */
 
 /* specific - Cirrus Logic */
 #define AC97_CSR_ACMODE		0x5e	/* AC Mode Register */
diff -purN linux_2.6.24_org/kernel/power/console.c linux_2.6.24_olpc/kernel/power/console.c
--- linux_2.6.24_org/kernel/power/console.c	2008-02-15 20:12:34.000000000 +0000
+++ linux_2.6.24_olpc/kernel/power/console.c	2008-02-15 19:00:00.000000000 +0000
@@ -9,7 +9,7 @@
 #include <linux/console.h>
 #include "power.h"
 
-#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE) && !defined(CONFIG_DISABLE_SUSPEND_VT_SWITCH)
 #define SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
 
 static int orig_fgconsole, orig_kmsg;
diff -purN linux_2.6.24_org/kernel/power/Kconfig linux_2.6.24_olpc/kernel/power/Kconfig
--- linux_2.6.24_org/kernel/power/Kconfig	2008-02-15 20:12:34.000000000 +0000
+++ linux_2.6.24_olpc/kernel/power/Kconfig	2008-02-15 19:00:00.000000000 +0000
@@ -37,9 +37,22 @@ config PM_DEBUG
 	code. This is helpful when debugging and reporting PM bugs, like
 	suspend support.
 
+config DISABLE_SUSPEND_VT_SWITCH
+	bool "Disable the console switch prior to suspend (DANGEROUS)"
+	depends on PM_DEBUG
+	default n
+	---help---
+	This option disables the automatic switch to VT console that happens
+	prior to Linux going into a suspend/sleep.  Your video card/framebuffer
+	must be able to properly restore the display (even if X is doing
+	something crazy!) in this scenario.  This is useful for saving
+	precious milliseconds during suspend and resume.
+
+	If unsure, say N.
+
 config PM_VERBOSE
 	bool "Verbose Power Management debugging"
-	depends on PM_DEBUG
+	depends on VT_CONSOLE && PM && EXPERIMENTAL
 	default n
 	---help---
 	This option enables verbose messages from the Power Management code.
diff -purN linux_2.6.24_org/kernel/power/main.c linux_2.6.24_olpc/kernel/power/main.c
--- linux_2.6.24_org/kernel/power/main.c	2008-02-15 20:12:34.000000000 +0000
+++ linux_2.6.24_olpc/kernel/power/main.c	2008-02-15 19:00:00.000000000 +0000
@@ -76,11 +76,13 @@ static int suspend_prepare(void)
 	if (!suspend_ops || !suspend_ops->enter)
 		return -EPERM;
 
+#ifndef CONFIG_OLPC_PM
 	error = pm_notifier_call_chain(PM_SUSPEND_PREPARE);
 	if (error)
 		goto Finish;
 
 	pm_prepare_console();
+#endif
 
 	if (freeze_processes()) {
 		error = -EAGAIN;
diff -purN linux_2.6.24_org/scripts/kconfig/conf.c linux_2.6.24_olpc/scripts/kconfig/conf.c
--- linux_2.6.24_org/scripts/kconfig/conf.c	2008-02-15 20:10:15.000000000 +0000
+++ linux_2.6.24_olpc/scripts/kconfig/conf.c	2008-02-15 18:57:09.000000000 +0000
@@ -22,6 +22,7 @@ enum {
 	ask_new,
 	ask_silent,
 	set_default,
+	set_silentdefault,
 	set_yes,
 	set_mod,
 	set_no,
@@ -64,10 +65,11 @@ static void strip(char *str)
 
 static void check_stdin(void)
 {
-	if (!valid_stdin && input_mode == ask_silent) {
+	if (!valid_stdin && (input_mode == ask_silent ||
+			input_mode == set_silentdefault)) {
 		printf(_("aborted!\n\n"));
 		printf(_("Console input/output is redirected. "));
-		printf(_("Run 'make oldconfig' to update configuration.\n\n"));
+		printf(_("Configuration file needs to be updated.\n\n"));
 		exit(1);
 	}
 }
@@ -102,6 +104,7 @@ static int conf_askvalue(struct symbol *
 		break;
 	case ask_new:
 	case ask_silent:
+	case set_silentdefault:
 		if (sym_has_value(sym)) {
 			printf("%s\n", def);
 			return 0;
@@ -352,6 +355,7 @@ static int conf_choice(struct menu *menu
 		switch (input_mode) {
 		case ask_new:
 		case ask_silent:
+		case set_silentdefault:
 			if (!is_new) {
 				cnt = def;
 				printf("%d\n", cnt);
@@ -424,7 +428,9 @@ static void conf(struct menu *menu)
 
 		switch (prop->type) {
 		case P_MENU:
-			if (input_mode == ask_silent && rootEntry != menu) {
+			if ((input_mode == ask_silent ||
+					input_mode == set_silentdefault) &&
+					rootEntry != menu) {
 				check_conf(menu);
 				return;
 			}
@@ -508,6 +514,16 @@ int main(int ac, char **av)
 			input_mode = ask_silent;
 			valid_stdin = isatty(0) && isatty(1) && isatty(2);
 			break;
+		case 'S':
+			input_mode = set_silentdefault;
+			valid_stdin = isatty(0) && isatty(1) && isatty(2);
+			defconfig_file = av[i++];
+			if (!defconfig_file) {
+				printf("%s: No default config file specified\n",
+					av[0]);
+				exit(1);
+			}
+			break;
 		case 'd':
 			input_mode = set_default;
 			break;
@@ -557,6 +573,14 @@ int main(int ac, char **av)
 			exit(1);
 		}
 		break;
+	case set_silentdefault:
+		if (conf_read(defconfig_file)) {
+			printf("***\n"
+				"*** Can't find default configuration \"%s\"!\n"
+				"***\n", defconfig_file);
+			exit(1);
+		}
+		break;
 	case ask_silent:
 		if (stat(".config", &tmpstat)) {
 			printf(_("***\n"
@@ -597,7 +621,7 @@ int main(int ac, char **av)
 		break;
 	}
 
-	if (input_mode != ask_silent) {
+	if (input_mode != ask_silent && input_mode != set_silentdefault) {
 		rootEntry = &rootmenu;
 		conf(&rootmenu);
 		if (input_mode == ask_all) {
@@ -610,19 +634,21 @@ int main(int ac, char **av)
 			fprintf(stderr, _("\n*** Kernel configuration requires explicit update.\n\n"));
 			return 1;
 		}
-	} else
+	} else if (input_mode != set_silentdefault)
 		goto skip_check;
 
 	do {
 		conf_cnt = 0;
 		check_conf(&rootmenu);
 	} while (conf_cnt);
-	if (conf_write(NULL)) {
+	if (conf_write(NULL, input_mode == ask_silent ||
+			input_mode == set_silentdefault)) {
 		fprintf(stderr, _("\n*** Error during writing of the kernel configuration.\n\n"));
 		return 1;
 	}
 skip_check:
-	if (input_mode == ask_silent && conf_write_autoconf()) {
+	if ((input_mode == ask_silent || input_mode == set_silentdefault) &&
+			conf_write_autoconf()) {
 		fprintf(stderr, _("\n*** Error during writing of the kernel configuration.\n\n"));
 		return 1;
 	}
diff -purN linux_2.6.24_org/scripts/kconfig/confdata.c linux_2.6.24_olpc/scripts/kconfig/confdata.c
--- linux_2.6.24_org/scripts/kconfig/confdata.c	2008-02-15 20:10:15.000000000 +0000
+++ linux_2.6.24_olpc/scripts/kconfig/confdata.c	2008-02-15 18:57:09.000000000 +0000
@@ -393,7 +393,7 @@ int conf_read(const char *name)
 	return 0;
 }
 
-int conf_write(const char *name)
+int conf_write(const char *name, int quiet)
 {
 	FILE *out;
 	struct symbol *sym;
@@ -548,9 +548,10 @@ int conf_write(const char *name)
 			return 1;
 	}
 
-	printf(_("#\n"
-		 "# configuration written to %s\n"
-		 "#\n"), newname);
+	if (!quiet)
+		printf("#\n"
+			"# configuration written to %s\n"
+			"#\n", newname);
 
 	sym_set_change_count(0);
 
diff -purN linux_2.6.24_org/scripts/kconfig/gconf.c linux_2.6.24_olpc/scripts/kconfig/gconf.c
--- linux_2.6.24_org/scripts/kconfig/gconf.c	2008-02-15 20:10:15.000000000 +0000
+++ linux_2.6.24_olpc/scripts/kconfig/gconf.c	2008-02-15 18:57:09.000000000 +0000
@@ -621,7 +621,7 @@ void on_load1_activate(GtkMenuItem * men
 
 void on_save_activate(GtkMenuItem * menuitem, gpointer user_data)
 {
-	if (conf_write(NULL))
+	if (conf_write(NULL, 0))
 		text_insert_msg(_("Error"), _("Unable to save configuration !"));
 }
 
@@ -634,7 +634,7 @@ store_filename(GtkFileSelection * file_s
 	fn = gtk_file_selection_get_filename(GTK_FILE_SELECTION
 					     (user_data));
 
-	if (conf_write(fn))
+	if (conf_write(fn, 0))
 		text_insert_msg(_("Error"), _("Unable to save configuration !"));
 
 	gtk_widget_destroy(GTK_WIDGET(user_data));
diff -purN linux_2.6.24_org/scripts/kconfig/lkc_proto.h linux_2.6.24_olpc/scripts/kconfig/lkc_proto.h
--- linux_2.6.24_org/scripts/kconfig/lkc_proto.h	2008-02-15 20:10:15.000000000 +0000
+++ linux_2.6.24_olpc/scripts/kconfig/lkc_proto.h	2008-02-15 18:57:09.000000000 +0000
@@ -3,7 +3,7 @@
 P(conf_parse,void,(const char *name));
 P(conf_read,int,(const char *name));
 P(conf_read_simple,int,(const char *name, int));
-P(conf_write,int,(const char *name));
+P(conf_write,int,(const char *name, int));
 P(conf_write_autoconf,int,(void));
 P(conf_get_changed,bool,(void));
 P(conf_set_changed_callback, void,(void (*fn)(void)));
diff -purN linux_2.6.24_org/scripts/kconfig/Makefile linux_2.6.24_olpc/scripts/kconfig/Makefile
--- linux_2.6.24_org/scripts/kconfig/Makefile	2008-02-15 20:10:15.000000000 +0000
+++ linux_2.6.24_olpc/scripts/kconfig/Makefile	2008-02-15 18:57:09.000000000 +0000
@@ -69,6 +69,9 @@ endif
 %_defconfig: $(obj)/conf
 	$(Q)$< -D arch/$(SRCARCH)/configs/$@ $(Kconfig)
 
+%_silentdefconfig: $(obj)/conf
+	$(Q)$< -S arch/$(ARCH)/configs/$(subst _silentdefconfig,_defconfig,$@) arch/$(ARCH)/Kconfig
+
 # Help text used by make help
 help:
 	@echo  '  config	  - Update current config utilising a line-oriented program'
Binary files linux_2.6.24_org/scripts/kconfig/mconf and linux_2.6.24_olpc/scripts/kconfig/mconf differ
diff -purN linux_2.6.24_org/scripts/kconfig/mconf.c linux_2.6.24_olpc/scripts/kconfig/mconf.c
--- linux_2.6.24_org/scripts/kconfig/mconf.c	2008-02-15 20:10:15.000000000 +0000
+++ linux_2.6.24_olpc/scripts/kconfig/mconf.c	2008-02-15 18:57:09.000000000 +0000
@@ -885,7 +885,7 @@ static void conf_save(void)
 		case 0:
 			if (!dialog_input_result[0])
 				return;
-			if (!conf_write(dialog_input_result)) {
+			if (!conf_write(dialog_input_result, 0)) {
 				set_config_filename(dialog_input_result);
 				return;
 			}
@@ -945,7 +945,7 @@ int main(int ac, char **av)
 
 	switch (res) {
 	case 0:
-		if (conf_write(filename)) {
+		if (conf_write(filename, 0)) {
 			fprintf(stderr, _("\n\n"
 				"Error during writing of the kernel configuration.\n"
 				"Your kernel configuration changes were NOT saved."
diff -purN linux_2.6.24_org/scripts/kconfig/qconf.cc linux_2.6.24_olpc/scripts/kconfig/qconf.cc
--- linux_2.6.24_org/scripts/kconfig/qconf.cc	2008-02-15 20:10:15.000000000 +0000
+++ linux_2.6.24_olpc/scripts/kconfig/qconf.cc	2008-02-15 18:57:09.000000000 +0000
@@ -1458,7 +1458,7 @@ void ConfigMainWindow::loadConfig(void)
 
 void ConfigMainWindow::saveConfig(void)
 {
-	if (conf_write(NULL))
+	if (conf_write(NULL, 0))
 		QMessageBox::information(this, "qconf", "Unable to save configuration!");
 }
 
@@ -1467,7 +1467,7 @@ void ConfigMainWindow::saveConfigAs(void
 	QString s = QFileDialog::getSaveFileName(".config", NULL, this);
 	if (s.isNull())
 		return;
-	if (conf_write(QFile::encodeName(s)))
+	if (conf_write(QFile::encodeName(s), 0))
 		QMessageBox::information(this, "qconf", "Unable to save configuration!");
 }
 
@@ -1619,7 +1619,7 @@ void ConfigMainWindow::closeEvent(QClose
 	mb.setButtonText(QMessageBox::Cancel, "Cancel Exit");
 	switch (mb.exec()) {
 	case QMessageBox::Yes:
-		conf_write(NULL);
+		conf_write(NULL, 0);
 	case QMessageBox::No:
 		e->accept();
 		break;
diff -purN linux_2.6.24_org/sound/pci/ac97/ac97_patch.c linux_2.6.24_olpc/sound/pci/ac97/ac97_patch.c
--- linux_2.6.24_org/sound/pci/ac97/ac97_patch.c	2008-02-15 20:10:24.000000000 +0000
+++ linux_2.6.24_olpc/sound/pci/ac97/ac97_patch.c	2008-02-15 18:57:24.000000000 +0000
@@ -2029,8 +2029,9 @@ static const struct snd_kcontrol_new snd
 		.get = snd_ac97_ad1888_lohpsel_get,
 		.put = snd_ac97_ad1888_lohpsel_put
 	},
-	AC97_SINGLE("V_REFOUT Enable", AC97_AD_MISC, 2, 1, 1),
-	AC97_SINGLE("High Pass Filter Enable", AC97_AD_TEST2, 12, 1, 1),
+	AC97_SINGLE("V_REFOUT Enable", AC97_AD_MISC, AC97_AD_VREFD_SHIFT, 1, 1),
+	AC97_SINGLE("High Pass Filter Enable", AC97_AD_TEST2,
+			AC97_AD_HPFD_SHIFT, 1, 1),
 	AC97_SINGLE("Spread Front to Surround and Center/LFE", AC97_AD_MISC, 7, 1, 0),
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
diff -purN linux_2.6.24_org/sound/pci/cs5535audio/cs5535audio.c linux_2.6.24_olpc/sound/pci/cs5535audio/cs5535audio.c
--- linux_2.6.24_org/sound/pci/cs5535audio/cs5535audio.c	2008-02-15 20:10:23.000000000 +0000
+++ linux_2.6.24_olpc/sound/pci/cs5535audio/cs5535audio.c	2008-02-15 18:57:23.000000000 +0000
@@ -145,7 +145,7 @@ static unsigned short snd_cs5535audio_ac
 	return snd_cs5535audio_codec_read(cs5535au, reg);
 }
 
-static int snd_cs5535audio_mixer(struct cs5535audio *cs5535au)
+static int __devinit snd_cs5535audio_mixer(struct cs5535audio *cs5535au)
 {
 	struct snd_card *card = cs5535au->card;
 	struct snd_ac97_bus *pbus;
@@ -160,10 +160,14 @@ static int snd_cs5535audio_mixer(struct 
 		return err;
 
 	memset(&ac97, 0, sizeof(ac97));
-	ac97.scaps = AC97_SCAP_AUDIO|AC97_SCAP_SKIP_MODEM;
+	ac97.scaps = AC97_SCAP_AUDIO | AC97_SCAP_SKIP_MODEM
+			| AC97_SCAP_POWER_SAVE;
 	ac97.private_data = cs5535au;
 	ac97.pci = cs5535au->pci;
 
+	/* olpc_prequirks is dummied out if not olpc */
+	olpc_prequirks(card, &ac97);
+
 	if ((err = snd_ac97_mixer(pbus, &ac97, &cs5535au->ac97)) < 0) {
 		snd_printk(KERN_ERR "mixer failed\n");
 		return err;
@@ -171,6 +175,12 @@ static int snd_cs5535audio_mixer(struct 
 
 	snd_ac97_tune_hardware(cs5535au->ac97, ac97_quirks, ac97_quirk);
 
+	/* olpc_quirks is dummied out if not olpc */
+	if (( err = olpc_quirks(card, cs5535au->ac97)) < 0) {
+		snd_printk(KERN_ERR "olpc quirks failed\n");
+		return err;
+	}
+
 	return 0;
 }
 
diff -purN linux_2.6.24_org/sound/pci/cs5535audio/cs5535audio.h linux_2.6.24_olpc/sound/pci/cs5535audio/cs5535audio.h
--- linux_2.6.24_org/sound/pci/cs5535audio/cs5535audio.h	2008-02-15 20:10:23.000000000 +0000
+++ linux_2.6.24_olpc/sound/pci/cs5535audio/cs5535audio.h	2008-02-15 18:57:23.000000000 +0000
@@ -78,6 +78,7 @@ struct cs5535audio_dma {
 	unsigned int buf_addr, buf_bytes;
 	unsigned int period_bytes, periods;
 	u32 saved_prd;
+	int pcm_open_flag;
 };
 
 struct cs5535audio {
@@ -93,8 +94,21 @@ struct cs5535audio {
 	struct cs5535audio_dma dmas[NUM_CS5535AUDIO_DMAS];
 };
 
+#ifdef CONFIG_PM
 int snd_cs5535audio_suspend(struct pci_dev *pci, pm_message_t state);
 int snd_cs5535audio_resume(struct pci_dev *pci);
+#endif
+
+#ifdef CONFIG_OLPC
+void olpc_prequirks(struct snd_card *card, struct snd_ac97_template *ac97) __devinit;
+int olpc_quirks(struct snd_card *card, struct snd_ac97 *ac97) __devinit;
+int olpc_ai_enable(struct snd_ac97 *ac97, u8 val);
+#else
+#define olpc_prequirks(arg,arg2)	do {} while (0)
+#define olpc_quirks(arg,arg2)		(0)
+#define olpc_ai_enable(a, v) (0)
+#endif
+
 int __devinit snd_cs5535audio_pcm(struct cs5535audio *cs5535audio);
 
 #endif /* __SOUND_CS5535AUDIO_H */
diff -purN linux_2.6.24_org/sound/pci/cs5535audio/cs5535audio_olpc.c linux_2.6.24_olpc/sound/pci/cs5535audio/cs5535audio_olpc.c
--- linux_2.6.24_org/sound/pci/cs5535audio/cs5535audio_olpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_2.6.24_olpc/sound/pci/cs5535audio/cs5535audio_olpc.c	2008-02-15 18:57:23.000000000 +0000
@@ -0,0 +1,110 @@
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/ac97_codec.h>
+
+#include <asm/olpc.h>
+#include "cs5535audio.h"
+
+/*
+ * OLPC has an additional feature on top of the regular AD1888 codec features.
+ * It has an Analog Input mode that is switched into (after disabling the
+ * High Pass Filter) via GPIO.  It is only supported on B2 and later models.
+ */
+
+int olpc_ai_enable(struct snd_ac97 *ac97, u8 val)
+{
+	int err;
+
+	/*
+	 * update the High Pass Filter (via AC97_AD_TEST2), and then set
+	 * Analog Input mode through a GPIO.
+	 */
+
+	if (val) {
+		err = snd_ac97_update_bits(ac97, AC97_AD_TEST2,
+				1<<AC97_AD_HPFD_SHIFT, 1<<AC97_AD_HPFD_SHIFT);
+		geode_gpio_set(OLPC_GPIO_MIC_AC, GPIO_OUTPUT_VAL);
+	}
+	else {
+		err = snd_ac97_update_bits(ac97, AC97_AD_TEST2,
+				1<<AC97_AD_HPFD_SHIFT, 0);
+		geode_gpio_clear(OLPC_GPIO_MIC_AC, GPIO_OUTPUT_VAL);
+	}
+	if (err < 0)
+		snd_printk(KERN_ERR "Error updating AD_TEST2: %d\n", err);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(olpc_ai_enable);
+
+static int snd_cs5535audio_ai_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_cs5535audio_ai_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = geode_gpio_isset(OLPC_GPIO_MIC_AC,
+			GPIO_OUTPUT_VAL);
+	return 0;
+}
+
+static int snd_cs5535audio_ai_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct cs5535audio *cs5535au = snd_kcontrol_chip(kcontrol);
+	struct snd_ac97 *ac97 = cs5535au->ac97;
+
+	olpc_ai_enable(ac97, ucontrol->value.integer.value[0]);
+
+	return 1;
+}
+
+static struct snd_kcontrol_new snd_cs5535audio_controls __devinitdata =
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "DC Mode Enable",
+	.info = snd_cs5535audio_ai_info,
+	.get = snd_cs5535audio_ai_get,
+	.put = snd_cs5535audio_ai_put,
+	.private_value = 0
+};
+
+void __devinit olpc_prequirks(struct snd_card *card,
+		struct snd_ac97_template *ac97)
+{
+	/* Bail if this isn't an OLPC platform */
+	if (!machine_is_olpc())
+		return;
+
+	/* If on an OLPC B3 or higher, invert EAPD. */
+	if (olpc_board_at_least(olpc_board_pre(0xb3)))
+		ac97->scaps |= AC97_SCAP_INV_EAPD;
+}
+
+int __devinit olpc_quirks(struct snd_card *card, struct snd_ac97 *ac97)
+{
+	struct snd_ctl_elem_id elem;
+
+	/* Bail if this isn't an OLPC platform */
+	if (!machine_is_olpc())
+		return 0;
+
+	/* drop the original ad1888 HPF control */
+	memset(&elem, 0, sizeof(elem));
+	elem.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	strcpy(elem.name, "High Pass Filter Enable");
+	snd_ctl_remove_id(card, &elem);
+
+	/* add the override for OLPC's HPF */
+	return snd_ctl_add(card, snd_ctl_new1(&snd_cs5535audio_controls,
+			ac97->private_data));
+}
diff -purN linux_2.6.24_org/sound/pci/cs5535audio/cs5535audio_pcm.c linux_2.6.24_olpc/sound/pci/cs5535audio/cs5535audio_pcm.c
--- linux_2.6.24_org/sound/pci/cs5535audio/cs5535audio_pcm.c	2008-02-15 20:10:23.000000000 +0000
+++ linux_2.6.24_olpc/sound/pci/cs5535audio/cs5535audio_pcm.c	2008-02-15 18:57:23.000000000 +0000
@@ -259,6 +259,9 @@ static int snd_cs5535audio_hw_params(str
 	err = cs5535audio_build_dma_packets(cs5535au, dma, substream,
 					    params_periods(hw_params),
 					    params_period_bytes(hw_params));
+	if (!err)
+		dma->pcm_open_flag = 1;
+
 	return err;
 }
 
@@ -267,6 +270,15 @@ static int snd_cs5535audio_hw_free(struc
 	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
 	struct cs5535audio_dma *dma = substream->runtime->private_data;
 
+	if (dma->pcm_open_flag) {
+		if (substream == cs5535au->playback_substream)
+			snd_ac97_update_power(cs5535au->ac97,
+					AC97_PCM_FRONT_DAC_RATE, 0);
+		else
+			snd_ac97_update_power(cs5535au->ac97,
+					AC97_PCM_LR_ADC_RATE, 0);
+		dma->pcm_open_flag = 0;
+	}
 	cs5535audio_clear_dma_packets(cs5535au, dma, substream);
 	return snd_pcm_lib_free_pages(substream);
 }
@@ -341,6 +353,7 @@ static int snd_cs5535audio_capture_open(
 	int err;
 	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_ac97 *ac97 = cs5535au->ac97;
 
 	runtime->hw = snd_cs5535audio_capture;
 	cs5535au->capture_substream = substream;
@@ -348,11 +361,29 @@ static int snd_cs5535audio_capture_open(
 	if ((err = snd_pcm_hw_constraint_integer(runtime,
 					 SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
 		return err;
-	return 0;
+
+#ifdef CONFIG_OLPC
+	/* Disable Analog Input */
+	olpc_ai_enable(ac97, 0);
+	/* Enable V_ref bias while recording. */
+	snd_ac97_update_bits(ac97, AC97_AD_MISC, 1<<AC97_AD_VREFD_SHIFT, 0);
+#endif
+	return err;
 }
 
 static int snd_cs5535audio_capture_close(struct snd_pcm_substream *substream)
 {
+#ifdef CONFIG_OLPC
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
+	struct snd_ac97 *ac97 = cs5535au->ac97;
+
+	/* Disable Analog Input */
+	olpc_ai_enable(ac97, 0);
+	/* Disable V_ref bias. */
+	snd_ac97_update_bits(ac97, AC97_AD_MISC, 1<<AC97_AD_VREFD_SHIFT,
+			1<<AC97_AD_VREFD_SHIFT);
+#endif
+
 	return 0;
 }
 
diff -purN linux_2.6.24_org/sound/pci/cs5535audio/Makefile linux_2.6.24_olpc/sound/pci/cs5535audio/Makefile
--- linux_2.6.24_org/sound/pci/cs5535audio/Makefile	2008-02-15 20:10:23.000000000 +0000
+++ linux_2.6.24_olpc/sound/pci/cs5535audio/Makefile	2008-02-15 18:57:23.000000000 +0000
@@ -5,5 +5,9 @@
 snd-cs5535audio-y := cs5535audio.o cs5535audio_pcm.o
 snd-cs5535audio-$(CONFIG_PM) += cs5535audio_pm.o
 
+ifdef CONFIG_OLPC
+snd-cs5535audio-objs += cs5535audio_olpc.o
+endif
+
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_CS5535AUDIO) += snd-cs5535audio.o
