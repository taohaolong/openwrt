Index: linux-2.6.23.17/arch/i386/Kconfig
===================================================================
--- linux-2.6.23.17.orig/arch/i386/Kconfig
+++ linux-2.6.23.17/arch/i386/Kconfig
@@ -796,6 +796,15 @@ config SECCOMP
 
 	  If unsure, say Y. Only embedded should say N here.
 
+config VGA_NOPROBE
+       bool "Don't probe VGA at boot" if EMBEDDED
+       default n
+       help
+         Saying Y here will cause the kernel to not probe VGA at boot time.
+         This will break everything that depends on the probed screen
+         data.  Say N here unless you are absolutely sure this is what you
+         want.
+
 source kernel/Kconfig.hz
 
 config KEXEC
@@ -1120,6 +1129,9 @@ config PCI_GODIRECT
 config PCI_GOANY
 	bool "Any"
 
+config PCI_GOOLPC
+	bool "OLPC"
+
 endchoice
 
 config PCI_BIOS
@@ -1129,7 +1141,7 @@ config PCI_BIOS
 
 config PCI_DIRECT
 	bool
- 	depends on PCI && ((PCI_GODIRECT || PCI_GOANY) || X86_VISWS)
+ 	depends on PCI && ((PCI_GODIRECT || PCI_GOANY || PCI_GOOLPC) || X86_VISWS)
 	default y
 
 config PCI_MMCONFIG
@@ -1137,6 +1149,11 @@ config PCI_MMCONFIG
 	depends on PCI && ACPI && (PCI_GOMMCONFIG || PCI_GOANY)
 	default y
 
+config PCI_OLPC
+	bool
+	depends on PCI && PCI_GOOLPC
+	default y
+
 source "drivers/pci/pcie/Kconfig"
 
 source "drivers/pci/Kconfig"
@@ -1206,10 +1223,43 @@ config SCx200HR_TIMER
 	  processor goes idle (as is done by the scheduler).  The
 	  other workaround is idle=poll boot option.
 
+config GEODE_MFGPT_TIMER
+	bool "Geode Multi-Function General Purpose Timer (mfgpt) Support"
+	depends on MGEODE_LX && GENERIC_TIME && GENERIC_CLOCKEVENTS
+	default y
+	help
+	  This driver provides a clock event source based on the MFGPT
+	  timer(s) in the CS5535 and CS5536 companion chip for the geode.
+	  MFGPTs have a better resolution and max interval than the
+	  generic PIT, and are suitable for use as high-res timers.
+
 config K8_NB
 	def_bool y
 	depends on AGP_AMD64
 
+config OLPC
+	bool "OLPC Support"
+	default n
+	help
+	  Add support for detecting the unique features of the OLPC 
+	  Childrens Machine
+
+config OLPC_PM
+       tristate "OLPC power management support"
+       default y
+       depends on OLPC
+       help
+         Add support for the Geode power management facilities on the
+	 OLPC Childrens Machine
+
+config OPEN_FIRMWARE
+	bool "Support for Open Firmware"
+	default y if OLPC
+	help
+	  This option adds support for the implementation of Open Firmware
+	  that is used on the OLPC Children's Machine.
+	  If unsure, say N here.
+
 source "drivers/pcmcia/Kconfig"
 
 source "drivers/pci/hotplug/Kconfig"
Index: linux-2.6.23.17/arch/i386/kernel/Makefile
===================================================================
--- linux-2.6.23.17.orig/arch/i386/kernel/Makefile
+++ linux-2.6.23.17/arch/i386/kernel/Makefile
@@ -39,13 +39,17 @@ obj-$(CONFIG_VM86)		+= vm86.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_HPET_TIMER) 	+= hpet.o
 obj-$(CONFIG_K8_NB)		+= k8.o
-obj-$(CONFIG_MGEODE_LX)		+= geode.o
+obj-$(CONFIG_MGEODE_LX)		+= geode.o mfgpt.o
 
 obj-$(CONFIG_VMI)		+= vmi.o vmiclock.o
 obj-$(CONFIG_PARAVIRT)		+= paravirt.o
 obj-y				+= pcspeaker.o
 
 obj-$(CONFIG_SCx200)		+= scx200.o
+obj-$(CONFIG_OLPC)		+= olpc.o
+obj-$(CONFIG_OLPC_PM)		+= olpc-pm.o olpc-wakeup.o
+obj-$(CONFIG_OPEN_FIRMWARE)	+= ofw.o
+obj-$(CONFIG_PROMFS_FS)		+= prom.o
 
 # vsyscall.o contains the vsyscall DSO images as __initdata.
 # We must build both images before we can assemble it.
Index: linux-2.6.23.17/arch/i386/kernel/geode.c
===================================================================
--- linux-2.6.23.17.orig/arch/i386/kernel/geode.c
+++ linux-2.6.23.17/arch/i386/kernel/geode.c
@@ -145,10 +145,14 @@ EXPORT_SYMBOL_GPL(geode_gpio_setup_event
 
 static int __init geode_southbridge_init(void)
 {
+	int timers;
+
 	if (!is_geode())
 		return -ENODEV;
 
 	init_lbars();
+	timers = geode_mfgpt_detect();
+	printk(KERN_INFO "geode-mfgpt:  %d timers available.\n", timers);
 	return 0;
 }
 
Index: linux-2.6.23.17/arch/i386/kernel/head.S
===================================================================
--- linux-2.6.23.17.orig/arch/i386/kernel/head.S
+++ linux-2.6.23.17/arch/i386/kernel/head.S
@@ -117,8 +117,34 @@ ENTRY(startup_32)
 	movl $(COMMAND_LINE_SIZE/4),%ecx
 	rep
 	movsl
+
+#ifdef CONFIG_OPEN_FIRMWARE
+/*
+ * If Open Firmware booted us, save the OFW client interface callback address
+ * and preserve the OFW page mappings by priming the kernel's new page
+ * directory area with a copy of the OFW page directory.  That lets OFW stay
+ * resident in high memory (high in both the virtual and physical spaces)
+ * for at least long enough to copy out the device tree.
+ */
 1:
+	movl $(boot_params - __PAGE_OFFSET + OFW_INFO_OFFSET), %ebp
+	cmpl $0x2057464F, (%ebp)	/* Magic number "OFW " */
+	jne 1f
+
+	mov 0x8(%ebp), %eax	/* Save callback address */
+	mov %eax, call_firmware - __PAGE_OFFSET
+
+	/* Copy the OFW pdir into swapper_pg_dir */
+	movl %esi, %edx		/* save %esi */
+	movl $(swapper_pg_dir - __PAGE_OFFSET), %edi
+	movl %cr3, %esi		/* Source is current pg_dir base address */
+	movl $1024, %ecx	/* Number of page directory entries */
+	rep
+	movsl
+	movl %edx, %esi		/* restore %esi */
+#endif
 
+1:
 /*
  * Initialize page tables.  This creates a PDE and a set of page
  * tables, which are located immediately beyond _end.  The variable
@@ -129,6 +155,7 @@ ENTRY(startup_32)
  * Warning: don't use %esi or the stack in this code.  However, %esp
  * can be used as a GPR if you really need it...
  */
+
 page_pde_offset = (__PAGE_OFFSET >> 20);
 
 	movl $(pg0 - __PAGE_OFFSET), %edi
Index: linux-2.6.23.17/arch/i386/kernel/setup.c
===================================================================
--- linux-2.6.23.17.orig/arch/i386/kernel/setup.c
+++ linux-2.6.23.17/arch/i386/kernel/setup.c
@@ -362,8 +362,10 @@ void __init zone_sizes_init(void)
 {
 	unsigned long max_zone_pfns[MAX_NR_ZONES];
 	memset(max_zone_pfns, 0, sizeof(max_zone_pfns));
+#ifdef CONFIG_ZONE_DMA
 	max_zone_pfns[ZONE_DMA] =
 		virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
+#endif
 	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
 #ifdef CONFIG_HIGHMEM
 	max_zone_pfns[ZONE_HIGHMEM] = highend_pfn;
@@ -428,6 +430,9 @@ void __init setup_bootmem_allocator(void
 	 */
 	acpi_reserve_bootmem();
 #endif
+#ifdef CONFIG_OLPC_PM
+	reserve_bootmem(0xf0000, PAGE_SIZE);
+#endif
 #ifdef CONFIG_X86_FIND_SMP_CONFIG
 	/*
 	 * Find and reserve possible boot-time SMP configuration:
Index: linux-2.6.23.17/arch/i386/pci/Makefile
===================================================================
--- linux-2.6.23.17.orig/arch/i386/pci/Makefile
+++ linux-2.6.23.17/arch/i386/pci/Makefile
@@ -3,6 +3,7 @@ obj-y				:= i386.o init.o
 obj-$(CONFIG_PCI_BIOS)		+= pcbios.o
 obj-$(CONFIG_PCI_MMCONFIG)	+= mmconfig.o direct.o mmconfig-shared.o
 obj-$(CONFIG_PCI_DIRECT)	+= direct.o
+obj-$(CONFIG_PCI_OLPC)		+= olpc.o
 
 pci-y				:= fixup.o
 pci-$(CONFIG_ACPI)		+= acpi.o
Index: linux-2.6.23.17/arch/i386/pci/init.c
===================================================================
--- linux-2.6.23.17.orig/arch/i386/pci/init.c
+++ linux-2.6.23.17/arch/i386/pci/init.c
@@ -14,6 +14,9 @@ static __init int pci_access_init(void)
 #ifdef CONFIG_PCI_MMCONFIG
 	pci_mmcfg_init(type);
 #endif
+#ifdef CONFIG_PCI_OLPC
+	pci_olpc_init();
+#endif
 	if (raw_pci_ops)
 		return 0;
 #ifdef CONFIG_PCI_BIOS
Index: linux-2.6.23.17/arch/i386/pci/pci.h
===================================================================
--- linux-2.6.23.17.orig/arch/i386/pci/pci.h
+++ linux-2.6.23.17/arch/i386/pci/pci.h
@@ -93,6 +93,7 @@ extern void pci_direct_init(int type);
 extern void pci_pcbios_init(void);
 extern void pci_mmcfg_init(int type);
 extern void pcibios_sort(void);
+extern void pci_olpc_init(void);
 
 /* pci-mmconfig.c */
 
Index: linux-2.6.23.17/drivers/Makefile
===================================================================
--- linux-2.6.23.17.orig/drivers/Makefile
+++ linux-2.6.23.17/drivers/Makefile
@@ -23,6 +23,8 @@ obj-y				+= char/
 
 obj-$(CONFIG_CONNECTOR)		+= connector/
 
+obj-$(CONFIG_SYSPROF)		+= sysprof/
+
 # i810fb and intelfb depend on char/agp/
 obj-$(CONFIG_FB_I810)           += video/i810/
 obj-$(CONFIG_FB_INTEL)          += video/intelfb/
Index: linux-2.6.23.17/drivers/char/vt_ioctl.c
===================================================================
--- linux-2.6.23.17.orig/drivers/char/vt_ioctl.c
+++ linux-2.6.23.17/drivers/char/vt_ioctl.c
@@ -37,6 +37,9 @@
 char vt_dont_switch;
 extern struct tty_driver *console_driver;
 
+/* Add a notifier chain to inform drivers of a VT_TEXT/VT_GRAPHICS switch */
+RAW_NOTIFIER_HEAD(console_notifier_list);
+
 #define VT_IS_IN_USE(i)	(console_driver->ttys[i] && console_driver->ttys[i]->count)
 #define VT_BUSY(i)	(VT_IS_IN_USE(i) || i == fg_console || vc_cons[i].d == sel_cons)
 
@@ -491,6 +494,14 @@ int vt_ioctl(struct tty_struct *tty, str
 		vc->vc_mode = (unsigned char) arg;
 		if (console != fg_console)
 			return 0;
+
+		/* Notify listeners if the current fg_console has switched */
+
+		raw_notifier_call_chain(&console_notifier_list,
+			(arg == KD_TEXT) ?
+			CONSOLE_EVENT_SWITCH_TEXT :
+			CONSOLE_EVENT_SWITCH_GRAPHICS, 0);
+
 		/*
 		 * explicitly blank/unblank the screen if switching modes
 		 */
Index: linux-2.6.23.17/drivers/i2c/busses/scx200_acb.c
===================================================================
--- linux-2.6.23.17.orig/drivers/i2c/busses/scx200_acb.c
+++ linux-2.6.23.17/drivers/i2c/busses/scx200_acb.c
@@ -46,6 +46,10 @@ static int base[MAX_DEVICES] = { 0x820, 
 module_param_array(base, int, NULL, 0);
 MODULE_PARM_DESC(base, "Base addresses for the ACCESS.bus controllers");
 
+static unsigned int smbclk = 0x70;
+module_param(smbclk, uint, 0);
+MODULE_PARM_DESC(smbclk, "Specify the SMB_CLK value");
+
 #define POLL_TIMEOUT	(HZ/5)
 
 enum scx200_acb_state {
@@ -108,6 +112,7 @@ struct scx200_acb_iface {
 #define ACBADDR		(iface->base + 4)
 #define ACBCTL2		(iface->base + 5)
 #define    ACBCTL2_ENABLE	0x01
+#define ACBCTL3        (iface->base + 6)
 
 /************************************************************************/
 
@@ -392,11 +397,13 @@ static __init int scx200_acb_probe(struc
 {
 	u8 val;
 
-	/* Disable the ACCESS.bus device and Configure the SCL
-	   frequency: 16 clock cycles */
-	outb(0x70, ACBCTL2);
+	/* Disable the ACCESS.bus device and Configure the SCL */
+
+	outb((smbclk & 0x7F) << 1, ACBCTL2);
+
+	outb((smbclk >> 7) & 0xFF, ACBCTL3);
 
-	if (inb(ACBCTL2) != 0x70) {
+	if (inb(ACBCTL2) != ((smbclk & 0x7F) << 1)) {
 		pr_debug(NAME ": ACBCTL2 readback failed\n");
 		return -ENXIO;
 	}
Index: linux-2.6.23.17/drivers/input/keyboard/atkbd.c
===================================================================
--- linux-2.6.23.17.orig/drivers/input/keyboard/atkbd.c
+++ linux-2.6.23.17/drivers/input/keyboard/atkbd.c
@@ -63,12 +63,25 @@ static int atkbd_extra;
 module_param_named(extra, atkbd_extra, bool, 0);
 MODULE_PARM_DESC(extra, "Enable extra LEDs and keys on IBM RapidAcces, EzKey and similar keyboards");
 
+#define ATKBD_KEY_UNKNOWN	  0
+#define ATKBD_KEY_NULL		0xFF0000FF
+
+#define ATKBD_SCR_1		0xFF0000FE
+#define ATKBD_SCR_2		0xFF0000FD
+#define ATKBD_SCR_4		0xFF0000FC
+#define ATKBD_SCR_8		0xFF0000FB
+#define ATKBD_SCR_CLICK		0xFF0000FA
+#define ATKBD_SCR_LEFT		0xFF0000F9
+#define ATKBD_SCR_RIGHT		0xFF0000F8
+
+#define ATKBD_SPECIAL		0xFF0000F8
+
 /*
  * Scancode to keycode tables. These are just the default setting, and
  * are loadable via an userland utility.
  */
 
-static unsigned char atkbd_set2_keycode[512] = {
+static unsigned int atkbd_set2_keycode[512] = {
 
 #ifdef CONFIG_KEYBOARD_ATKBD_HP_KEYCODES
 
@@ -87,11 +100,17 @@ static unsigned char atkbd_set2_keycode[
 	 82, 83, 80, 76, 77, 72,  1, 69, 87, 78, 81, 74, 55, 73, 70, 99,
 
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	217,100,255,  0, 97,165,  0,  0,156,  0,  0,  0,  0,  0,  0,125,
+
+	217,100,ATKBD_KEY_NULL,  0, 97,165,  0,  0,
+	156,  0,  0,  0,  0,  0,  0,125,
+
 	173,114,  0,113,  0,  0,  0,126,128,  0,  0,140,  0,  0,  0,127,
 	159,  0,115,  0,164,  0,  0,116,158,  0,172,166,  0,  0,  0,142,
 	157,  0,  0,  0,  0,  0,  0,  0,155,  0, 98,  0,  0,163,  0,  0,
-	226,  0,  0,  0,  0,  0,  0,  0,  0,255, 96,  0,  0,  0,143,  0,
+
+	226,  0,  0,  0,  0,  0,  0,  0,
+	  0,ATKBD_KEY_NULL, 96,  0,  0,  0,143,  0,
+
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,107,  0,105,102,  0,  0,112,
 	110,111,108,112,106,103,  0,119,  0,118,109,  0, 99,104,119,  0,
 
@@ -150,19 +169,6 @@ static unsigned char atkbd_unxlate_table
 #define ATKBD_RET_HANGEUL	0xf2
 #define ATKBD_RET_ERR		0xff
 
-#define ATKBD_KEY_UNKNOWN	  0
-#define ATKBD_KEY_NULL		255
-
-#define ATKBD_SCR_1		254
-#define ATKBD_SCR_2		253
-#define ATKBD_SCR_4		252
-#define ATKBD_SCR_8		251
-#define ATKBD_SCR_CLICK		250
-#define ATKBD_SCR_LEFT		249
-#define ATKBD_SCR_RIGHT		248
-
-#define ATKBD_SPECIAL		248
-
 #define ATKBD_LED_EVENT_BIT	0
 #define ATKBD_REP_EVENT_BIT	1
 
@@ -174,7 +180,7 @@ static unsigned char atkbd_unxlate_table
 #define ATKBD_XL_HANJA		0x20
 
 static struct {
-	unsigned char keycode;
+	unsigned int keycode;
 	unsigned char set2;
 } atkbd_scroll_keys[] = {
 	{ ATKBD_SCR_1,     0xc5 },
@@ -200,7 +206,7 @@ struct atkbd {
 	char phys[32];
 
 	unsigned short id;
-	unsigned char keycode[512];
+	unsigned int keycode[512];
 	unsigned char set;
 	unsigned char translated;
 	unsigned char extra;
@@ -351,7 +357,7 @@ static irqreturn_t atkbd_interrupt(struc
 	unsigned int code = data;
 	int scroll = 0, hscroll = 0, click = -1, add_release_event = 0;
 	int value;
-	unsigned char keycode;
+	unsigned int keycode;
 
 #ifdef ATKBD_DEBUG
 	printk(KERN_DEBUG "atkbd.c: Received %02x flags %02x\n", data, flags);
@@ -856,9 +862,11 @@ static void atkbd_set_keycode_table(stru
 						atkbd->keycode[i | 0x80] = atkbd_scroll_keys[j].keycode;
 		}
 	} else if (atkbd->set == 3) {
-		memcpy(atkbd->keycode, atkbd_set3_keycode, sizeof(atkbd->keycode));
+		for (i = 0; i < ARRAY_SIZE(atkbd_set3_keycode); i++)
+			atkbd->keycode[i] = atkbd_set3_keycode[i];
 	} else {
-		memcpy(atkbd->keycode, atkbd_set2_keycode, sizeof(atkbd->keycode));
+		for (i = 0; i < ARRAY_SIZE(atkbd_set2_keycode); i++)
+			atkbd->keycode[i] = atkbd_set2_keycode[i];
 
 		if (atkbd->scroll)
 			for (i = 0; i < ARRAY_SIZE(atkbd_scroll_keys); i++)
@@ -925,8 +933,8 @@ static void atkbd_set_device_attrs(struc
 	}
 
 	input_dev->keycode = atkbd->keycode;
-	input_dev->keycodesize = sizeof(unsigned char);
-	input_dev->keycodemax = ARRAY_SIZE(atkbd_set2_keycode);
+	input_dev->keycodesize = sizeof(unsigned int);
+	input_dev->keycodemax = ARRAY_SIZE(atkbd->keycode);
 
 	for (i = 0; i < 512; i++)
 		if (atkbd->keycode[i] && atkbd->keycode[i] < ATKBD_SPECIAL)
@@ -1017,6 +1025,10 @@ static int atkbd_connect(struct serio *s
 	return err;
 }
 
+#ifdef CONFIG_OLPC
+#include <asm/olpc.h>
+#endif
+
 /*
  * atkbd_reconnect() tries to restore keyboard into a sane state and is
  * most likely called on resume.
@@ -1027,6 +1039,12 @@ static int atkbd_reconnect(struct serio 
 	struct atkbd *atkbd = serio_get_drvdata(serio);
 	struct serio_driver *drv = serio->drv;
 
+#ifdef CONFIG_OLPC
+	if (olpc_rev_after(OLPC_REV_B2))
+		if (serio->dev.power.power_state.event != PM_EVENT_ON)
+			return 0;
+#endif
+
 	if (!atkbd || !drv) {
 		printk(KERN_DEBUG "atkbd: reconnect request, but serio is disconnected, ignoring...\n");
 		return -1;
Index: linux-2.6.23.17/drivers/input/mouse/Kconfig
===================================================================
--- linux-2.6.23.17.orig/drivers/input/mouse/Kconfig
+++ linux-2.6.23.17/drivers/input/mouse/Kconfig
@@ -96,6 +96,16 @@ config MOUSE_PS2_TOUCHKIT
 
 	  If unsure, say N.
 
+config MOUSE_PS2_OLPC
+	bool "OLPC PS/2 mouse protocol extension" if EMBEDDED
+	default n
+	depends on MOUSE_PS2 && OLPC
+	---help---
+	  Say Y here if you have an OLPC PS/2 touchpad connected to
+	  your system.
+
+	  If unsure, say N.
+
 config MOUSE_SERIAL
 	tristate "Serial mouse"
 	select SERIO
Index: linux-2.6.23.17/drivers/input/mouse/Makefile
===================================================================
--- linux-2.6.23.17.orig/drivers/input/mouse/Makefile
+++ linux-2.6.23.17/drivers/input/mouse/Makefile
@@ -24,3 +24,4 @@ psmouse-$(CONFIG_MOUSE_PS2_LOGIPS2PP)	+=
 psmouse-$(CONFIG_MOUSE_PS2_LIFEBOOK)	+= lifebook.o
 psmouse-$(CONFIG_MOUSE_PS2_TRACKPOINT)	+= trackpoint.o
 psmouse-$(CONFIG_MOUSE_PS2_TOUCHKIT)	+= touchkit_ps2.o
+psmouse-$(CONFIG_MOUSE_PS2_OLPC)	+= olpc.o
Index: linux-2.6.23.17/drivers/input/mouse/psmouse-base.c
===================================================================
--- linux-2.6.23.17.orig/drivers/input/mouse/psmouse-base.c
+++ linux-2.6.23.17/drivers/input/mouse/psmouse-base.c
@@ -26,6 +26,7 @@
 #include "synaptics.h"
 #include "logips2pp.h"
 #include "alps.h"
+#include "olpc.h"
 #include "lifebook.h"
 #include "trackpoint.h"
 #include "touchkit_ps2.h"
@@ -103,7 +104,7 @@ static struct attribute_group psmouse_at
  */
 static DEFINE_MUTEX(psmouse_mutex);
 
-static struct workqueue_struct *kpsmoused_wq;
+struct workqueue_struct *kpsmoused_wq;
 
 struct psmouse_protocol {
 	enum psmouse_type type;
@@ -320,7 +321,7 @@ static irqreturn_t psmouse_interrupt(str
 			goto out;
 		}
 
-		if (psmouse->packet[1] == PSMOUSE_RET_ID) {
+		if (psmouse->packet[1] == PSMOUSE_RET_ID || psmouse->packet[1] == PSMOUSE_RET_BAT) {
 			__psmouse_set_state(psmouse, PSMOUSE_IGNORE);
 			serio_reconnect(serio);
 			goto out;
@@ -631,8 +632,21 @@ static int psmouse_extensions(struct psm
 		}
 	}
 
+/*
+ * Try OLPC touchpad.
+ */
 	if (max_proto > PSMOUSE_IMEX) {
+		if (olpc_detect(psmouse, set_properties) == 0) {
+			if (!set_properties || olpc_init(psmouse) == 0)
+				return PSMOUSE_OLPC;
+/*
+ * Init failed, try basic relative protocols
+ */
+			max_proto = PSMOUSE_IMEX;
+		}
+	}
 
+	if (max_proto > PSMOUSE_IMEX) {
 		if (genius_detect(psmouse, set_properties) == 0)
 			return PSMOUSE_GENPS;
 
@@ -762,6 +776,14 @@ static const struct psmouse_protocol psm
 		.detect		= touchkit_ps2_detect,
 	},
 #endif
+#ifdef CONFIG_MOUSE_PS2_OLPC
+	{
+		.type		= PSMOUSE_OLPC,
+		.name		= "OLPC",
+		.alias		= "olpc",
+		.detect		= olpc_detect,
+	},
+#endif
 	{
 		.type		= PSMOUSE_CORTRON,
 		.name		= "CortronPS/2",
Index: linux-2.6.23.17/drivers/input/mouse/psmouse.h
===================================================================
--- linux-2.6.23.17.orig/drivers/input/mouse/psmouse.h
+++ linux-2.6.23.17/drivers/input/mouse/psmouse.h
@@ -89,6 +89,7 @@ enum psmouse_type {
 	PSMOUSE_TRACKPOINT,
 	PSMOUSE_TOUCHKIT_PS2,
 	PSMOUSE_CORTRON,
+	PSMOUSE_OLPC,
 	PSMOUSE_AUTO		/* This one should always be last */
 };
 
@@ -96,6 +97,7 @@ int psmouse_sliced_command(struct psmous
 int psmouse_reset(struct psmouse *psmouse);
 void psmouse_set_resolution(struct psmouse *psmouse, unsigned int resolution);
 
+extern struct workqueue_struct *kpsmoused_wq;
 
 struct psmouse_attribute {
 	struct device_attribute dattr;
Index: linux-2.6.23.17/drivers/input/serio/i8042.c
===================================================================
--- linux-2.6.23.17.orig/drivers/input/serio/i8042.c
+++ linux-2.6.23.17/drivers/input/serio/i8042.c
@@ -868,6 +868,11 @@ static long i8042_panic_blink(long count
 #undef DELAY
 
 #ifdef CONFIG_PM
+
+#ifdef CONFIG_OLPC
+#include <asm/olpc.h>
+#endif
+
 /*
  * Here we try to restore the original BIOS settings. We only want to
  * do that once, when we really suspend, not when we taking memory
@@ -878,8 +883,15 @@ static long i8042_panic_blink(long count
 static int i8042_suspend(struct platform_device *dev, pm_message_t state)
 {
 	if (dev->dev.power.power_state.event != state.event) {
+#ifdef CONFIG_OLPC
+		/* Anything newer than B2 remains powered; no reset needed */
+		if (olpc_rev_before(OLPC_REV_PRE_B3)) {
+#endif
 		if (state.event == PM_EVENT_SUSPEND)
 			i8042_controller_reset();
+#ifdef CONFIG_OLPC
+		}
+#endif
 
 		dev->dev.power.power_state = state;
 	}
@@ -902,9 +914,15 @@ static int i8042_resume(struct platform_
 	if (dev->dev.power.power_state.event == PM_EVENT_ON)
 		return 0;
 
+#ifdef CONFIG_OLPC
+	if (olpc_rev_before(OLPC_REV_PRE_B3)) {
+#endif
 	error = i8042_controller_check();
 	if (error)
 		return error;
+#ifdef CONFIG_OLPC
+	}
+#endif
 
 	error = i8042_controller_selftest();
 	if (error)
Index: linux-2.6.23.17/drivers/input/serio/serio.c
===================================================================
--- linux-2.6.23.17.orig/drivers/input/serio/serio.c
+++ linux-2.6.23.17/drivers/input/serio/serio.c
@@ -916,11 +916,22 @@ static int serio_uevent(struct device *d
 #endif /* CONFIG_HOTPLUG */
 
 #ifdef CONFIG_PM
+
+#ifdef CONFIG_OLPC
+#include <asm/olpc.h>
+#endif
+
 static int serio_suspend(struct device *dev, pm_message_t state)
 {
 	if (dev->power.power_state.event != state.event) {
+#ifdef CONFIG_OLPC
+		if (olpc_rev_before(OLPC_REV_PRE_B3)) {
+#endif
 		if (state.event == PM_EVENT_SUSPEND)
 			serio_cleanup(to_serio_port(dev));
+#ifdef CONFIG_OLPC
+		}
+#endif
 
 		dev->power.power_state = state;
 	}
Index: linux-2.6.23.17/drivers/media/video/cafe_ccic.c
===================================================================
--- linux-2.6.23.17.orig/drivers/media/video/cafe_ccic.c
+++ linux-2.6.23.17/drivers/media/video/cafe_ccic.c
@@ -63,13 +63,13 @@ MODULE_SUPPORTED_DEVICE("Video");
  */
 
 #define MAX_DMA_BUFS 3
-static int alloc_bufs_at_load = 0;
-module_param(alloc_bufs_at_load, bool, 0444);
-MODULE_PARM_DESC(alloc_bufs_at_load,
-		"Non-zero value causes DMA buffers to be allocated at module "
-		"load time.  This increases the chances of successfully getting "
-		"those buffers, but at the cost of nailing down the memory from "
-		"the outset.");
+static int alloc_bufs_at_read = 0;
+module_param(alloc_bufs_at_read, bool, 0444);
+MODULE_PARM_DESC(alloc_bufs_at_read,
+		"Non-zero value causes DMA buffers to be allocated when the "
+		"video capture device is read, rather than at module load "
+		"time.  This saves memory, but decreases the chances of "
+		"successfully getting those buffers.");
 
 static int n_dma_bufs = 3;
 module_param(n_dma_bufs, uint, 0644);
@@ -370,6 +370,10 @@ static int cafe_smbus_write_data(struct 
 	rval = value | ((command << TWSIC1_ADDR_SHIFT) & TWSIC1_ADDR);
 	cafe_reg_write(cam, REG_TWSIC1, rval);
 	spin_unlock_irqrestore(&cam->dev_lock, flags);
+	mdelay(2); /* It'll probably take about 900µs anyway, and the
+		      CAFÉ is apparently quite sensitive to being poked
+		      at this point. If we can work out precisely what's
+		      going on and reduce this delay, it would be nice. */
 
 	/*
 	 * Time to wait for the write to complete.  THIS IS A RACY
@@ -1503,7 +1507,7 @@ static int cafe_v4l_release(struct inode
 	}
 	if (cam->users == 0) {
 		cafe_ctlr_power_down(cam);
-		if (! alloc_bufs_at_load)
+		if (alloc_bufs_at_read)
 			cafe_free_dma_bufs(cam);
 	}
 	mutex_unlock(&cam->s_mutex);
@@ -2162,7 +2166,7 @@ static int cafe_pci_probe(struct pci_dev
 	/*
 	 * If so requested, try to get our DMA buffers now.
 	 */
-	if (alloc_bufs_at_load) {
+	if (!alloc_bufs_at_read) {
 		if (cafe_alloc_dma_bufs(cam, 1))
 			cam_warn(cam, "Unable to alloc DMA buffers at load"
 					" will try again later.");
Index: linux-2.6.23.17/drivers/misc/Kconfig
===================================================================
--- linux-2.6.23.17.orig/drivers/misc/Kconfig
+++ linux-2.6.23.17/drivers/misc/Kconfig
@@ -202,5 +202,10 @@ config THINKPAD_ACPI_BAY
 
 	  If you are not sure, say Y here.
 
+config EEPROM_93CX6
+	tristate "EEPROM 93CX6 support"
+	---help---
+	  This is a driver for the EEPROM chipsets 93c46 and 93c66.
+	  The driver supports both read as well as write commands.
 
 endif # MISC_DEVICES
Index: linux-2.6.23.17/drivers/mmc/host/sdhci.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mmc/host/sdhci.c
+++ linux-2.6.23.17/drivers/mmc/host/sdhci.c
@@ -411,6 +411,12 @@ static void sdhci_prepare_data(struct sd
 			break;
 	}
 
+	/*
+	 * There's an off-by-one error in the hw that we need to
+	 * compensate for.
+	 */
+	count++;
+
 	if (count >= 0xF) {
 		printk(KERN_WARNING "%s: Too large timeout requested!\n",
 			mmc_hostname(host->mmc));
@@ -676,19 +682,17 @@ static void sdhci_set_power(struct sdhci
 	if (!(host->chip->quirks & SDHCI_QUIRK_SINGLE_POWER_WRITE))
 		writeb(0, host->ioaddr + SDHCI_POWER_CONTROL);
 
-	pwr = SDHCI_POWER_ON;
-
 	switch (1 << power) {
 	case MMC_VDD_165_195:
-		pwr |= SDHCI_POWER_180;
+		pwr = SDHCI_POWER_180;
 		break;
 	case MMC_VDD_29_30:
 	case MMC_VDD_30_31:
-		pwr |= SDHCI_POWER_300;
+		pwr = SDHCI_POWER_300;
 		break;
 	case MMC_VDD_32_33:
 	case MMC_VDD_33_34:
-		pwr |= SDHCI_POWER_330;
+		pwr = SDHCI_POWER_330;
 		break;
 	default:
 		BUG();
@@ -696,6 +700,10 @@ static void sdhci_set_power(struct sdhci
 
 	writeb(pwr, host->ioaddr + SDHCI_POWER_CONTROL);
 
+	pwr |= SDHCI_POWER_ON;
+
+	writeb(pwr, host->ioaddr + SDHCI_POWER_CONTROL);
+
 out:
 	host->power = power;
 }
Index: linux-2.6.23.17/drivers/mtd/Kconfig
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/Kconfig
+++ linux-2.6.23.17/drivers/mtd/Kconfig
@@ -288,6 +288,14 @@ config SSFDC
 	  This enables read only access to SmartMedia formatted NAND
 	  flash. You can mount it with FAT file system.
 
+config MTD_OOPS
+	tristate "Log panic/oops to an MTD buffer"
+	depends on MTD
+	help
+	  This enables panic and oops messages to be logged to a circular
+	  buffer in a flash partition where it can be read back at some
+	  later point.
+
 source "drivers/mtd/chips/Kconfig"
 
 source "drivers/mtd/maps/Kconfig"
Index: linux-2.6.23.17/drivers/mtd/Makefile
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/Makefile
+++ linux-2.6.23.17/drivers/mtd/Makefile
@@ -22,6 +22,7 @@ obj-$(CONFIG_NFTL)		+= nftl.o
 obj-$(CONFIG_INFTL)		+= inftl.o
 obj-$(CONFIG_RFD_FTL)		+= rfd_ftl.o
 obj-$(CONFIG_SSFDC)		+= ssfdc.o
+obj-$(CONFIG_MTD_OOPS)		+= mtdoops.o
 
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
Index: linux-2.6.23.17/drivers/mtd/chips/cfi_cmdset_0001.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/chips/cfi_cmdset_0001.c
+++ linux-2.6.23.17/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -526,7 +526,7 @@ static int cfi_intelext_partition_fixup(
 	struct cfi_pri_intelext *extp = cfi->cmdset_priv;
 
 	/*
-	 * Probing of multi-partition flash ships.
+	 * Probing of multi-partition flash chips.
 	 *
 	 * To support multiple partitions when available, we simply arrange
 	 * for each of them to have their own flchip structure even if they
@@ -1781,7 +1781,7 @@ static int __xipram do_erase_oneblock(st
 	return ret;
 }
 
-int cfi_intelext_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
+static int cfi_intelext_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
 {
 	unsigned long ofs, len;
 	int ret;
@@ -1931,7 +1931,7 @@ static int cfi_intelext_lock(struct mtd_
 	printk(KERN_DEBUG "%s: lock status before, ofs=0x%08llx, len=0x%08X\n",
 	       __FUNCTION__, ofs, len);
 	cfi_varsize_frob(mtd, do_printlockstatus_oneblock,
-		ofs, len, 0);
+		ofs, len, NULL);
 #endif
 
 	ret = cfi_varsize_frob(mtd, do_xxlock_oneblock,
@@ -1941,7 +1941,7 @@ static int cfi_intelext_lock(struct mtd_
 	printk(KERN_DEBUG "%s: lock status after, ret=%d\n",
 	       __FUNCTION__, ret);
 	cfi_varsize_frob(mtd, do_printlockstatus_oneblock,
-		ofs, len, 0);
+		ofs, len, NULL);
 #endif
 
 	return ret;
@@ -1955,7 +1955,7 @@ static int cfi_intelext_unlock(struct mt
 	printk(KERN_DEBUG "%s: lock status before, ofs=0x%08llx, len=0x%08X\n",
 	       __FUNCTION__, ofs, len);
 	cfi_varsize_frob(mtd, do_printlockstatus_oneblock,
-		ofs, len, 0);
+		ofs, len, NULL);
 #endif
 
 	ret = cfi_varsize_frob(mtd, do_xxlock_oneblock,
@@ -1965,7 +1965,7 @@ static int cfi_intelext_unlock(struct mt
 	printk(KERN_DEBUG "%s: lock status after, ret=%d\n",
 	       __FUNCTION__, ret);
 	cfi_varsize_frob(mtd, do_printlockstatus_oneblock,
-		ofs, len, 0);
+		ofs, len, NULL);
 #endif
 
 	return ret;
@@ -2256,7 +2256,7 @@ static void cfi_intelext_save_locks(stru
 			adr = region->offset + block * len;
 
 			status = cfi_varsize_frob(mtd,
-					do_getlockstatus_oneblock, adr, len, 0);
+					do_getlockstatus_oneblock, adr, len, NULL);
 			if (status)
 				set_bit(block, region->lockmap);
 			else
Index: linux-2.6.23.17/drivers/mtd/chips/cfi_cmdset_0002.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/chips/cfi_cmdset_0002.c
+++ linux-2.6.23.17/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -1617,7 +1617,7 @@ static int __xipram do_erase_oneblock(st
 }
 
 
-int cfi_amdstd_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
+static int cfi_amdstd_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)
 {
 	unsigned long ofs, len;
 	int ret;
Index: linux-2.6.23.17/drivers/mtd/chips/jedec_probe.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/chips/jedec_probe.c
+++ linux-2.6.23.17/drivers/mtd/chips/jedec_probe.c
@@ -70,6 +70,7 @@
 
 /* Fujitsu */
 #define MBM29F040C	0x00A4
+#define MBM29F800BA	0x2258
 #define MBM29LV650UE	0x22D7
 #define MBM29LV320TE	0x22F6
 #define MBM29LV320BE	0x22F9
@@ -129,6 +130,7 @@
 #define LH28F640BF	0x00b0
 
 /* ST - www.st.com */
+#define M29F800AB	0x0058
 #define M29W800DT	0x00D7
 #define M29W800DB	0x005B
 #define M29W160DT	0x22C4
@@ -646,6 +648,23 @@ static const struct amd_flash_info jedec
 		}
 	}, {
 		.mfr_id		= MANUFACTURER_FUJITSU,
+		.dev_id		= MBM29F800BA,
+		.name		= "Fujitsu MBM29F800BA",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,15),
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_FUJITSU,
 		.dev_id		= MBM29LV650UE,
 		.name		= "Fujitsu MBM29LV650UE",
 		.uaddr		= {
@@ -1510,6 +1529,23 @@ static const struct amd_flash_info jedec
                        ERASEINFO(0x1000,256)
                }
 
+	}, {
+		.mfr_id		= MANUFACTURER_ST,
+		.dev_id		= M29F800AB,
+		.name		= "ST M29F800AB",
+		.uaddr		= {
+			[0] = MTD_UADDR_0x0AAA_0x0555,  /* x8 */
+			[1] = MTD_UADDR_0x0555_0x02AA,  /* x16 */
+		},
+		.DevSize	= SIZE_1MiB,
+		.CmdSet		= P_ID_AMD_STD,
+		.NumEraseRegions= 4,
+		.regions	= {
+			ERASEINFO(0x04000,1),
+			ERASEINFO(0x02000,2),
+			ERASEINFO(0x08000,1),
+			ERASEINFO(0x10000,15),
+		}
        }, {
 		.mfr_id		= MANUFACTURER_ST,	/* FIXME - CFI device? */
 		.dev_id		= M29W800DT,
Index: linux-2.6.23.17/drivers/mtd/devices/Kconfig
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/devices/Kconfig
+++ linux-2.6.23.17/drivers/mtd/devices/Kconfig
@@ -69,12 +69,21 @@ config MTD_DATAFLASH26
 	  If you have such a board and such a DataFlash, say 'Y'.
 
 config MTD_M25P80
-	tristate "Support for M25 SPI Flash"
+	tristate "Support most SPI Flash chips (AT26DF, M25P, W25X, ...)"
 	depends on SPI_MASTER && EXPERIMENTAL
 	help
-	  This enables access to ST M25P80 and similar SPI flash chips,
-	  used for program and data storage.  Set up your spi devices
-	  with the right board-specific platform data.
+	  This enables access to most modern SPI flash chips, used for
+	  program and data storage.   Series supported include Atmel AT26DF,
+	  Spansion S25SL, SST 25VF, ST M25P, and Winbond W25X.  Other chips
+	  are supported as well.  See the driver source for the current list,
+	  or to add other chips.
+
+	  Note that the original DataFlash chips (AT45 series, not AT26DF),
+	  need an entirely different driver.
+
+	  Set up your spi devices with the right board-specific platform data,
+	  if you want to specify device partitioning or to use a device which
+	  doesn't support the JEDEC ID instruction.
 
 config MTD_SLRAM
 	tristate "Uncached system RAM"
Index: linux-2.6.23.17/drivers/mtd/devices/m25p80.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/devices/m25p80.c
+++ linux-2.6.23.17/drivers/mtd/devices/m25p80.c
@@ -1,5 +1,5 @@
 /*
- * MTD SPI driver for ST M25Pxx flash chips
+ * MTD SPI driver for ST M25Pxx (and similar) serial flash chips
  *
  * Author: Mike Lavender, mike@steroidmicros.com
  *
@@ -19,33 +19,32 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/interrupt.h>
-#include <linux/interrupt.h>
+#include <linux/mutex.h>
+
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
+
 #include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
 
-#include <asm/semaphore.h>
-
-
-/* NOTE: AT 25F and SST 25LF series are very similar,
- * but commands for sector erase and chip id differ...
- */
 
 #define FLASH_PAGESIZE		256
 
 /* Flash opcodes. */
-#define	OPCODE_WREN		6	/* Write enable */
-#define	OPCODE_RDSR		5	/* Read status register */
-#define	OPCODE_READ		3	/* Read data bytes */
-#define	OPCODE_PP		2	/* Page program */
-#define	OPCODE_SE		0xd8	/* Sector erase */
-#define	OPCODE_RES		0xab	/* Read Electronic Signature */
+#define	OPCODE_WREN		0x06	/* Write enable */
+#define	OPCODE_RDSR		0x05	/* Read status register */
+#define	OPCODE_READ		0x03	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define	OPCODE_BE_4K 		0x20	/* Erase 4KiB block */
+#define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
 #define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
 
 /* Status Register bits. */
 #define	SR_WIP			1	/* Write in progress */
 #define	SR_WEL			2	/* Write enable latch */
+/* meaning of other SR_* bits may differ between vendors */
 #define	SR_BP0			4	/* Block protect 0 */
 #define	SR_BP1			8	/* Block protect 1 */
 #define	SR_BP2			0x10	/* Block protect 2 */
@@ -65,9 +64,10 @@
 
 struct m25p {
 	struct spi_device	*spi;
-	struct semaphore	lock;
+	struct mutex		lock;
 	struct mtd_info		mtd;
-	unsigned		partitioned;
+	unsigned		partitioned:1;
+	u8			erase_opcode;
 	u8			command[4];
 };
 
@@ -150,8 +150,9 @@ static int wait_till_ready(struct m25p *
  */
 static int erase_sector(struct m25p *flash, u32 offset)
 {
-	DEBUG(MTD_DEBUG_LEVEL3, "%s: %s at 0x%08x\n", flash->spi->dev.bus_id,
-			__FUNCTION__, offset);
+	DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
+			flash->spi->dev.bus_id, __FUNCTION__,
+			flash->mtd.erasesize / 1024, offset);
 
 	/* Wait until finished previous write command. */
 	if (wait_till_ready(flash))
@@ -161,7 +162,7 @@ static int erase_sector(struct m25p *fla
 	write_enable(flash);
 
 	/* Set up command buffer. */
-	flash->command[0] = OPCODE_SE;
+	flash->command[0] = flash->erase_opcode;
 	flash->command[1] = offset >> 16;
 	flash->command[2] = offset >> 8;
 	flash->command[3] = offset;
@@ -201,13 +202,17 @@ static int m25p80_erase(struct mtd_info 
 	addr = instr->addr;
 	len = instr->len;
 
-  	down(&flash->lock);
+	mutex_lock(&flash->lock);
+
+	/* REVISIT in some cases we could speed up erasing large regions
+	 * by using OPCODE_SE instead of OPCODE_BE_4K
+	 */
 
 	/* now erase those sectors */
 	while (len) {
 		if (erase_sector(flash, addr)) {
 			instr->state = MTD_ERASE_FAILED;
-			up(&flash->lock);
+			mutex_unlock(&flash->lock);
 			return -EIO;
 		}
 
@@ -215,7 +220,7 @@ static int m25p80_erase(struct mtd_info 
 		len -= mtd->erasesize;
 	}
 
-  	up(&flash->lock);
+	mutex_unlock(&flash->lock);
 
 	instr->state = MTD_ERASE_DONE;
 	mtd_erase_callback(instr);
@@ -260,16 +265,19 @@ static int m25p80_read(struct mtd_info *
 	if (retlen)
 		*retlen = 0;
 
-	down(&flash->lock);
+	mutex_lock(&flash->lock);
 
 	/* Wait till previous write/erase is done. */
 	if (wait_till_ready(flash)) {
 		/* REVISIT status return?? */
-		up(&flash->lock);
+		mutex_unlock(&flash->lock);
 		return 1;
 	}
 
-	/* NOTE:  OPCODE_FAST_READ (if available) is faster... */
+	/* FIXME switch to OPCODE_FAST_READ.  It's required for higher
+	 * clocks; and at this writing, every chip this driver handles
+	 * supports that opcode.
+	 */
 
 	/* Set up the write data buffer. */
 	flash->command[0] = OPCODE_READ;
@@ -281,7 +289,7 @@ static int m25p80_read(struct mtd_info *
 
 	*retlen = m.actual_length - sizeof(flash->command);
 
-  	up(&flash->lock);
+	mutex_unlock(&flash->lock);
 
 	return 0;
 }
@@ -323,7 +331,7 @@ static int m25p80_write(struct mtd_info 
 	t[1].tx_buf = buf;
 	spi_message_add_tail(&t[1], &m);
 
-  	down(&flash->lock);
+	mutex_lock(&flash->lock);
 
 	/* Wait until finished previous write command. */
 	if (wait_till_ready(flash))
@@ -381,10 +389,10 @@ static int m25p80_write(struct mtd_info 
 			if (retlen)
 				*retlen += m.actual_length
 					- sizeof(flash->command);
-	        }
- 	}
+		}
+	}
 
-	up(&flash->lock);
+	mutex_unlock(&flash->lock);
 
 	return 0;
 }
@@ -398,24 +406,118 @@ static int m25p80_write(struct mtd_info 
 
 struct flash_info {
 	char		*name;
-	u8		id;
-	u16		jedec_id;
+
+	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+	 * a high byte of zero plus three data bytes: the manufacturer id,
+	 * then a two byte device id.
+	 */
+	u32		jedec_id;
+
+	/* The size listed here is what works with OPCODE_SE, which isn't
+	 * necessarily called a "sector" by the vendor.
+	 */
 	unsigned	sector_size;
-	unsigned	n_sectors;
+	u16		n_sectors;
+
+	u16		flags;
+#define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
 };
 
+
+/* NOTE: double check command sets and memory organization when you add
+ * more flash chips.  This current list focusses on newer chips, which
+ * have been converging on command sets which including JEDEC ID.
+ */
 static struct flash_info __devinitdata m25p_data [] = {
-	/* REVISIT: fill in JEDEC ids, for parts that have them */
-	{ "m25p05", 0x05, 0x2010, 32 * 1024, 2 },
-	{ "m25p10", 0x10, 0x2011, 32 * 1024, 4 },
-	{ "m25p20", 0x11, 0x2012, 64 * 1024, 4 },
-	{ "m25p40", 0x12, 0x2013, 64 * 1024, 8 },
-	{ "m25p80", 0x13, 0x0000, 64 * 1024, 16 },
-	{ "m25p16", 0x14, 0x2015, 64 * 1024, 32 },
-	{ "m25p32", 0x15, 0x2016, 64 * 1024, 64 },
-	{ "m25p64", 0x16, 0x2017, 64 * 1024, 128 },
+
+	/* Atmel -- some are (confusingly) marketed as "DataFlash" */
+	{ "at25fs010",  0x1f6601, 32 * 1024, 4, SECT_4K, },
+	{ "at25fs040",  0x1f6604, 64 * 1024, 8, SECT_4K, },
+
+	{ "at25df041a", 0x1f4401, 64 * 1024, 8, SECT_4K, },
+
+	{ "at26f004",   0x1f0400, 64 * 1024, 8, SECT_4K, },
+	{ "at26df081a", 0x1f4501, 64 * 1024, 16, SECT_4K, },
+	{ "at26df161a", 0x1f4601, 64 * 1024, 32, SECT_4K, },
+	{ "at26df321",  0x1f4701, 64 * 1024, 64, SECT_4K, },
+
+	/* Spansion -- single (large) sector size only, at least
+	 * for the chips listed here (without boot sectors).
+	 */
+	{ "s25sl004a", 0x010212, 64 * 1024, 8, },
+	{ "s25sl008a", 0x010213, 64 * 1024, 16, },
+	{ "s25sl016a", 0x010214, 64 * 1024, 32, },
+	{ "s25sl032a", 0x010215, 64 * 1024, 64, },
+	{ "s25sl064a", 0x010216, 64 * 1024, 128, },
+
+	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
+	{ "sst25vf040b", 0xbf258d, 64 * 1024, 8, SECT_4K, },
+	{ "sst25vf080b", 0xbf258e, 64 * 1024, 16, SECT_4K, },
+	{ "sst25vf016b", 0xbf2541, 64 * 1024, 32, SECT_4K, },
+	{ "sst25vf032b", 0xbf254a, 64 * 1024, 64, SECT_4K, },
+
+	/* ST Microelectronics -- newer production may have feature updates */
+	{ "m25p05",  0x202010,  32 * 1024, 2, },
+	{ "m25p10",  0x202011,  32 * 1024, 4, },
+	{ "m25p20",  0x202012,  64 * 1024, 4, },
+	{ "m25p40",  0x202013,  64 * 1024, 8, },
+	{ "m25p80",         0,  64 * 1024, 16, },
+	{ "m25p16",  0x202015,  64 * 1024, 32, },
+	{ "m25p32",  0x202016,  64 * 1024, 64, },
+	{ "m25p64",  0x202017,  64 * 1024, 128, },
+	{ "m25p128", 0x202018, 256 * 1024, 64, },
+
+	{ "m45pe80", 0x204014,  64 * 1024, 16, },
+	{ "m45pe16", 0x204015,  64 * 1024, 32, },
+
+	{ "m25pe80", 0x208014,  64 * 1024, 16, },
+	{ "m25pe16", 0x208015,  64 * 1024, 32, SECT_4K, },
+
+	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
+	{ "w25x10", 0xef3011, 64 * 1024, 2, SECT_4K, },
+	{ "w25x20", 0xef3012, 64 * 1024, 4, SECT_4K, },
+	{ "w25x40", 0xef3013, 64 * 1024, 8, SECT_4K, },
+	{ "w25x80", 0xef3014, 64 * 1024, 16, SECT_4K, },
+	{ "w25x16", 0xef3015, 64 * 1024, 32, SECT_4K, },
+	{ "w25x32", 0xef3016, 64 * 1024, 64, SECT_4K, },
+	{ "w25x64", 0xef3017, 64 * 1024, 128, SECT_4K, },
 };
 
+static struct flash_info *__devinit jedec_probe(struct spi_device *spi)
+{
+	int			tmp;
+	u8			code = OPCODE_RDID;
+	u8			id[3];
+	u32			jedec;
+	struct flash_info	*info;
+
+	/* JEDEC also defines an optional "extended device information"
+	 * string for after vendor-specific data, after the three bytes
+	 * we use here.  Supporting some chips might require using it.
+	 */
+	tmp = spi_write_then_read(spi, &code, 1, id, 3);
+	if (tmp < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d reading JEDEC ID\n",
+			spi->dev.bus_id, tmp);
+		return NULL;
+	}
+	jedec = id[0];
+	jedec = jedec << 8;
+	jedec |= id[1];
+	jedec = jedec << 8;
+	jedec |= id[2];
+
+	for (tmp = 0, info = m25p_data;
+			tmp < ARRAY_SIZE(m25p_data);
+			tmp++, info++) {
+		if (info->jedec_id == jedec)
+			return info;
+	}
+	dev_err(&spi->dev, "unrecognized JEDEC id %06x\n", jedec);
+	return NULL;
+}
+
+
 /*
  * board specific setup should have ensured the SPI clock used here
  * matches what the READ command supports, at least until this driver
@@ -429,37 +531,51 @@ static int __devinit m25p_probe(struct s
 	unsigned			i;
 
 	/* Platform data helps sort out which chip type we have, as
-	 * well as how this board partitions it.
+	 * well as how this board partitions it.  If we don't have
+	 * a chip ID, try the JEDEC id commands; they'll work for most
+	 * newer chips, even if we don't recognize the particular chip.
 	 */
 	data = spi->dev.platform_data;
-	if (!data || !data->type) {
-		/* FIXME some chips can identify themselves with RES
-		 * or JEDEC get-id commands.  Try them ...
-		 */
-		DEBUG(MTD_DEBUG_LEVEL1, "%s: no chip id\n",
-				spi->dev.bus_id);
-		return -ENODEV;
-	}
+	if (data && data->type) {
+		for (i = 0, info = m25p_data;
+				i < ARRAY_SIZE(m25p_data);
+				i++, info++) {
+			if (strcmp(data->type, info->name) == 0)
+				break;
+		}
 
-	for (i = 0, info = m25p_data; i < ARRAY_SIZE(m25p_data); i++, info++) {
-		if (strcmp(data->type, info->name) == 0)
-			break;
-	}
-	if (i == ARRAY_SIZE(m25p_data)) {
-		DEBUG(MTD_DEBUG_LEVEL1, "%s: unrecognized id %s\n",
-				spi->dev.bus_id, data->type);
+		/* unrecognized chip? */
+		if (i == ARRAY_SIZE(m25p_data)) {
+			DEBUG(MTD_DEBUG_LEVEL0, "%s: unrecognized id %s\n",
+					spi->dev.bus_id, data->type);
+			info = NULL;
+
+		/* recognized; is that chip really what's there? */
+		} else if (info->jedec_id) {
+			struct flash_info	*chip = jedec_probe(spi);
+
+			if (!chip || chip != info) {
+				dev_warn(&spi->dev, "found %s, expected %s\n",
+						chip ? chip->name : "UNKNOWN",
+						info->name);
+				info = NULL;
+			}
+		}
+	} else
+		info = jedec_probe(spi);
+
+	if (!info)
 		return -ENODEV;
-	}
 
 	flash = kzalloc(sizeof *flash, GFP_KERNEL);
 	if (!flash)
 		return -ENOMEM;
 
 	flash->spi = spi;
-	init_MUTEX(&flash->lock);
+	mutex_init(&flash->lock);
 	dev_set_drvdata(&spi->dev, flash);
 
-	if (data->name)
+	if (data && data->name)
 		flash->mtd.name = data->name;
 	else
 		flash->mtd.name = spi->dev.bus_id;
@@ -468,17 +584,25 @@ static int __devinit m25p_probe(struct s
 	flash->mtd.writesize = 1;
 	flash->mtd.flags = MTD_CAP_NORFLASH;
 	flash->mtd.size = info->sector_size * info->n_sectors;
-	flash->mtd.erasesize = info->sector_size;
 	flash->mtd.erase = m25p80_erase;
 	flash->mtd.read = m25p80_read;
 	flash->mtd.write = m25p80_write;
 
+	/* prefer "small sector" erase if possible */
+	if (info->flags & SECT_4K) {
+		flash->erase_opcode = OPCODE_BE_4K;
+		flash->mtd.erasesize = 4096;
+	} else {
+		flash->erase_opcode = OPCODE_SE;
+		flash->mtd.erasesize = info->sector_size;
+	}
+
 	dev_info(&spi->dev, "%s (%d Kbytes)\n", info->name,
 			flash->mtd.size / 1024);
 
 	DEBUG(MTD_DEBUG_LEVEL2,
-		"mtd .name = %s, .size = 0x%.8x (%uM) "
-			".erasesize = 0x%.8x (%uK) .numeraseregions = %d\n",
+		"mtd .name = %s, .size = 0x%.8x (%uMiB) "
+			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
 		flash->mtd.name,
 		flash->mtd.size, flash->mtd.size / (1024*1024),
 		flash->mtd.erasesize, flash->mtd.erasesize / 1024,
@@ -488,7 +612,7 @@ static int __devinit m25p_probe(struct s
 		for (i = 0; i < flash->mtd.numeraseregions; i++)
 			DEBUG(MTD_DEBUG_LEVEL2,
 				"mtd.eraseregions[%d] = { .offset = 0x%.8x, "
-				".erasesize = 0x%.8x (%uK), "
+				".erasesize = 0x%.8x (%uKiB), "
 				".numblocks = %d }\n",
 				i, flash->mtd.eraseregions[i].offset,
 				flash->mtd.eraseregions[i].erasesize,
@@ -516,14 +640,14 @@ static int __devinit m25p_probe(struct s
 		}
 
 		if (nr_parts > 0) {
-			for (i = 0; i < data->nr_parts; i++) {
+			for (i = 0; i < nr_parts; i++) {
 				DEBUG(MTD_DEBUG_LEVEL2, "partitions[%d] = "
 					"{.name = %s, .offset = 0x%.8x, "
-						".size = 0x%.8x (%uK) }\n",
-					i, data->parts[i].name,
-					data->parts[i].offset,
-					data->parts[i].size,
-					data->parts[i].size / 1024);
+						".size = 0x%.8x (%uKiB) }\n",
+					i, parts[i].name,
+					parts[i].offset,
+					parts[i].size,
+					parts[i].size / 1024);
 			}
 			flash->partitioned = 1;
 			return add_mtd_partitions(&flash->mtd, parts, nr_parts);
@@ -560,6 +684,11 @@ static struct spi_driver m25p80_driver =
 	},
 	.probe	= m25p_probe,
 	.remove	= __devexit_p(m25p_remove),
+
+	/* REVISIT: many of these chips have deep power-down modes, which
+	 * should clearly be entered on suspend() to minimize power use.
+	 * And also when they're otherwise idle...
+	 */
 };
 
 
Index: linux-2.6.23.17/drivers/mtd/devices/mtd_dataflash.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/devices/mtd_dataflash.c
+++ linux-2.6.23.17/drivers/mtd/devices/mtd_dataflash.c
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/device.h>
+#include <linux/mutex.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
 
@@ -89,7 +90,7 @@ struct dataflash {
 	unsigned short		page_offset;	/* offset in flash address */
 	unsigned int		page_size;	/* of bytes per page */
 
-	struct semaphore	lock;
+	struct mutex		lock;
 	struct spi_device	*spi;
 
 	struct mtd_info		mtd;
@@ -167,7 +168,7 @@ static int dataflash_erase(struct mtd_in
 	x.len = 4;
 	spi_message_add_tail(&x, &msg);
 
-	down(&priv->lock);
+	mutex_lock(&priv->lock);
 	while (instr->len > 0) {
 		unsigned int	pageaddr;
 		int		status;
@@ -210,7 +211,7 @@ static int dataflash_erase(struct mtd_in
 			instr->len -= priv->page_size;
 		}
 	}
-	up(&priv->lock);
+	mutex_unlock(&priv->lock);
 
 	/* Inform MTD subsystem that erase is complete */
 	instr->state = MTD_ERASE_DONE;
@@ -266,7 +267,7 @@ static int dataflash_read(struct mtd_inf
 	x[1].len = len;
 	spi_message_add_tail(&x[1], &msg);
 
-	down(&priv->lock);
+	mutex_lock(&priv->lock);
 
 	/* Continuous read, max clock = f(car) which may be less than
 	 * the peak rate available.  Some chips support commands with
@@ -279,7 +280,7 @@ static int dataflash_read(struct mtd_inf
 	/* plus 4 "don't care" bytes */
 
 	status = spi_sync(priv->spi, &msg);
-	up(&priv->lock);
+	mutex_unlock(&priv->lock);
 
 	if (status >= 0) {
 		*retlen = msg.actual_length - 8;
@@ -336,7 +337,7 @@ static int dataflash_write(struct mtd_in
 	else
 		writelen = len;
 
-	down(&priv->lock);
+	mutex_lock(&priv->lock);
 	while (remaining > 0) {
 		DEBUG(MTD_DEBUG_LEVEL3, "write @ %i:%i len=%i\n",
 			pageaddr, offset, writelen);
@@ -441,7 +442,7 @@ static int dataflash_write(struct mtd_in
 		else
 			writelen = remaining;
 	}
-	up(&priv->lock);
+	mutex_unlock(&priv->lock);
 
 	return status;
 }
@@ -463,7 +464,7 @@ add_dataflash(struct spi_device *spi, ch
 	if (!priv)
 		return -ENOMEM;
 
-	init_MUTEX(&priv->lock);
+	mutex_init(&priv->lock);
 	priv->spi = spi;
 	priv->page_size = pagesize;
 	priv->page_offset = pageoffset;
Index: linux-2.6.23.17/drivers/mtd/devices/pmc551.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/devices/pmc551.c
+++ linux-2.6.23.17/drivers/mtd/devices/pmc551.c
@@ -30,8 +30,8 @@
  *
  * Notes:
  *	Due to what I assume is more buggy SROM, the 64M PMC551 I
- *	have available claims that all 4 of it's DRAM banks have 64M
- *	of ram configured (making a grand total of 256M onboard).
+ *	have available claims that all 4 of its DRAM banks have 64MiB
+ *	of ram configured (making a grand total of 256MiB onboard).
  *	This is slightly annoying since the BAR0 size reflects the
  *	aperture size, not the dram size, and the V370PDC supplies no
  *	other method for memory size discovery.  This problem is
@@ -70,7 +70,7 @@
  *	 made the memory unusable, added a fix to code to touch up
  *	 the DRAM some.
  *
- * Bugs/FIXME's:
+ * Bugs/FIXMEs:
  *	* MUST fix the init function to not spin on a register
  *	waiting for it to set .. this does not safely handle busted
  *	devices that never reset the register correctly which will
@@ -562,10 +562,10 @@ static u32 fixup_pmc551(struct pci_dev *
 	/*
 	 * Some screen fun
 	 */
-	printk(KERN_DEBUG "pmc551: %d%c (0x%x) of %sprefetchable memory at "
+	printk(KERN_DEBUG "pmc551: %d%sB (0x%x) of %sprefetchable memory at "
 		"0x%llx\n", (size < 1024) ? size : (size < 1048576) ?
 		size >> 10 : size >> 20,
-		(size < 1024) ? 'B' : (size < 1048576) ? 'K' : 'M', size,
+		(size < 1024) ? "" : (size < 1048576) ? "Ki" : "Mi", size,
 		((dcmd & (0x1 << 3)) == 0) ? "non-" : "",
 		(unsigned long long)pci_resource_start(dev, 0));
 
@@ -649,14 +649,10 @@ MODULE_DESCRIPTION(PMC551_VERSION);
  * Stuff these outside the ifdef so as to not bust compiled in driver support
  */
 static int msize = 0;
-#if defined(CONFIG_MTD_PMC551_APERTURE_SIZE)
-static int asize = CONFIG_MTD_PMC551_APERTURE_SIZE;
-#else
 static int asize = 0;
-#endif
 
 module_param(msize, int, 0);
-MODULE_PARM_DESC(msize, "memory size in Megabytes [1 - 1024]");
+MODULE_PARM_DESC(msize, "memory size in MiB [1 - 1024]");
 module_param(asize, int, 0);
 MODULE_PARM_DESC(asize, "aperture size, must be <= memsize [1-1024]");
 
@@ -799,8 +795,7 @@ static int __init init_pmc551(void)
 		mtd->owner = THIS_MODULE;
 
 		if (add_mtd_device(mtd)) {
-			printk(KERN_NOTICE "pmc551: Failed to register new "
-				"device\n");
+			printk(KERN_NOTICE "pmc551: Failed to register new device\n");
 			pci_iounmap(PCI_Device, priv->start);
 			kfree(mtd->priv);
 			kfree(mtd);
@@ -811,13 +806,13 @@ static int __init init_pmc551(void)
 		pci_dev_get(PCI_Device);
 
 		printk(KERN_NOTICE "Registered pmc551 memory device.\n");
-		printk(KERN_NOTICE "Mapped %dM of memory from 0x%p to 0x%p\n",
+		printk(KERN_NOTICE "Mapped %dMiB of memory from 0x%p to 0x%p\n",
 			priv->asize >> 20,
 			priv->start, priv->start + priv->asize);
-		printk(KERN_NOTICE "Total memory is %d%c\n",
+		printk(KERN_NOTICE "Total memory is %d%sB\n",
 			(length < 1024) ? length :
 			(length < 1048576) ? length >> 10 : length >> 20,
-			(length < 1024) ? 'B' : (length < 1048576) ? 'K' : 'M');
+			(length < 1024) ? "" : (length < 1048576) ? "Ki" : "Mi");
 		priv->nextpmc551 = pmc551list;
 		pmc551list = mtd;
 		found++;
@@ -850,7 +845,7 @@ static void __exit cleanup_pmc551(void)
 		pmc551list = priv->nextpmc551;
 
 		if (priv->start) {
-			printk(KERN_DEBUG "pmc551: unmapping %dM starting at "
+			printk(KERN_DEBUG "pmc551: unmapping %dMiB starting at "
 				"0x%p\n", priv->asize >> 20, priv->start);
 			pci_iounmap(priv->dev, priv->start);
 		}
Index: linux-2.6.23.17/drivers/mtd/maps/nettel.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/maps/nettel.c
+++ linux-2.6.23.17/drivers/mtd/maps/nettel.c
@@ -158,68 +158,11 @@ static struct notifier_block nettel_noti
 	nettel_reboot_notifier, NULL, 0
 };
 
-/*
- *	Erase the configuration file system.
- *	Used to support the software reset button.
- */
-static void nettel_erasecallback(struct erase_info *done)
-{
-	wait_queue_head_t *wait_q = (wait_queue_head_t *)done->priv;
-	wake_up(wait_q);
-}
-
-static struct erase_info nettel_erase;
-
-int nettel_eraseconfig(void)
-{
-	struct mtd_info *mtd;
-	DECLARE_WAITQUEUE(wait, current);
-	wait_queue_head_t wait_q;
-	int ret;
-
-	init_waitqueue_head(&wait_q);
-	mtd = get_mtd_device(NULL, 2);
-	if (!IS_ERR(mtd)) {
-		nettel_erase.mtd = mtd;
-		nettel_erase.callback = nettel_erasecallback;
-		nettel_erase.callback = NULL;
-		nettel_erase.addr = 0;
-		nettel_erase.len = mtd->size;
-		nettel_erase.priv = (u_long) &wait_q;
-		nettel_erase.priv = 0;
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		add_wait_queue(&wait_q, &wait);
-
-		ret = mtd->erase(mtd, &nettel_erase);
-		if (ret) {
-			set_current_state(TASK_RUNNING);
-			remove_wait_queue(&wait_q, &wait);
-			put_mtd_device(mtd);
-			return(ret);
-		}
-
-		schedule();  /* Wait for erase to finish. */
-		remove_wait_queue(&wait_q, &wait);
-
-		put_mtd_device(mtd);
-	}
-
-	return(0);
-}
-
-#else
-
-int nettel_eraseconfig(void)
-{
-	return(0);
-}
-
 #endif
 
 /****************************************************************************/
 
-int __init nettel_init(void)
+static int __init nettel_init(void)
 {
 	volatile unsigned long *amdpar;
 	unsigned long amdaddr, maxsize;
@@ -421,10 +364,6 @@ int __init nettel_init(void)
 
 	intel_mtd->owner = THIS_MODULE;
 
-#ifndef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, 1);
-#endif
-
 	num_intel_partitions = sizeof(nettel_intel_partitions) /
 		sizeof(nettel_intel_partitions[0]);
 
@@ -477,7 +416,7 @@ out_unmap2:
 
 /****************************************************************************/
 
-void __exit nettel_cleanup(void)
+static void __exit nettel_cleanup(void)
 {
 #ifdef CONFIG_MTD_CFI_INTELEXT
 	unregister_reboot_notifier(&nettel_notifier_block);
Index: linux-2.6.23.17/drivers/mtd/maps/pmcmsp-ramroot.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/maps/pmcmsp-ramroot.c
+++ linux-2.6.23.17/drivers/mtd/maps/pmcmsp-ramroot.c
@@ -79,7 +79,6 @@ static int __init init_rrmap(void)
 		rr_mtd->owner = THIS_MODULE;
 
 		add_mtd_device(rr_mtd);
-		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, rr_mtd->index);
 
 		return 0;
 	}
Index: linux-2.6.23.17/drivers/mtd/mtd_blkdevs.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/mtd_blkdevs.c
+++ linux-2.6.23.17/drivers/mtd/mtd_blkdevs.c
@@ -24,10 +24,9 @@
 #include <linux/kthread.h>
 #include <asm/uaccess.h>
 
-static LIST_HEAD(blktrans_majors);
+#include "mtdcore.h"
 
-extern struct mutex mtd_table_mutex;
-extern struct mtd_info *mtd_table[];
+static LIST_HEAD(blktrans_majors);
 
 struct mtd_blkcore_priv {
 	struct task_struct *thread;
@@ -202,7 +201,7 @@ static int blktrans_ioctl(struct inode *
 	}
 }
 
-struct block_device_operations mtd_blktrans_ops = {
+static struct block_device_operations mtd_blktrans_ops = {
 	.owner		= THIS_MODULE,
 	.open		= blktrans_open,
 	.release	= blktrans_release,
Index: linux-2.6.23.17/drivers/mtd/mtdchar.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/mtdchar.c
+++ linux-2.6.23.17/drivers/mtd/mtdchar.c
@@ -137,7 +137,8 @@ static int mtd_close(struct inode *inode
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
 
-	if (mtd->sync)
+	/* Only sync if opened RW */
+	if ((file->f_mode & 2) && mtd->sync)
 		mtd->sync(mtd);
 
 	put_mtd_device(mtd);
Index: linux-2.6.23.17/drivers/mtd/mtdcore.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/mtdcore.c
+++ linux-2.6.23.17/drivers/mtd/mtdcore.c
@@ -22,6 +22,8 @@
 
 #include <linux/mtd/mtd.h>
 
+#include "mtdcore.h"
+
 /* These are exported solely for the purpose of mtd_blkdevs.c. You
    should not use them for _anything_ else */
 DEFINE_MUTEX(mtd_table_mutex);
Index: linux-2.6.23.17/drivers/mtd/nand/Kconfig
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/nand/Kconfig
+++ linux-2.6.23.17/drivers/mtd/nand/Kconfig
@@ -134,10 +134,10 @@ config MTD_NAND_S3C2410_HWECC
 
 config MTD_NAND_NDFC
 	tristate "NDFC NanD Flash Controller"
-	depends on 44x
+	depends on 4xx
 	select MTD_NAND_ECC_SMC
 	help
-	 NDFC Nand Flash Controllers are integrated in EP44x SoCs
+	 NDFC Nand Flash Controllers are integrated in IBM/AMCC's 4xx SoCs
 
 config MTD_NAND_S3C2410_CLKSTOP
 	bool "S3C2410 NAND IDLE clock stop"
@@ -237,7 +237,7 @@ config MTD_NAND_CAFE
 	select REED_SOLOMON
 	select REED_SOLOMON_DEC16
 	help
-	  Use NAND flash attached to the CAFÉ chip designed for the $100
+	  Use NAND flash attached to the CAFÉ chip designed for the OLPC
 	  laptop.
 
 config MTD_NAND_CS553X
Index: linux-2.6.23.17/drivers/mtd/nand/cafe_nand.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/nand/cafe_nand.c
+++ linux-2.6.23.17/drivers/mtd/nand/cafe_nand.c
@@ -822,14 +822,53 @@ static struct pci_device_id cafe_nand_tb
 
 MODULE_DEVICE_TABLE(pci, cafe_nand_tbl);
 
+static int cafe_nand_resume(struct pci_dev *pdev)
+{
+	uint32_t timing1, timing2, timing3;
+	uint32_t ctrl;
+	struct mtd_info *mtd = pci_get_drvdata(pdev);
+	struct cafe_priv *cafe = mtd->priv;
+
+	timing1 = timing2 = timing3 = 0xffffffff;
+       /* Start off by resetting the NAND controller completely */
+	cafe_writel(cafe, 1, NAND_RESET);
+	cafe_writel(cafe, 0, NAND_RESET);
+	cafe_writel(cafe, timing1, NAND_TIMING1);
+	cafe_writel(cafe, timing2, NAND_TIMING2);
+	cafe_writel(cafe, timing3, NAND_TIMING3);
+	cafe_writel(cafe, 0xffffffff, NAND_IRQ_MASK);
+
+        /* Disable master reset, enable NAND clock */
+	ctrl = cafe_readl(cafe, GLOBAL_CTRL);
+	ctrl &= 0xffffeff0;
+	ctrl |= 0x00007000;
+	cafe_writel(cafe, ctrl | 0x05, GLOBAL_CTRL);
+	cafe_writel(cafe, ctrl | 0x0a, GLOBAL_CTRL);
+	cafe_writel(cafe, 0, NAND_DMA_CTRL);
+	cafe_writel(cafe, 0x7006, GLOBAL_CTRL);
+	cafe_writel(cafe, 0x700a, GLOBAL_CTRL);
+
+	/* Set up DMA address */
+	cafe_writel(cafe, cafe->dmaaddr & 0xffffffff, NAND_DMA_ADDR0);
+	if (sizeof(cafe->dmaaddr) > 4)
+	/* Shift in two parts to shut the compiler up */
+		cafe_writel(cafe, (cafe->dmaaddr >> 16) >> 16, NAND_DMA_ADDR1);
+	else
+		cafe_writel(cafe, 0, NAND_DMA_ADDR1);
+
+	/* Enable NAND IRQ in global IRQ mask register */
+	cafe_writel(cafe, 0x80000007, GLOBAL_IRQ_MASK);
+	return 0;
+}
+
 static struct pci_driver cafe_nand_pci_driver = {
 	.name = "CAFÉ NAND",
 	.id_table = cafe_nand_tbl,
 	.probe = cafe_nand_probe,
 	.remove = __devexit_p(cafe_nand_remove),
+	.resume = cafe_nand_resume,
 #ifdef CONFIG_PMx
 	.suspend = cafe_nand_suspend,
-	.resume = cafe_nand_resume,
 #endif
 };
 
Index: linux-2.6.23.17/drivers/mtd/nand/ndfc.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/nand/ndfc.c
+++ linux-2.6.23.17/drivers/mtd/nand/ndfc.c
@@ -24,7 +24,11 @@
 #include <linux/platform_device.h>
 
 #include <asm/io.h>
+#ifdef CONFIG_40x
+#include <asm/ibm405.h>
+#else
 #include <asm/ibm44x.h>
+#endif
 
 struct ndfc_nand_mtd {
 	struct mtd_info			mtd;
@@ -230,7 +234,11 @@ static int ndfc_nand_probe(struct platfo
 	struct ndfc_controller *ndfc = &ndfc_ctrl;
 	unsigned long long phys = settings->ndfc_erpn | res->start;
 
+#ifndef CONFIG_PHYS_64BIT
+	ndfc->ndfcbase = ioremap((phys_addr_t)phys, res->end - res->start + 1);
+#else
 	ndfc->ndfcbase = ioremap64(phys, res->end - res->start + 1);
+#endif
 	if (!ndfc->ndfcbase) {
 		printk(KERN_ERR "NDFC: ioremap failed\n");
 		return -EIO;
Index: linux-2.6.23.17/drivers/mtd/onenand/Kconfig
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/onenand/Kconfig
+++ linux-2.6.23.17/drivers/mtd/onenand/Kconfig
@@ -40,4 +40,27 @@ config MTD_ONENAND_OTP
 
 	  OTP block is fully-guaranteed to be a valid block.
 
+config MTD_ONENAND_2X_PROGRAM
+	bool "OneNAND 2X program support"
+	help
+	  The 2X Program is an extension of Program Operation.
+	  Since the device is equipped with two DataRAMs, and two-plane NAND
+	  Flash memory array, these two component enables simultaneous program
+	  of 4KiB. Plane1 has only even blocks such as block0, block2, block4
+	  while Plane2 has only odd blocks such as block1, block3, block5.
+	  So MTD regards it as 4KiB page size and 256KiB block size
+
+	  Now the following chips support it. (KFXXX16Q2M)
+	    Demux: KFG2G16Q2M, KFH4G16Q2M, KFW8G16Q2M,
+	    Mux:   KFM2G16Q2M, KFN4G16Q2M,
+
+	  And more recent chips
+
+config MTD_ONENAND_SIM
+	tristate "OneNAND simulator support"
+	depends on MTD_PARTITIONS
+	help
+	  The simulator may simulate various OneNAND flash chips for the
+	  OneNAND MTD layer.
+
 endif # MTD_ONENAND
Index: linux-2.6.23.17/drivers/mtd/onenand/Makefile
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/onenand/Makefile
+++ linux-2.6.23.17/drivers/mtd/onenand/Makefile
@@ -8,4 +8,7 @@ obj-$(CONFIG_MTD_ONENAND)		+= onenand.o
 # Board specific.
 obj-$(CONFIG_MTD_ONENAND_GENERIC)	+= generic.o
 
+# Simulator
+obj-$(CONFIG_MTD_ONENAND_SIM)		+= onenand_sim.o
+
 onenand-objs = onenand_base.o onenand_bbt.o
Index: linux-2.6.23.17/drivers/mtd/onenand/onenand_base.c
===================================================================
--- linux-2.6.23.17.orig/drivers/mtd/onenand/onenand_base.c
+++ linux-2.6.23.17/drivers/mtd/onenand/onenand_base.c
@@ -206,6 +206,15 @@ static int onenand_command(struct mtd_in
 	default:
 		block = (int) (addr >> this->erase_shift);
 		page = (int) (addr >> this->page_shift);
+
+		if (ONENAND_IS_2PLANE(this)) {
+			/* Make the even block number */
+			block &= ~1;
+			/* Is it the odd plane? */
+			if (addr & this->writesize)
+				block++;
+			page >>= 1;
+		}
 		page &= this->page_mask;
 		break;
 	}
@@ -216,8 +225,12 @@ static int onenand_command(struct mtd_in
 		value = onenand_bufferram_address(this, block);
 		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
 
-		/* Switch to the next data buffer */
-		ONENAND_SET_NEXT_BUFFERRAM(this);
+		if (ONENAND_IS_2PLANE(this))
+			/* It is always BufferRAM0 */
+			ONENAND_SET_BUFFERRAM0(this);
+		else
+			/* Switch to the next data buffer */
+			ONENAND_SET_NEXT_BUFFERRAM(this);
 
 		return 0;
 	}
@@ -247,6 +260,8 @@ static int onenand_command(struct mtd_in
 			break;
 
 		default:
+			if (ONENAND_IS_2PLANE(this) && cmd == ONENAND_CMD_PROG)
+				cmd = ONENAND_CMD_2X_PROG;
 			dataram = ONENAND_CURRENT_BUFFERRAM(this);
 			break;
 		}
@@ -445,8 +460,9 @@ static inline int onenand_bufferram_offs
 	struct onenand_chip *this = mtd->priv;
 
 	if (ONENAND_CURRENT_BUFFERRAM(this)) {
+		/* Note: the 'this->writesize' is a real page size */
 		if (area == ONENAND_DATARAM)
-			return mtd->writesize;
+			return this->writesize;
 		if (area == ONENAND_SPARERAM)
 			return mtd->oobsize;
 	}
@@ -572,6 +588,30 @@ static int onenand_write_bufferram(struc
 }
 
 /**
+ * onenand_get_2x_blockpage - [GENERIC] Get blockpage at 2x program mode
+ * @param mtd		MTD data structure
+ * @param addr		address to check
+ * @return		blockpage address
+ *
+ * Get blockpage address at 2x program mode
+ */
+static int onenand_get_2x_blockpage(struct mtd_info *mtd, loff_t addr)
+{
+	struct onenand_chip *this = mtd->priv;
+	int blockpage, block, page;
+
+	/* Calculate the even block number */
+	block = (int) (addr >> this->erase_shift) & ~1;
+	/* Is it the odd plane? */
+	if (addr & this->writesize)
+		block++;
+	page = (int) (addr >> (this->page_shift + 1)) & this->page_mask;
+	blockpage = (block << 7) | page;
+
+	return blockpage;
+}
+
+/**
  * onenand_check_bufferram - [GENERIC] Check BufferRAM information
  * @param mtd		MTD data structure
  * @param addr		address to check
@@ -585,7 +625,10 @@ static int onenand_check_bufferram(struc
 	int blockpage, found = 0;
 	unsigned int i;
 
-	blockpage = (int) (addr >> this->page_shift);
+	if (ONENAND_IS_2PLANE(this))
+		blockpage = onenand_get_2x_blockpage(mtd, addr);
+	else
+		blockpage = (int) (addr >> this->page_shift);
 
 	/* Is there valid data? */
 	i = ONENAND_CURRENT_BUFFERRAM(this);
@@ -625,7 +668,10 @@ static void onenand_update_bufferram(str
 	int blockpage;
 	unsigned int i;
 
-	blockpage = (int) (addr >> this->page_shift);
+	if (ONENAND_IS_2PLANE(this))
+		blockpage = onenand_get_2x_blockpage(mtd, addr);
+	else
+		blockpage = (int) (addr >> this->page_shift);
 
 	/* Invalidate another BufferRAM */
 	i = ONENAND_NEXT_BUFFERRAM(this);
@@ -734,6 +780,7 @@ static int onenand_read(struct mtd_info 
 	int read = 0, column;
 	int thislen;
 	int ret = 0, boundary = 0;
+	int writesize = this->writesize;
 
 	DEBUG(MTD_DEBUG_LEVEL3, "onenand_read: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
@@ -754,22 +801,22 @@ static int onenand_read(struct mtd_info 
  	/* Do first load to bufferRAM */
  	if (read < len) {
  		if (!onenand_check_bufferram(mtd, from)) {
- 			this->command(mtd, ONENAND_CMD_READ, from, mtd->writesize);
+			this->command(mtd, ONENAND_CMD_READ, from, writesize);
  			ret = this->wait(mtd, FL_READING);
  			onenand_update_bufferram(mtd, from, !ret);
  		}
  	}
 
- 	thislen = min_t(int, mtd->writesize, len - read);
- 	column = from & (mtd->writesize - 1);
- 	if (column + thislen > mtd->writesize)
- 		thislen = mtd->writesize - column;
+	thislen = min_t(int, writesize, len - read);
+	column = from & (writesize - 1);
+	if (column + thislen > writesize)
+		thislen = writesize - column;
 
  	while (!ret) {
  		/* If there is more to load then start next load */
  		from += thislen;
  		if (read + thislen < len) {
- 			this->command(mtd, ONENAND_CMD_READ, from, mtd->writesize);
+			this->command(mtd, ONENAND_CMD_READ, from, writesize);
  			/*
  			 * Chip boundary handling in DDP
  			 * Now we issued chip 1 read and pointed chip 1
@@ -794,7 +841,7 @@ static int onenand_read(struct mtd_info 
  			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
  		ONENAND_SET_NEXT_BUFFERRAM(this);
  		buf += thislen;
- 		thislen = min_t(int, mtd->writesize, len - read);
+		thislen = min_t(int, writesize, len - read);
  		column = 0;
  		cond_resched();
  		/* Now wait for load */
@@ -1079,7 +1126,7 @@ int onenand_bbt_read_oob(struct mtd_info
 		/* Read more? */
 		if (read < len) {
 			/* Update Page size */
-			from += mtd->writesize;
+			from += this->writesize;
 			column = 0;
 		}
 	}
@@ -1135,12 +1182,12 @@ static int onenand_verify(struct mtd_inf
 	int thislen, column;
 
 	while (len != 0) {
-		thislen = min_t(int, mtd->writesize, len);
-		column = addr & (mtd->writesize - 1);
-		if (column + thislen > mtd->writesize)
-			thislen = mtd->writesize - column;
+		thislen = min_t(int, this->writesize, len);
+		column = addr & (this->writesize - 1);
+		if (column + thislen > this->writesize)
+			thislen = this->writesize - column;
 
-		this->command(mtd, ONENAND_CMD_READ, addr, mtd->writesize);
+		this->command(mtd, ONENAND_CMD_READ, addr, this->writesize);
 
 		onenand_update_bufferram(mtd, addr, 0);
 
@@ -1236,6 +1283,10 @@ static int onenand_write(struct mtd_info
 
 		/* In partial page write we don't update bufferram */
 		onenand_update_bufferram(mtd, to, !ret && !subpage);
+		if (ONENAND_IS_2PLANE(this)) {
+			ONENAND_SET_BUFFERRAM1(this);
+			onenand_update_bufferram(mtd, to + this->writesize, !ret && !subpage);
+		}
 
 		if (ret) {
 			printk(KERN_ERR "onenand_write: write filaed %d\n", ret);
@@ -1384,6 +1435,10 @@ static int onenand_do_write_oob(struct m
 		this->command(mtd, ONENAND_CMD_PROGOOB, to, mtd->oobsize);
 
 		onenand_update_bufferram(mtd, to, 0);
+		if (ONENAND_IS_2PLANE(this)) {
+			ONENAND_SET_BUFFERRAM1(this);
+			onenand_update_bufferram(mtd, to + this->writesize, 0);
+		}
 
 		ret = this->wait(mtd, FL_WRITING);
 		if (ret) {
@@ -2107,6 +2162,7 @@ static int onenand_lock_user_prot_reg(st
  *
  * Check and set OneNAND features
  * - lock scheme
+ * - two plane
  */
 static void onenand_check_features(struct mtd_info *mtd)
 {
@@ -2118,19 +2174,35 @@ static void onenand_check_features(struc
 	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
 
 	/* Lock scheme */
-	if (density >= ONENAND_DEVICE_DENSITY_1Gb) {
+	switch (density) {
+	case ONENAND_DEVICE_DENSITY_4Gb:
+		this->options |= ONENAND_HAS_2PLANE;
+
+	case ONENAND_DEVICE_DENSITY_2Gb:
+		/* 2Gb DDP don't have 2 plane */
+		if (!ONENAND_IS_DDP(this))
+			this->options |= ONENAND_HAS_2PLANE;
+		this->options |= ONENAND_HAS_UNLOCK_ALL;
+
+	case ONENAND_DEVICE_DENSITY_1Gb:
 		/* A-Die has all block unlock */
-		if (process) {
-			printk(KERN_DEBUG "Chip support all block unlock\n");
+		if (process)
 			this->options |= ONENAND_HAS_UNLOCK_ALL;
-		}
-	} else {
-		/* Some OneNAND has continues lock scheme */
-		if (!process) {
-			printk(KERN_DEBUG "Lock scheme is Continues Lock\n");
+		break;
+
+	default:
+		/* Some OneNAND has continuous lock scheme */
+		if (!process)
 			this->options |= ONENAND_HAS_CONT_LOCK;
-		}
+		break;
 	}
+
+	if (this->options & ONENAND_HAS_CONT_LOCK)
+		printk(KERN_DEBUG "Lock scheme is Continuous Lock\n");
+	if (this->options & ONENAND_HAS_UNLOCK_ALL)
+		printk(KERN_DEBUG "Chip support all block unlock\n");
+	if (this->options & ONENAND_HAS_2PLANE)
+		printk(KERN_DEBUG "Chip has 2 plane\n");
 }
 
 /**
@@ -2257,6 +2329,8 @@ static int onenand_probe(struct mtd_info
 	this->erase_shift = ffs(mtd->erasesize) - 1;
 	this->page_shift = ffs(mtd->writesize) - 1;
 	this->page_mask = (1 << (this->erase_shift - this->page_shift)) - 1;
+	/* It's real page size */
+	this->writesize = mtd->writesize;
 
 	/* REVIST: Multichip handling */
 
@@ -2265,6 +2339,17 @@ static int onenand_probe(struct mtd_info
 	/* Check OneNAND features */
 	onenand_check_features(mtd);
 
+	/*
+	 * We emulate the 4KiB page and 256KiB erase block size
+	 * But oobsize is still 64 bytes.
+	 * It is only valid if you turn on 2X program support,
+	 * Otherwise it will be ignored by compiler.
+	 */
+	if (ONENAND_IS_2PLANE(this)) {
+		mtd->writesize <<= 1;
+		mtd->erasesize <<= 1;
+	}
+
 	return 0;
 }
 
Index: linux-2.6.23.17/drivers/pci/quirks.c
===================================================================
--- linux-2.6.23.17.orig/drivers/pci/quirks.c
+++ linux-2.6.23.17/drivers/pci/quirks.c
@@ -1396,6 +1396,17 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260b, quirk_intel_pcie_pm);
 
 /*
+ * According to Tom Sylla, the Geode does not support PCI power management
+ * transition, so we shouldn't need the D3hot delay.
+ */
+static void __init quirk_geode_pci_pm(struct pci_dev *dev)
+{
+	pci_pm_d3_delay = 0;
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5530_LEGACY, quirk_geode_pci_pm);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_ISA, quirk_geode_pci_pm);
+
+/*
  * Toshiba TC86C001 IDE controller reports the standard 8-byte BAR0 size
  * but the PIO transfers won't work if BAR0 falls at the odd 8 bytes.
  * Re-allocate the region if needed...
Index: linux-2.6.23.17/drivers/video/Kconfig
===================================================================
--- linux-2.6.23.17.orig/drivers/video/Kconfig
+++ linux-2.6.23.17/drivers/video/Kconfig
@@ -594,7 +594,7 @@ config FB_TGA
 
 config FB_VESA
 	bool "VESA VGA graphics support"
-	depends on (FB = y) && X86
+	depends on (FB = y) && X86 && !VGA_NOPROBE
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
@@ -1028,7 +1028,7 @@ config FB_CARILLO_RANCH
 
 config FB_INTEL
 	tristate "Intel 830M/845G/852GM/855GM/865G/915G/945G support (EXPERIMENTAL)"
-	depends on FB && EXPERIMENTAL && PCI && X86
+	depends on FB && EXPERIMENTAL && PCI && X86 && !VGA_NOPROBE
 	select AGP
 	select AGP_INTEL
 	select FB_MODE_HELPERS
@@ -1383,7 +1383,7 @@ config FB_SAVAGE_ACCEL
 
 config FB_SIS
 	tristate "SiS/XGI display support"
-	depends on FB && PCI
+	depends on FB && PCI && !VGA_NOPROBE
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
@@ -1822,6 +1822,15 @@ config FB_PS3_DEFAULT_SIZE_M
 	  The default value can be overridden on the kernel command line
 	  using the "ps3fb" option (e.g. "ps3fb=9M");
 
+config FB_OLPC_DCON
+	tristate "One Laptop Per Child Display CONtroller support"
+	depends on OLPC
+	select I2C
+	---help---
+	  Add support for the OLPC DCON controller.  This controller is only
+	  available on OLPC platforms.   Unless you have one of these
+	  platforms, you will want to say 'N'.
+
 config FB_XILINX
 	tristate "Xilinx frame buffer support"
 	depends on FB && XILINX_VIRTEX
Index: linux-2.6.23.17/drivers/video/Makefile
===================================================================
--- linux-2.6.23.17.orig/drivers/video/Makefile
+++ linux-2.6.23.17/drivers/video/Makefile
@@ -111,6 +111,7 @@ obj-$(CONFIG_FB_PNX4008_DUM_RGB)  += pnx
 obj-$(CONFIG_FB_IBM_GXT4500)	  += gxt4500.o
 obj-$(CONFIG_FB_PS3)		  += ps3fb.o
 obj-$(CONFIG_FB_SM501)            += sm501fb.o
+obj-$(CONFIG_FB_OLPC_DCON)	  += olpc_dcon.o
 obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
 obj-$(CONFIG_FB_OMAP)             += omap/
 
Index: linux-2.6.23.17/drivers/video/fbmem.c
===================================================================
--- linux-2.6.23.17.orig/drivers/video/fbmem.c
+++ linux-2.6.23.17/drivers/video/fbmem.c
@@ -820,6 +820,53 @@ static void try_to_load(int fb)
 #endif /* CONFIG_KMOD */
 
 int
+fb_powerup(struct fb_info *info)
+{
+	int ret = 0;
+
+	if (!info || info->state == FBINFO_STATE_RUNNING)
+		return 0;
+
+	if (info->fbops->fb_powerup)
+		ret = info->fbops->fb_powerup(info);
+
+	if (!ret) {
+		acquire_console_sem();
+		fb_set_suspend(info, 0);
+		release_console_sem();
+	}
+
+	return ret;
+}
+
+int
+fb_powerdown(struct fb_info *info)
+{
+	int ret = 0;
+
+	if (!info || info->state == FBINFO_STATE_SUSPENDED)
+		return 0;
+
+	/* Tell everybody that the fbdev is going down */
+	acquire_console_sem();
+	fb_set_suspend(info, 1);
+	release_console_sem();
+
+	if (info->fbops->fb_powerdown)
+		ret = info->fbops->fb_powerdown(info);
+
+	/* If the power down failed, then un-notify */
+
+	if (ret) {
+		acquire_console_sem();
+		fb_set_suspend(info, 0);
+		release_console_sem();
+	}
+
+	return ret;
+}
+
+int
 fb_pan_display(struct fb_info *info, struct fb_var_screeninfo *var)
 {
 	struct fb_fix_screeninfo *fix = &info->fix;
Index: linux-2.6.23.17/drivers/video/geode/Makefile
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/Makefile
+++ linux-2.6.23.17/drivers/video/geode/Makefile
@@ -5,5 +5,5 @@ obj-$(CONFIG_FB_GEODE_GX)  += gxfb.o
 obj-$(CONFIG_FB_GEODE_LX)  += lxfb.o
 
 gx1fb-objs := gx1fb_core.o display_gx1.o video_cs5530.o
-gxfb-objs  := gxfb_core.o display_gx.o video_gx.o
+gxfb-objs  := gxfb_core.o display_gx.o video_gx.o suspend_gx.o
 lxfb-objs  := lxfb_core.o lxfb_ops.o
Index: linux-2.6.23.17/drivers/video/geode/display_gx.c
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/display_gx.c
+++ linux-2.6.23.17/drivers/video/geode/display_gx.c
@@ -11,26 +11,44 @@
  *   Free Software Foundation; either version 2 of the License, or * (at your
  *   option) any later version.
  */
+
+#include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <linux/fb.h>
 #include <linux/delay.h>
 #include <asm/io.h>
 #include <asm/div64.h>
 #include <asm/delay.h>
+#include <asm/olpc.h>
 
 #include "geodefb.h"
 #include "display_gx.h"
 
-#ifdef CONFIG_FB_GEODE_GX_SET_FBSIZE
-unsigned int gx_frame_buffer_size(void)
+static inline void rmwl(u32 val, u32 *reg)
 {
-	return CONFIG_FB_GEODE_GX_FBSIZE;
+	u32 in = readl(reg);
+	if (in != val)
+		writel(val, reg);
 }
-#else
+
 unsigned int gx_frame_buffer_size(void)
 {
 	unsigned int val;
 
+#ifdef CONFIG_OLPC
+	if (machine_is_olpc() && !olpc_has_vsa()) {
+		u32 hi,lo;	
+		rdmsr(GLIU0_P2D_RO0, lo, hi);
+
+		/* Top page number */
+		val = ((hi & 0xff) << 12) | ((lo & 0xfff00000) >> 20);  
+
+		val -= (lo & 0x000fffff); /* Subtract bottom page number */
+		val += 1;		  /* Adjust page count */
+		return (val << 12);
+	}
+#endif
+
 	/* FB size is reported by a virtual register */
 	/* Virtual register class = 0x02 */
 	/* VG_MEM_SIZE(512Kb units) = 0x00 */
@@ -41,7 +59,6 @@ unsigned int gx_frame_buffer_size(void)
 	val = (unsigned int)(inw(0xAC1E)) & 0xFFl;
 	return (val << 19);
 }
-#endif
 
 int gx_line_delta(int xres, int bpp)
 {
@@ -63,23 +80,23 @@ static void gx_set_mode(struct fb_info *
 	gcfg = readl(par->dc_regs + DC_GENERAL_CFG);
 	dcfg = readl(par->dc_regs + DC_DISPLAY_CFG);
 
-	/* Disable the timing generator. */
-	dcfg &= ~(DC_DCFG_TGEN);
-	writel(dcfg, par->dc_regs + DC_DISPLAY_CFG);
-
-	/* Wait for pending memory requests before disabling the FIFO load. */
-	udelay(100);
-
-	/* Disable FIFO load and compression. */
-	gcfg &= ~(DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);
-	writel(gcfg, par->dc_regs + DC_GENERAL_CFG);
-
-	/* Setup DCLK and its divisor. */
-	par->vid_ops->set_dclk(info);
-
-	/*
-	 * Setup new mode.
-	 */
+	/* Programming the clock is costly and ugly, so avoid if if we can */
+
+	if (par->curdclk != info->var.pixclock) {
+		/* Disable the timing generator. */
+		dcfg &= ~(DC_DCFG_TGEN);
+		writel(dcfg, par->dc_regs + DC_DISPLAY_CFG);
+
+		/* Wait for pending memory requests before disabling the FIFO load. */
+		udelay(100);
+
+		/* Disable FIFO load and compression. */
+		gcfg &= ~(DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);
+		writel(gcfg, par->dc_regs + DC_GENERAL_CFG);
+
+		/* Setup DCLK and its divisor. */
+		par->vid_ops->set_dclk(info);
+	}
 
 	/* Clear all unused feature bits. */
 	gcfg &= DC_GCFG_YUVM | DC_GCFG_VDSE;
@@ -90,12 +107,13 @@ static void gx_set_mode(struct fb_info *
 	gcfg |= (6 << DC_GCFG_DFHPEL_POS) | (5 << DC_GCFG_DFHPSL_POS) | DC_GCFG_DFLE;
 
 	/* Framebuffer start offset. */
-	writel(0, par->dc_regs + DC_FB_ST_OFFSET);
+	rmwl(0, par->dc_regs + DC_FB_ST_OFFSET);
 
 	/* Line delta and line buffer length. */
-	writel(info->fix.line_length >> 3, par->dc_regs + DC_GFX_PITCH);
-	writel(((info->var.xres * info->var.bits_per_pixel/8) >> 3) + 2,
-	       par->dc_regs + DC_LINE_SIZE);
+	rmwl(info->fix.line_length >> 3, par->dc_regs + DC_GFX_PITCH);
+
+	rmwl(((info->var.xres * info->var.bits_per_pixel/8) >> 3) + 2,
+	     par->dc_regs + DC_LINE_SIZE);
 
 
 	/* Enable graphics and video data and unmask address lines. */
@@ -134,17 +152,16 @@ static void gx_set_mode(struct fb_info *
 	vblankend = vsyncend + info->var.upper_margin;
 	vtotal = vblankend;
 
-	writel((hactive - 1)     | ((htotal - 1) << 16),    par->dc_regs + DC_H_ACTIVE_TIMING);
-	writel((hblankstart - 1) | ((hblankend - 1) << 16), par->dc_regs + DC_H_BLANK_TIMING);
-	writel((hsyncstart - 1)  | ((hsyncend - 1) << 16),  par->dc_regs + DC_H_SYNC_TIMING);
-
-	writel((vactive - 1)     | ((vtotal - 1) << 16),    par->dc_regs + DC_V_ACTIVE_TIMING);
-	writel((vblankstart - 1) | ((vblankend - 1) << 16), par->dc_regs + DC_V_BLANK_TIMING);
-	writel((vsyncstart - 1)  | ((vsyncend - 1) << 16),  par->dc_regs + DC_V_SYNC_TIMING);
+	rmwl((hactive - 1)     | ((htotal - 1) << 16),    par->dc_regs + DC_H_ACTIVE_TIMING);
+	rmwl((hblankstart - 1) | ((hblankend - 1) << 16), par->dc_regs + DC_H_BLANK_TIMING);
+	rmwl((hsyncstart - 1)  | ((hsyncend - 1) << 16),  par->dc_regs + DC_H_SYNC_TIMING);
+	rmwl((vactive - 1)     | ((vtotal - 1) << 16),    par->dc_regs + DC_V_ACTIVE_TIMING);
+	rmwl((vblankstart - 1) | ((vblankend - 1) << 16), par->dc_regs + DC_V_BLANK_TIMING);
+	rmwl((vsyncstart - 1)  | ((vsyncend - 1) << 16),  par->dc_regs + DC_V_SYNC_TIMING);
 
 	/* Write final register values. */
-	writel(dcfg, par->dc_regs + DC_DISPLAY_CFG);
-	writel(gcfg, par->dc_regs + DC_GENERAL_CFG);
+	rmwl(dcfg, par->dc_regs + DC_DISPLAY_CFG);
+	rmwl(gcfg, par->dc_regs + DC_GENERAL_CFG);
 
 	par->vid_ops->configure_display(info);
 
Index: linux-2.6.23.17/drivers/video/geode/display_gx.h
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/display_gx.h
+++ linux-2.6.23.17/drivers/video/geode/display_gx.h
@@ -20,6 +20,9 @@ extern struct geode_dc_ops gx_dc_ops;
 #define GLD_MSR_CONFIG   0xC0002001
 #define GLD_MSR_CONFIG_DM_FP 0x40
 
+/* Used for memory dection on the OLPC */
+#define GLIU0_P2D_RO0 0x10000029
+
 /* Display controller registers */
 
 #define DC_UNLOCK 0x00
Index: linux-2.6.23.17/drivers/video/geode/geodefb.h
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/geodefb.h
+++ linux-2.6.23.17/drivers/video/geode/geodefb.h
@@ -12,6 +12,10 @@
 #ifndef __GEODEFB_H__
 #define __GEODEFB_H__
 
+#define FB_POWER_STATE_OFF      0
+#define FB_POWER_STATE_SUSPEND  1
+#define FB_POWER_STATE_ON       2
+
 struct geodefb_info;
 
 struct geode_dc_ops {
@@ -21,18 +25,24 @@ struct geode_dc_ops {
 
 struct geode_vid_ops {
 	void (*set_dclk)(struct fb_info *);
+	unsigned int (*get_dclk)(struct fb_info *);
 	void (*configure_display)(struct fb_info *);
 	int  (*blank_display)(struct fb_info *, int blank_mode);
 };
 
 struct geodefb_par {
 	int enable_crt;
+	int fbactive;  /* True if the current console is in KD_GRAPHICS mode */
 	int panel_x; /* dimensions of an attached flat panel, non-zero => enable panel */
 	int panel_y;
+	unsigned int curdclk;  /* Used by GX to avoid unnessesary clock switching */
 	void __iomem *dc_regs;
 	void __iomem *vid_regs;
+	void __iomem *gp_regs;
 	struct geode_dc_ops  *dc_ops;
 	struct geode_vid_ops *vid_ops;
+
+	int state;
 };
 
 #endif /* !__GEODEFB_H__ */
Index: linux-2.6.23.17/drivers/video/geode/gxfb_core.c
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/gxfb_core.c
+++ linux-2.6.23.17/drivers/video/geode/gxfb_core.c
@@ -30,12 +30,31 @@
 #include <linux/fb.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/notifier.h>
+#include <linux/vt_kern.h>
+#include <linux/console.h>
+#include <asm/uaccess.h>
+#include <asm/olpc.h>
 
 #include "geodefb.h"
 #include "display_gx.h"
 #include "video_gx.h"
 
+#define FBIOSGAMMA		_IOW('F', 0x20, void *)
+#define FBIOGGAMMA		_IOW('F', 0x21, void *)
+
+#ifdef DEBUG
+
+#define FBIODUMPGP		_IOW('F', 0x22, void *)
+#define FBIODUMPDC		_IOW('F', 0x23, void *)
+#define FBIODUMPVP		_IOW('F', 0x24, void *)
+#define FBIODUMPFP		_IOW('F', 0x25, void *)
+
+#endif
+
 static char *mode_option;
+static int noclear;
+struct fb_info *gxfb_info;
 
 /* Modes relevant to the GX (taken from modedb.c) */
 static const struct fb_videomode gx_modedb[] __initdata = {
@@ -103,8 +122,20 @@ static const struct fb_videomode gx_mode
 	{ NULL, 85, 1600, 1200, 4357, 304, 64, 46, 1, 192, 3,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1200x900-75 - CRT timings for the OLPC mode */
+	{ NULL, 75, 1200, 900, 8049, 104, 240, 29, 54, 136, 3,
+	  0, FB_VMODE_NONINTERLACED, 0 }
 };
 
+#ifdef CONFIG_OLPC
+static const struct fb_videomode gx_dcon_modedb[] __initdata = {
+	/* The only mode the DCON has is 1200x900 */
+	{ NULL, 50, 1200, 900, 17460, 24, 8, 4, 5, 8, 3,
+	  0, FB_VMODE_NONINTERLACED, 0 }
+};
+#endif
+
+
 static int gxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	if (var->xres > 1600 || var->yres > 1200)
@@ -137,7 +168,7 @@ static int gxfb_check_var(struct fb_var_
 	return 0;
 }
 
-static int gxfb_set_par(struct fb_info *info)
+int gxfb_set_par(struct fb_info *info)
 {
 	struct geodefb_par *par = info->par;
 
@@ -204,16 +235,26 @@ static int gxfb_blank(int blank_mode, st
 	return par->vid_ops->blank_display(info, blank_mode);
 }
 
+static int fbsize;
+
 static int __init gxfb_map_video_memory(struct fb_info *info, struct pci_dev *dev)
 {
 	struct geodefb_par *par = info->par;
-	int fb_len;
 	int ret;
 
 	ret = pci_enable_device(dev);
 	if (ret < 0)
 		return ret;
 
+	ret = pci_request_region(dev, 1, "gxfb (graphics processor)");
+	if (ret < 0)
+		return ret;
+
+	par->gp_regs = ioremap(pci_resource_start(dev, 1),
+				pci_resource_len(dev, 1));
+	if (!par->gp_regs)
+		return -ENOMEM;
+
 	ret = pci_request_region(dev, 3, "gxfb (video processor)");
 	if (ret < 0)
 		return ret;
@@ -232,36 +273,118 @@ static int __init gxfb_map_video_memory(
 	ret = pci_request_region(dev, 0, "gxfb (framebuffer)");
 	if (ret < 0)
 		return ret;
-	if ((fb_len = gx_frame_buffer_size()) < 0)
-		return -ENOMEM;
+
+	/* If the fbsize wasn't specified then try to probe it */
+
+	if (!fbsize) {
+		fbsize = gx_frame_buffer_size();
+		if (fbsize == 0)
+			return -ENOMEM;
+	}
+
 	info->fix.smem_start = pci_resource_start(dev, 0);
-	info->fix.smem_len = fb_len;
+	info->fix.smem_len = fbsize;
 	info->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);
 	if (!info->screen_base)
 		return -ENOMEM;
 
-	/* Set the 16MB aligned base address of the graphics memory region
+	/* Set the 16MiB aligned base address of the graphics memory region
 	 * in the display controller */
 
 	writel(info->fix.smem_start & 0xFF000000,
 			par->dc_regs + DC_GLIU0_MEM_OFFSET);
 
-	dev_info(&dev->dev, "%d Kibyte of video memory at 0x%lx\n",
+	dev_info(&dev->dev, "%d KiB of video memory at 0x%lx\n",
 		 info->fix.smem_len / 1024, info->fix.smem_start);
 
 	return 0;
 }
 
+static int gxfb_ioctl( struct fb_info *info, unsigned int cmd,
+		       unsigned long arg)
+{
+	unsigned int gamma[GXFB_GAMMA_DWORDS];
+	int ret = -EINVAL;
+	struct geodefb_par *par = info->par;
+	int i;
+
+	switch(cmd) {
+	case FBIOSGAMMA:
+		/* Read the gamma information from the user - 256 dwords */
+
+		if (copy_from_user(gamma, (void * __user) arg, GXFB_GAMMA_SIZE))
+			return -EFAULT;
+
+		writel(0, par->vid_regs + GX_GAR);
+
+		/* Sequential writes to the data register will increment the
+		   address automatically  */
+
+		for(i = 0; i < GXFB_GAMMA_DWORDS; i++)
+			writel(gamma[i] & 0xFFFFFF, par->vid_regs + GX_GDR);
+
+		writel(readl(par->vid_regs + GX_MISC) & ~GX_MISC_GAM_EN,
+		       par->vid_regs + GX_MISC);
+
+		ret = 0;
+		break;
+
+	case FBIOGGAMMA:
+		if (readl(par->vid_regs + GX_MISC) & GX_MISC_GAM_EN)
+			return -EINVAL;
+
+		memset(gamma, 0, GXFB_GAMMA_SIZE);
+		writel(0, par->vid_regs + GX_GAR);
+
+		for(i = 0; i < GXFB_GAMMA_DWORDS;i++)
+			gamma[i] = readl(par->vid_regs + GX_GDR);
+
+		if (copy_to_user((void * __user) arg, gamma, GXFB_GAMMA_SIZE))
+			ret = -EFAULT;
+		else
+			ret = 0;
+
+		break;
+
+#ifdef DEBUG
+	case FBIODUMPGP:
+		ret = 0;
+		dump_regs(info, 0);
+		break;
+		
+	case FBIODUMPDC:
+		ret = 0;
+		dump_regs(info, 1);
+		break;
+
+	case FBIODUMPVP:
+		ret = 0;
+		dump_regs(info, 2);
+		break;
+
+	case FBIODUMPFP:
+		ret = 0;
+		dump_regs(info, 3);
+		break;
+#endif
+	}
+
+	return ret;
+}
+
 static struct fb_ops gxfb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_check_var	= gxfb_check_var,
 	.fb_set_par	= gxfb_set_par,
 	.fb_setcolreg	= gxfb_setcolreg,
 	.fb_blank       = gxfb_blank,
+	.fb_ioctl       = gxfb_ioctl,
 	/* No HW acceleration for now. */
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
+	.fb_powerdown   = gxfb_powerdown,
+	.fb_powerup     = gxfb_powerup,
 };
 
 static struct fb_info * __init gxfb_init_fbinfo(struct device *dev)
@@ -303,23 +426,86 @@ static struct fb_info * __init gxfb_init
 	return info;
 }
 
-static int __init gxfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static int gxfb_console_notify(struct notifier_block *self,
+				unsigned long action, void *data)
+{
+	if (gxfb_info != NULL) {
+		struct geodefb_par *par = gxfb_info->par;
+		par->fbactive = (action == CONSOLE_EVENT_SWITCH_TEXT) ? 0 : 1;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block gxfb_console_notifier = {
+	.notifier_call = gxfb_console_notify
+};
+
+#ifdef CONFIG_PM
+
+static int gxfb_suspend(struct pci_dev *pdev,  pm_message_t state)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+	struct geodefb_par *par = info->par;
+
+	if (pdev->dev.power.power_state.event == state.event)
+		return 0;
+
+	if (state.event == PM_EVENT_SUSPEND) {
+	 
+		acquire_console_sem();
+		gxfb_powerdown(info);
+
+		par->state = FB_POWER_STATE_OFF;
+		fb_set_suspend(info, 1);
+		
+		release_console_sem();
+	}
+
+	pdev->dev.power.power_state = state;
+	return 0;
+}
+
+static int gxfb_resume(struct pci_dev *pdev)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+
+	acquire_console_sem();
+	
+	/* Turn the engine completely on */
+
+	if (gxfb_powerup(info))
+	  printk(KERN_ERR "gxfb:  Powerup failed\n");
+
+	fb_set_suspend(info, 0);
+	release_console_sem();
+
+	pdev->dev.power.power_state = PMSG_ON;
+        return 0;
+}
+#endif
+
+static int __init gxfb_probe(struct pci_dev *pdev,
+			     const struct pci_device_id *id)
 {
 	struct geodefb_par *par;
-	struct fb_info *info;
 	int ret;
 	unsigned long val;
 
-	info = gxfb_init_fbinfo(&pdev->dev);
-	if (!info)
+	struct fb_videomode *modedb_ptr;
+	int modedb_size;
+
+	gxfb_info = gxfb_init_fbinfo(&pdev->dev);
+	if (gxfb_info == NULL)
 		return -ENOMEM;
-	par = info->par;
+
+	par = gxfb_info->par;
 
 	/* GX display controller and GX video device. */
 	par->dc_ops  = &gx_dc_ops;
 	par->vid_ops = &gx_vid_ops;
 
-	if ((ret = gxfb_map_video_memory(info, pdev)) < 0) {
+	if ((ret = gxfb_map_video_memory(gxfb_info, pdev)) < 0) {
 		dev_err(&pdev->dev, "failed to map frame buffer or controller registers\n");
 		goto err;
 	}
@@ -333,32 +519,60 @@ static int __init gxfb_probe(struct pci_
 	else
 		par->enable_crt = 1;
 
-	ret = fb_find_mode(&info->var, info, mode_option,
-			   gx_modedb, ARRAY_SIZE(gx_modedb), NULL, 16);
+	/* Get the current dotclock */
+
+	par->curdclk = (par->vid_ops->get_dclk) ? par->vid_ops->get_dclk(gxfb_info) : 0;
+
+	/* We need to determine a display mode right now, so we will
+	 * check to see if the DCON was previously detected by the BIOS
+	 * and use that to make our mode database decision.
+	 */
+
+	modedb_ptr = (struct fb_videomode *) gx_modedb;
+	modedb_size = ARRAY_SIZE(gx_modedb);
+
+#ifdef CONFIG_OLPC
+	if (olpc_has_dcon()) {
+		modedb_ptr = (struct fb_videomode *) gx_dcon_modedb;
+		modedb_size = ARRAY_SIZE(gx_dcon_modedb);
+	}
+#endif
+
+	ret = fb_find_mode(&gxfb_info->var, gxfb_info, mode_option,
+			   modedb_ptr, modedb_size, NULL, 16);
+
 	if (ret == 0 || ret == 4) {
 		dev_err(&pdev->dev, "could not find valid video mode\n");
 		ret = -EINVAL;
 		goto err;
 	}
 
+	/* Clear the screen of garbage, unless noclear was specified,
+	 * in which case we assume the user knows what he is doing */
+
+	if (!noclear)
+		memset_io(gxfb_info->screen_base, 0, gxfb_info->fix.smem_len);
+
+	gxfb_check_var(&gxfb_info->var, gxfb_info);
+	gxfb_set_par(gxfb_info);
+
+	/* We are powered up */
+	par->state = FB_POWER_STATE_ON;
 
-	/* Clear the frame buffer of garbage. */
-        memset_io(info->screen_base, 0, info->fix.smem_len);
 
-	gxfb_check_var(&info->var, info);
-	gxfb_set_par(info);
+	console_event_register(&gxfb_console_notifier);
 
-	if (register_framebuffer(info) < 0) {
+	if (register_framebuffer(gxfb_info) < 0) {
 		ret = -EINVAL;
 		goto err;
 	}
-	pci_set_drvdata(pdev, info);
-	printk(KERN_INFO "fb%d: %s frame buffer device\n", info->node, info->fix.id);
+	pci_set_drvdata(pdev, gxfb_info);
+	printk(KERN_INFO "fb%d: %s frame buffer device\n", gxfb_info->node, gxfb_info->fix.id);
 	return 0;
 
   err:
-	if (info->screen_base) {
-		iounmap(info->screen_base);
+	if (gxfb_info->screen_base) {
+		iounmap(gxfb_info->screen_base);
 		pci_release_region(pdev, 0);
 	}
 	if (par->vid_regs) {
@@ -370,8 +584,9 @@ static int __init gxfb_probe(struct pci_
 		pci_release_region(pdev, 2);
 	}
 
-	if (info)
-		framebuffer_release(info);
+	if (gxfb_info)
+		framebuffer_release(gxfb_info);
+
 	return ret;
 }
 
@@ -397,9 +612,7 @@ static void gxfb_remove(struct pci_dev *
 }
 
 static struct pci_device_id gxfb_id_table[] = {
-	{ PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_GX_VIDEO,
-	  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,
-	  0xff0000, 0 },
+	{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_GX_VIDEO) },
 	{ 0, }
 };
 
@@ -410,22 +623,30 @@ static struct pci_driver gxfb_driver = {
 	.id_table	= gxfb_id_table,
 	.probe		= gxfb_probe,
 	.remove		= gxfb_remove,
+#ifdef CONFIG_PM
+	.suspend        = gxfb_suspend,
+	.resume         = gxfb_resume
+#endif
 };
 
 #ifndef MODULE
-static int __init gxfb_setup(char *options)
-{
+static int __init gxfb_setup(char *options) {
 
 	char *opt;
 
 	if (!options || !*options)
 		return 0;
 
-	while ((opt = strsep(&options, ",")) != NULL) {
+	while((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
 
-		mode_option = opt;
+		if (!strncmp(opt, "fbsize:", 7))
+			fbsize = simple_strtoul(opt+7, NULL, 0);
+		else if (!strcmp(opt, "noclear"))
+			noclear = 1;
+		else
+			mode_option = opt;
 	}
 
 	return 0;
@@ -444,7 +665,6 @@ static int __init gxfb_init(void)
 #endif
 	return pci_register_driver(&gxfb_driver);
 }
-
 static void __exit gxfb_cleanup(void)
 {
 	pci_unregister_driver(&gxfb_driver);
@@ -456,5 +676,8 @@ module_exit(gxfb_cleanup);
 module_param(mode_option, charp, 0);
 MODULE_PARM_DESC(mode_option, "video mode (<x>x<y>[-<bpp>][@<refr>])");
 
+module_param(fbsize, int, 0);
+MODULE_PARM_DESC(fbsize, "video memory size");
+
 MODULE_DESCRIPTION("Framebuffer driver for the AMD Geode GX");
 MODULE_LICENSE("GPL");
Index: linux-2.6.23.17/drivers/video/geode/lxfb.h
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/lxfb.h
+++ linux-2.6.23.17/drivers/video/geode/lxfb.h
@@ -25,10 +25,23 @@ void lx_set_mode(struct fb_info *);
 void lx_get_gamma(struct fb_info *, unsigned int *, int);
 void lx_set_gamma(struct fb_info *, unsigned int *, int);
 unsigned int lx_framebuffer_size(void);
+int lx_shutdown(struct fb_info *);
+int lx_powerup(struct fb_info *);
 int lx_blank_display(struct fb_info *, int);
 void lx_set_palette_reg(struct fb_info *, unsigned int, unsigned int,
 			unsigned int, unsigned int);
 
+
+
+/* ioctl() defines */
+
+#define FBIOSGAMMA              _IOW('F', 0x20, void *)
+#define FBIOGGAMMA              _IOW('F', 0x21, void *)
+
+/* General definitions */
+#define LXFB_GAMMA_DWORDS 256 /* number of dwords in the gamma ram */
+#define LXFB_GAMMA_SIZE (LXFB_GAMMA_DWORDS * sizeof(unsigned int))
+
 /* MSRS */
 
 #define MSR_LX_GLD_CONFIG    0x48002001
Index: linux-2.6.23.17/drivers/video/geode/lxfb_core.c
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/lxfb_core.c
+++ linux-2.6.23.17/drivers/video/geode/lxfb_core.c
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/uaccess.h>
+#include <asm/olpc.h>
 
 #include "lxfb.h"
 
@@ -35,186 +36,84 @@ static int fbsize;
  */
 
 const struct fb_videomode geode_modedb[] __initdata = {
-	/* 640x480-60 */
-	{ NULL, 60, 640, 480, 39682, 48, 8, 25, 2, 88, 2,
+	/* 640x480-60 VESA */
+	{ NULL, 60, 640, 480, 39682,  48, 16, 33, 10, 96, 2,
+	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 640x480-75 VESA */
+	{ NULL, 75, 640, 480, 31746, 120, 16, 16, 01, 64, 3,
+	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 640x480-85 VESA */
+	{ NULL, 85, 640, 480, 27777, 80, 56, 25, 01, 56, 3,
+	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 800x600-60 VESA */
+	{ NULL, 60, 800, 600, 25000, 88, 40, 23, 01, 128, 4,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 800x600-75 VESA */
+	{ NULL, 75, 800, 600, 20202, 160, 16, 21, 01, 80, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 800x600-85 VESA */
+	{ NULL, 85, 800, 600, 17761, 152, 32, 27, 01, 64, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1024x768-60 VESA */
+	{ NULL, 60, 1024, 768, 15384, 160, 24, 29, 3, 136, 6,
+	  0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1024x768-75 VESA */
+	{ NULL, 75, 1024, 768, 12690, 176, 16, 28, 1, 96, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1024x768-85 VESA */
+	{ NULL, 85, 1024, 768, 10582, 208, 48, 36, 1, 96, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x960-60 VESA */
+	{ NULL, 60, 1280, 960, 9259, 312, 96, 36, 1, 112, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x960-85 VESA */
+	{ NULL, 85, 1280, 960, 6734, 224, 64, 47, 1, 160, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x1024-60 VESA */
+	{ NULL, 60, 1280, 1024, 9259, 248, 48, 38, 1, 112, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x1024-75 VESA */
+	{ NULL, 75, 1280, 1024, 7407, 248, 16, 38, 1, 144, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1280x1024-85 VESA */
+	{ NULL, 85, 1280, 1024, 6349, 224, 64, 44, 1, 160, 3,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x400-70 */
-	{ NULL, 70, 640, 400, 39770, 40, 8, 28, 5, 96, 2,
-	  FB_SYNC_HOR_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-70 */
-	{ NULL, 70, 640, 480, 35014, 88, 24, 15, 2, 64, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-72 */
-	{ NULL, 72, 640, 480, 32102, 120, 16, 20, 1, 40, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-75 */
-	{ NULL, 75, 640, 480, 31746, 120, 16, 16, 1, 64, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-85 */
-	{ NULL, 85, 640, 480, 27780, 80, 56, 25, 1, 56, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-90 */
-	{ NULL, 90, 640, 480, 26392, 96, 32, 22, 1, 64, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-100 */
-	{ NULL, 100, 640, 480, 23167, 104, 40, 25, 1, 64, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 640x480-60 */
-	{ NULL, 60, 640, 480, 39682, 48, 16, 25, 10, 88, 2,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-56 */
-	{ NULL, 56, 800, 600, 27901, 128, 24, 22, 1, 72, 2,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-60 */
-	{ NULL, 60, 800, 600, 25131, 72, 32, 23, 1, 136, 4,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-70 */
-	{ NULL, 70, 800, 600, 21873, 120, 40, 21, 4, 80, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-72 */
-	{ NULL, 72, 800, 600, 20052, 64, 56, 23, 37, 120, 6,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-75 */
-	{ NULL, 75, 800, 600, 20202, 160, 16, 21, 1, 80, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-85 */
-	{ NULL, 85, 800, 600, 17790, 152, 32, 27, 1, 64, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-90 */
-	{ NULL, 90, 800, 600, 16648, 128, 40, 28, 1, 88, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-100 */
-	{ NULL, 100, 800, 600, 14667, 136, 48, 27, 1, 88, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 800x600-60 */
-	{ NULL, 60, 800, 600, 25131, 88, 40, 23, 1, 128, 4,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-60 */
-	{ NULL, 60, 1024, 768, 15385, 160, 24, 29, 3, 136, 6,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-70 */
-	{ NULL, 70, 1024, 768, 13346, 144, 24, 29, 3, 136, 6,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-72 */
-	{ NULL, 72, 1024, 768, 12702, 168, 56, 29, 4, 112, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-75 */
-	{ NULL, 75, 1024, 768, 12703, 176, 16, 28, 1, 96, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-85 */
-	{ NULL, 85, 1024, 768, 10581, 208, 48, 36, 1, 96, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-90 */
-	{ NULL, 90, 1024, 768, 9981, 176, 64, 37, 1, 112, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-100 */
-	{ NULL, 100, 1024, 768, 8825, 184, 72, 42, 1, 112, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1024x768-60 */
-	{ NULL, 60, 1024, 768, 15385, 160, 24, 29, 3, 136, 6,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-60 */
-	{ NULL, 60, 1152, 864, 12251, 184, 64, 27, 1, 120, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-70 */
-	{ NULL, 70, 1152, 864, 10254, 192, 72, 32, 8, 120, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-72 */
-	{ NULL, 72, 1152, 864, 9866, 200, 72, 33, 7, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-75 */
-	{ NULL, 75, 1152, 864, 9259, 256, 64, 32, 1, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-85 */
-	{ NULL, 85, 1152, 864, 8357, 200, 72, 37, 3, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-90 */
-	{ NULL, 90, 1152, 864, 7719, 208, 80, 42, 9, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-100 */
-	{ NULL, 100, 1152, 864, 6947, 208, 80, 48, 3, 128, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1152x864-60 */
-	{ NULL, 60, 1152, 864, 12251, 184, 64, 27, 1, 120, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-60 */
-	{ NULL, 60, 1280, 1024, 9262, 248, 48, 38, 1, 112, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-70 */
-	{ NULL, 70, 1280, 1024, 7719, 224, 88, 38, 6, 136, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-72 */
-	{ NULL, 72, 1280, 1024, 7490, 224, 88, 39, 7, 136, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-75 */
-	{ NULL, 75, 1280, 1024, 7409, 248, 16, 38, 1, 144, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-85 */
-	{ NULL, 85, 1280, 1024, 6351, 224, 64, 44, 1, 160, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-90 */
-	{ NULL, 90, 1280, 1024, 5791, 240, 96, 51, 12, 144, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-100 */
-	{ NULL, 100, 1280, 1024, 5212, 240, 96, 57, 6, 144, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1280x1024-60 */
-	{ NULL, 60, 1280, 1024, 9262, 248, 48, 38, 1, 112, 3,
-	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-60 */
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1600x1200-60 VESA */
 	{ NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-70 */
-	{ NULL, 70, 1600, 1200, 5291, 304, 64, 46, 1, 192, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-72 */
-	{ NULL, 72, 1600, 1200, 5053, 288, 112, 47, 13, 176, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-75 */
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1600x1200-75 VESA */
 	{ NULL, 75, 1600, 1200, 4938, 304, 64, 46, 1, 192, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-85 */
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1600x1200-85 VESA */
 	{ NULL, 85, 1600, 1200, 4357, 304, 64, 46, 1, 192, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-90 */
-	{ NULL, 90, 1600, 1200, 3981, 304, 128, 60, 1, 176, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-100 */
-	{ NULL, 100, 1600, 1200, 3563, 304, 128, 67, 1, 176, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1600x1200-60 */
-	{ NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,
 	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	  FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-60 */
-	{ NULL, 60, 1920, 1440, 4273, 344, 128, 56, 1, 208, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-70 */
-	{ NULL, 70, 1920, 1440, 3593, 360, 152, 55, 8, 208, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-72 */
-	{ NULL, 72, 1920, 1440, 3472, 360, 152, 68, 4, 208, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-75 */
-	{ NULL, 75, 1920, 1440, 3367, 352, 144, 56, 1, 224, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
-	/* 1920x1440-85 */
-	{ NULL, 85, 1920, 1440, 2929, 368, 152, 68, 1, 216, 3,
-	  0, FB_VMODE_NONINTERLACED, 0 },
+	  FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA },
+	/* 1200x900-75 - CRT timings for the OLPC mode */
+	{ NULL, 75, 1200, 900, 8049, 104, 240, 29, 54, 136, 3,
+	  0, FB_VMODE_NONINTERLACED, 0 }
 };
 
+#ifdef CONFIG_OLPC
+const struct fb_videomode olpc_dcon_modedb[] __initdata = {
+	/* The only mode the DCON has is 1200x900 */
+	{ NULL, 50, 1200, 900, 17460, 24, 8, 4, 5, 8, 3,
+	  FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	  FB_VMODE_NONINTERLACED, 0 }
+};
+#endif
+
 static int lxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	if (var->xres > 1920 || var->yres > 1440)
@@ -379,16 +278,55 @@ static int __init lxfb_map_video_memory(
 	return 0;
 }
 
+static int lxfb_set_gamma(struct fb_info *info, void * __user data)
+{
+	unsigned int gamma[LXFB_GAMMA_DWORDS];
+
+	if (copy_from_user(gamma, data, LXFB_GAMMA_SIZE))
+		return -EFAULT;
+
+	lx_set_gamma(info, gamma, LXFB_GAMMA_SIZE);
+	return 0;
+}
+
+static int lxfb_get_gamma(struct fb_info *info, void * __user data)
+{
+	unsigned int gamma[LXFB_GAMMA_DWORDS];
+	memset(gamma, 0, sizeof(gamma));
+
+	lx_get_gamma(info, gamma, LXFB_GAMMA_DWORDS);
+
+	return copy_to_user(data, gamma, LXFB_GAMMA_SIZE) ?
+		-EFAULT : 0;
+}
+
+static int lxfb_ioctl( struct fb_info *info, unsigned int cmd,
+		       unsigned long arg)
+{
+	switch(cmd) {
+	case FBIOSGAMMA:
+		return lxfb_set_gamma(info, (void * __user) arg);
+
+	case FBIOGGAMMA:
+		return lxfb_get_gamma(info, (void * __user) arg);
+	}
+
+	return -ENOTTY;
+}
+
 static struct fb_ops lxfb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_check_var	= lxfb_check_var,
 	.fb_set_par	= lxfb_set_par,
 	.fb_setcolreg	= lxfb_setcolreg,
 	.fb_blank       = lxfb_blank,
+	.fb_ioctl       = lxfb_ioctl,
 	/* No HW acceleration for now. */
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
+	.fb_powerdown	= lx_shutdown,
+	.fb_powerup	= lx_powerup,
 };
 
 static struct fb_info * __init lxfb_init_fbinfo(struct device *dev)
@@ -431,6 +369,45 @@ static struct fb_info * __init lxfb_init
 	return info;
 }
 
+#ifdef CONFIG_PM
+
+static int lxfb_suspend(struct pci_dev *pdev,  pm_message_t state)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+
+	if (pdev->dev.power.power_state.event == state.event)
+		return 0;
+
+	if (state.event == PM_EVENT_SUSPEND) {
+
+		acquire_console_sem();
+		lx_shutdown(info);
+		fb_set_suspend(info, 1);
+		release_console_sem();
+	}
+
+	pdev->dev.power.power_state = state;
+	return 0;
+}
+
+static int lxfb_resume(struct pci_dev *pdev)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+
+	acquire_console_sem();
+
+	/* Turn the engine completely on */
+
+	lx_powerup(info);
+	fb_set_suspend(info, 0);
+	release_console_sem();
+
+	pdev->dev.power.power_state = PMSG_ON;
+        return 0;
+}
+
+#endif
+
 static int __init lxfb_probe(struct pci_dev *pdev,
 			     const struct pci_device_id *id)
 {
@@ -467,6 +444,13 @@ static int __init lxfb_probe(struct pci_
 	modedb_ptr = (struct fb_videomode *) geode_modedb;
 	modedb_size = ARRAY_SIZE(geode_modedb);
 
+#ifdef CONFIG_OLPC
+	if (olpc_has_dcon()) {
+		modedb_ptr = (struct fb_videomode *) olpc_dcon_modedb;
+		modedb_size = ARRAY_SIZE(olpc_dcon_modedb);
+	}
+#endif
+
 	ret = fb_find_mode(&info->var, info, mode_option,
 			   modedb_ptr, modedb_size, NULL, 16);
 
@@ -556,6 +540,10 @@ static struct pci_driver lxfb_driver = {
 	.id_table	= lxfb_id_table,
 	.probe		= lxfb_probe,
 	.remove		= lxfb_remove,
+#ifdef CONFIG_PM
+	.suspend        = lxfb_suspend,
+	.resume         = lxfb_resume
+#endif
 };
 
 #ifndef MODULE
Index: linux-2.6.23.17/drivers/video/geode/lxfb_ops.c
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/lxfb_ops.c
+++ linux-2.6.23.17/drivers/video/geode/lxfb_ops.c
@@ -13,9 +13,13 @@
 #include <linux/fb.h>
 #include <linux/uaccess.h>
 #include <linux/delay.h>
+#include <asm/olpc.h>
 
 #include "lxfb.h"
 
+#define _GEODELX_
+#include "geode_regs.h"
+
 /* TODO
  * Support panel scaling
  * Add acceleration
@@ -290,6 +294,19 @@ unsigned int lx_framebuffer_size(void)
 {
 	unsigned int val;
 
+#ifdef CONFIG_OLPC
+	 if (machine_is_olpc() && !olpc_has_vsa()) {
+		u32 hi,lo;
+		rdmsr(MSR_LX_GLIU0_P2D_RO0, lo, hi);
+
+		/* Top page number */
+		val = ((hi & 0xff) << 12) | ((lo & 0xfff00000) >> 20);
+		val -= (lo & 0x000fffff); /* Subtract bottom page number */
+		val += 1;                 /* Adjust page count */
+		return (val << 12);
+	}
+#endif
+
 	/* The frame buffer size is reported by a VSM in VSA II */
 	/* Virtual Register Class    = 0x02                     */
 	/* VG_MEM_SIZE (1MB units)   = 0x00                     */
@@ -301,6 +318,34 @@ unsigned int lx_framebuffer_size(void)
 	return (val << 20);
 }
 
+void lx_set_gamma(struct fb_info *info, unsigned int *gamma, int len)
+{
+	int i;
+	struct lxfb_par *par = info->par;
+
+	writel(0, par->df_regs + DF_PAR);
+
+	/* Sequential writes to the data register will increment the
+	   address automatically  */
+
+	for(i = 0; i < len; i++)
+		writel(gamma[i] & 0xFFFFFF, par->df_regs + DF_PDR);
+
+	writel(readl(par->df_regs + DF_MISC) & ~DF_MISC_GAM_BYPASS,
+	       par->df_regs + DF_MISC);
+}
+
+void lx_get_gamma(struct fb_info *info, unsigned int *gamma, int len)
+{
+	int i;
+	struct lxfb_par *par = info->par;
+
+	writel(0, par->df_regs + DF_PAR);
+
+	for(i = 0; i < len;i++)
+		gamma[i] = readl(par->df_regs + DF_PDR);
+}
+
 void lx_set_mode(struct fb_info *info)
 {
 	struct lxfb_par *par = info->par;
@@ -313,6 +358,7 @@ void lx_set_mode(struct fb_info *info)
 	int vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal;
 
 	/* Unlock the DC registers */
+	readl(par->dc_regs + DC_UNLOCK);
 	writel(DC_UNLOCK_CODE, par->dc_regs + DC_UNLOCK);
 
 	lx_graphics_disable(info);
@@ -534,3 +580,285 @@ int lx_blank_display(struct fb_info *inf
 
 	return 0;
 }
+
+static struct geoderegs saved_regs;
+
+static void lx_save_regs(struct fb_info *info, struct geoderegs *regs)
+{
+	struct lxfb_par *par = info->par;
+	int i;
+
+	/* Wait for the command buffer to empty */
+	while(!(readl(par->gp_regs + 0x44) & (1 << 4)));
+
+	rdmsrl(MSR_LX_DF_PADSEL, regs->msr.padsel);
+	rdmsrl(MSR_LX_GLCP_DOTPLL, regs->msr.dotpll);
+	rdmsrl(MSR_LX_DF_GLCONFIG, regs->msr.dfglcfg);
+	rdmsrl(MSR_LX_DC_SPARE, regs->msr.dcspare);
+
+	writel(0x4758, par->dc_regs + 0x00);
+
+	memcpy(regs->gp.b, par->gp_regs, GP_REG_SIZE);
+	memcpy(regs->dc.b, par->dc_regs, DC_REG_SIZE);
+	memcpy(regs->vp.b, par->df_regs, VP_REG_SIZE);
+	memcpy(regs->fp.b, par->df_regs + VP_FP_START, FP_REG_SIZE);
+
+	/* Save the palettes */
+	writel(0, par->dc_regs + 0x70);
+
+	for(i = 0; i < DC_PAL_SIZE; i++) 
+		regs->pal[i] = readl(par->dc_regs + 0x74);
+	
+	writel(0, par->df_regs + 0x38);
+
+	for(i = 0; i <= 0xFF; i++)
+		regs->gamma[i] = readl(par->df_regs + 0x40);
+}
+
+static void lx_restore_regs(struct fb_info *info, struct geoderegs *regs)
+{
+	struct lxfb_par *par = info->par;
+	u32 val, i;
+
+	/* == DOTPLL == */
+
+	lx_set_dotpll((u32) (regs->msr.dotpll >> 32));
+
+	/* MSRs */
+
+	wrmsrl(MSR_LX_DF_GLCONFIG, regs->msr.dfglcfg);
+
+	/* == GP == */
+
+	writel(regs->gp.r.dst_offset, par->gp_regs + 0x00);
+	writel(regs->gp.r.src_offset, par->gp_regs + 0x04);
+	writel(regs->gp.r.stride, par->gp_regs + 0x08);
+	writel(regs->gp.r.wid_height, par->gp_regs + 0x0C);
+	writel(regs->gp.r.src_color_fg, par->gp_regs + 0x10);
+	writel(regs->gp.r.src_color_bg, par->gp_regs + 0x14);
+	writel(regs->gp.r.pat_color_0, par->gp_regs + 0x18);
+	writel(regs->gp.r.pat_color_1, par->gp_regs + 0x1C);
+	writel(regs->gp.r.pat_color_2, par->gp_regs + 0x20);
+	writel(regs->gp.r.pat_color_3, par->gp_regs + 0x24);
+	writel(regs->gp.r.pat_color_4, par->gp_regs + 0x28);
+	writel(regs->gp.r.pat_color_5, par->gp_regs + 0x2C);
+	writel(regs->gp.r.pat_data_0, par->gp_regs + 0x30);
+	writel(regs->gp.r.pat_data_1, par->gp_regs + 0x34);
+
+	/* Writing to these registers would cause a blt to happen */
+	/* 0x38, 0x3c, 0x40 */
+
+	/* Status register (0x44) is read only */
+
+	writel(regs->gp.r.hst_src, par->gp_regs + 0x48);
+	writel(regs->gp.r.base_offset, par->gp_regs + 0x4c);
+	writel(regs->gp.r.cmd_top, par->gp_regs + 0x50);
+	writel(regs->gp.r.cmd_bot, par->gp_regs + 0x54);
+	writel(regs->gp.r.cmd_read, par->gp_regs + 0x58);
+	writel(regs->gp.r.cmd_write, par->gp_regs + 0x5C);
+	writel(regs->gp.r.ch3_offset, par->gp_regs + 0x60);
+	writel(regs->gp.r.ch3_mode_str, par->gp_regs + 0x64);
+	writel(regs->gp.r.ch3_width, par->gp_regs + 0x6C);
+	writel(regs->gp.r.ch3_hsrc, par->gp_regs + 0x70);
+
+	/* FIXME:  Restore the LUT data here */
+
+	writel(regs->gp.r.int_cntrl, par->gp_regs + 0x70);
+
+	/* == DC == */
+
+	/* Write the unlock value */
+	writel(0x4758, par->dc_regs + 0x00);
+
+	/* Write the palette data first */
+
+	writel(0, par->dc_regs + 0x70);
+
+	for(i = 0; i < DC_PAL_SIZE; i++)
+		writel(regs->pal[i], par->dc_regs + 0x74);
+
+	/* MSRs */
+	wrmsrl(MSR_LX_DC_SPARE, regs->msr.dcspare);
+
+	/* Write the gcfg register without the enables */
+	writel(regs->dc.r.gcfg & ~0x0F, par->dc_regs + 0x04);
+
+	/* Write the vcfg register without the enables */
+	writel(regs->dc.r.dcfg & ~0x19, par->dc_regs + 0x08);
+
+	/* Write the rest of the active registers */
+	writel(regs->dc.r.arb, par->dc_regs + 0x0C);
+	writel(regs->dc.r.fb_st_offset, par->dc_regs + 0x10);
+	writel(regs->dc.r.cb_st_offset, par->dc_regs + 0x14);
+	writel(regs->dc.r.curs_st_offset, par->dc_regs + 0x18);
+	writel(regs->dc.r.icon_st_offset, par->dc_regs + 0x1C);
+	writel(regs->dc.r.vid_y_st_offset, par->dc_regs + 0x20);
+	writel(regs->dc.r.vid_u_st_offset, par->dc_regs + 0x24);
+	writel(regs->dc.r.vid_v_st_offset, par->dc_regs + 0x28);
+	writel(regs->dc.r.dctop, par->dc_regs + 0x2c);
+	writel(regs->dc.r.line_size, par->dc_regs + 0x30);
+	writel(regs->dc.r.gfx_pitch, par->dc_regs + 0x34);
+	writel(regs->dc.r.vid_yuv_pitch, par->dc_regs + 0x38);
+	writel(regs->dc.r.h_active_timing, par->dc_regs + 0x40);
+	writel(regs->dc.r.h_blank_timing, par->dc_regs + 0x44);
+	writel(regs->dc.r.h_sync_timing, par->dc_regs + 0x48);
+	writel(regs->dc.r.v_active_timing, par->dc_regs + 0x50);
+	writel(regs->dc.r.v_blank_timing, par->dc_regs + 0x54);
+	writel(regs->dc.r.v_sync_timing, par->dc_regs + 0x58);
+	writel(regs->dc.r.fbactive, par->dc_regs + 0x5c);
+	writel(regs->dc.r.dc_cursor_x, par->dc_regs + 0x60);
+	writel(regs->dc.r.dc_cursor_y, par->dc_regs + 0x64);
+	writel(regs->dc.r.dc_icon_x, par->dc_regs + 0x68);
+
+	/* Skip register 0x6C (line_cnt), 0x70/0x74 (palette),
+	   0x78 (diagnostic), and 0x7c (diagnostic)
+	*/
+
+	writel(regs->dc.r.dc_vid_ds_delta, par->dc_regs + 0x80);
+	writel(regs->dc.r.gliu0_mem_offset, par->dc_regs + 0x84);
+	writel(regs->dc.r.dv_ctl, par->dc_regs + 0x88);
+	writel(regs->dc.r.dv_acc, par->dc_regs + 0x8C);
+
+	writel(regs->dc.r.gfx_scale, par->dc_regs + 0x90);
+	writel(regs->dc.r.irq_filt_ctl, par->dc_regs + 0x94);
+	writel(regs->dc.r.filt_coeff1, par->dc_regs + 0x98);
+	writel(regs->dc.r.filt_coeff2, par->dc_regs + 0x9C);
+	writel(regs->dc.r.vbi_event_ctl, par->dc_regs + 0xA0);
+
+	writel(regs->dc.r.vbi_odd_ctl, par->dc_regs + 0xA4);
+	writel(regs->dc.r.vbi_hor, par->dc_regs + 0xA8);
+	writel(regs->dc.r.vbi_ln_odd, par->dc_regs + 0xAC);
+	writel(regs->dc.r.vbi_ln_event, par->dc_regs + 0xB0);
+	writel(regs->dc.r.vbi_pitch, par->dc_regs + 0xB4);
+	writel(regs->dc.r.clr_key, par->dc_regs + 0xB8);
+	writel(regs->dc.r.clr_key_mask, par->dc_regs + 0xBC);
+
+	writel(regs->dc.r.clr_key_x, par->dc_regs + 0xC0);
+	writel(regs->dc.r.clr_key_y, par->dc_regs + 0xC4);
+	writel(regs->dc.r.irq, par->dc_regs + 0xC8);
+	writel(regs->dc.r.genlk_ctrl, par->dc_regs + 0xD4);
+
+	writel(regs->dc.r.vid_even_y_st_offset, par->dc_regs + 0xD8);
+	writel(regs->dc.r.vid_even_u_st_offset, par->dc_regs + 0xDC);
+	writel(regs->dc.r.vid_even_v_st_offset, par->dc_regs + 0xE0);
+
+	writel(regs->dc.r.v_active_even_timing, par->dc_regs + 0xE4);
+	writel(regs->dc.r.v_blank_even_timing, par->dc_regs + 0xE8);
+	writel(regs->dc.r.v_sync_even_timing, par->dc_regs + 0xEC);
+
+	/* == VP == */
+
+	/* MSR */
+	wrmsrl(MSR_LX_DF_PADSEL, regs->msr.padsel);
+
+	/* Write gamma information first */
+
+	writel(0, par->df_regs + 0x38);
+
+	for(i = 0; i <= 0xFF; i++)
+		writel((u32) regs->gamma[i], par->df_regs + 0x40);
+
+	/* Don't enable video yet */
+	writel((u32) regs->vp.r.vcfg & ~0x01, par->df_regs + 0x00);
+
+	/* Don't enable the CRT yet */
+	writel((u32) regs->vp.r.dcfg & ~0x0F, par->df_regs + 0x08);
+
+	/* Write the rest of the VP registers */
+
+	writel((u32) regs->vp.r.vx, par->df_regs + 0x10);
+	writel((u32) regs->vp.r.vy, par->df_regs + 0x18);
+	writel((u32) regs->vp.r.vs, par->df_regs + 0x20);
+	writel((u32) regs->vp.r.vck, par->df_regs + 0x28);
+	writel((u32) regs->vp.r.vcm, par->df_regs + 0x30);
+	writel((u32) regs->vp.r.misc, par->df_regs + 0x50);
+	writel((u32) regs->vp.r.ccs, par->df_regs + 0x58);
+	writel((u32) regs->vp.r.vdc, par->df_regs + 0x78);
+	writel((u32) regs->vp.r.vco, par->df_regs + 0x80);
+	writel((u32) regs->vp.r.crc, par->df_regs + 0x88);
+	writel((u32) regs->vp.r.vde, par->df_regs + 0x98);
+	writel((u32) regs->vp.r.cck, par->df_regs + 0xA0);
+	writel((u32) regs->vp.r.ccm, par->df_regs + 0xA8);
+	writel((u32) regs->vp.r.cc1, par->df_regs + 0xB0);
+	writel((u32) regs->vp.r.cc2, par->df_regs + 0xB8);
+	writel((u32) regs->vp.r.a1x, par->df_regs + 0xC0);
+	writel((u32) regs->vp.r.a1y, par->df_regs + 0xC8);
+	writel((u32) regs->vp.r.a1c, par->df_regs + 0xD0);
+	writel((u32) regs->vp.r.a1t, par->df_regs + 0xD8);
+	writel((u32) regs->vp.r.a2x, par->df_regs + 0xE0);
+	writel((u32) regs->vp.r.a2y, par->df_regs + 0xE8);
+	writel((u32) regs->vp.r.a2c, par->df_regs + 0xF0);
+	writel((u32) regs->vp.r.a2t, par->df_regs + 0xF8);
+	writel((u32) regs->vp.r.a3x, par->df_regs + 0x100);
+	writel((u32) regs->vp.r.a3y, par->df_regs + 0x108);
+	writel((u32) regs->vp.r.a3c, par->df_regs + 0x110);
+	writel((u32) regs->vp.r.a3t, par->df_regs + 0x118);
+	writel((u32) regs->vp.r.vrr, par->df_regs + 0x120);
+
+	writel((u32) regs->vp.r.vye, par->df_regs + 0x138);
+	writel((u32) regs->vp.r.a1ye, par->df_regs + 0x140);
+	writel((u32) regs->vp.r.a2ye, par->df_regs + 0x148);
+	writel((u32) regs->vp.r.a3ye, par->df_regs + 0x150);
+
+	/* == FP == */
+
+	writel((u32) regs->fp.r.pt1, par->df_regs + 0x400);
+	writel((u32) regs->fp.r.pt2, par->df_regs + 0x408);
+	writel((u32) regs->fp.r.dfc, par->df_regs + 0x418);
+	writel(regs->fp.r.dca, par->df_regs + 0x448);
+	writel(regs->fp.r.dmd, par->df_regs + 0x450);
+	writel(regs->fp.r.crc, par->df_regs + 0x458);
+
+	/* Final enables */
+
+	val = readl(par->df_regs + 0x410);
+
+	/* Control the panel */
+	if (regs->fp.r.pm & (1 << 24)) {
+
+		if (!(val & 0x09))
+			writel(regs->fp.r.pm, par->df_regs + 0x410);
+	}
+	else {
+		if (!(val & 0x05))
+			writel(regs->fp.r.pm, par->df_regs + 0x410);
+	}
+
+	/* Turn everything on */
+
+	writel(regs->dc.r.gcfg, par->dc_regs + 0x04);
+	writel((u32) regs->vp.r.vcfg, par->df_regs + 0x00);
+	writel((u32) regs->vp.r.dcfg, par->df_regs + 0x08);
+	writel(regs->dc.r.dcfg, par->dc_regs + 0x08);
+}
+
+static int lx_power_on = 1;
+
+int lx_shutdown(struct fb_info *info)
+{
+	struct lxfb_par *par = info->par;
+
+	if (lx_power_on == 0)
+		return 0;
+
+	writel(DC_UNLOCK_CODE, par->dc_regs + DC_UNLOCK);
+	lx_save_regs(info, &saved_regs);
+	lx_graphics_disable(info);
+
+	lx_power_on = 0;
+	return 0;
+}
+
+int lx_powerup(struct fb_info *info)
+{
+	struct lxfb_par *par = info->par;
+
+	if (lx_power_on == 1)
+		return 0;
+
+	lx_restore_regs(info, &saved_regs);
+	writel(0, par->dc_regs + DC_UNLOCK);
+
+	lx_power_on = 1;
+	return 0;
+}
Index: linux-2.6.23.17/drivers/video/geode/video_gx.c
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/video_gx.c
+++ linux-2.6.23.17/drivers/video/geode/video_gx.c
@@ -16,10 +16,14 @@
 #include <asm/io.h>
 #include <asm/delay.h>
 #include <asm/msr.h>
+#include <asm/olpc.h>
 
 #include "geodefb.h"
 #include "video_gx.h"
+#include "display_gx.h"
 
+/* This structure is used to store the saved registers during suspend */
+static struct geoderegs gx_saved_regs;
 
 /*
  * Tables of register settings for various DOTCLKs.
@@ -58,7 +62,7 @@ static const struct gx_pll_entry gx_pll_
 	{ 13888, POSTDIV3,	    0x000007E1 },	/*  72.0000 */
 	{ 13426, PREMULT2,	    0x00000F4A },	/*  74.4810 */
 	{ 13333, 0,		    0x00000052 },	/*  75.0000 */
-	{ 12698, 0,		    0x00000056 },	/*  78.7500 */
+	{ 12698, 0,		    0x00000056 },       /*  78.7500 */
 	{ 12500, POSTDIV3|PREMULT2, 0x00000709 },	/*  80.0000 */
 	{ 11135, PREMULT2,	    0x00000262 },	/*  89.8000 */
 	{ 10582, 0,		    0x000002D2 },	/*  94.5000 */
@@ -117,8 +121,9 @@ static const struct gx_pll_entry gx_pll_
 	{  4357, 0, 0x0000057D },	/* 229.5000 */
 };
 
-static void gx_set_dclk_frequency(struct fb_info *info)
+void gx_set_dclk_frequency(struct fb_info *info)
 {
+	struct geodefb_par *par = info->par;
 	const struct gx_pll_entry *pll_table;
 	int pll_table_len;
 	int i, best_i;
@@ -173,115 +178,169 @@ static void gx_set_dclk_frequency(struct
 	do {
 		rdmsrl(MSR_GLCP_DOTPLL, dotpll);
 	} while (timeout-- && !(dotpll & MSR_GLCP_DOTPLL_LOCK));
+
+	par->curdclk = pll_table[best_i].dotpll_value;
 }
 
-static void
-gx_configure_tft(struct fb_info *info)
+/* Find out the current clock - we will use this information to avoid
+   re-programming it if we don't need to */
+
+unsigned int gx_get_dclk(struct fb_info *info)
 {
-	struct geodefb_par *par = info->par;
-	unsigned long val;
-	unsigned long fp;
+	const struct gx_pll_entry *pll_table;
+	int pll_table_len;
+	u64 dotpll;
+	int i;
 
-	/* Set up the DF pad select MSR */
+	if (cpu_data->x86_mask == 1) {
+		pll_table = gx_pll_table_14MHz;
+		pll_table_len = ARRAY_SIZE(gx_pll_table_14MHz);
+	} else {
+		pll_table = gx_pll_table_48MHz;
+		pll_table_len = ARRAY_SIZE(gx_pll_table_48MHz);
+	}
 
-	rdmsrl(GX_VP_MSR_PAD_SELECT, val);
-	val &= ~GX_VP_PAD_SELECT_MASK;
-	val |= GX_VP_PAD_SELECT_TFT;
-	wrmsrl(GX_VP_MSR_PAD_SELECT, val);
+	rdmsrl(MSR_GLCP_DOTPLL, dotpll);
 
-	/* Turn off the panel */
+	for(i = 0; i < pll_table_len; i++) {
+		if (pll_table[i].dotpll_value == (u32) (dotpll >> 32))
+			break;
+	}
+
+	return (i == pll_table_len) ? 0 : pll_table[i].pixclock;
+}
 
-	fp = readl(par->vid_regs + GX_FP_PM);
-	fp &= ~GX_FP_PM_P;
-	writel(fp, par->vid_regs + GX_FP_PM);
 
-	/* Set timing 1 */
+#define CMP(val, mask, res) (((val) & (mask)) == (res))
 
-	fp = readl(par->vid_regs + GX_FP_PT1);
-	fp &= GX_FP_PT1_VSIZE_MASK;
-	fp |= info->var.yres << GX_FP_PT1_VSIZE_SHIFT;
-	writel(fp, par->vid_regs + GX_FP_PT1);
+static void
+gx_configure_tft(struct fb_info *info) {
 
-	/* Timing 2 */
-	/* Set bits that are always on for TFT */
+	struct geodefb_par *par = info->par;
+	u32 val, fp = 0, fp1, fp2, sync = 0;
 
-	fp = 0x0F100000;
+	/* Set up the DF pad select MSR */
 
-	/* Add sync polarity */
+	rdmsrl(GX_VP_MSR_PAD_SELECT, val);
+
+	if ((val & GX_VP_PAD_SELECT_MASK) != GX_VP_PAD_SELECT_TFT) {
+		val &= ~GX_VP_PAD_SELECT_MASK;
+		val |= GX_VP_PAD_SELECT_TFT;
+		wrmsrl(GX_VP_MSR_PAD_SELECT, val);
+	}
 
 	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
-		fp |= GX_FP_PT2_VSP;
+		sync |= GX_FP_PT2_VSP;
 
 	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
-		fp |= GX_FP_PT2_HSP;
+		sync |= GX_FP_PT2_HSP;
 
-	writel(fp, par->vid_regs + GX_FP_PT2);
+	/* We only need to turn off the panel if something changed */
 
-	/*  Set the dither control */
-	writel(0x70, par->vid_regs + GX_FP_DFC);
+	fp1 = readl(par->vid_regs + GX_FP_PT1);
+	fp2 = readl(par->vid_regs + GX_FP_PT2);
+
+	if (!CMP(fp1, GX_FP_PT1_VSIZE_MASK, info->var.yres << GX_FP_PT1_VSIZE_SHIFT) ||
+	    (fp2 != (0x0F100000 | sync))) {
+
+		/* Turn off the panel */
+
+#ifdef NOTUSED
+		/* Do we really need to turn off the panel? */
+		/* Possibly - we have a glitch somewhere */
 
-	/* Enable the FP data and power (in case the BIOS didn't) */
+		fp = readl(par->vid_regs + GX_FP_PM);
+		fp &= ~GX_FP_PM_P;
+		writel(fp, par->vid_regs + GX_FP_PM);
+#endif
 
-	fp = readl(par->vid_regs + GX_DCFG);
-	fp |= GX_DCFG_FP_PWR_EN | GX_DCFG_FP_DATA_EN;
-	writel(fp, par->vid_regs + GX_DCFG);
+		/* Timing 1 */
+		fp1 &= GX_FP_PT1_VSIZE_MASK;
+		fp1 |= info->var.yres << GX_FP_PT1_VSIZE_SHIFT;
+		writel(fp, par->vid_regs + GX_FP_PT1);
 
-	/* Unblank the panel */
+		/* Timing 2 */
+		writel(0x0F100000 | sync, par->vid_regs + GX_FP_PT2);
+	}
+
+	/*  Set the dither control */
+	if (readl(par->vid_regs + GX_FP_DFC) != 0x70) {
+		writel(0x70, par->vid_regs + GX_FP_DFC);
+	}
+
+	/* Turn on the panel */
 
 	fp = readl(par->vid_regs + GX_FP_PM);
-	fp |= GX_FP_PM_P;
-	writel(fp, par->vid_regs + GX_FP_PM);
+
+	if (!(fp & 0x09))
+		writel(fp | GX_FP_PM_P, par->vid_regs + GX_FP_PM);
 }
 
+#define DCFG_DEFAULT_VAL GX_DCFG_CRT_SYNC_SKW_DFLT | GX_DCFG_HSYNC_EN | GX_DCFG_VSYNC_EN | \
+GX_DCFG_CRT_EN | GX_DCFG_DAC_BL_EN
+
 static void gx_configure_display(struct fb_info *info)
 {
 	struct geodefb_par *par = info->par;
-	u32 dcfg, misc;
+	u32 dcfg, misc, sync = 0;
 
 	/* Set up the MISC register */
-
 	misc = readl(par->vid_regs + GX_MISC);
 
-	/* Power up the DAC */
-	misc &= ~(GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN);
+	/* We leave gamma enabled if it was already enabled.
+	   Although the hardware enables it without setting
+	   up the gamma table, the BIOS or bootloader ought
+	   to have either disabled it or loaded a table by now */
 
-	/* Disable gamma correction */
-	misc |= GX_MISC_GAM_EN;
 
-	writel(misc, par->vid_regs + GX_MISC);
 
-	/* Write the display configuration */
-	dcfg = readl(par->vid_regs + GX_DCFG);
+	if (par->enable_crt) {
+		/* Power up the CRT DACs */
+		if (misc & ( GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN)) {
+			misc &= ~(GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN);
+			writel(misc, par->vid_regs + GX_MISC);
+		}
 
-	/* Disable hsync and vsync */
-	dcfg &= ~(GX_DCFG_VSYNC_EN | GX_DCFG_HSYNC_EN);
-	writel(dcfg, par->vid_regs + GX_DCFG);
+		if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+			sync |= GX_DCFG_CRT_HSYNC_POL;
 
-	/* Clear bits from existing mode. */
-	dcfg &= ~(GX_DCFG_CRT_SYNC_SKW_MASK
-		  | GX_DCFG_CRT_HSYNC_POL   | GX_DCFG_CRT_VSYNC_POL
-		  | GX_DCFG_VSYNC_EN        | GX_DCFG_HSYNC_EN);
+		if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+			sync |= GX_DCFG_CRT_VSYNC_POL;
+	}
+	else {
+		/* Turn off the CRT DACs in FP mode - we don't need them */
+		if ((misc & (GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN))) {
+			misc |= (GX_MISC_A_PWRDN | GX_MISC_DAC_PWRDN);
+			writel(misc, par->vid_regs + GX_MISC);
+		}
+	}
 
-	/* Set default sync skew.  */
-	dcfg |= GX_DCFG_CRT_SYNC_SKW_DFLT;
+	/* Write the display configuration */
+	dcfg = readl(par->vid_regs + GX_DCFG);
 
-	/* Enable hsync and vsync. */
-	dcfg |= GX_DCFG_HSYNC_EN | GX_DCFG_VSYNC_EN;
+	if (!CMP(dcfg, DCFG_DEFAULT_VAL | GX_DCFG_CRT_HSYNC_POL | GX_DCFG_CRT_VSYNC_POL,
+		 DCFG_DEFAULT_VAL | sync)) {
 
-	/* Sync polarities. */
-	if (info->var.sync & FB_SYNC_HOR_HIGH_ACT)
-		dcfg |= GX_DCFG_CRT_HSYNC_POL;
-	if (info->var.sync & FB_SYNC_VERT_HIGH_ACT)
-		dcfg |= GX_DCFG_CRT_VSYNC_POL;
+		/* Disable hsync and vsync */
+		dcfg &= ~(GX_DCFG_VSYNC_EN | GX_DCFG_HSYNC_EN);
+		writel(dcfg, par->vid_regs + GX_DCFG);
 
-	/* Enable the display logic */
-	/* Set up the DACS to blank normally */
+		/* Clear bits from existing mode. */
+		dcfg &= ~(GX_DCFG_CRT_SYNC_SKW_MASK
+			  | GX_DCFG_CRT_HSYNC_POL   | GX_DCFG_CRT_VSYNC_POL
+			  | GX_DCFG_VSYNC_EN        | GX_DCFG_HSYNC_EN);
 
-	dcfg |= GX_DCFG_CRT_EN | GX_DCFG_DAC_BL_EN;
+		/* Set default sync skew.  */
+		dcfg |= GX_DCFG_CRT_SYNC_SKW_DFLT;
 
-	/* Enable the external DAC VREF? */
+		/* Enable hsync and vsync. */
+		dcfg |= GX_DCFG_HSYNC_EN | GX_DCFG_VSYNC_EN;
 
-	writel(dcfg, par->vid_regs + GX_DCFG);
+		/* Enable the display logic */
+		dcfg |= GX_DCFG_CRT_EN | GX_DCFG_DAC_BL_EN;
+
+		writel(dcfg, par->vid_regs + GX_DCFG);
+	}
 
 	/* Set up the flat panel (if it is enabled) */
 
@@ -289,6 +348,100 @@ static void gx_configure_display(struct 
 		gx_configure_tft(info);
 }
 
+int gxfb_powerdown(struct fb_info *info) 
+{
+	struct geodefb_par *par = info->par;
+
+	/* We're already suspended */
+
+	if (par->state != FB_POWER_STATE_ON)
+		return 0;
+
+	/* Save the registers */
+	gx_save_regs(info, &gx_saved_regs);
+
+	/* Shut down the engine */
+
+	writel(gx_saved_regs.vp.r.vcfg & ~0x01, par->vid_regs + GX_VCFG);
+	writel(gx_saved_regs.vp.r.dcfg & ~0x0F, par->vid_regs + GX_DCFG);
+
+	/* Turn off the flat panel unless we are attached to a DCON */
+	if (!olpc_has_dcon())
+		writel(gx_saved_regs.fp.r.pm & ~GX_FP_PM_P, par->vid_regs + GX_FP_PM);
+
+	writel(0x4758, par->dc_regs + DC_UNLOCK);
+
+	writel(gx_saved_regs.dc.r.gcfg & ~0x0F,
+	       par->dc_regs + DC_GENERAL_CFG);
+
+	writel(gx_saved_regs.dc.r.dcfg & ~0x19,
+	       par->dc_regs + DC_DISPLAY_CFG);
+	
+	par->state = FB_POWER_STATE_SUSPEND;
+
+	return 0;
+}
+
+int gxfb_powerup(struct fb_info *info)
+{
+	struct geodefb_par *par = info->par;
+	u32 val;
+
+	if (par->state == FB_POWER_STATE_SUSPEND) {
+
+		writel(gx_saved_regs.dc.r.dcfg,
+		       par->dc_regs + DC_DISPLAY_CFG);
+
+		writel(gx_saved_regs.vp.r.vcfg, par->vid_regs + GX_VCFG);
+		writel(gx_saved_regs.vp.r.dcfg, par->vid_regs + GX_DCFG);
+
+		val = readl(par->vid_regs + GX_FP_PM);
+
+		/* power up the panel if it needs it; we don't always power it down */
+		if (!(val & 0x09)) {
+			writel(gx_saved_regs.fp.r.pm, par->vid_regs + GX_FP_PM);
+			mdelay(64);
+		}
+	}
+
+	/* If the panel is currently on its way up, then wait up to 100ms
+	   for it */
+	
+	if (readl(par->vid_regs + GX_FP_PM) & 0x08) {
+		int i;
+		
+		for(i = 0; i < 10; i++) {
+			if (readl(par->vid_regs + GX_FP_PM) & 0x01)
+				break;
+
+			mdelay(10);
+		}
+
+		if (i == 10) 
+			printk(KERN_ERR "gxfb:  Panel power up timed out\n");
+	}
+
+	if (par->state == FB_POWER_STATE_ON)
+		return 0;
+	
+	switch(par->state) {
+	case FB_POWER_STATE_OFF:
+		gx_restore_regs(info, &gx_saved_regs);
+		break;
+
+	case FB_POWER_STATE_SUSPEND:
+		/* Do this because it will turn on the FIFO which will
+	   	   start the line count */
+		writel(gx_saved_regs.dc.r.gcfg,
+		       par->dc_regs + DC_GENERAL_CFG);
+		writel(0x0, par->dc_regs + DC_UNLOCK);
+		break;
+	}
+
+	par->state = FB_POWER_STATE_ON;
+	return 0;
+}
+
 static int gx_blank_display(struct fb_info *info, int blank_mode)
 {
 	struct geodefb_par *par = info->par;
@@ -315,6 +468,7 @@ static int gx_blank_display(struct fb_in
 	default:
 		return -EINVAL;
 	}
+
 	dcfg = readl(par->vid_regs + GX_DCFG);
 	dcfg &= ~(GX_DCFG_DAC_BL_EN
 		  | GX_DCFG_HSYNC_EN | GX_DCFG_VSYNC_EN);
@@ -326,7 +480,7 @@ static int gx_blank_display(struct fb_in
 		dcfg |= GX_DCFG_VSYNC_EN;
 	writel(dcfg, par->vid_regs + GX_DCFG);
 
-	/* Power on/off flat panel. */
+	/* Power on/off flat panel */
 
 	if (par->enable_crt == 0) {
 		fp_pm = readl(par->vid_regs + GX_FP_PM);
@@ -340,8 +494,37 @@ static int gx_blank_display(struct fb_in
 	return 0;
 }
 
+extern struct fb_info *gxfb_info;
+
+/* This function controls the flatpanel power sequencing - this is used
+   by the OLPC power management engine to enable the FP sequencing much
+   earlier in the resume process
+*/
+
+void gxfb_flatpanel_control(int state)
+{
+	struct geodefb_par *par = gxfb_info->par;
+	u32 val, fp = readl(par->vid_regs + GX_FP_PM);
+	val  = fp;
+
+	/* Turn on the panel if it isn't aleady */
+
+	if (state) {
+		if (!(val & 0x01))
+			val |= GX_FP_PM_P;
+	}
+	else {
+		if (!(val & 0x02))
+			val &= ~GX_FP_PM_P;
+	}
+
+	if (val != fp)
+		writel(val, par->vid_regs + GX_FP_PM);
+}
+
 struct geode_vid_ops gx_vid_ops = {
 	.set_dclk	   = gx_set_dclk_frequency,
+	.get_dclk          = gx_get_dclk,
 	.configure_display = gx_configure_display,
 	.blank_display	   = gx_blank_display,
 };
Index: linux-2.6.23.17/drivers/video/geode/video_gx.h
===================================================================
--- linux-2.6.23.17.orig/drivers/video/geode/video_gx.h
+++ linux-2.6.23.17/drivers/video/geode/video_gx.h
@@ -11,6 +11,8 @@
 #ifndef __VIDEO_GX_H__
 #define __VIDEO_GX_H__
 
+#include "geode_regs.h"
+
 extern struct geode_vid_ops gx_vid_ops;
 
 /* GX Flatpanel control MSR */
@@ -20,6 +22,8 @@ extern struct geode_vid_ops gx_vid_ops;
 
 /* Geode GX video processor registers */
 
+#define GX_VCFG         0x0000
+
 #define GX_DCFG		0x0008
 #  define GX_DCFG_CRT_EN		0x00000001
 #  define GX_DCFG_HSYNC_EN		0x00000002
@@ -42,6 +46,14 @@ extern struct geode_vid_ops gx_vid_ops;
 #define GX_MISC_DAC_PWRDN  0x00000400
 #define GX_MISC_A_PWRDN    0x00000800
 
+/* Gamma correction RAM - address and data registers */
+
+#define GX_GAR 0x038
+#define GX_GDR 0x040
+
+#define GXFB_GAMMA_DWORDS 256 /* number of dwords in the gamma ram */
+#define GXFB_GAMMA_SIZE (GXFB_GAMMA_DWORDS * sizeof(unsigned int))
+
 /* Geode GX flat panel display control registers */
 
 #define GX_FP_PT1 0x0400
@@ -69,4 +81,13 @@ extern struct geode_vid_ops gx_vid_ops;
 #  define MSR_GLCP_DOTPLL_BYPASS		(0x0000000000008000ull)
 #  define MSR_GLCP_DOTPLL_LOCK			(0x0000000002000000ull)
 
+int gxfb_powerdown(struct fb_info *info);
+int gxfb_powerup(struct fb_info *info);
+
+void gx_set_dclk_frequency(struct fb_info *info);
+unsigned int gx_get_dclk(struct fb_info *info);
+
+void gx_save_regs(struct fb_info *info, struct geoderegs *regs);
+void gx_restore_regs(struct fb_info *info, struct geoderegs *regs);
+
 #endif /* !__VIDEO_GX_H__ */
Index: linux-2.6.23.17/drivers/video/modedb.c
===================================================================
--- linux-2.6.23.17.orig/drivers/video/modedb.c
+++ linux-2.6.23.17/drivers/video/modedb.c
@@ -33,6 +33,8 @@ const char *global_mode_option;
      *  Standard video mode definitions (taken from XFree86)
      */
 
+#define DEFAULT_MODEDB_INDEX	0
+
 static const struct fb_videomode modedb[] = {
     {
 	/* 640x400 @ 70 Hz, 31.5 kHz hsync */
@@ -504,7 +506,8 @@ int fb_find_mode(struct fb_var_screeninf
     }
 
     if (!default_mode)
-	default_mode = &db[0];
+	    default_mode = (db == modedb) ?
+		    &modedb[DEFAULT_MODEDB_INDEX] : &db[0];
 
     if (!default_bpp)
 	default_bpp = 8;
Index: linux-2.6.23.17/fs/Kconfig
===================================================================
--- linux-2.6.23.17.orig/fs/Kconfig
+++ linux-2.6.23.17/fs/Kconfig
@@ -1003,6 +1003,23 @@ config HUGETLBFS
 config HUGETLB_PAGE
 	def_bool HUGETLBFS
 
+config PROMFS_FS
+	tristate "PromFS IEEE 1275 file system support"
+	depends on SPARC || PPC || OLPC
+	help
+	  PromFS is a file system interface to various IEEE-1275 compatible
+	  firmwares.  If you have such a firmware (Sparc64, PowerPC, and
+	  some other architectures and embedded systems have such firmwares,
+	  with names like "OpenBoot (tm)" and "OpenFirmware"), say Y here
+	  to be able to access the firmware's device-tree from Linux.
+
+	  The firmware device-tree is available as a virtual file system,
+	  can be mounted under /prom with the command "mount -t promfs
+	  none /prom".
+
+	  To compile PromFS support as a module, choose M here; the module
+	  will be called promfs.  If unsure, choose M.
+
 config RAMFS
 	bool
 	default y
@@ -1229,6 +1246,14 @@ config JFFS2_FS_WRITEBUFFER
 	    - NOR flash with transparent ECC
 	    - DataFlash
 
+config JFFS2_FS_WBUF_VERIFY
+	bool "Verify JFFS2 write-buffer reads"
+	depends on JFFS2_FS_WRITEBUFFER
+	default n
+	help
+	  This causes JFFS2 to read back every page written through the
+	  write-buffer, and check for errors.
+
 config JFFS2_SUMMARY
 	bool "JFFS2 summary support (EXPERIMENTAL)"
 	depends on JFFS2_FS && EXPERIMENTAL
@@ -1299,52 +1324,52 @@ config JFFS2_ZLIB
 	select ZLIB_DEFLATE
 	depends on JFFS2_FS
 	default y
-        help
-          Zlib is designed to be a free, general-purpose, legally unencumbered,
-          lossless data-compression library for use on virtually any computer
-          hardware and operating system. See <http://www.gzip.org/zlib/> for
-          further information.
+	help
+	  Zlib is designed to be a free, general-purpose, legally unencumbered,
+	  lossless data-compression library for use on virtually any computer
+	  hardware and operating system. See <http://www.gzip.org/zlib/> for
+	  further information.
 
-          Say 'Y' if unsure.
+	  Say 'Y' if unsure.
 
 config JFFS2_RTIME
 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
 	depends on JFFS2_FS
 	default y
-        help
-          Rtime does manage to recompress already-compressed data. Say 'Y' if unsure.
+	help
+	  Rtime does manage to recompress already-compressed data. Say 'Y' if unsure.
 
 config JFFS2_RUBIN
 	bool "JFFS2 RUBIN compression support" if JFFS2_COMPRESSION_OPTIONS
 	depends on JFFS2_FS
 	default n
-        help
-          RUBINMIPS and DYNRUBIN compressors. Say 'N' if unsure.
+	help
+	  RUBINMIPS and DYNRUBIN compressors. Say 'N' if unsure.
 
 choice
-        prompt "JFFS2 default compression mode" if JFFS2_COMPRESSION_OPTIONS
-        default JFFS2_CMODE_PRIORITY
-        depends on JFFS2_FS
-        help
-          You can set here the default compression mode of JFFS2 from
-          the available compression modes. Don't touch if unsure.
+	prompt "JFFS2 default compression mode" if JFFS2_COMPRESSION_OPTIONS
+	default JFFS2_CMODE_PRIORITY
+	depends on JFFS2_FS
+	help
+	  You can set here the default compression mode of JFFS2 from
+	  the available compression modes. Don't touch if unsure.
 
 config JFFS2_CMODE_NONE
-        bool "no compression"
-        help
-          Uses no compression.
+	bool "no compression"
+	help
+	  Uses no compression.
 
 config JFFS2_CMODE_PRIORITY
-        bool "priority"
-        help
-          Tries the compressors in a predefined order and chooses the first
-          successful one.
+	bool "priority"
+	help
+	  Tries the compressors in a predefined order and chooses the first
+	  successful one.
 
 config JFFS2_CMODE_SIZE
-        bool "size (EXPERIMENTAL)"
-        help
-          Tries all compressors and chooses the one which has the smallest
-          result.
+	bool "size (EXPERIMENTAL)"
+	help
+	  Tries all compressors and chooses the one which has the smallest
+	  result.
 
 endchoice
 
Index: linux-2.6.23.17/fs/Makefile
===================================================================
--- linux-2.6.23.17.orig/fs/Makefile
+++ linux-2.6.23.17/fs/Makefile
@@ -110,6 +110,7 @@ obj-$(CONFIG_ADFS_FS)		+= adfs/
 obj-$(CONFIG_FUSE_FS)		+= fuse/
 obj-$(CONFIG_UDF_FS)		+= udf/
 obj-$(CONFIG_SUN_OPENPROMFS)	+= openpromfs/
+obj-$(CONFIG_PROMFS_FS)		+= promfs/
 obj-$(CONFIG_JFS_FS)		+= jfs/
 obj-$(CONFIG_XFS_FS)		+= xfs/
 obj-$(CONFIG_9P_FS)		+= 9p/
Index: linux-2.6.23.17/fs/jffs2/background.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/background.c
+++ linux-2.6.23.17/fs/jffs2/background.c
@@ -23,8 +23,8 @@ static int jffs2_garbage_collect_thread(
 void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)
 {
 	spin_lock(&c->erase_completion_lock);
-        if (c->gc_task && jffs2_thread_should_wake(c))
-                send_sig(SIGHUP, c->gc_task, 1);
+	if (c->gc_task && jffs2_thread_should_wake(c))
+		send_sig(SIGHUP, c->gc_task, 1);
 	spin_unlock(&c->erase_completion_lock);
 }
 
Index: linux-2.6.23.17/fs/jffs2/compr.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/compr.c
+++ linux-2.6.23.17/fs/jffs2/compr.c
@@ -5,7 +5,7 @@
  * Created by Arjan van de Ven <arjanv@redhat.com>
  *
  * Copyright © 2004 Ferenc Havasi <havasi@inf.u-szeged.hu>,
- *                    University of Szeged, Hungary
+ *		    University of Szeged, Hungary
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
@@ -43,121 +43,122 @@ static uint32_t none_stat_compr_blocks=0
  * *datalen accordingly to show the amount of data which were compressed.
  */
 uint16_t jffs2_compress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-			     unsigned char *data_in, unsigned char **cpage_out,
-			     uint32_t *datalen, uint32_t *cdatalen)
+			unsigned char *data_in, unsigned char **cpage_out,
+			uint32_t *datalen, uint32_t *cdatalen)
 {
 	int ret = JFFS2_COMPR_NONE;
-        int compr_ret;
-        struct jffs2_compressor *this, *best=NULL;
-        unsigned char *output_buf = NULL, *tmp_buf;
-        uint32_t orig_slen, orig_dlen;
-        uint32_t best_slen=0, best_dlen=0;
-
-        switch (jffs2_compression_mode) {
-        case JFFS2_COMPR_MODE_NONE:
-                break;
-        case JFFS2_COMPR_MODE_PRIORITY:
-                output_buf = kmalloc(*cdatalen,GFP_KERNEL);
-                if (!output_buf) {
-                        printk(KERN_WARNING "JFFS2: No memory for compressor allocation. Compression failed.\n");
-                        goto out;
-                }
-                orig_slen = *datalen;
-                orig_dlen = *cdatalen;
-                spin_lock(&jffs2_compressor_list_lock);
-                list_for_each_entry(this, &jffs2_compressor_list, list) {
-                        /* Skip decompress-only backwards-compatibility and disabled modules */
-                        if ((!this->compress)||(this->disabled))
-                                continue;
-
-                        this->usecount++;
-                        spin_unlock(&jffs2_compressor_list_lock);
-                        *datalen  = orig_slen;
-                        *cdatalen = orig_dlen;
-                        compr_ret = this->compress(data_in, output_buf, datalen, cdatalen, NULL);
-                        spin_lock(&jffs2_compressor_list_lock);
-                        this->usecount--;
-                        if (!compr_ret) {
-                                ret = this->compr;
-                                this->stat_compr_blocks++;
-                                this->stat_compr_orig_size += *datalen;
-                                this->stat_compr_new_size  += *cdatalen;
-                                break;
-                        }
-                }
-                spin_unlock(&jffs2_compressor_list_lock);
-                if (ret == JFFS2_COMPR_NONE) kfree(output_buf);
-                break;
-        case JFFS2_COMPR_MODE_SIZE:
-                orig_slen = *datalen;
-                orig_dlen = *cdatalen;
-                spin_lock(&jffs2_compressor_list_lock);
-                list_for_each_entry(this, &jffs2_compressor_list, list) {
-                        /* Skip decompress-only backwards-compatibility and disabled modules */
-                        if ((!this->compress)||(this->disabled))
-                                continue;
-                        /* Allocating memory for output buffer if necessary */
-                        if ((this->compr_buf_size<orig_dlen)&&(this->compr_buf)) {
-                                spin_unlock(&jffs2_compressor_list_lock);
-                                kfree(this->compr_buf);
-                                spin_lock(&jffs2_compressor_list_lock);
-                                this->compr_buf_size=0;
-                                this->compr_buf=NULL;
-                        }
-                        if (!this->compr_buf) {
-                                spin_unlock(&jffs2_compressor_list_lock);
-                                tmp_buf = kmalloc(orig_dlen,GFP_KERNEL);
-                                spin_lock(&jffs2_compressor_list_lock);
-                                if (!tmp_buf) {
-                                        printk(KERN_WARNING "JFFS2: No memory for compressor allocation. (%d bytes)\n",orig_dlen);
-                                        continue;
-                                }
-                                else {
-                                        this->compr_buf = tmp_buf;
-                                        this->compr_buf_size = orig_dlen;
-                                }
-                        }
-                        this->usecount++;
-                        spin_unlock(&jffs2_compressor_list_lock);
-                        *datalen  = orig_slen;
-                        *cdatalen = orig_dlen;
-                        compr_ret = this->compress(data_in, this->compr_buf, datalen, cdatalen, NULL);
-                        spin_lock(&jffs2_compressor_list_lock);
-                        this->usecount--;
-                        if (!compr_ret) {
-                                if ((!best_dlen)||(best_dlen>*cdatalen)) {
-                                        best_dlen = *cdatalen;
-                                        best_slen = *datalen;
-                                        best = this;
-                                }
-                        }
-                }
-                if (best_dlen) {
-                        *cdatalen = best_dlen;
-                        *datalen  = best_slen;
-                        output_buf = best->compr_buf;
-                        best->compr_buf = NULL;
-                        best->compr_buf_size = 0;
-                        best->stat_compr_blocks++;
-                        best->stat_compr_orig_size += best_slen;
-                        best->stat_compr_new_size  += best_dlen;
-                        ret = best->compr;
-                }
-                spin_unlock(&jffs2_compressor_list_lock);
-                break;
-        default:
-                printk(KERN_ERR "JFFS2: unknow compression mode.\n");
-        }
+	int compr_ret;
+	struct jffs2_compressor *this, *best=NULL;
+	unsigned char *output_buf = NULL, *tmp_buf;
+	uint32_t orig_slen, orig_dlen;
+	uint32_t best_slen=0, best_dlen=0;
+
+	switch (jffs2_compression_mode) {
+	case JFFS2_COMPR_MODE_NONE:
+		break;
+	case JFFS2_COMPR_MODE_PRIORITY:
+		output_buf = kmalloc(*cdatalen,GFP_KERNEL);
+		if (!output_buf) {
+			printk(KERN_WARNING "JFFS2: No memory for compressor allocation. Compression failed.\n");
+			goto out;
+		}
+		orig_slen = *datalen;
+		orig_dlen = *cdatalen;
+		spin_lock(&jffs2_compressor_list_lock);
+		list_for_each_entry(this, &jffs2_compressor_list, list) {
+			/* Skip decompress-only backwards-compatibility and disabled modules */
+			if ((!this->compress)||(this->disabled))
+				continue;
+
+			this->usecount++;
+			spin_unlock(&jffs2_compressor_list_lock);
+			*datalen  = orig_slen;
+			*cdatalen = orig_dlen;
+			compr_ret = this->compress(data_in, output_buf, datalen, cdatalen, NULL);
+			spin_lock(&jffs2_compressor_list_lock);
+			this->usecount--;
+			if (!compr_ret) {
+				ret = this->compr;
+				this->stat_compr_blocks++;
+				this->stat_compr_orig_size += *datalen;
+				this->stat_compr_new_size  += *cdatalen;
+				break;
+			}
+		}
+		spin_unlock(&jffs2_compressor_list_lock);
+		if (ret == JFFS2_COMPR_NONE)
+			kfree(output_buf);
+		break;
+	case JFFS2_COMPR_MODE_SIZE:
+		orig_slen = *datalen;
+		orig_dlen = *cdatalen;
+		spin_lock(&jffs2_compressor_list_lock);
+		list_for_each_entry(this, &jffs2_compressor_list, list) {
+			/* Skip decompress-only backwards-compatibility and disabled modules */
+			if ((!this->compress)||(this->disabled))
+				continue;
+			/* Allocating memory for output buffer if necessary */
+			if ((this->compr_buf_size<orig_dlen)&&(this->compr_buf)) {
+				spin_unlock(&jffs2_compressor_list_lock);
+				kfree(this->compr_buf);
+				spin_lock(&jffs2_compressor_list_lock);
+				this->compr_buf_size=0;
+				this->compr_buf=NULL;
+			}
+			if (!this->compr_buf) {
+				spin_unlock(&jffs2_compressor_list_lock);
+				tmp_buf = kmalloc(orig_dlen,GFP_KERNEL);
+				spin_lock(&jffs2_compressor_list_lock);
+				if (!tmp_buf) {
+					printk(KERN_WARNING "JFFS2: No memory for compressor allocation. (%d bytes)\n",orig_dlen);
+					continue;
+				}
+				else {
+					this->compr_buf = tmp_buf;
+					this->compr_buf_size = orig_dlen;
+				}
+			}
+			this->usecount++;
+			spin_unlock(&jffs2_compressor_list_lock);
+			*datalen  = orig_slen;
+			*cdatalen = orig_dlen;
+			compr_ret = this->compress(data_in, this->compr_buf, datalen, cdatalen, NULL);
+			spin_lock(&jffs2_compressor_list_lock);
+			this->usecount--;
+			if (!compr_ret) {
+				if ((!best_dlen)||(best_dlen>*cdatalen)) {
+					best_dlen = *cdatalen;
+					best_slen = *datalen;
+					best = this;
+				}
+			}
+		}
+		if (best_dlen) {
+			*cdatalen = best_dlen;
+			*datalen  = best_slen;
+			output_buf = best->compr_buf;
+			best->compr_buf = NULL;
+			best->compr_buf_size = 0;
+			best->stat_compr_blocks++;
+			best->stat_compr_orig_size += best_slen;
+			best->stat_compr_new_size  += best_dlen;
+			ret = best->compr;
+		}
+		spin_unlock(&jffs2_compressor_list_lock);
+		break;
+	default:
+		printk(KERN_ERR "JFFS2: unknow compression mode.\n");
+	}
  out:
-        if (ret == JFFS2_COMPR_NONE) {
-	        *cpage_out = data_in;
-	        *datalen = *cdatalen;
-                none_stat_compr_blocks++;
-                none_stat_compr_size += *datalen;
-        }
-        else {
-                *cpage_out = output_buf;
-        }
+	if (ret == JFFS2_COMPR_NONE) {
+		*cpage_out = data_in;
+		*datalen = *cdatalen;
+		none_stat_compr_blocks++;
+		none_stat_compr_size += *datalen;
+	}
+	else {
+		*cpage_out = output_buf;
+	}
 	return ret;
 }
 
@@ -165,8 +166,8 @@ int jffs2_decompress(struct jffs2_sb_inf
 		     uint16_t comprtype, unsigned char *cdata_in,
 		     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen)
 {
-        struct jffs2_compressor *this;
-        int ret;
+	struct jffs2_compressor *this;
+	int ret;
 
 	/* Older code had a bug where it would write non-zero 'usercompr'
 	   fields. Deal with it. */
@@ -177,32 +178,32 @@ int jffs2_decompress(struct jffs2_sb_inf
 	case JFFS2_COMPR_NONE:
 		/* This should be special-cased elsewhere, but we might as well deal with it */
 		memcpy(data_out, cdata_in, datalen);
-                none_stat_decompr_blocks++;
+		none_stat_decompr_blocks++;
 		break;
 	case JFFS2_COMPR_ZERO:
 		memset(data_out, 0, datalen);
 		break;
 	default:
-                spin_lock(&jffs2_compressor_list_lock);
-                list_for_each_entry(this, &jffs2_compressor_list, list) {
-                        if (comprtype == this->compr) {
-                                this->usecount++;
-                                spin_unlock(&jffs2_compressor_list_lock);
-                                ret = this->decompress(cdata_in, data_out, cdatalen, datalen, NULL);
-                                spin_lock(&jffs2_compressor_list_lock);
-                                if (ret) {
-                                        printk(KERN_WARNING "Decompressor \"%s\" returned %d\n", this->name, ret);
-                                }
-                                else {
-                                        this->stat_decompr_blocks++;
-                                }
-                                this->usecount--;
-                                spin_unlock(&jffs2_compressor_list_lock);
-                                return ret;
-                        }
-                }
+		spin_lock(&jffs2_compressor_list_lock);
+		list_for_each_entry(this, &jffs2_compressor_list, list) {
+			if (comprtype == this->compr) {
+				this->usecount++;
+				spin_unlock(&jffs2_compressor_list_lock);
+				ret = this->decompress(cdata_in, data_out, cdatalen, datalen, NULL);
+				spin_lock(&jffs2_compressor_list_lock);
+				if (ret) {
+					printk(KERN_WARNING "Decompressor \"%s\" returned %d\n", this->name, ret);
+				}
+				else {
+					this->stat_decompr_blocks++;
+				}
+				this->usecount--;
+				spin_unlock(&jffs2_compressor_list_lock);
+				return ret;
+			}
+		}
 		printk(KERN_WARNING "JFFS2 compression type 0x%02x not available.\n", comprtype);
-                spin_unlock(&jffs2_compressor_list_lock);
+		spin_unlock(&jffs2_compressor_list_lock);
 		return -EIO;
 	}
 	return 0;
@@ -210,108 +211,108 @@ int jffs2_decompress(struct jffs2_sb_inf
 
 int jffs2_register_compressor(struct jffs2_compressor *comp)
 {
-        struct jffs2_compressor *this;
+	struct jffs2_compressor *this;
 
-        if (!comp->name) {
-                printk(KERN_WARNING "NULL compressor name at registering JFFS2 compressor. Failed.\n");
-                return -1;
-        }
-        comp->compr_buf_size=0;
-        comp->compr_buf=NULL;
-        comp->usecount=0;
-        comp->stat_compr_orig_size=0;
-        comp->stat_compr_new_size=0;
-        comp->stat_compr_blocks=0;
-        comp->stat_decompr_blocks=0;
-        D1(printk(KERN_DEBUG "Registering JFFS2 compressor \"%s\"\n", comp->name));
-
-        spin_lock(&jffs2_compressor_list_lock);
-
-        list_for_each_entry(this, &jffs2_compressor_list, list) {
-                if (this->priority < comp->priority) {
-                        list_add(&comp->list, this->list.prev);
-                        goto out;
-                }
-        }
-        list_add_tail(&comp->list, &jffs2_compressor_list);
+	if (!comp->name) {
+		printk(KERN_WARNING "NULL compressor name at registering JFFS2 compressor. Failed.\n");
+		return -1;
+	}
+	comp->compr_buf_size=0;
+	comp->compr_buf=NULL;
+	comp->usecount=0;
+	comp->stat_compr_orig_size=0;
+	comp->stat_compr_new_size=0;
+	comp->stat_compr_blocks=0;
+	comp->stat_decompr_blocks=0;
+	D1(printk(KERN_DEBUG "Registering JFFS2 compressor \"%s\"\n", comp->name));
+
+	spin_lock(&jffs2_compressor_list_lock);
+
+	list_for_each_entry(this, &jffs2_compressor_list, list) {
+		if (this->priority < comp->priority) {
+			list_add(&comp->list, this->list.prev);
+			goto out;
+		}
+	}
+	list_add_tail(&comp->list, &jffs2_compressor_list);
 out:
-        D2(list_for_each_entry(this, &jffs2_compressor_list, list) {
-                printk(KERN_DEBUG "Compressor \"%s\", prio %d\n", this->name, this->priority);
-        })
+	D2(list_for_each_entry(this, &jffs2_compressor_list, list) {
+		printk(KERN_DEBUG "Compressor \"%s\", prio %d\n", this->name, this->priority);
+	})
 
-        spin_unlock(&jffs2_compressor_list_lock);
+	spin_unlock(&jffs2_compressor_list_lock);
 
-        return 0;
+	return 0;
 }
 
 int jffs2_unregister_compressor(struct jffs2_compressor *comp)
 {
-        D2(struct jffs2_compressor *this;)
+	D2(struct jffs2_compressor *this;)
+
+	D1(printk(KERN_DEBUG "Unregistering JFFS2 compressor \"%s\"\n", comp->name));
 
-        D1(printk(KERN_DEBUG "Unregistering JFFS2 compressor \"%s\"\n", comp->name));
+	spin_lock(&jffs2_compressor_list_lock);
 
-        spin_lock(&jffs2_compressor_list_lock);
+	if (comp->usecount) {
+		spin_unlock(&jffs2_compressor_list_lock);
+		printk(KERN_WARNING "JFFS2: Compressor modul is in use. Unregister failed.\n");
+		return -1;
+	}
+	list_del(&comp->list);
 
-        if (comp->usecount) {
-                spin_unlock(&jffs2_compressor_list_lock);
-                printk(KERN_WARNING "JFFS2: Compressor modul is in use. Unregister failed.\n");
-                return -1;
-        }
-        list_del(&comp->list);
-
-        D2(list_for_each_entry(this, &jffs2_compressor_list, list) {
-                printk(KERN_DEBUG "Compressor \"%s\", prio %d\n", this->name, this->priority);
-        })
-        spin_unlock(&jffs2_compressor_list_lock);
-        return 0;
+	D2(list_for_each_entry(this, &jffs2_compressor_list, list) {
+		printk(KERN_DEBUG "Compressor \"%s\", prio %d\n", this->name, this->priority);
+	})
+	spin_unlock(&jffs2_compressor_list_lock);
+	return 0;
 }
 
 void jffs2_free_comprbuf(unsigned char *comprbuf, unsigned char *orig)
 {
-        if (orig != comprbuf)
-                kfree(comprbuf);
+	if (orig != comprbuf)
+		kfree(comprbuf);
 }
 
 int __init jffs2_compressors_init(void)
 {
 /* Registering compressors */
 #ifdef CONFIG_JFFS2_ZLIB
-        jffs2_zlib_init();
+	jffs2_zlib_init();
 #endif
 #ifdef CONFIG_JFFS2_RTIME
-        jffs2_rtime_init();
+	jffs2_rtime_init();
 #endif
 #ifdef CONFIG_JFFS2_RUBIN
-        jffs2_rubinmips_init();
-        jffs2_dynrubin_init();
+	jffs2_rubinmips_init();
+	jffs2_dynrubin_init();
 #endif
 /* Setting default compression mode */
 #ifdef CONFIG_JFFS2_CMODE_NONE
-        jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
-        D1(printk(KERN_INFO "JFFS2: default compression mode: none\n");)
+	jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
+	D1(printk(KERN_INFO "JFFS2: default compression mode: none\n");)
 #else
 #ifdef CONFIG_JFFS2_CMODE_SIZE
-        jffs2_compression_mode = JFFS2_COMPR_MODE_SIZE;
-        D1(printk(KERN_INFO "JFFS2: default compression mode: size\n");)
+	jffs2_compression_mode = JFFS2_COMPR_MODE_SIZE;
+	D1(printk(KERN_INFO "JFFS2: default compression mode: size\n");)
 #else
-        D1(printk(KERN_INFO "JFFS2: default compression mode: priority\n");)
+	D1(printk(KERN_INFO "JFFS2: default compression mode: priority\n");)
 #endif
 #endif
-        return 0;
+	return 0;
 }
 
 int jffs2_compressors_exit(void)
 {
 /* Unregistering compressors */
 #ifdef CONFIG_JFFS2_RUBIN
-        jffs2_dynrubin_exit();
-        jffs2_rubinmips_exit();
+	jffs2_dynrubin_exit();
+	jffs2_rubinmips_exit();
 #endif
 #ifdef CONFIG_JFFS2_RTIME
-        jffs2_rtime_exit();
+	jffs2_rtime_exit();
 #endif
 #ifdef CONFIG_JFFS2_ZLIB
-        jffs2_zlib_exit();
+	jffs2_zlib_exit();
 #endif
-        return 0;
+	return 0;
 }
Index: linux-2.6.23.17/fs/jffs2/compr.h
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/compr.h
+++ linux-2.6.23.17/fs/jffs2/compr.h
@@ -2,7 +2,7 @@
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
  * Copyright © 2004   Ferenc Havasi <havasi@inf.u-szeged.hu>,
- *                    University of Szeged, Hungary
+ *		      University of Szeged, Hungary
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
@@ -32,29 +32,29 @@
 #define JFFS2_ZLIB_PRIORITY      60
 
 #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
-#define JFFS2_DYNRUBIN_DISABLED  /*        for decompression */
+#define JFFS2_DYNRUBIN_DISABLED  /*	   for decompression */
 
 #define JFFS2_COMPR_MODE_NONE       0
 #define JFFS2_COMPR_MODE_PRIORITY   1
 #define JFFS2_COMPR_MODE_SIZE       2
 
 struct jffs2_compressor {
-        struct list_head list;
-        int priority;              /* used by prirority comr. mode */
-        char *name;
-        char compr;                /* JFFS2_COMPR_XXX */
-        int (*compress)(unsigned char *data_in, unsigned char *cpage_out,
-                        uint32_t *srclen, uint32_t *destlen, void *model);
-        int (*decompress)(unsigned char *cdata_in, unsigned char *data_out,
-                        uint32_t cdatalen, uint32_t datalen, void *model);
-        int usecount;
-        int disabled;              /* if seted the compressor won't compress */
-        unsigned char *compr_buf;  /* used by size compr. mode */
-        uint32_t compr_buf_size;   /* used by size compr. mode */
-        uint32_t stat_compr_orig_size;
-        uint32_t stat_compr_new_size;
-        uint32_t stat_compr_blocks;
-        uint32_t stat_decompr_blocks;
+	struct list_head list;
+	int priority;			/* used by prirority comr. mode */
+	char *name;
+	char compr;			/* JFFS2_COMPR_XXX */
+	int (*compress)(unsigned char *data_in, unsigned char *cpage_out,
+			uint32_t *srclen, uint32_t *destlen, void *model);
+	int (*decompress)(unsigned char *cdata_in, unsigned char *data_out,
+			  uint32_t cdatalen, uint32_t datalen, void *model);
+	int usecount;
+	int disabled;		/* if set the compressor won't compress */
+	unsigned char *compr_buf;	/* used by size compr. mode */
+	uint32_t compr_buf_size;	/* used by size compr. mode */
+	uint32_t stat_compr_orig_size;
+	uint32_t stat_compr_new_size;
+	uint32_t stat_compr_blocks;
+	uint32_t stat_decompr_blocks;
 };
 
 int jffs2_register_compressor(struct jffs2_compressor *comp);
@@ -64,12 +64,12 @@ int jffs2_compressors_init(void);
 int jffs2_compressors_exit(void);
 
 uint16_t jffs2_compress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-                             unsigned char *data_in, unsigned char **cpage_out,
-                             uint32_t *datalen, uint32_t *cdatalen);
+			unsigned char *data_in, unsigned char **cpage_out,
+			uint32_t *datalen, uint32_t *cdatalen);
 
 int jffs2_decompress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-                     uint16_t comprtype, unsigned char *cdata_in,
-                     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen);
+		     uint16_t comprtype, unsigned char *cdata_in,
+		     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen);
 
 void jffs2_free_comprbuf(unsigned char *comprbuf, unsigned char *orig);
 
Index: linux-2.6.23.17/fs/jffs2/compr_rtime.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/compr_rtime.c
+++ linux-2.6.23.17/fs/jffs2/compr_rtime.c
@@ -104,7 +104,7 @@ static int jffs2_rtime_decompress(unsign
 			}
 		}
 	}
-        return 0;
+	return 0;
 }
 
 static struct jffs2_compressor jffs2_rtime_comp = {
Index: linux-2.6.23.17/fs/jffs2/compr_rubin.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/compr_rubin.c
+++ linux-2.6.23.17/fs/jffs2/compr_rubin.c
@@ -384,7 +384,7 @@ static int jffs2_rubinmips_decompress(un
 				      void *model)
 {
 	rubin_do_decompress(BIT_DIVIDER_MIPS, bits_mips, data_in, cpage_out, sourcelen, dstlen);
-        return 0;
+	return 0;
 }
 
 static int jffs2_dynrubin_decompress(unsigned char *data_in,
@@ -399,7 +399,7 @@ static int jffs2_dynrubin_decompress(uns
 		bits[c] = data_in[c];
 
 	rubin_do_decompress(256, bits, data_in+8, cpage_out, sourcelen-8, dstlen);
-        return 0;
+	return 0;
 }
 
 static struct jffs2_compressor jffs2_rubinmips_comp = {
Index: linux-2.6.23.17/fs/jffs2/compr_zlib.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/compr_zlib.c
+++ linux-2.6.23.17/fs/jffs2/compr_zlib.c
@@ -181,7 +181,7 @@ static int jffs2_zlib_decompress(unsigne
 	}
 	zlib_inflateEnd(&inf_strm);
 	mutex_unlock(&inflate_mutex);
-        return 0;
+	return 0;
 }
 
 static struct jffs2_compressor jffs2_zlib_comp = {
@@ -203,11 +203,11 @@ int __init jffs2_zlib_init(void)
 
     ret = alloc_workspaces();
     if (ret)
-        return ret;
+	    return ret;
 
     ret = jffs2_register_compressor(&jffs2_zlib_comp);
     if (ret)
-        free_workspaces();
+	    free_workspaces();
 
     return ret;
 }
Index: linux-2.6.23.17/fs/jffs2/dir.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/dir.c
+++ linux-2.6.23.17/fs/jffs2/dir.c
@@ -32,7 +32,7 @@ static int jffs2_mkdir (struct inode *,s
 static int jffs2_rmdir (struct inode *,struct dentry *);
 static int jffs2_mknod (struct inode *,struct dentry *,int,dev_t);
 static int jffs2_rename (struct inode *, struct dentry *,
-                        struct inode *, struct dentry *);
+			 struct inode *, struct dentry *);
 
 const struct file_operations jffs2_dir_operations =
 {
@@ -770,7 +770,7 @@ static int jffs2_mknod (struct inode *di
 }
 
 static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
-                        struct inode *new_dir_i, struct dentry *new_dentry)
+			 struct inode *new_dir_i, struct dentry *new_dentry)
 {
 	int ret;
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
Index: linux-2.6.23.17/fs/jffs2/erase.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/erase.c
+++ linux-2.6.23.17/fs/jffs2/erase.c
@@ -38,8 +38,8 @@ static void jffs2_erase_block(struct jff
 #ifdef __ECOS
        ret = jffs2_flash_erase(c, jeb);
        if (!ret) {
-               jffs2_erase_succeeded(c, jeb);
-               return;
+	       jffs2_erase_succeeded(c, jeb);
+	       return;
        }
        bad_offset = jeb->offset;
 #else /* Linux */
@@ -50,12 +50,14 @@ static void jffs2_erase_block(struct jff
 	instr = kmalloc(sizeof(struct erase_info) + sizeof(struct erase_priv_struct), GFP_KERNEL);
 	if (!instr) {
 		printk(KERN_WARNING "kmalloc for struct erase_info in jffs2_erase_block failed. Refiling block for later\n");
+		down(&c->erase_free_sem);
 		spin_lock(&c->erase_completion_lock);
 		list_move(&jeb->list, &c->erase_pending_list);
 		c->erasing_size -= c->sector_size;
 		c->dirty_size += c->sector_size;
 		jeb->dirty_size = c->sector_size;
 		spin_unlock(&c->erase_completion_lock);
+		up(&c->erase_free_sem);
 		return;
 	}
 
@@ -82,12 +84,14 @@ static void jffs2_erase_block(struct jff
 	if (ret == -ENOMEM || ret == -EAGAIN) {
 		/* Erase failed immediately. Refile it on the list */
 		D1(printk(KERN_DEBUG "Erase at 0x%08x failed: %d. Refiling on erase_pending_list\n", jeb->offset, ret));
+		down(&c->erase_free_sem);
 		spin_lock(&c->erase_completion_lock);
 		list_move(&jeb->list, &c->erase_pending_list);
 		c->erasing_size -= c->sector_size;
 		c->dirty_size += c->sector_size;
 		jeb->dirty_size = c->sector_size;
 		spin_unlock(&c->erase_completion_lock);
+		up(&c->erase_free_sem);
 		return;
 	}
 
@@ -114,6 +118,7 @@ void jffs2_erase_pending_blocks(struct j
 			jeb = list_entry(c->erase_complete_list.next, struct jffs2_eraseblock, list);
 			list_del(&jeb->list);
 			spin_unlock(&c->erase_completion_lock);
+			up(&c->erase_free_sem);
 			jffs2_mark_erased_block(c, jeb);
 
 			if (!--count) {
@@ -134,6 +139,7 @@ void jffs2_erase_pending_blocks(struct j
 			jffs2_free_jeb_node_refs(c, jeb);
 			list_add(&jeb->list, &c->erasing_list);
 			spin_unlock(&c->erase_completion_lock);
+			up(&c->erase_free_sem);
 
 			jffs2_erase_block(c, jeb);
 
@@ -142,23 +148,25 @@ void jffs2_erase_pending_blocks(struct j
 		}
 
 		/* Be nice */
-		cond_resched();
+		yield();
+		down(&c->erase_free_sem);
 		spin_lock(&c->erase_completion_lock);
 	}
 
 	spin_unlock(&c->erase_completion_lock);
+	up(&c->erase_free_sem);
  done:
 	D1(printk(KERN_DEBUG "jffs2_erase_pending_blocks completed\n"));
-
-	up(&c->erase_free_sem);
 }
 
 static void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
 {
 	D1(printk(KERN_DEBUG "Erase completed successfully at 0x%08x\n", jeb->offset));
+	down(&c->erase_free_sem);
 	spin_lock(&c->erase_completion_lock);
 	list_move_tail(&jeb->list, &c->erase_complete_list);
 	spin_unlock(&c->erase_completion_lock);
+	up(&c->erase_free_sem);
 	/* Ensure that kupdated calls us again to mark them clean */
 	jffs2_erase_pending_trigger(c);
 }
@@ -172,22 +180,26 @@ static void jffs2_erase_failed(struct jf
 		   failed too many times. */
 		if (!jffs2_write_nand_badblock(c, jeb, bad_offset)) {
 			/* We'd like to give this block another try. */
+			down(&c->erase_free_sem);
 			spin_lock(&c->erase_completion_lock);
 			list_move(&jeb->list, &c->erase_pending_list);
 			c->erasing_size -= c->sector_size;
 			c->dirty_size += c->sector_size;
 			jeb->dirty_size = c->sector_size;
 			spin_unlock(&c->erase_completion_lock);
+			up(&c->erase_free_sem);
 			return;
 		}
 	}
 
+	down(&c->erase_free_sem);
 	spin_lock(&c->erase_completion_lock);
 	c->erasing_size -= c->sector_size;
 	c->bad_size += c->sector_size;
 	list_move(&jeb->list, &c->bad_list);
 	c->nr_erasing_blocks--;
 	spin_unlock(&c->erase_completion_lock);
+	up(&c->erase_free_sem);
 	wake_up(&c->erase_wait);
 }
 
@@ -317,6 +329,33 @@ static int jffs2_block_check_erase(struc
 	size_t retlen;
 	int ret = -EIO;
 
+	if (c->mtd->point) {
+		unsigned long *wordebuf;
+
+		ret = c->mtd->point(c->mtd, jeb->offset, c->sector_size, &retlen, (unsigned char **)&ebuf);
+		if (ret) {
+			D1(printk(KERN_DEBUG "MTD point failed %d\n", ret));
+			goto do_flash_read;
+		}
+		if (retlen < c->sector_size) {
+			/* Don't muck about if it won't let us point to the whole erase sector */
+			D1(printk(KERN_DEBUG "MTD point returned len too short: 0x%zx\n", retlen));
+			c->mtd->unpoint(c->mtd, ebuf, jeb->offset, c->sector_size);
+			goto do_flash_read;
+		}
+		wordebuf = ebuf-sizeof(*wordebuf);
+		retlen /= sizeof(*wordebuf);
+		do {
+		   if (*++wordebuf != ~0)
+			   break;
+		} while(--retlen);
+		c->mtd->unpoint(c->mtd, ebuf, jeb->offset, c->sector_size);
+		if (retlen)
+			printk(KERN_WARNING "Newly-erased block contained word 0x%lx at offset 0x%08x\n",
+			       *wordebuf, jeb->offset + c->sector_size-retlen*sizeof(*wordebuf));
+		return 0;
+	}
+ do_flash_read:
 	ebuf = kmalloc(PAGE_SIZE, GFP_KERNEL);
 	if (!ebuf) {
 		printk(KERN_WARNING "Failed to allocate page buffer for verifying erase at 0x%08x. Refiling\n", jeb->offset);
@@ -417,6 +456,7 @@ static void jffs2_mark_erased_block(stru
 		jffs2_link_node_ref(c, jeb, jeb->offset | REF_NORMAL, c->cleanmarker_size, NULL);
 	}
 
+	down(&c->erase_free_sem);
 	spin_lock(&c->erase_completion_lock);
 	c->erasing_size -= c->sector_size;
 	c->free_size += jeb->free_size;
@@ -429,23 +469,28 @@ static void jffs2_mark_erased_block(stru
 	c->nr_erasing_blocks--;
 	c->nr_free_blocks++;
 	spin_unlock(&c->erase_completion_lock);
+	up(&c->erase_free_sem);
 	wake_up(&c->erase_wait);
 	return;
 
 filebad:
+	down(&c->erase_free_sem);
 	spin_lock(&c->erase_completion_lock);
 	/* Stick it on a list (any list) so erase_failed can take it
 	   right off again.  Silly, but shouldn't happen often. */
 	list_add(&jeb->list, &c->erasing_list);
 	spin_unlock(&c->erase_completion_lock);
+	up(&c->erase_free_sem);
 	jffs2_erase_failed(c, jeb, bad_offset);
 	return;
 
 refile:
 	/* Stick it back on the list from whence it came and come back later */
 	jffs2_erase_pending_trigger(c);
+	down(&c->erase_free_sem);
 	spin_lock(&c->erase_completion_lock);
 	list_add(&jeb->list, &c->erase_complete_list);
 	spin_unlock(&c->erase_completion_lock);
+	up(&c->erase_free_sem);
 	return;
 }
Index: linux-2.6.23.17/fs/jffs2/gc.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/gc.c
+++ linux-2.6.23.17/fs/jffs2/gc.c
@@ -556,7 +556,7 @@ static int jffs2_garbage_collect_pristin
 
 	node = kmalloc(rawlen, GFP_KERNEL);
 	if (!node)
-               return -ENOMEM;
+		return -ENOMEM;
 
 	ret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)node);
 	if (!ret && retlen != rawlen)
@@ -624,7 +624,7 @@ static int jffs2_garbage_collect_pristin
 
 	if (ret || (retlen != rawlen)) {
 		printk(KERN_NOTICE "Write of %d bytes at 0x%08x failed. returned %d, retlen %zd\n",
-                       rawlen, phys_ofs, ret, retlen);
+		       rawlen, phys_ofs, ret, retlen);
 		if (retlen) {
 			jffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, rawlen, NULL);
 		} else {
Index: linux-2.6.23.17/fs/jffs2/jffs2_fs_sb.h
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/jffs2_fs_sb.h
+++ linux-2.6.23.17/fs/jffs2/jffs2_fs_sb.h
@@ -106,6 +106,9 @@ struct jffs2_sb_info {
 
 	uint32_t wbuf_pagesize; /* 0 for NOR and other flashes with no wbuf */
 
+#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY
+	unsigned char *wbuf_verify; /* read-back buffer for verification */
+#endif
 #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
 	unsigned char *wbuf; /* Write-behind buffer for NAND flash */
 	uint32_t wbuf_ofs;
Index: linux-2.6.23.17/fs/jffs2/nodelist.h
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/nodelist.h
+++ linux-2.6.23.17/fs/jffs2/nodelist.h
@@ -127,7 +127,7 @@ static inline struct jffs2_inode_cache *
 	return ((struct jffs2_inode_cache *)raw);
 }
 
-        /* flash_offset & 3 always has to be zero, because nodes are
+	/* flash_offset & 3 always has to be zero, because nodes are
 	   always aligned at 4 bytes. So we have a couple of extra bits
 	   to play with, which indicate the node's status; see below: */
 #define REF_UNCHECKED	0	/* We haven't yet checked the CRC or built its inode */
@@ -197,7 +197,7 @@ struct jffs2_inode_cache {
 #define RAWNODE_CLASS_XATTR_DATUM	1
 #define RAWNODE_CLASS_XATTR_REF		2
 
-#define INOCACHE_HASHSIZE 128
+#define INOCACHE_HASHSIZE 1024
 
 #define write_ofs(c) ((c)->nextblock->offset + (c)->sector_size - (c)->nextblock->free_size)
 
Index: linux-2.6.23.17/fs/jffs2/nodemgmt.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/nodemgmt.c
+++ linux-2.6.23.17/fs/jffs2/nodemgmt.c
@@ -154,7 +154,7 @@ int jffs2_reserve_space_gc(struct jffs2_
 	while(ret == -EAGAIN) {
 		ret = jffs2_do_reserve_space(c, minsize, len, sumsize);
 		if (ret) {
-		        D1(printk(KERN_DEBUG "jffs2_reserve_space_gc: looping, ret is %d\n", ret));
+			D1(printk(KERN_DEBUG "jffs2_reserve_space_gc: looping, ret is %d\n", ret));
 		}
 	}
 	spin_unlock(&c->erase_completion_lock);
@@ -423,7 +423,12 @@ struct jffs2_raw_node_ref *jffs2_add_phy
 	   even after refiling c->nextblock */
 	if ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))
 	    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {
-		printk(KERN_WARNING "argh. node added in wrong place\n");
+		printk(KERN_WARNING "argh. node added in wrong place at 0x%08x(%d)\n", ofs & ~3, ofs & 3);
+		if (c->nextblock)
+			printk(KERN_WARNING "nextblock 0x%08x", c->nextblock->offset);
+		else
+			printk(KERN_WARNING "No nextblock");
+		printk(", expected at %08x\n", jeb->offset + (c->sector_size - jeb->free_size));
 		return ERR_PTR(-EINVAL);
 	}
 #endif
Index: linux-2.6.23.17/fs/jffs2/readinode.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/readinode.c
+++ linux-2.6.23.17/fs/jffs2/readinode.c
@@ -211,7 +211,7 @@ static void jffs2_kill_tn(struct jffs2_s
  * ordering.
  *
  * Returns 0 if the node was handled (including marking it obsolete)
- *         < 0 an if error occurred
+ *	 < 0 an if error occurred
  */
 static int jffs2_add_tn_to_tree(struct jffs2_sb_info *c,
 				struct jffs2_readinode_info *rii,
@@ -862,8 +862,8 @@ static inline int read_unknown(struct jf
 		JFFS2_ERROR("REF_UNCHECKED but unknown node at %#08x\n",
 			    ref_offset(ref));
 		JFFS2_ERROR("Node is {%04x,%04x,%08x,%08x}. Please report this error.\n",
-                            je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),
-                            je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc));
+			    je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),
+			    je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc));
 		jffs2_mark_node_obsolete(c, ref);
 		return 0;
 	}
Index: linux-2.6.23.17/fs/jffs2/scan.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/scan.c
+++ linux-2.6.23.17/fs/jffs2/scan.c
@@ -877,7 +877,7 @@ scan_more:
 			switch (je16_to_cpu(node->nodetype) & JFFS2_COMPAT_MASK) {
 			case JFFS2_FEATURE_ROCOMPAT:
 				printk(KERN_NOTICE "Read-only compatible feature node (0x%04x) found at offset 0x%08x\n", je16_to_cpu(node->nodetype), ofs);
-			        c->flags |= JFFS2_SB_FLAG_RO;
+				c->flags |= JFFS2_SB_FLAG_RO;
 				if (!(jffs2_is_readonly(c)))
 					return -EROFS;
 				if ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))
Index: linux-2.6.23.17/fs/jffs2/security.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/security.c
+++ linux-2.6.23.17/fs/jffs2/security.c
@@ -38,9 +38,9 @@ int jffs2_init_security(struct inode *in
 	}
 	rc = do_jffs2_setxattr(inode, JFFS2_XPREFIX_SECURITY, name, value, len, 0);
 
-        kfree(name);
-        kfree(value);
-        return rc;
+	kfree(name);
+	kfree(value);
+	return rc;
 }
 
 /* ---- XATTR Handler for "security.*" ----------------- */
Index: linux-2.6.23.17/fs/jffs2/summary.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/summary.c
+++ linux-2.6.23.17/fs/jffs2/summary.c
@@ -2,10 +2,10 @@
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
  * Copyright © 2004  Ferenc Havasi <havasi@inf.u-szeged.hu>,
- *                   Zoltan Sogor <weth@inf.u-szeged.hu>,
- *                   Patrik Kluba <pajko@halom.u-szeged.hu>,
- *                   University of Szeged, Hungary
- *             2006  KaiGai Kohei <kaigai@ak.jp.nec.com>
+ *		     Zoltan Sogor <weth@inf.u-szeged.hu>,
+ *		     Patrik Kluba <pajko@halom.u-szeged.hu>,
+ *		     University of Szeged, Hungary
+ *	       2006  KaiGai Kohei <kaigai@ak.jp.nec.com>
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
Index: linux-2.6.23.17/fs/jffs2/summary.h
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/summary.h
+++ linux-2.6.23.17/fs/jffs2/summary.h
@@ -2,9 +2,9 @@
  * JFFS2 -- Journalling Flash File System, Version 2.
  *
  * Copyright © 2004  Ferenc Havasi <havasi@inf.u-szeged.hu>,
- *                   Zoltan Sogor <weth@inf.u-szeged.hu>,
- *                   Patrik Kluba <pajko@halom.u-szeged.hu>,
- *                   University of Szeged, Hungary
+ *		     Zoltan Sogor <weth@inf.u-szeged.hu>,
+ *		     Patrik Kluba <pajko@halom.u-szeged.hu>,
+ *		     University of Szeged, Hungary
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
Index: linux-2.6.23.17/fs/jffs2/wbuf.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/wbuf.c
+++ linux-2.6.23.17/fs/jffs2/wbuf.c
@@ -220,6 +220,47 @@ static struct jffs2_raw_node_ref **jffs2
 	return NULL;
 }
 
+#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY
+static int jffs2_verify_write(struct jffs2_sb_info *c, unsigned char *buf,
+			      uint32_t ofs)
+{
+	int ret;
+	size_t retlen;
+	char *eccstr;
+
+	ret = c->mtd->read(c->mtd, ofs, c->wbuf_pagesize, &retlen, c->wbuf_verify);
+	if (ret && ret != -EUCLEAN && ret != -EBADMSG) {
+		printk(KERN_WARNING "jffs2_verify_write(): Read back of page at %08x failed: %d\n", c->wbuf_ofs, ret);
+		return ret;
+	} else if (retlen != c->wbuf_pagesize) {
+		printk(KERN_WARNING "jffs2_verify_write(): Read back of page at %08x gave short read: %zd not %d.\n", ofs, retlen, c->wbuf_pagesize);
+		return -EIO;
+	}
+	if (!memcmp(buf, c->wbuf_verify, c->wbuf_pagesize))
+		return 0;
+
+	if (ret == -EUCLEAN)
+		eccstr = "corrected";
+	else if (ret == -EBADMSG)
+		eccstr = "correction failed";
+	else
+		eccstr = "OK or unused";
+
+	printk(KERN_WARNING "Write verify error (ECC %s) at %08x. Wrote:\n",
+	       eccstr, c->wbuf_ofs);
+	print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 16, 1,
+		       c->wbuf, c->wbuf_pagesize, 0);
+
+	printk(KERN_WARNING "Read back:\n");
+	print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 16, 1,
+		       c->wbuf_verify, c->wbuf_pagesize, 0);
+
+	return -EIO;
+}
+#else
+#define jffs2_verify_write(c,b,o) (0)
+#endif
+
 /* Recover from failure to write wbuf. Recover the nodes up to the
  * wbuf, not the one which we were starting to try to write. */
 
@@ -380,7 +421,7 @@ static void jffs2_wbuf_recover(struct jf
 			ret = c->mtd->write(c->mtd, ofs, towrite, &retlen,
 					    rewrite_buf);
 
-		if (ret || retlen != towrite) {
+		if (ret || retlen != towrite || jffs2_verify_write(c, rewrite_buf, ofs)) {
 			/* Argh. We tried. Really we did. */
 			printk(KERN_CRIT "Recovery of wbuf failed due to a second write error\n");
 			kfree(buf);
@@ -587,15 +628,16 @@ static int __jffs2_flush_wbuf(struct jff
 
 		ret = c->mtd->write(c->mtd, c->wbuf_ofs, c->wbuf_pagesize, &retlen, c->wbuf);
 
-	if (ret || retlen != c->wbuf_pagesize) {
-		if (ret)
-			printk(KERN_WARNING "jffs2_flush_wbuf(): Write failed with %d\n",ret);
-		else {
-			printk(KERN_WARNING "jffs2_flush_wbuf(): Write was short: %zd instead of %d\n",
-				retlen, c->wbuf_pagesize);
-			ret = -EIO;
-		}
-
+	if (ret) {
+		printk(KERN_WARNING "jffs2_flush_wbuf(): Write failed with %d\n", ret);
+		goto wfail;
+	} else if (retlen != c->wbuf_pagesize) {
+		printk(KERN_WARNING "jffs2_flush_wbuf(): Write was short: %zd instead of %d\n",
+		       retlen, c->wbuf_pagesize);
+		ret = -EIO;
+		goto wfail;
+	} else if ((ret = jffs2_verify_write(c, c->wbuf, c->wbuf_ofs))) {
+	wfail:
 		jffs2_wbuf_recover(c);
 
 		return ret;
@@ -966,8 +1008,8 @@ exit:
 
 #define NR_OOB_SCAN_PAGES 4
 
-/* For historical reasons we use only 12 bytes for OOB clean marker */
-#define OOB_CM_SIZE 12
+/* For historical reasons we use only 8 bytes for OOB clean marker */
+#define OOB_CM_SIZE 8
 
 static const struct jffs2_unknown_node oob_cleanmarker =
 {
@@ -1021,8 +1063,8 @@ int jffs2_check_oob_empty(struct jffs2_s
 /*
  * Check for a valid cleanmarker.
  * Returns: 0 if a valid cleanmarker was found
- *          1 if no cleanmarker was found
- *          negative error code if an error occurred
+ *	    1 if no cleanmarker was found
+ *	    negative error code if an error occurred
  */
 int jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c,
 				 struct jffs2_eraseblock *jeb)
@@ -1138,11 +1180,22 @@ int jffs2_nand_flash_setup(struct jffs2_
 		return -ENOMEM;
 	}
 
+#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY
+	c->wbuf_verify = kmalloc(c->wbuf_pagesize, GFP_KERNEL);
+	if (!c->wbuf_verify) {
+		kfree(c->oobbuf);
+		kfree(c->wbuf);
+		return -ENOMEM;
+	}
+#endif
 	return 0;
 }
 
 void jffs2_nand_flash_cleanup(struct jffs2_sb_info *c)
 {
+#ifdef CONFIG_JFFS2_FS_WBUF_VERIFY
+	kfree(c->wbuf_verify);
+#endif
 	kfree(c->wbuf);
 	kfree(c->oobbuf);
 }
Index: linux-2.6.23.17/fs/jffs2/xattr.h
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/xattr.h
+++ linux-2.6.23.17/fs/jffs2/xattr.h
@@ -75,7 +75,7 @@ extern void jffs2_build_xattr_subsystem(
 extern void jffs2_clear_xattr_subsystem(struct jffs2_sb_info *c);
 
 extern struct jffs2_xattr_datum *jffs2_setup_xattr_datum(struct jffs2_sb_info *c,
-                                                  uint32_t xid, uint32_t version);
+							 uint32_t xid, uint32_t version);
 
 extern void jffs2_xattr_delete_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic);
 extern void jffs2_xattr_free_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic);
Index: linux-2.6.23.17/fs/jffs2/xattr_user.c
===================================================================
--- linux-2.6.23.17.orig/fs/jffs2/xattr_user.c
+++ linux-2.6.23.17/fs/jffs2/xattr_user.c
@@ -17,7 +17,7 @@
 #include "nodelist.h"
 
 static int jffs2_user_getxattr(struct inode *inode, const char *name,
-                               void *buffer, size_t size)
+			       void *buffer, size_t size)
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
@@ -25,7 +25,7 @@ static int jffs2_user_getxattr(struct in
 }
 
 static int jffs2_user_setxattr(struct inode *inode, const char *name, const void *buffer,
-                               size_t size, int flags)
+			       size_t size, int flags)
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
Index: linux-2.6.23.17/include/asm-i386/geode.h
===================================================================
--- linux-2.6.23.17.orig/include/asm-i386/geode.h
+++ linux-2.6.23.17/include/asm-i386/geode.h
@@ -135,6 +135,55 @@ static inline void geode_gpio_event_pme(
 	geode_gpio_setup_event(gpio, pair, 1);
 }
 
+/* MFGPT */
+
+#define MFGPT_TIMER_ANY -1
+
+#define MFGPT_DOMAIN_WORKING 1
+#define MFGPT_DOMAIN_STANDBY 2
+#define MFGPT_DOMAIN_ANY (MFGPT_DOMAIN_WORKING | MFGPT_DOMAIN_STANDBY)
+
+#define MFGPT_CMP1 0
+#define MFGPT_CMP2 1
+
+#define MFGPT_EVENT_IRQ   0
+#define MFGPT_EVENT_NMI   1
+#define MFGPT_EVENT_RESET 3
+
+#define MFGPT_REG_CMP1    0
+#define MFGPT_REG_CMP2    2
+#define MFGPT_REG_COUNTER 4
+#define MFGPT_REG_SETUP   6
+
+#define MFGPT_SETUP_CNTEN  (1 << 15)
+#define MFGPT_SETUP_CMP2   (1 << 14)
+#define MFGPT_SETUP_CMP1   (1 << 13)
+#define MFGPT_SETUP_SETUP  (1 << 12)
+#define MFGPT_SETUP_STOPEN (1 << 11)
+#define MFGPT_SETUP_EXTEN  (1 << 10)
+#define MFGPT_SETUP_REVEN  (1 << 5)
+#define MFGPT_SETUP_CLKSEL (1 << 4)
+
+static inline void geode_mfgpt_write(int timer, u16 reg, u16 value)
+{
+	u32 base = geode_get_dev_base(GEODE_DEV_MFGPT);
+	outw(value, base + reg + (timer * 8));
+}
+
+static inline u16 geode_mfgpt_read(int timer, u16 reg)
+{
+	u32 base = geode_get_dev_base(GEODE_DEV_MFGPT);
+	return inw(base + reg + (timer * 8));
+}
+
+extern int __init geode_mfgpt_detect(void);
+extern int geode_mfgpt_toggle_event(int timer, int cmp, int event, int enable);
+extern int geode_mfgpt_set_irq(int timer, int cmp, int irq, int enable);
+extern int geode_mfgpt_alloc_timer(int timer, int domain, struct module *owner);
+
+#define geode_mfgpt_setup_irq(t,c,i) geode_mfgpt_set_irq((t),(c),(i),1)
+#define geode_mfgpt_release_irq(t,c,i) geode_mfgpt_set_irq((t),(c),(i),0)
+
 /* Specific geode tests */
 
 static inline int is_geode_gx(void)
Index: linux-2.6.23.17/include/asm-i386/setup.h
===================================================================
--- linux-2.6.23.17.orig/include/asm-i386/setup.h
+++ linux-2.6.23.17/include/asm-i386/setup.h
@@ -24,6 +24,7 @@
 #define OLD_CL_BASE_ADDR	0x90000
 #define OLD_CL_OFFSET		0x90022
 #define NEW_CL_POINTER		0x228	/* Relative to real mode data */
+#define OFW_INFO_OFFSET		0xb0 	/* Relative to real mode data */
 
 #ifndef __ASSEMBLY__
 
Index: linux-2.6.23.17/include/linux/console.h
===================================================================
--- linux-2.6.23.17.orig/include/linux/console.h
+++ linux-2.6.23.17/include/linux/console.h
@@ -121,14 +121,11 @@ extern void console_stop(struct console 
 extern void console_start(struct console *);
 extern int is_console_locked(void);
 
-#ifndef CONFIG_DISABLE_CONSOLE_SUSPEND
+extern int serial_console_suspend_enabled;
+
 /* Suspend and resume console messages over PM events */
 extern void suspend_console(void);
 extern void resume_console(void);
-#else
-static inline void suspend_console(void) {}
-static inline void resume_console(void) {}
-#endif /* CONFIG_DISABLE_CONSOLE_SUSPEND */
 
 int mda_console_init(void);
 void prom_con_init(void);
Index: linux-2.6.23.17/include/linux/fb.h
===================================================================
--- linux-2.6.23.17.orig/include/linux/fb.h
+++ linux-2.6.23.17/include/linux/fb.h
@@ -664,6 +664,12 @@ struct fb_ops {
 	/* restore saved state */
 	void (*fb_restore_state)(struct fb_info *info);
 
+	/* Shut down the graphics engine to save power */
+	int (*fb_powerdown)(struct fb_info *info);
+
+	/* Power it back up */
+	int (*fb_powerup)(struct fb_info *info);
+
 	/* get capability given var */
 	void (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps,
 			    struct fb_var_screeninfo *var);
@@ -943,6 +949,9 @@ extern int fb_get_color_depth(struct fb_
 extern int fb_get_options(char *name, char **option);
 extern int fb_new_modelist(struct fb_info *info);
 
+extern int fb_powerdown(struct fb_info *info);
+extern int fb_powerup(struct fb_info *info);
+
 extern struct fb_info *registered_fb[FB_MAX];
 extern int num_registered_fb;
 extern struct class *fb_class;
Index: linux-2.6.23.17/include/linux/mtd/onenand.h
===================================================================
--- linux-2.6.23.17.orig/include/linux/mtd/onenand.h
+++ linux-2.6.23.17/include/linux/mtd/onenand.h
@@ -60,6 +60,7 @@ struct onenand_bufferram {
  * @erase_shift:	[INTERN] number of address bits in a block
  * @page_shift:		[INTERN] number of address bits in a page
  * @page_mask:		[INTERN] a page per block mask
+ * @writesize:		[INTERN] a real page size
  * @bufferram_index:	[INTERN] BufferRAM index
  * @bufferram:		[INTERN] BufferRAM info
  * @readw:		[REPLACEABLE] hardware specific function for read short
@@ -100,6 +101,7 @@ struct onenand_chip {
 	unsigned int		erase_shift;
 	unsigned int		page_shift;
 	unsigned int		page_mask;
+	unsigned int		writesize;
 
 	unsigned int		bufferram_index;
 	struct onenand_bufferram	bufferram[MAX_BUFFERRAM];
@@ -140,6 +142,8 @@ struct onenand_chip {
 #define ONENAND_NEXT_BUFFERRAM(this)		(this->bufferram_index ^ 1)
 #define ONENAND_SET_NEXT_BUFFERRAM(this)	(this->bufferram_index ^= 1)
 #define ONENAND_SET_PREV_BUFFERRAM(this)	(this->bufferram_index ^= 1)
+#define ONENAND_SET_BUFFERRAM0(this)		(this->bufferram_index = 0)
+#define ONENAND_SET_BUFFERRAM1(this)		(this->bufferram_index = 1)
 
 #define ONENAND_GET_SYS_CFG1(this)					\
 	(this->read_word(this->base + ONENAND_REG_SYS_CFG1))
@@ -149,6 +153,13 @@ struct onenand_chip {
 #define ONENAND_IS_DDP(this)						\
 	(this->device_id & ONENAND_DEVICE_IS_DDP)
 
+#ifdef CONFIG_MTD_ONENAND_2X_PROGRAM
+#define ONENAND_IS_2PLANE(this)						\
+	(this->options & ONENAND_HAS_2PLANE)
+#else
+#define ONENAND_IS_2PLANE(this)			(0)
+#endif
+
 /* Check byte access in OneNAND */
 #define ONENAND_CHECK_BYTE_ACCESS(addr)		(addr & 0x1)
 
@@ -157,6 +168,7 @@ struct onenand_chip {
  */
 #define ONENAND_HAS_CONT_LOCK		(0x0001)
 #define ONENAND_HAS_UNLOCK_ALL		(0x0002)
+#define ONENAND_HAS_2PLANE		(0x0004)
 #define ONENAND_PAGEBUF_ALLOC		(0x1000)
 #define ONENAND_OOBBUF_ALLOC		(0x2000)
 
Index: linux-2.6.23.17/include/linux/mtd/onenand_regs.h
===================================================================
--- linux-2.6.23.17.orig/include/linux/mtd/onenand_regs.h
+++ linux-2.6.23.17/include/linux/mtd/onenand_regs.h
@@ -74,6 +74,8 @@
 
 #define ONENAND_DEVICE_DENSITY_512Mb	(0x002)
 #define ONENAND_DEVICE_DENSITY_1Gb	(0x003)
+#define ONENAND_DEVICE_DENSITY_2Gb	(0x004)
+#define ONENAND_DEVICE_DENSITY_4Gb	(0x005)
 
 /*
  * Version ID Register F002h (R)
@@ -111,6 +113,8 @@
 #define ONENAND_CMD_READOOB		(0x13)
 #define ONENAND_CMD_PROG		(0x80)
 #define ONENAND_CMD_PROGOOB		(0x1A)
+#define ONENAND_CMD_2X_PROG		(0x7D)
+#define ONENAND_CMD_2X_CACHE_PROG	(0x7F)
 #define ONENAND_CMD_UNLOCK		(0x23)
 #define ONENAND_CMD_LOCK		(0x2A)
 #define ONENAND_CMD_LOCK_TIGHT		(0x2C)
Index: linux-2.6.23.17/include/linux/vt_kern.h
===================================================================
--- linux-2.6.23.17.orig/include/linux/vt_kern.h
+++ linux-2.6.23.17/include/linux/vt_kern.h
@@ -95,4 +95,23 @@ struct vt_spawn_console {
 };
 extern struct vt_spawn_console vt_spawn_con;
 
+/* A notifier list for console events  */
+extern struct raw_notifier_head console_notifier_list;
+
+/* Called when the FG console switches to KD_TEXT mode */
+#define CONSOLE_EVENT_SWITCH_TEXT 0x01
+
+/* Called when the FG console switches to KD_GRAPHICS mode */
+#define CONSOLE_EVENT_SWITCH_GRAPHICS 0x02
+
+static inline int console_event_register(struct notifier_block *n)
+{
+	return raw_notifier_chain_register(&console_notifier_list, n);
+}
+
+static inline int console_event_unregister(struct notifier_block *n)
+{
+	return raw_notifier_chain_unregister(&console_notifier_list, n);
+}
+
 #endif /* _VT_KERN_H */
Index: linux-2.6.23.17/kernel/power/console.c
===================================================================
--- linux-2.6.23.17.orig/kernel/power/console.c
+++ linux-2.6.23.17/kernel/power/console.c
@@ -9,7 +9,7 @@
 #include <linux/console.h>
 #include "power.h"
 
-#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE) && !defined(CONFIG_DISABLE_SUSPEND_VT_SWITCH)
 #define SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
 
 static int orig_fgconsole, orig_kmsg;
