Index: linux-2.6.38.2/mm/shmem.c
===================================================================
--- linux-2.6.38.2.orig/mm/shmem.c	2011-03-27 20:37:20.000000000 +0200
+++ linux-2.6.38.2/mm/shmem.c	2011-03-30 18:23:12.296417197 +0200
@@ -30,6 +30,7 @@
 #include <linux/module.h>
 #include <linux/percpu_counter.h>
 #include <linux/swap.h>
+#include <linux/ima.h>
 
 static struct vfsmount *shm_mnt;
 
@@ -2710,6 +2711,17 @@ out:
 
 /* common code */
 
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	ima_counts_get(file);
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &shmem_vm_ops;
+	vma->vm_flags |= VM_CAN_NONLINEAR;
+}
+EXPORT_SYMBOL_GPL(shmem_set_file);
+
 /**
  * shmem_file_setup - get an unlinked file living in tmpfs
  * @name: name for dentry (to be seen in /proc/<pid>/maps
@@ -2787,10 +2799,7 @@ int shmem_zero_setup(struct vm_area_stru
 	if (IS_ERR(file))
 		return PTR_ERR(file);
 
-	if (vma->vm_file)
-		fput(vma->vm_file);
-	vma->vm_file = file;
-	vma->vm_ops = &shmem_vm_ops;
-	vma->vm_flags |= VM_CAN_NONLINEAR;
+	shmem_set_file(vma, file);
+
 	return 0;
 }
Index: linux-2.6.38.2/fs/file.c
===================================================================
--- linux-2.6.38.2.orig/fs/file.c	2011-03-27 20:37:20.000000000 +0200
+++ linux-2.6.38.2/fs/file.c	2011-03-28 22:44:57.267151662 +0200
@@ -264,6 +264,7 @@ int expand_files(struct files_struct *fi
 	/* All good, so we try */
 	return expand_fdtable(files, nr);
 }
+EXPORT_SYMBOL_GPL(expand_files);
 
 static int count_open_files(struct fdtable *fdt)
 {
Index: linux-2.6.38.2/kernel/exit.c
===================================================================
--- linux-2.6.38.2.orig/kernel/exit.c	2011-03-27 20:37:20.000000000 +0200
+++ linux-2.6.38.2/kernel/exit.c	2011-03-28 22:44:57.269151650 +0200
@@ -513,6 +513,7 @@ struct files_struct *get_files_struct(st
 
 	return files;
 }
+EXPORT_SYMBOL_GPL(get_files_struct);
 
 void put_files_struct(struct files_struct *files)
 {
@@ -534,6 +535,7 @@ void put_files_struct(struct files_struc
 		rcu_read_unlock();
 	}
 }
+EXPORT_SYMBOL_GPL(put_files_struct);
 
 void reset_files_struct(struct files_struct *files)
 {
Index: linux-2.6.38.2/kernel/fork.c
===================================================================
--- linux-2.6.38.2.orig/kernel/fork.c	2011-03-27 20:37:20.000000000 +0200
+++ linux-2.6.38.2/kernel/fork.c	2011-03-28 22:44:57.270151644 +0200
@@ -193,6 +193,7 @@ void __put_task_struct(struct task_struc
 	if (!profile_handoff_task(tsk))
 		free_task(tsk);
 }
+EXPORT_SYMBOL_GPL(__put_task_struct);
 
 /*
  * macro override instead of weak attribute alias, to workaround
Index: linux-2.6.38.2/kernel/sched.c
===================================================================
--- linux-2.6.38.2.orig/kernel/sched.c	2011-03-27 20:37:20.000000000 +0200
+++ linux-2.6.38.2/kernel/sched.c	2011-03-28 22:44:57.274151620 +0200
@@ -4641,6 +4641,7 @@ int can_nice(const struct task_struct *p
 	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
 		capable(CAP_SYS_NICE));
 }
+EXPORT_SYMBOL_GPL(can_nice);
 
 #ifdef __ARCH_WANT_SYS_NICE
 
Index: linux-2.6.38.2/mm/memory.c
===================================================================
--- linux-2.6.38.2.orig/mm/memory.c	2011-03-27 20:37:20.000000000 +0200
+++ linux-2.6.38.2/mm/memory.c	2011-03-28 22:44:57.277151603 +0200
@@ -1229,6 +1229,7 @@ unsigned long zap_page_range(struct vm_a
 		tlb_finish_mmu(tlb, address, end);
 	return end;
 }
+EXPORT_SYMBOL_GPL(zap_page_range);
 
 /**
  * zap_vma_ptes - remove ptes mapping the vma
@@ -2692,6 +2693,7 @@ int vmtruncate_range(struct inode *inode
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(vmtruncate_range);
 
 /*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
Index: linux-2.6.38.2/mm/vmalloc.c
===================================================================
--- linux-2.6.38.2.orig/mm/vmalloc.c	2011-03-27 20:37:20.000000000 +0200
+++ linux-2.6.38.2/mm/vmalloc.c	2011-03-28 22:44:57.278151598 +0200
@@ -1193,6 +1193,7 @@ void unmap_kernel_range(unsigned long ad
 	vunmap_page_range(addr, end);
 	flush_tlb_kernel_range(addr, end);
 }
+EXPORT_SYMBOL_GPL(unmap_kernel_range);
 
 int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page ***pages)
 {
@@ -1308,6 +1309,7 @@ struct vm_struct *get_vm_area(unsigned l
 	return __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,
 				-1, GFP_KERNEL, __builtin_return_address(0));
 }
+EXPORT_SYMBOL_GPL(get_vm_area);
 
 struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,
 				void *caller)
Index: linux-2.6.38.2/include/linux/mm.h
===================================================================
--- linux-2.6.38.2.orig/include/linux/mm.h	2011-03-27 20:37:20.000000000 +0200
+++ linux-2.6.38.2/include/linux/mm.h	2011-03-28 22:44:57.279151592 +0200
@@ -863,6 +863,7 @@ extern void show_free_areas(void);
 
 int shmem_lock(struct file *file, int lock, struct user_struct *user);
 struct file *shmem_file_setup(const char *name, loff_t size, unsigned long flags);
+void shmem_set_file(struct vm_area_struct *vma, struct file *file);
 int shmem_zero_setup(struct vm_area_struct *);
 
 #ifndef CONFIG_MMU
