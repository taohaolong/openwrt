--- a/drivers/mmc/host/atmel-mci.c
+++ b/drivers/mmc/host/atmel-mci.c
@@ -77,6 +77,7 @@ struct atmel_mci {
 	struct clk		*mck;
 	struct platform_device	*pdev;
 
+	int pending_stop;
 #ifdef CONFIG_DEBUG_FS
 	struct dentry		*debugfs_root;
 	struct dentry		*debugfs_regs;
@@ -866,6 +867,12 @@ static void atmci_tasklet_func(unsigned long priv)
 		data->bytes_xfered = data->blocks * data->blksz;
 		atmci_data_complete(host, data);
 	}
+	/* See if there is a pending STOP which can be sent */
+	if (host->pending_stop && mci_cmd_is_complete(host)) {
+		host->pending_stop = 0;
+		if (mrq->stop && !mci_set_stop_sent_is_completed(host))
+			send_stop_cmd(host->mmc, mrq->data, 0);
+	}
 }
 
 static void atmci_cmd_interrupt(struct mmc_host *mmc, u32 status)
@@ -918,9 +925,16 @@ static void atmci_xfer_complete(struct dma_request *_req)
 	 * drivers) or when interrupts are disabled for a long time.
 	 */
 	mci_set_dma_complete(host);
-	if (data->stop && mci_cmd_is_complete(host)
-			&& !mci_set_stop_sent_is_completed(host))
-		send_stop_cmd(host->mmc, data, 0);
+
+	if (data->stop) {
+		if (!mci_cmd_is_complete(host)) {
+			/* Just remember a STOP must be sent */
+			host->pending_stop = 1;
+		} else if (!mci_set_stop_sent_is_completed(host)) {
+			send_stop_cmd(host->mmc, data, 0);
+			host->pending_stop = 0;
+		}
+	}
 
 	/*
 	 * Regardless of what the documentation says, we have to wait
