This is an incomplete proof of concept that I applied to be able to
build a 64 bit kernel with GCC-4.4.  It doesn't handle the 32 bit case
or the R4000_WAR case.

Comments welcome.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
---
 arch/mips/include/asm/compiler.h |    7 +++++++
 arch/mips/include/asm/delay.h    |    4 ++++
 2 files changed, 11 insertions(+), 0 deletions(-)

diff --git a/arch/mips/include/asm/compiler.h b/arch/mips/include/asm/compiler.h
index 71f5c5c..1f0954d 100644
--- a/arch/mips/include/asm/compiler.h
+++ b/arch/mips/include/asm/compiler.h
@@ -16,4 +16,11 @@
 #define GCC_REG_ACCUM "accum"
 #endif
 
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
+#define GCC_NO_H_CONSTRAINT
+#ifdef CONFIG_64BIT
+typedef unsigned int uint128_t __attribute__((mode(TI)));
+#endif
+#endif
+
 #endif /* _ASM_COMPILER_H */
diff --git a/arch/mips/include/asm/delay.h b/arch/mips/include/asm/delay.h
index b0bccd2..3e467e8 100644
--- a/arch/mips/include/asm/delay.h
+++ b/arch/mips/include/asm/delay.h
@@ -83,10 +83,14 @@ static inline void __udelay(unsigned long usecs, unsigned long lpj)
 		: "r" (usecs), "r" (lpj)
 		: GCC_REG_ACCUM);
 	else if (sizeof(long) == 8 && !R4000_WAR)
+#ifdef GCC_NO_H_CONSTRAINT
+		usecs = ((uint128_t)usecs * lpj) >> 64;
+#else
 		__asm__("dmultu\t%2, %3"
 		: "=h" (usecs), "=l" (lo)
 		: "r" (usecs), "r" (lpj)
 		: GCC_REG_ACCUM);
+#endif
 	else if (sizeof(long) == 8 && R4000_WAR)
 		__asm__("dmultu\t%3, %4\n\tmfhi\t%0"
 		: "=r" (usecs), "=h" (hi), "=l" (lo)
-- 
1.5.6.5



