Index: linux-2.6.23/arch/mips/kernel/genex.S
===================================================================
--- linux-2.6.23.orig/arch/mips/kernel/genex.S	2007-10-09 22:31:38.000000000 +0200
+++ linux-2.6.23/arch/mips/kernel/genex.S	2007-10-13 02:47:32.546043867 +0200
@@ -51,6 +51,10 @@
 NESTED(except_vec3_generic, 0, sp)
 	.set	push
 	.set	noat
+#ifdef CONFIG_BCM947XX
+	nop
+	nop
+#endif
 #if R5432_CP0_INTERRUPT_WAR
 	mfc0	k0, CP0_INDEX
 #endif
Index: linux-2.6.23/arch/mips/mm/c-r4k.c
===================================================================
--- linux-2.6.23.orig/arch/mips/mm/c-r4k.c	2007-10-13 02:47:02.792348301 +0200
+++ linux-2.6.23/arch/mips/mm/c-r4k.c	2007-10-13 02:55:35.877587360 +0200
@@ -30,6 +30,9 @@
 #include <asm/cacheflush.h> /* for run_uncached() */
 
 
+/* For enabling BCM4710 cache workarounds */
+int bcm4710 = 0;
+
 /*
  * Special Variant of smp_call_function for use by cache functions:
  *
@@ -86,14 +89,21 @@
 
 static inline void r4k_blast_dcache_page_dc32(unsigned long addr)
 {
+	unsigned long flags;
+
+	local_irq_save(flags);
 	R4600_HIT_CACHEOP_WAR_IMPL;
 	blast_dcache32_page(addr);
+	local_irq_restore(flags);
 }
 
 static void __init r4k_blast_dcache_page_setup(void)
 {
 	unsigned long  dc_lsize = cpu_dcache_line_size();
 
+	if (bcm4710)
+		r4k_blast_dcache_page = blast_dcache_page;
+	else
 	if (dc_lsize == 0)
 		r4k_blast_dcache_page = (void *)cache_noop;
 	else if (dc_lsize == 16)
@@ -108,6 +118,9 @@
 {
 	unsigned long dc_lsize = cpu_dcache_line_size();
 
+	if (bcm4710)
+		r4k_blast_dcache_page_indexed = blast_dcache_page_indexed;
+	else
 	if (dc_lsize == 0)
 		r4k_blast_dcache_page_indexed = (void *)cache_noop;
 	else if (dc_lsize == 16)
@@ -122,6 +135,9 @@
 {
 	unsigned long dc_lsize = cpu_dcache_line_size();
 
+	if (bcm4710)
+		r4k_blast_dcache = blast_dcache;
+	else
 	if (dc_lsize == 0)
 		r4k_blast_dcache = (void *)cache_noop;
 	else if (dc_lsize == 16)
@@ -203,8 +219,12 @@
 
 static void (* r4k_blast_icache_page)(unsigned long addr);
 
+static void r4k_flush_cache_all(void);
 static void __init r4k_blast_icache_page_setup(void)
 {
+#ifdef CONFIG_BCM947XX
+	r4k_blast_icache_page = (void *)r4k_flush_cache_all;
+#else
 	unsigned long ic_lsize = cpu_icache_line_size();
 
 	if (ic_lsize == 0)
@@ -215,6 +235,7 @@
 		r4k_blast_icache_page = blast_icache32_page;
 	else if (ic_lsize == 64)
 		r4k_blast_icache_page = blast_icache64_page;
+#endif
 }
 
 
@@ -222,6 +243,9 @@
 
 static void __init r4k_blast_icache_page_indexed_setup(void)
 {
+#ifdef CONFIG_BCM947XX
+	r4k_blast_icache_page_indexed = (void *)r4k_flush_cache_all;
+#else
 	unsigned long ic_lsize = cpu_icache_line_size();
 
 	if (ic_lsize == 0)
@@ -240,6 +264,7 @@
 				blast_icache32_page_indexed;
 	} else if (ic_lsize == 64)
 		r4k_blast_icache_page_indexed = blast_icache64_page_indexed;
+#endif
 }
 
 static void (* r4k_blast_icache)(void);
@@ -323,12 +348,17 @@
  */
 static inline void local_r4k_flush_cache_all(void * args)
 {
+	unsigned long flags;
+
+	local_irq_save(flags);
 	r4k_blast_dcache();
+	r4k_blast_icache();
+	local_irq_restore(flags);
 }
 
 static void r4k_flush_cache_all(void)
 {
-	if (!cpu_has_dc_aliases)
+	if (!cpu_has_dc_aliases && cpu_use_kmap_coherent)
 		return;
 
 	r4k_on_each_cpu(local_r4k_flush_cache_all, NULL, 1, 1);
@@ -336,6 +366,9 @@
 
 static inline void local_r4k___flush_cache_all(void * args)
 {
+	unsigned long flags;
+
+	local_irq_save(flags);
 #if defined(CONFIG_CPU_LOONGSON2)
 	r4k_blast_scache();
 	return;
@@ -353,6 +386,7 @@
 	case CPU_R14000:
 		r4k_blast_scache();
 	}
+	local_irq_restore(flags);
 }
 
 static void r4k___flush_cache_all(void)
@@ -363,17 +397,21 @@
 static inline void local_r4k_flush_cache_range(void * args)
 {
 	struct vm_area_struct *vma = args;
+	unsigned long flags;
 
 	if (!(cpu_context(smp_processor_id(), vma->vm_mm)))
 		return;
 
+	local_irq_save(flags);
 	r4k_blast_dcache();
+	r4k_blast_icache();
+	local_irq_restore(flags);
 }
 
 static void r4k_flush_cache_range(struct vm_area_struct *vma,
 	unsigned long start, unsigned long end)
 {
-	if (!cpu_has_dc_aliases)
+	if (!cpu_has_dc_aliases && cpu_use_kmap_coherent)
 		return;
 
 	r4k_on_each_cpu(local_r4k_flush_cache_range, vma, 1, 1);
@@ -382,6 +420,7 @@
 static inline void local_r4k_flush_cache_mm(void * args)
 {
 	struct mm_struct *mm = args;
+	unsigned long flags;
 
 	if (!cpu_context(smp_processor_id(), mm))
 		return;
@@ -400,12 +439,15 @@
 		return;
 	}
 
+	local_irq_save(flags);
 	r4k_blast_dcache();
+	r4k_blast_icache();
+	local_irq_restore(flags);
 }
 
 static void r4k_flush_cache_mm(struct mm_struct *mm)
 {
-	if (!cpu_has_dc_aliases)
+	if (!cpu_has_dc_aliases && cpu_use_kmap_coherent)
 		return;
 
 	r4k_on_each_cpu(local_r4k_flush_cache_mm, mm, 1, 1);
@@ -425,6 +467,7 @@
 	unsigned long paddr = fcp_args->pfn << PAGE_SHIFT;
 	int exec = vma->vm_flags & VM_EXEC;
 	struct mm_struct *mm = vma->vm_mm;
+	unsigned long flags;
 	pgd_t *pgdp;
 	pud_t *pudp;
 	pmd_t *pmdp;
@@ -456,8 +499,9 @@
 	 * for every cache flush operation.  So we do indexed flushes
 	 * in that case, which doesn't overly flush the cache too much.
 	 */
+	local_irq_save(flags);
 	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID)) {
-		if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
+		if (!cpu_use_kmap_coherent || cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
 			r4k_blast_dcache_page(addr);
 			if (exec && !cpu_icache_snoops_remote_store)
 				r4k_blast_scache_page(addr);
@@ -465,14 +509,14 @@
 		if (exec)
 			r4k_blast_icache_page(addr);
 
-		return;
+		goto done;
 	}
 
 	/*
 	 * Do indexed flush, too much work to get the (possible) TLB refills
 	 * to work correctly.
 	 */
-	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
+	if (!cpu_use_kmap_coherent || cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
 		r4k_blast_dcache_page_indexed(cpu_has_pindexed_dcache ?
 					      paddr : addr);
 		if (exec && !cpu_icache_snoops_remote_store) {
@@ -488,6 +532,8 @@
 		} else
 			r4k_blast_icache_page_indexed(addr);
 	}
+done:
+	local_irq_restore(flags);
 }
 
 static void r4k_flush_cache_page(struct vm_area_struct *vma,
@@ -504,7 +550,11 @@
 
 static inline void local_r4k_flush_data_cache_page(void * addr)
 {
+	unsigned long flags;
+
+	local_irq_save(flags);
 	r4k_blast_dcache_page((unsigned long) addr);
+	local_irq_restore(flags);
 }
 
 static void r4k_flush_data_cache_page(unsigned long addr)
@@ -547,6 +597,9 @@
 
 static void r4k_flush_icache_range(unsigned long start, unsigned long end)
 {
+#ifdef CONFIG_BCM947XX
+	r4k_flush_cache_all();
+#else
 	struct flush_icache_range_args args;
 
 	args.start = start;
@@ -554,12 +607,15 @@
 
 	r4k_on_each_cpu(local_r4k_flush_icache_range, &args, 1, 1);
 	instruction_hazard();
+#endif
 }
 
 #ifdef CONFIG_DMA_NONCOHERENT
 
 static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
 {
+	unsigned long flags;
+
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
 
@@ -576,18 +632,21 @@
 	 * subset property so we have to flush the primary caches
 	 * explicitly
 	 */
+	local_irq_save(flags);
 	if (size >= dcache_size) {
 		r4k_blast_dcache();
 	} else {
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_dcache_range(addr, addr + size);
 	}
-
 	bc_wback_inv(addr, size);
+	local_irq_restore(flags);
 }
 
 static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
 {
+	unsigned long flags;
+
 	/* Catch bad driver code */
 	BUG_ON(size == 0);
 
@@ -599,6 +658,7 @@
 		return;
 	}
 
+	local_irq_save(flags);
 	if (size >= dcache_size) {
 		r4k_blast_dcache();
 	} else {
@@ -607,6 +667,7 @@
 	}
 
 	bc_inv(addr, size);
+	local_irq_restore(flags);
 }
 #endif /* CONFIG_DMA_NONCOHERENT */
 
@@ -621,8 +682,12 @@
 	unsigned long dc_lsize = cpu_dcache_line_size();
 	unsigned long sc_lsize = cpu_scache_line_size();
 	unsigned long addr = (unsigned long) arg;
+	unsigned long flags;
 
+	local_irq_save(flags);
 	R4600_HIT_CACHEOP_WAR_IMPL;
+	BCM4710_PROTECTED_FILL_TLB(addr);
+	BCM4710_PROTECTED_FILL_TLB(addr + 4);
 	if (dc_lsize)
 		protected_writeback_dcache_line(addr & ~(dc_lsize - 1));
 	if (!cpu_icache_snoops_remote_store && scache_size)
@@ -649,6 +714,7 @@
 	}
 	if (MIPS_CACHE_SYNC_WAR)
 		__asm__ __volatile__ ("sync");
+	local_irq_restore(flags);
 }
 
 static void r4k_flush_cache_sigtramp(unsigned long addr)
@@ -1198,6 +1264,17 @@
 	 * silly idea of putting something else there ...
 	 */
 	switch (current_cpu_data.cputype) {
+	case CPU_BCM3302:
+		{
+			u32 cm;
+			cm = read_c0_diag();
+			/* Enable icache */
+			cm |= (1 << 31);
+			/* Enable dcache */
+			cm |= (1 << 30);
+			write_c0_diag(cm);
+		}
+		break;
 	case CPU_R4000PC:
 	case CPU_R4000SC:
 	case CPU_R4000MC:
@@ -1228,6 +1305,15 @@
 	/* Default cache error handler for R4000 and R5000 family */
 	set_uncached_handler (0x100, &except_vec2_generic, 0x80);
 
+	/* Check if special workarounds are required */
+#ifdef CONFIG_BCM947XX
+	if (current_cpu_data.cputype == CPU_BCM4710 && (current_cpu_data.processor_id & 0xff) == 0) {
+		printk("Enabling BCM4710A0 cache workarounds.\n");
+		bcm4710 = 1;
+	} else
+#endif
+		bcm4710 = 0;
+
 	probe_pcache();
 	setup_scache();
 
@@ -1273,5 +1359,13 @@
 	build_clear_page();
 	build_copy_page();
 	local_r4k___flush_cache_all(NULL);
+#ifdef CONFIG_BCM947XX
+	{
+		static void (*_coherency_setup)(void);
+		_coherency_setup = (void (*)(void)) KSEG1ADDR(coherency_setup);
+		_coherency_setup();
+	}
+#else
 	coherency_setup();
+#endif
 }
Index: linux-2.6.23/arch/mips/mm/tlbex.c
===================================================================
--- linux-2.6.23.orig/arch/mips/mm/tlbex.c	2007-10-13 02:26:00.272401391 +0200
+++ linux-2.6.23/arch/mips/mm/tlbex.c	2007-10-13 02:47:32.550044103 +0200
@@ -1247,6 +1247,10 @@
 #endif
 }
 
+#ifdef CONFIG_BCM947XX
+extern int bcm4710;
+#endif
+
 static void __init build_r4000_tlb_refill_handler(void)
 {
 	u32 *p = tlb_handler;
@@ -1261,6 +1265,10 @@
 	memset(relocs, 0, sizeof(relocs));
 	memset(final_handler, 0, sizeof(final_handler));
 
+#ifdef CONFIG_BCM947XX
+	i_nop(&p);
+#endif
+
 	/*
 	 * create the plain linear handler
 	 */
@@ -1756,6 +1764,9 @@
 	memset(labels, 0, sizeof(labels));
 	memset(relocs, 0, sizeof(relocs));
 
+#ifdef CONFIG_BCM947XX
+	i_nop(&p);
+#endif
 	if (bcm1250_m3_war()) {
 		i_MFC0(&p, K0, C0_BADVADDR);
 		i_MFC0(&p, K1, C0_ENTRYHI);
Index: linux-2.6.23/include/asm-mips/r4kcache.h
===================================================================
--- linux-2.6.23.orig/include/asm-mips/r4kcache.h	2007-10-09 22:31:38.000000000 +0200
+++ linux-2.6.23/include/asm-mips/r4kcache.h	2007-10-13 02:47:32.554044332 +0200
@@ -17,6 +17,20 @@
 #include <asm/cpu-features.h>
 #include <asm/mipsmtregs.h>
 
+#ifdef CONFIG_BCM947XX
+#include <asm/paccess.h>
+#include <linux/ssb/ssb.h>
+#define BCM4710_DUMMY_RREG() ((void) *((u8 *) KSEG1ADDR(SSB_ENUM_BASE + SSB_IMSTATE)))
+
+#define BCM4710_FILL_TLB(addr) (*(volatile unsigned long *)(addr))
+#define BCM4710_PROTECTED_FILL_TLB(addr) ({ unsigned long x; get_dbe(x, (volatile unsigned long *)(addr)); })
+#else
+#define BCM4710_DUMMY_RREG()
+
+#define BCM4710_FILL_TLB(addr)
+#define BCM4710_PROTECTED_FILL_TLB(addr)
+#endif
+
 /*
  * This macro return a properly sign-extended address suitable as base address
  * for indexed cache operations.  Two issues here:
@@ -150,6 +164,7 @@
 static inline void flush_dcache_line_indexed(unsigned long addr)
 {
 	__dflush_prologue
+	BCM4710_DUMMY_RREG();
 	cache_op(Index_Writeback_Inv_D, addr);
 	__dflush_epilogue
 }
@@ -169,6 +184,7 @@
 static inline void flush_dcache_line(unsigned long addr)
 {
 	__dflush_prologue
+	BCM4710_DUMMY_RREG();
 	cache_op(Hit_Writeback_Inv_D, addr);
 	__dflush_epilogue
 }
@@ -176,6 +192,7 @@
 static inline void invalidate_dcache_line(unsigned long addr)
 {
 	__dflush_prologue
+	BCM4710_DUMMY_RREG();
 	cache_op(Hit_Invalidate_D, addr);
 	__dflush_epilogue
 }
@@ -208,6 +225,7 @@
  */
 static inline void protected_flush_icache_line(unsigned long addr)
 {
+	BCM4710_DUMMY_RREG();
 	protected_cache_op(Hit_Invalidate_I, addr);
 }
 
@@ -219,6 +237,7 @@
  */
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
+	BCM4710_DUMMY_RREG();
 	protected_cache_op(Hit_Writeback_Inv_D, addr);
 }
 
@@ -339,8 +358,52 @@
 		: "r" (base),						\
 		  "i" (op));
 
+static inline void blast_dcache(void)
+{
+	unsigned long start = KSEG0;
+	unsigned long dcache_size = current_cpu_data.dcache.waysize * current_cpu_data.dcache.ways;
+	unsigned long end = (start + dcache_size);
+
+	do {
+		BCM4710_DUMMY_RREG();
+		cache_op(Index_Writeback_Inv_D, start);
+		start += current_cpu_data.dcache.linesz;
+	} while(start < end);
+}
+
+static inline void blast_dcache_page(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = start + PAGE_SIZE;
+
+	BCM4710_FILL_TLB(start);
+	do {
+		BCM4710_DUMMY_RREG();
+		cache_op(Hit_Writeback_Inv_D, start);
+		start += current_cpu_data.dcache.linesz;
+	} while(start < end);
+}
+
+static inline void blast_dcache_page_indexed(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = start + PAGE_SIZE;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	unsigned long ws_end = current_cpu_data.dcache.ways <<
+	                       current_cpu_data.dcache.waybit;
+	unsigned long ws, addr;
+	for (ws = 0; ws < ws_end; ws += ws_inc) {
+		start = page + ws;
+		for (addr = start; addr < end; addr += current_cpu_data.dcache.linesz) {
+			BCM4710_DUMMY_RREG();
+			cache_op(Index_Writeback_Inv_D, addr);
+		}
+	}
+}
+
+
 /* build blast_xxx, blast_xxx_page, blast_xxx_page_indexed */
-#define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize) \
+#define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize, war) \
 static inline void blast_##pfx##cache##lsize(void)			\
 {									\
 	unsigned long start = INDEX_BASE;				\
@@ -352,6 +415,7 @@
 									\
 	__##pfx##flush_prologue						\
 									\
+	war								\
 	for (ws = 0; ws < ws_end; ws += ws_inc)				\
 		for (addr = start; addr < end; addr += lsize * 32)	\
 			cache##lsize##_unroll32(addr|ws,indexop);	\
@@ -366,6 +430,7 @@
 									\
 	__##pfx##flush_prologue						\
 									\
+	war								\
 	do {								\
 		cache##lsize##_unroll32(start,hitop);			\
 		start += lsize * 32;					\
@@ -384,6 +449,8 @@
 	                       current_cpu_data.desc.waybit;		\
 	unsigned long ws, addr;						\
 									\
+	war								\
+									\
 	__##pfx##flush_prologue						\
 									\
 	for (ws = 0; ws < ws_end; ws += ws_inc)				\
@@ -393,28 +460,30 @@
 	__##pfx##flush_epilogue						\
 }
 
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16)
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128)
+__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16, )
+__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16, BCM4710_FILL_TLB(start);)
+__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16, )
+__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32, )
+__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32, BCM4710_FILL_TLB(start);)
+__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32, )
+__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64, BCM4710_FILL_TLB(start);)
+__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64, )
+__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128, )
 
 /* build blast_xxx_range, protected_blast_xxx_range */
-#define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \
+#define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot, war, war2) \
 static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
 						    unsigned long end)	\
 {									\
 	unsigned long lsize = cpu_##desc##_line_size();			\
 	unsigned long addr = start & ~(lsize - 1);			\
 	unsigned long aend = (end - 1) & ~(lsize - 1);			\
+	war								\
 									\
 	__##pfx##flush_prologue						\
 									\
 	while (1) {							\
+		war2						\
 		prot##cache_op(hitop, addr);				\
 		if (addr == aend)					\
 			break;						\
@@ -424,13 +493,13 @@
 	__##pfx##flush_epilogue						\
 }
 
-__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_)
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
-__BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_)
-__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, )
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, )
+__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_, BCM4710_PROTECTED_FILL_TLB(addr); BCM4710_PROTECTED_FILL_TLB(aend);, BCM4710_DUMMY_RREG();)
+__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_,, )
+__BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_,, )
+__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D,, BCM4710_FILL_TLB(addr); BCM4710_FILL_TLB(aend);, BCM4710_DUMMY_RREG();)
+__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD,,, )
 /* blast_inv_dcache_range */
-__BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D, )
-__BUILD_BLAST_CACHE_RANGE(inv_s, scache, Hit_Invalidate_SD, )
+__BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D,,,BCM4710_DUMMY_RREG();)
+__BUILD_BLAST_CACHE_RANGE(inv_s, scache, Hit_Invalidate_SD,,, )
 
 #endif /* _ASM_R4KCACHE_H */
Index: linux-2.6.23/include/asm-mips/stackframe.h
===================================================================
--- linux-2.6.23.orig/include/asm-mips/stackframe.h	2007-10-09 22:31:38.000000000 +0200
+++ linux-2.6.23/include/asm-mips/stackframe.h	2007-10-13 02:47:32.554044332 +0200
@@ -350,6 +350,10 @@
 		.macro	RESTORE_SP_AND_RET
 		LONG_L	sp, PT_R29(sp)
 		.set	mips3
+#ifdef CONFIG_BCM947XX
+		nop
+		nop
+#endif
 		eret
 		.set	mips0
 		.endm
