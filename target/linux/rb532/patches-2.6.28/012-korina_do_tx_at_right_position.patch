Triggering TX before the write to the DMA status mask register leads to
transferring packets with maximum payload no matter what the actual
packet size is.
While here, also trigger RX scheduling after writing the DMA status mask
register, like it was in the original driver before it was sent
upstream.

Signed-off-by: Phil Sutter <n0-1@freewrt.org>
---
--- a/drivers/net/korina.c
+++ b/drivers/net/korina.c
@@ -330,12 +330,12 @@ static irqreturn_t korina_rx_dma_interru
 
 	dmas = readl(&lp->rx_dma_regs->dmas);
 	if (dmas & (DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR)) {
-		netif_rx_schedule(dev, &lp->napi);
-
 		dmasm = readl(&lp->rx_dma_regs->dmasm);
 		writel(dmasm | (DMA_STAT_DONE |
 				DMA_STAT_HALT | DMA_STAT_ERR),
 				&lp->rx_dma_regs->dmasm);
+		
+		netif_rx_schedule(dev, &lp->napi);
 
 		if (dmas & DMA_STAT_ERR)
 			printk(KERN_ERR DRV_NAME "%s: DMA error\n", dev->name);
@@ -621,11 +621,11 @@ korina_tx_dma_interrupt(int irq, void *d
 	dmas = readl(&lp->tx_dma_regs->dmas);
 
 	if (dmas & (DMA_STAT_FINI | DMA_STAT_ERR)) {
-		korina_tx(dev);
-
 		dmasm = readl(&lp->tx_dma_regs->dmasm);
 		writel(dmasm | (DMA_STAT_FINI | DMA_STAT_ERR),
 				&lp->tx_dma_regs->dmasm);
+		
+		korina_tx(dev);
 
 		if (lp->tx_chain_status == desc_filled &&
 			(readl(&(lp->tx_dma_regs->dmandptr)) == 0)) {
