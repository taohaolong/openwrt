After applying the following changes I could verify functionality by
mounting a filesystem on the cfdisk and reading/writing files in it.

The set_irq_type() function must be wrong, as there is no set_type()
function defined for the rb532 IRQ chip. But as the used IRQ actually is
being triggered by a GPIO, setting it's interrupt level should be the
right alternative. Also to clear a GPIO triggered IRQ, the source has to
be cleared. This is being done at the end of rb532_pata_irq_handler.

Signed-off-by: Phil Sutter <n0-1@freewrt.org>
Acked-by: Florian Fainelli <florian@openwrt.org>
---
diff -urN linux-2.6.28.7/drivers/ata/pata_rb532_cf.c linux-2.6.28.7.new/drivers/ata/pata_rb532_cf.c
--- linux-2.6.28.7/drivers/ata/pata_rb532_cf.c	2009-02-20 23:41:27.000000000 +0100
+++ linux-2.6.28.7.new/drivers/ata/pata_rb532_cf.c	2009-03-15 13:21:06.000000000 +0100
@@ -31,6 +31,7 @@
 #include <scsi/scsi_host.h>
 
 #include <asm/gpio.h>
+#include <asm/mach-rc32434/gpio.h>
 
 #define DRV_NAME	"pata-rb532-cf"
 #define DRV_VERSION	"0.1.0"
@@ -63,8 +64,8 @@
 	   ata_sff_sync might be sufficient. */
 	ata_sff_dma_pause(ap);
 	ndelay(RB500_CF_IO_DELAY);
-
-	set_irq_type(info->irq, IRQ_TYPE_LEVEL_HIGH);
+	
+	rb532_gpio_set_ilevel(1, info->gpio_line);
 }
 
 static void rb532_pata_exec_command(struct ata_port *ap,
@@ -113,13 +114,15 @@
 	struct rb532_cf_info *info = ah->private_data;
 
 	if (gpio_get_value(info->gpio_line)) {
-		set_irq_type(info->irq, IRQ_TYPE_LEVEL_LOW);
+		rb532_gpio_set_ilevel(0, info->gpio_line);
 		if (!info->frozen)
 			ata_sff_interrupt(info->irq, dev_instance);
 	} else {
-		set_irq_type(info->irq, IRQ_TYPE_LEVEL_HIGH);
+		rb532_gpio_set_ilevel(1, info->gpio_line);
 	}
 
+	rb532_gpio_set_istat(0, info->gpio_line);
+
 	return IRQ_HANDLED;
 }
 
