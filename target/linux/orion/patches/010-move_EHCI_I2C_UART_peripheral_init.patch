This patch moves initialisation of EHCI/I2C/UART platform devices
from the common orion5x_init() into the board support code.

The rationale behind this is that only the board support code knows
whether certain peripherals have been brought out on the board, and
not initialising peripherals that haven't been brought out is
desirable for example:
- to reduce user confusion (e.g. seeing both 'eth0' and 'eth1'
  appear while there is only one ethernet port on the board); and
- to allow for future power savings (peripherals that have not
  been brought out can be clock gated off entirely.)

Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
---
 arch/arm/mach-orion5x/common.c            |  226 +++++++++++++++++------------
 arch/arm/mach-orion5x/common.h            |   35 ++---
 arch/arm/mach-orion5x/db88f5281-setup.c   |   39 +++---
 arch/arm/mach-orion5x/dns323-setup.c      |   40 +++---
 arch/arm/mach-orion5x/kurobox_pro-setup.c |   28 +++--
 arch/arm/mach-orion5x/rd88f5182-setup.c   |   29 ++--
 arch/arm/mach-orion5x/ts209-setup.c       |   38 ++---
 7 files changed, 240 insertions(+), 195 deletions(-)

--- a/arch/arm/mach-orion5x/common.c
+++ b/arch/arm/mach-orion5x/common.c
@@ -63,65 +63,20 @@
 	iotable_init(orion5x_io_desc, ARRAY_SIZE(orion5x_io_desc));
 }
 
+
 /*****************************************************************************
- * UART
+ * EHCI
  ****************************************************************************/
-
-static struct resource orion5x_uart_resources[] = {
-	{
-		.start		= UART0_PHYS_BASE,
-		.end		= UART0_PHYS_BASE + 0xff,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= IRQ_ORION5X_UART0,
-		.end		= IRQ_ORION5X_UART0,
-		.flags		= IORESOURCE_IRQ,
-	}, {
-		.start		= UART1_PHYS_BASE,
-		.end		= UART1_PHYS_BASE + 0xff,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= IRQ_ORION5X_UART1,
-		.end		= IRQ_ORION5X_UART1,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct plat_serial8250_port orion5x_uart_data[] = {
-	{
-		.mapbase	= UART0_PHYS_BASE,
-		.membase	= (char *)UART0_VIRT_BASE,
-		.irq		= IRQ_ORION5X_UART0,
-		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-		.uartclk	= ORION5X_TCLK,
-	}, {
-		.mapbase	= UART1_PHYS_BASE,
-		.membase	= (char *)UART1_VIRT_BASE,
-		.irq		= IRQ_ORION5X_UART1,
-		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-		.uartclk	= ORION5X_TCLK,
-	}, {
-	},
+static struct orion_ehci_data orion5x_ehci_data = {
+	.dram		= &orion5x_mbus_dram_info,
 };
 
-static struct platform_device orion5x_uart = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= orion5x_uart_data,
-	},
-	.resource		= orion5x_uart_resources,
-	.num_resources		= ARRAY_SIZE(orion5x_uart_resources),
-};
+static u64 ehci_dmamask = 0xffffffffUL;
 
-/*******************************************************************************
- * USB Controller - 2 interfaces
- ******************************************************************************/
 
+/*****************************************************************************
+ * EHCI0
+ ****************************************************************************/
 static struct resource orion5x_ehci0_resources[] = {
 	{
 		.start	= ORION5X_USB0_PHYS_BASE,
@@ -134,24 +89,6 @@
 	},
 };
 
-static struct resource orion5x_ehci1_resources[] = {
-	{
-		.start	= ORION5X_USB1_PHYS_BASE,
-		.end	= ORION5X_USB1_PHYS_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_ORION5X_USB1_CTRL,
-		.end	= IRQ_ORION5X_USB1_CTRL,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct orion_ehci_data orion5x_ehci_data = {
-	.dram		= &orion5x_mbus_dram_info,
-};
-
-static u64 ehci_dmamask = 0xffffffffUL;
-
 static struct platform_device orion5x_ehci0 = {
 	.name		= "orion-ehci",
 	.id		= 0,
@@ -164,6 +101,27 @@
 	.num_resources	= ARRAY_SIZE(orion5x_ehci0_resources),
 };
 
+void __init orion5x_ehci0_init(void)
+{
+	platform_device_register(&orion5x_ehci0);
+}
+
+
+/*****************************************************************************
+ * EHCI1
+ ****************************************************************************/
+static struct resource orion5x_ehci1_resources[] = {
+	{
+		.start	= ORION5X_USB1_PHYS_BASE,
+		.end	= ORION5X_USB1_PHYS_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_ORION5X_USB1_CTRL,
+		.end	= IRQ_ORION5X_USB1_CTRL,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
 static struct platform_device orion5x_ehci1 = {
 	.name		= "orion-ehci",
 	.id		= 1,
@@ -176,11 +134,15 @@
 	.num_resources	= ARRAY_SIZE(orion5x_ehci1_resources),
 };
 
+void __init orion5x_ehci1_init(void)
+{
+	platform_device_register(&orion5x_ehci1);
+}
+
+
 /*****************************************************************************
- * Gigabit Ethernet port
- * (The Orion and Discovery (MV643xx) families use the same Ethernet driver)
+ * GigE
  ****************************************************************************/
-
 struct mv643xx_eth_shared_platform_data orion5x_eth_shared_data = {
 	.dram		= &orion5x_mbus_dram_info,
 	.t_clk		= ORION5X_TCLK,
@@ -229,11 +191,10 @@
 	platform_device_register(&orion5x_eth);
 }
 
+
 /*****************************************************************************
- * I2C controller
- * (The Orion and Discovery (MV643xx) families share the same I2C controller)
+ * I2C
  ****************************************************************************/
-
 static struct mv64xxx_i2c_pdata orion5x_i2c_pdata = {
 	.freq_m		= 8, /* assumes 166 MHz TCLK */
 	.freq_n		= 3,
@@ -244,7 +205,7 @@
 	{
 		.name	= "i2c base",
 		.start	= I2C_PHYS_BASE,
-		.end	= I2C_PHYS_BASE + 0x20 -1,
+		.end	= I2C_PHYS_BASE + 0x1f,
 		.flags	= IORESOURCE_MEM,
 	}, {
 		.name	= "i2c irq",
@@ -264,8 +225,14 @@
 	},
 };
 
+void __init orion5x_i2c_init(void)
+{
+	platform_device_register(&orion5x_i2c);
+}
+
+
 /*****************************************************************************
- * Sata port
+ * SATA
  ****************************************************************************/
 static struct resource orion5x_sata_resources[] = {
 	{
@@ -298,10 +265,98 @@
 	platform_device_register(&orion5x_sata);
 }
 
+
 /*****************************************************************************
- * Time handling
+ * UART0
+ ****************************************************************************/
+static struct plat_serial8250_port orion5x_uart0_data[] = {
+	{
+		.mapbase	= UART0_PHYS_BASE,
+		.membase	= (char *)UART0_VIRT_BASE,
+		.irq		= IRQ_ORION5X_UART0,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= ORION5X_TCLK,
+	}, {
+	},
+};
+
+static struct resource orion5x_uart0_resources[] = {
+	{
+		.start		= UART0_PHYS_BASE,
+		.end		= UART0_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_ORION5X_UART0,
+		.end		= IRQ_ORION5X_UART0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device orion5x_uart0 = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev			= {
+		.platform_data	= orion5x_uart0_data,
+	},
+	.resource		= orion5x_uart0_resources,
+	.num_resources		= ARRAY_SIZE(orion5x_uart0_resources),
+};
+
+void __init orion5x_uart0_init(void)
+{
+	platform_device_register(&orion5x_uart0);
+}
+
+
+/*****************************************************************************
+ * UART1
  ****************************************************************************/
+static struct plat_serial8250_port orion5x_uart1_data[] = {
+	{
+		.mapbase	= UART1_PHYS_BASE,
+		.membase	= (char *)UART1_VIRT_BASE,
+		.irq		= IRQ_ORION5X_UART1,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= ORION5X_TCLK,
+	}, {
+	},
+};
+
+static struct resource orion5x_uart1_resources[] = {
+	{
+		.start		= UART1_PHYS_BASE,
+		.end		= UART1_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_ORION5X_UART1,
+		.end		= IRQ_ORION5X_UART1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device orion5x_uart1 = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM1,
+	.dev			= {
+		.platform_data	= orion5x_uart1_data,
+	},
+	.resource		= orion5x_uart1_resources,
+	.num_resources		= ARRAY_SIZE(orion5x_uart1_resources),
+};
+
+void __init orion5x_uart1_init(void)
+{
+	platform_device_register(&orion5x_uart1);
+}
 
+
+/*****************************************************************************
+ * Time handling
+ ****************************************************************************/
 static void orion5x_timer_init(void)
 {
 	orion_time_init(IRQ_ORION5X_BRIDGE, ORION5X_TCLK);
@@ -311,10 +366,10 @@
 	.init = orion5x_timer_init,
 };
 
+
 /*****************************************************************************
  * General
  ****************************************************************************/
-
 /*
  * Identify device ID and rev from PCIe configuration header space '0'.
  */
@@ -359,15 +414,6 @@
 	 * Setup Orion address map
 	 */
 	orion5x_setup_cpu_mbus_bridge();
-
-	/*
-	 * Register devices.
-	 */
-	platform_device_register(&orion5x_uart);
-	platform_device_register(&orion5x_ehci0);
-	if (dev == MV88F5182_DEV_ID)
-		platform_device_register(&orion5x_ehci1);
-	platform_device_register(&orion5x_i2c);
 }
 
 /*
--- a/arch/arm/mach-orion5x/common.h
+++ b/arch/arm/mach-orion5x/common.h
@@ -1,10 +1,12 @@
 #ifndef __ARCH_ORION5X_COMMON_H
 #define __ARCH_ORION5X_COMMON_H
 
+struct mv643xx_eth_platform_data;
+struct mv_sata_platform_data;
+
 /*
  * Basic Orion init functions used early by machine-setup.
  */
-
 void orion5x_map_io(void);
 void orion5x_init_irq(void);
 void orion5x_init(void);
@@ -23,13 +25,19 @@
 void orion5x_setup_dev2_win(u32 base, u32 size);
 void orion5x_setup_pcie_wa_win(u32 base, u32 size);
 
+void orion5x_ehci0_init(void);
+void orion5x_ehci1_init(void);
+void orion5x_eth_init(struct mv643xx_eth_platform_data *eth_data);
+void orion5x_i2c_init(void);
+void orion5x_sata_init(struct mv_sata_platform_data *sata_data);
+void orion5x_uart0_init(void);
+void orion5x_uart1_init(void);
+
 /*
- * Shared code used internally by other Orion core functions.
- * (/mach-orion/pci.c)
+ * PCIe/PCI functions.
  */
-
-struct pci_sys_data;
 struct pci_bus;
+struct pci_sys_data;
 
 void orion5x_pcie_id(u32 *dev, u32 *rev);
 int orion5x_pci_sys_setup(int nr, struct pci_sys_data *sys);
@@ -40,26 +48,9 @@
  * Valid GPIO pins according to MPP setup, used by machine-setup.
  * (/mach-orion/gpio.c).
  */
-
 void orion5x_gpio_set_valid_pins(u32 pins);
 void gpio_display(void);	/* debug */
 
-/*
- * Pull in Orion Ethernet platform_data, used by machine-setup
- */
-
-struct mv643xx_eth_platform_data;
-
-void orion5x_eth_init(struct mv643xx_eth_platform_data *eth_data);
-
-/*
- * Orion Sata platform_data, used by machine-setup
- */
-
-struct mv_sata_platform_data;
-
-void orion5x_sata_init(struct mv_sata_platform_data *sata_data);
-
 struct machine_desc;
 struct meminfo;
 struct tag;
--- a/arch/arm/mach-orion5x/db88f5281-setup.c
+++ b/arch/arm/mach-orion5x/db88f5281-setup.c
@@ -298,13 +298,6 @@
 /*****************************************************************************
  * General Setup
  ****************************************************************************/
-
-static struct platform_device *db88f5281_devs[] __initdata = {
-	&db88f5281_boot_flash,
-	&db88f5281_nor_flash,
-	&db88f5281_nand_flash,
-};
-
 static void __init db88f5281_init(void)
 {
 	/*
@@ -313,15 +306,6 @@
 	orion5x_init();
 
 	/*
-	 * Setup the CPU address decode windows for our on-board devices
-	 */
-	orion5x_setup_dev_boot_win(DB88F5281_NOR_BOOT_BASE,
-				DB88F5281_NOR_BOOT_SIZE);
-	orion5x_setup_dev0_win(DB88F5281_7SEG_BASE, DB88F5281_7SEG_SIZE);
-	orion5x_setup_dev1_win(DB88F5281_NOR_BASE, DB88F5281_NOR_SIZE);
-	orion5x_setup_dev2_win(DB88F5281_NAND_BASE, DB88F5281_NAND_SIZE);
-
-	/*
 	 * Setup Multiplexing Pins:
 	 * MPP0: GPIO (USB Over Current)	MPP1: GPIO (USB Vbat input)
 	 * MPP2: PCI_REQn[2]			MPP3: PCI_GNTn[2]
@@ -342,9 +326,28 @@
 
 	orion5x_gpio_set_valid_pins(0x00003fc3);
 
-	platform_add_devices(db88f5281_devs, ARRAY_SIZE(db88f5281_devs));
-	i2c_register_board_info(0, &db88f5281_i2c_rtc, 1);
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
 	orion5x_eth_init(&db88f5281_eth_data);
+	orion5x_i2c_init();
+	orion5x_uart0_init();
+	orion5x_uart1_init();
+
+	orion5x_setup_dev_boot_win(DB88F5281_NOR_BOOT_BASE,
+				DB88F5281_NOR_BOOT_SIZE);
+	platform_device_register(&db88f5281_boot_flash);
+
+	orion5x_setup_dev0_win(DB88F5281_7SEG_BASE, DB88F5281_7SEG_SIZE);
+
+	orion5x_setup_dev1_win(DB88F5281_NOR_BASE, DB88F5281_NOR_SIZE);
+	platform_device_register(&db88f5281_nor_flash);
+
+	orion5x_setup_dev2_win(DB88F5281_NAND_BASE, DB88F5281_NAND_SIZE);
+	platform_device_register(&db88f5281_nand_flash);
+
+	i2c_register_board_info(0, &db88f5281_i2c_rtc, 1);
 }
 
 MACHINE_START(DB88F5281, "Marvell Orion-2 Development Board")
--- a/arch/arm/mach-orion5x/dns323-setup.c
+++ b/arch/arm/mach-orion5x/dns323-setup.c
@@ -213,12 +213,6 @@
  * General Setup
  */
 
-static struct platform_device *dns323_plat_devices[] __initdata = {
-	&dns323_nor_flash,
-	&dns323_gpio_leds,
-	&dns323_button_device,
-};
-
 /*
  * On the DNS-323 the following devices are attached via I2C:
  *
@@ -253,11 +247,6 @@
 	/* Setup basic Orion functions. Need to be called early. */
 	orion5x_init();
 
-	/* setup flash mapping
-	 * CS3 holds a 8 MB Spansion S29GL064M90TFIR4
-	 */
-	orion5x_setup_dev_boot_win(DNS323_NOR_BOOT_BASE, DNS323_NOR_BOOT_SIZE);
-
 	/* DNS-323 has a Marvell 88X7042 SATA controller attached via PCIe
 	 *
 	 * Open a special address decode windows for the PCIe WA.
@@ -294,21 +283,32 @@
 	*/
 	orion5x_gpio_set_valid_pins(0x07f6);
 
-	/* register dns323 specific power-off method */
-	if (gpio_request(DNS323_GPIO_POWER_OFF, "POWEROFF") != 0 ||
-	    gpio_direction_output(DNS323_GPIO_POWER_OFF, 0) != 0)
-		pr_err("DNS323: failed to setup power-off GPIO\n");
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_eth_init(&dns323_eth_data);
+	orion5x_i2c_init();
+	orion5x_uart0_init();
 
-	pm_power_off = dns323_power_off;
+	/* setup flash mapping
+	 * CS3 holds a 8 MB Spansion S29GL064M90TFIR4
+	 */
+	orion5x_setup_dev_boot_win(DNS323_NOR_BOOT_BASE, DNS323_NOR_BOOT_SIZE);
+	platform_device_register(&dns323_nor_flash);
+
+	platform_device_register(&dns323_gpio_leds);
 
-	/* register flash and other platform devices */
-	platform_add_devices(dns323_plat_devices,
-			     ARRAY_SIZE(dns323_plat_devices));
+	platform_device_register(&dns323_button_device);
 
 	i2c_register_board_info(0, dns323_i2c_devices,
 				ARRAY_SIZE(dns323_i2c_devices));
 
-	orion5x_eth_init(&dns323_eth_data);
+	/* register dns323 specific power-off method */
+	if (gpio_request(DNS323_GPIO_POWER_OFF, "POWEROFF") != 0 ||
+	    gpio_direction_output(DNS323_GPIO_POWER_OFF, 0) != 0)
+		pr_err("DNS323: failed to setup power-off GPIO\n");
+	pm_power_off = dns323_power_off;
 }
 
 /* Warning: D-Link uses a wrong mach-type (=526) in their bootloader */
--- a/arch/arm/mach-orion5x/kurobox_pro-setup.c
+++ b/arch/arm/mach-orion5x/kurobox_pro-setup.c
@@ -188,13 +188,6 @@
 	orion5x_init();
 
 	/*
-	 * Setup the CPU address decode windows for our devices
-	 */
-	orion5x_setup_dev_boot_win(KUROBOX_PRO_NOR_BOOT_BASE,
-				KUROBOX_PRO_NOR_BOOT_SIZE);
-	orion5x_setup_dev0_win(KUROBOX_PRO_NAND_BASE, KUROBOX_PRO_NAND_SIZE);
-
-	/*
 	 * Open a special address decode windows for the PCIe WA.
 	 */
 	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
@@ -221,12 +214,27 @@
 
 	orion5x_gpio_set_valid_pins(0x0000000c);
 
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
+	orion5x_eth_init(&kurobox_pro_eth_data);
+	orion5x_i2c_init();
+	orion5x_sata_init(&kurobox_pro_sata_data);
+	orion5x_uart0_init();
+
+	orion5x_setup_dev_boot_win(KUROBOX_PRO_NOR_BOOT_BASE,
+				   KUROBOX_PRO_NOR_BOOT_SIZE);
 	platform_device_register(&kurobox_pro_nor_flash);
-	if (machine_is_kurobox_pro())
+
+	if (machine_is_kurobox_pro()) {
+		orion5x_setup_dev0_win(KUROBOX_PRO_NAND_BASE,
+				       KUROBOX_PRO_NAND_SIZE);
 		platform_device_register(&kurobox_pro_nand_flash);
+	}
+
 	i2c_register_board_info(0, &kurobox_pro_i2c_rtc, 1);
-	orion5x_eth_init(&kurobox_pro_eth_data);
-	orion5x_sata_init(&kurobox_pro_sata_data);
 }
 
 #ifdef CONFIG_MACH_KUROBOX_PRO
--- a/arch/arm/mach-orion5x/rd88f5182-setup.c
+++ b/arch/arm/mach-orion5x/rd88f5182-setup.c
@@ -241,11 +241,6 @@
 /*****************************************************************************
  * General Setup
  ****************************************************************************/
-
-static struct platform_device *rd88f5182_devices[] __initdata = {
-	&rd88f5182_nor_flash,
-};
-
 static void __init rd88f5182_init(void)
 {
 	/*
@@ -254,13 +249,6 @@
 	orion5x_init();
 
 	/*
-	 * Setup the CPU address decode windows for our devices
-	 */
-	orion5x_setup_dev_boot_win(RD88F5182_NOR_BOOT_BASE,
-				RD88F5182_NOR_BOOT_SIZE);
-	orion5x_setup_dev1_win(RD88F5182_NOR_BASE, RD88F5182_NOR_SIZE);
-
-	/*
 	 * Open a special address decode windows for the PCIe WA.
 	 */
 	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
@@ -296,10 +284,23 @@
 
 	orion5x_gpio_set_valid_pins(0x000000fb);
 
-	platform_add_devices(rd88f5182_devices, ARRAY_SIZE(rd88f5182_devices));
-	i2c_register_board_info(0, &rd88f5182_i2c_rtc, 1);
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
 	orion5x_eth_init(&rd88f5182_eth_data);
+	orion5x_i2c_init();
 	orion5x_sata_init(&rd88f5182_sata_data);
+	orion5x_uart0_init();
+
+	orion5x_setup_dev_boot_win(RD88F5182_NOR_BOOT_BASE,
+				   RD88F5182_NOR_BOOT_SIZE);
+
+	orion5x_setup_dev1_win(RD88F5182_NOR_BASE, RD88F5182_NOR_SIZE);
+	platform_device_register(&rd88f5182_nor_flash);
+
+	i2c_register_board_info(0, &rd88f5182_i2c_rtc, 1);
 }
 
 MACHINE_START(RD88F5182, "Marvell Orion-NAS Reference Design")
--- a/arch/arm/mach-orion5x/ts209-setup.c
+++ b/arch/arm/mach-orion5x/ts209-setup.c
@@ -332,16 +332,9 @@
 
  * General Setup
  ****************************************************************************/
-
-static struct platform_device *qnap_ts209_devices[] __initdata = {
-	&qnap_ts209_nor_flash,
-	&qnap_ts209_button_device,
-};
-
 /*
  * QNAP TS-[12]09 specific power off method via UART1-attached PIC
  */
-
 #define UART1_REG(x)	(UART1_VIRT_BASE + ((UART_##x) << 2))
 
 static void qnap_ts209_power_off(void)
@@ -372,12 +365,6 @@
 	orion5x_init();
 
 	/*
-	 * Setup flash mapping
-	 */
-	orion5x_setup_dev_boot_win(QNAP_TS209_NOR_BOOT_BASE,
-				   QNAP_TS209_NOR_BOOT_SIZE);
-
-	/*
 	 * Open a special address decode windows for the PCIe WA.
 	 */
 	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
@@ -411,11 +398,22 @@
 	orion5x_write(MPP_16_19_CTRL, 0x5500);
 	orion5x_gpio_set_valid_pins(0x3cc0fff);
 
-	/* register ts209 specific power-off method */
-	pm_power_off = qnap_ts209_power_off;
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
+	ts209_find_mac_addr();
+	orion5x_eth_init(&qnap_ts209_eth_data);
+	orion5x_i2c_init();
+	orion5x_sata_init(&qnap_ts209_sata_data);
+	orion5x_uart0_init();
+
+	orion5x_setup_dev_boot_win(QNAP_TS209_NOR_BOOT_BASE,
+				   QNAP_TS209_NOR_BOOT_SIZE);
+	platform_device_register(&qnap_ts209_nor_flash);
 
-	platform_add_devices(qnap_ts209_devices,
-				ARRAY_SIZE(qnap_ts209_devices));
+	platform_device_register(&qnap_ts209_button_device);
 
 	/* Get RTC IRQ and register the chip */
 	if (gpio_request(TS209_RTC_GPIO, "rtc") == 0) {
@@ -428,10 +426,8 @@
 		pr_warning("qnap_ts209_init: failed to get RTC IRQ\n");
 	i2c_register_board_info(0, &qnap_ts209_i2c_rtc, 1);
 
-	ts209_find_mac_addr();
-	orion5x_eth_init(&qnap_ts209_eth_data);
-
-	orion5x_sata_init(&qnap_ts209_sata_data);
+	/* register ts209 specific power-off method */
+	pm_power_off = qnap_ts209_power_off;
 }
 
 MACHINE_START(TS209, "QNAP TS-109/TS-209")
