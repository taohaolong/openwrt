--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2691,12 +2691,10 @@
 S:	Maintained
 
 MARVELL MV643XX ETHERNET DRIVER
-P:	Dale Farnsworth
-M:	dale@farnsworth.org
-P:	Manish Lachwani
-M:	mlachwani@mvista.com
+P:	Lennert Buytenhek
+M:	buytenh@marvell.com
 L:	netdev@vger.kernel.org
-S:	Odd Fixes for 2.4; Maintained for 2.6.
+S:	Supported
 
 MATROX FRAMEBUFFER DRIVER
 P:	Petr Vandrovec
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -84,6 +84,11 @@
 	bool
 	default y
 
+config HAVE_LATENCYTOP_SUPPORT
+	bool
+	depends on !SMP
+	default y
+
 config LOCKDEP_SUPPORT
 	bool
 	default y
@@ -347,6 +352,16 @@
 	  If you have any questions or comments about the Linux kernel port
 	  to this board, send e-mail to <sjhill@cotw.com>.
 
+config ARCH_KIRKWOOD
+	bool "Marvell Kirkwood"
+	select PCI
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	select PLAT_ORION
+	help
+	  Support for the following Marvell Kirkwood series SoCs:
+	  88F6180, 88F6192 and 88F6281.
+
 config ARCH_KS8695
 	bool "Micrel/Kendin KS8695"
 	select GENERIC_GPIO
@@ -365,6 +380,24 @@
 
 	  <http://www.digi.com/products/microprocessors/index.jsp>
 
+config ARCH_LOKI
+	bool "Marvell Loki (88RC8480)"
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	select PLAT_ORION
+	help
+	  Support for the Marvell Loki (88RC8480) SoC.
+
+config ARCH_MV78XX0
+	bool "Marvell MV78xx0"
+	select PCI
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	select PLAT_ORION
+	help
+	  Support for the following Marvell MV78xx0 series SoCs:
+	  MV781x0, MV782x0.
+
 config ARCH_MXC
 	bool "Freescale MXC/iMX-based"
 	select ARCH_MTD_XIP
@@ -381,7 +414,8 @@
 	select PLAT_ORION
 	help
 	  Support for the following Marvell Orion 5x series SoCs:
-	  Orion-1 (5181), Orion-NAS (5182), Orion-2 (5281.)
+	  Orion-1 (5181), Orion-VoIP (5181L), Orion-NAS (5182),
+	  Orion-2 (5281).
 
 config ARCH_PNX4008
 	bool "Philips Nexperia PNX4008 Mobile"
@@ -502,6 +536,10 @@
 
 source "arch/arm/mach-ixp23xx/Kconfig"
 
+source "arch/arm/mach-loki/Kconfig"
+
+source "arch/arm/mach-mv78xx0/Kconfig"
+
 source "arch/arm/mach-pxa/Kconfig"
 
 source "arch/arm/mach-sa1100/Kconfig"
@@ -514,6 +552,8 @@
 
 source "arch/arm/mach-orion5x/Kconfig"
 
+source "arch/arm/mach-kirkwood/Kconfig"
+
 source "arch/arm/plat-s3c24xx/Kconfig"
 source "arch/arm/plat-s3c/Kconfig"
 
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -135,11 +135,14 @@
  machine-$(CONFIG_ARCH_NETX)	   := netx
  machine-$(CONFIG_ARCH_NS9XXX)	   := ns9xxx
  machine-$(CONFIG_ARCH_DAVINCI)	   := davinci
+ machine-$(CONFIG_ARCH_KIRKWOOD)   := kirkwood
  machine-$(CONFIG_ARCH_KS8695)     := ks8695
   incdir-$(CONFIG_ARCH_MXC)	   := mxc
  machine-$(CONFIG_ARCH_MX3)	   := mx3
  machine-$(CONFIG_ARCH_ORION5X)	   := orion5x
  machine-$(CONFIG_ARCH_MSM7X00A)   := msm
+ machine-$(CONFIG_ARCH_LOKI)       := loki
+ machine-$(CONFIG_ARCH_MV78XX0)    := mv78xx0
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -623,8 +623,8 @@
 		b	__armv4_mmu_cache_off
 		b	__armv4_mmu_cache_flush
 
-		.word	0x56055310		@ Feroceon
-		.word	0xfffffff0
+		.word	0x56050000		@ Feroceon
+		.word	0xff0f0000
 		b	__armv4_mmu_cache_on
 		b	__armv4_mmu_cache_off
 		b	__armv5tej_mmu_cache_flush
--- /dev/null
+++ b/arch/arm/configs/kirkwood_defconfig
@@ -0,0 +1,1426 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.26-rc5
+# Sun Jun 22 15:51:25 2008
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
+CONFIG_ZONE_DMA=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HAVE_DMA_ATTRS is not set
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CLASSIC_RCU=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+CONFIG_ARCH_KIRKWOOD=y
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM7X00A is not set
+
+#
+# Marvell Kirkwood Implementations
+#
+CONFIG_MACH_DB88F6281_BP=y
+CONFIG_MACH_RD88F6192_NAS=y
+CONFIG_MACH_RD88F6281=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+CONFIG_PLAT_ORION=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_FEROCEON=y
+# CONFIG_CPU_FEROCEON_OLD_ID is not set
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_FEROCEON=y
+CONFIG_CPU_TLB_FEROCEON=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_FEROCEON_L2=y
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_SYSCALL=y
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_PCI_LEGACY=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x0
+CONFIG_MTD_PHYSMAP_LEN=0x0
+CONFIG_MTD_PHYSMAP_BANKWIDTH=0
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_ORION=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_SRP is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_SATA_PMP=y
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_SVW is not set
+# CONFIG_ATA_PIIX is not set
+CONFIG_SATA_MV=y
+# CONFIG_SATA_NV is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_MD is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=y
+CONFIG_E1000_NAPI=y
+# CONFIG_E1000_DISABLE_PACKET_SPLIT is not set
+# CONFIG_E1000E is not set
+# CONFIG_E1000E_ENABLED is not set
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+CONFIG_MV643XX_ETH=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_MV64XXX=y
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_ORION=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_PASIC3 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+# CONFIG_USB_STORAGE_ISD200 is not set
+CONFIG_USB_STORAGE_DPCM=y
+# CONFIG_USB_STORAGE_USBAT is not set
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+CONFIG_NEW_LEDS=y
+# CONFIG_LEDS_CLASS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+CONFIG_RTC_DRV_MV=y
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_MV_XOR=y
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_XFS_FS=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SAMPLES is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_ASYNC_CORE=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_MANAGER=m
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_GENERIC_FIND_FIRST_BIT is not set
+# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- /dev/null
+++ b/arch/arm/configs/loki_defconfig
@@ -0,0 +1,1147 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.26-rc5
+# Fri Jun 13 03:07:49 2008
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
+CONFIG_ZONE_DMA=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HAVE_DMA_ATTRS is not set
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CLASSIC_RCU=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+CONFIG_ARCH_LOKI=y
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM7X00A is not set
+
+#
+# Marvell Loki (88RC8480) Implementations
+#
+CONFIG_MACH_LB88RC8480=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+CONFIG_PLAT_ORION=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_FEROCEON=y
+# CONFIG_CPU_FEROCEON_OLD_ID is not set
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_FEROCEON=y
+CONFIG_CPU_TLB_FEROCEON=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_FTL=y
+CONFIG_NFTL=y
+# CONFIG_NFTL_RW is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+CONFIG_MTD_CFI_I4=y
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x0
+CONFIG_MTD_PHYSMAP_LEN=0x0
+CONFIG_MTD_PHYSMAP_BANKWIDTH=0
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_ORION=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_SATA_PMP=y
+CONFIG_ATA_SFF=y
+CONFIG_SATA_MV=y
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_E1000E_ENABLED is not set
+CONFIG_MV643XX_ETH=y
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=m
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_MV64XXX=y
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_PASIC3 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+# CONFIG_USB_STORAGE_ISD200 is not set
+CONFIG_USB_STORAGE_DPCM=y
+# CONFIG_USB_STORAGE_USBAT is not set
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+CONFIG_NEW_LEDS=y
+# CONFIG_LEDS_CLASS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_XFS_FS=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_LDM_PARTITION=y
+CONFIG_LDM_DEBUG=y
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_SUN_PARTITION=y
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SAMPLES is not set
+CONFIG_DEBUG_USER=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_MANAGER=m
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_GENERIC_FIND_FIRST_BIT is not set
+# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- /dev/null
+++ b/arch/arm/configs/mv78xx0_defconfig
@@ -0,0 +1,1445 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.26-rc5
+# Fri Jun 13 02:57:32 2008
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+# CONFIG_GENERIC_GPIO is not set
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
+CONFIG_ZONE_DMA=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+# CONFIG_MARKERS is not set
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HAVE_DMA_ATTRS is not set
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CLASSIC_RCU=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+CONFIG_ARCH_MV78XX0=y
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM7X00A is not set
+
+#
+# Marvell MV78xx0 Implementations
+#
+CONFIG_MACH_DB78X00_BP=y
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+CONFIG_PLAT_ORION=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_FEROCEON=y
+CONFIG_CPU_FEROCEON_OLD_ID=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_FEROCEON=y
+CONFIG_CPU_TLB_FEROCEON=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_FEROCEON_L2=y
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_SYSCALL=y
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_PCI_LEGACY=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_START=0x0
+CONFIG_MTD_PHYSMAP_LEN=0x0
+CONFIG_MTD_PHYSMAP_BANKWIDTH=0
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_ORION=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_PHANTOM is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_SRP is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_SATA_PMP=y
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_SVW is not set
+# CONFIG_ATA_PIIX is not set
+CONFIG_SATA_MV=y
+# CONFIG_SATA_NV is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_MD is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_E1000E_ENABLED is not set
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+CONFIG_MV643XX_ETH=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_TINY_USB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_MV64XXX=y
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_PASIC3 is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+# CONFIG_USB_STORAGE_ISD200 is not set
+CONFIG_USB_STORAGE_DPCM=y
+# CONFIG_USB_STORAGE_USBAT is not set
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=y
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+CONFIG_RTC_DRV_RS5C372=y
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+CONFIG_RTC_DRV_M41T80=y
+# CONFIG_RTC_DRV_M41T80_WDT is not set
+# CONFIG_RTC_DRV_S35390A is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SAMPLES is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_MANAGER=m
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_GENERIC_FIND_FIRST_BIT is not set
+# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- a/arch/arm/configs/orion5x_defconfig
+++ b/arch/arm/configs/orion5x_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.24
-# Thu Feb  7 14:10:30 2008
+# Linux kernel version: 2.6.26-rc4
+# Mon Jun  2 23:54:48 2008
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -21,6 +21,7 @@
 # CONFIG_ARCH_HAS_ILOG2_U64 is not set
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
 CONFIG_ZONE_DMA=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
@@ -40,24 +41,24 @@
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_TASKSTATS is not set
-# CONFIG_USER_NS is not set
-# CONFIG_PID_NS is not set
 # CONFIG_AUDIT is not set
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
-CONFIG_FAIR_GROUP_SCHED=y
-CONFIG_FAIR_USER_SCHED=y
-# CONFIG_FAIR_CGROUP_SCHED is not set
+# CONFIG_GROUP_SCHED is not set
 CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
 # CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
 # CONFIG_BLK_DEV_INITRD is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
 CONFIG_EMBEDDED=y
 CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
 CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
 CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
@@ -73,20 +74,25 @@
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
 CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
 # CONFIG_SLOB is not set
-# CONFIG_PROFILING is not set
+CONFIG_PROFILING=y
 # CONFIG_MARKERS is not set
+CONFIG_OPROFILE=y
 CONFIG_HAVE_OPROFILE=y
-# CONFIG_KPROBES is not set
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
 CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HAVE_DMA_ATTRS is not set
 CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
 # CONFIG_TINY_SHMEM is not set
 CONFIG_BASE_SMALL=0
 CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
 CONFIG_MODULE_UNLOAD=y
 # CONFIG_MODULE_FORCE_UNLOAD is not set
 # CONFIG_MODVERSIONS is not set
@@ -111,7 +117,6 @@
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_IOSCHED="cfq"
 CONFIG_CLASSIC_RCU=y
-# CONFIG_PREEMPT_RCU is not set
 
 #
 # System Type
@@ -160,6 +165,7 @@
 CONFIG_MACH_KUROBOX_PRO=y
 CONFIG_MACH_DNS323=y
 CONFIG_MACH_TS209=y
+CONFIG_MACH_LINKSTATION_PRO=y
 
 #
 # Boot options
@@ -168,6 +174,7 @@
 #
 # Power management
 #
+CONFIG_PLAT_ORION=y
 
 #
 # Processor Type
@@ -177,8 +184,9 @@
 CONFIG_CPU_FEROCEON_OLD_ID=y
 CONFIG_CPU_32v5=y
 CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_PABRT_NOIFAR=y
 CONFIG_CPU_CACHE_VIVT=y
-CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_COPY_FEROCEON=y
 CONFIG_CPU_TLB_V4WBI=y
 CONFIG_CPU_CP15=y
 CONFIG_CPU_CP15_MMU=y
@@ -189,7 +197,6 @@
 CONFIG_ARM_THUMB=y
 # CONFIG_CPU_ICACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_DISABLE is not set
-# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_OUTER_CACHE is not set
 
 #
@@ -199,6 +206,7 @@
 CONFIG_PCI_SYSCALL=y
 # CONFIG_ARCH_SUPPORTS_MSI is not set
 CONFIG_PCI_LEGACY=y
+# CONFIG_PCI_DEBUG is not set
 # CONFIG_PCCARD is not set
 
 #
@@ -221,6 +229,7 @@
 CONFIG_FLAT_NODE_MEM_MAP=y
 # CONFIG_SPARSEMEM_STATIC is not set
 # CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_SPLIT_PTLOCK_CPUS=4096
 # CONFIG_RESOURCES_64BIT is not set
 CONFIG_ZONE_DMA_FLAG=1
@@ -238,7 +247,6 @@
 CONFIG_CMDLINE=""
 # CONFIG_XIP_KERNEL is not set
 # CONFIG_KEXEC is not set
-# CONFIG_ATAGS_PROC is not set
 
 #
 # Floating point emulation
@@ -311,8 +319,6 @@
 CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET6_TUNNEL is not set
 # CONFIG_NETWORK_SECMARK is not set
 # CONFIG_NETFILTER is not set
 # CONFIG_IP_DCCP is not set
@@ -335,6 +341,7 @@
 # Network testing
 #
 CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_CAN is not set
 # CONFIG_IRDA is not set
@@ -362,6 +369,8 @@
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
 CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
 # CONFIG_CONNECTOR is not set
 CONFIG_MTD=y
@@ -371,6 +380,7 @@
 # CONFIG_MTD_REDBOOT_PARTS is not set
 CONFIG_MTD_CMDLINE_PARTS=y
 # CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
 
 #
 # User Modules And Translation Layers
@@ -378,9 +388,8 @@
 CONFIG_MTD_CHAR=y
 CONFIG_MTD_BLKDEVS=y
 CONFIG_MTD_BLOCK=y
-CONFIG_FTL=y
-CONFIG_NFTL=y
-# CONFIG_NFTL_RW is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
 # CONFIG_INFTL is not set
 # CONFIG_RFD_FTL is not set
 # CONFIG_SSFDC is not set
@@ -405,12 +414,12 @@
 # CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
 CONFIG_MTD_CFI_I1=y
 CONFIG_MTD_CFI_I2=y
-CONFIG_MTD_CFI_I4=y
+# CONFIG_MTD_CFI_I4 is not set
 # CONFIG_MTD_CFI_I8 is not set
 # CONFIG_MTD_OTP is not set
 CONFIG_MTD_CFI_INTELEXT=y
 CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_CFI_STAA=y
+# CONFIG_MTD_CFI_STAA is not set
 CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
@@ -481,6 +490,9 @@
 # CONFIG_EEPROM_93CX6 is not set
 # CONFIG_SGI_IOC4 is not set
 # CONFIG_TIFM_CORE is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
 
 #
 # SCSI device support
@@ -542,6 +554,7 @@
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_MVSAS is not set
 # CONFIG_SCSI_STEX is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
@@ -556,7 +569,10 @@
 # CONFIG_SCSI_SRP is not set
 CONFIG_ATA=y
 # CONFIG_ATA_NONSTANDARD is not set
+CONFIG_SATA_PMP=y
 # CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
 # CONFIG_SATA_SVW is not set
 # CONFIG_ATA_PIIX is not set
 CONFIG_SATA_MV=y
@@ -566,7 +582,6 @@
 # CONFIG_SATA_PROMISE is not set
 # CONFIG_SATA_SX4 is not set
 # CONFIG_SATA_SIL is not set
-# CONFIG_SATA_SIL24 is not set
 # CONFIG_SATA_SIS is not set
 # CONFIG_SATA_ULI is not set
 # CONFIG_SATA_VIA is not set
@@ -611,6 +626,7 @@
 # CONFIG_PATA_VIA is not set
 # CONFIG_PATA_WINBOND is not set
 # CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_SCH is not set
 # CONFIG_MD is not set
 # CONFIG_FUSION is not set
 
@@ -652,7 +668,7 @@
 # CONFIG_B44 is not set
 # CONFIG_FORCEDETH is not set
 # CONFIG_EEPRO100 is not set
-CONFIG_E100=y
+# CONFIG_E100 is not set
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
@@ -668,9 +684,7 @@
 CONFIG_NETDEV_1000=y
 # CONFIG_ACENIC is not set
 # CONFIG_DL2K is not set
-CONFIG_E1000=y
-CONFIG_E1000_NAPI=y
-# CONFIG_E1000_DISABLE_PACKET_SPLIT is not set
+# CONFIG_E1000 is not set
 # CONFIG_E1000E is not set
 # CONFIG_E1000E_ENABLED is not set
 # CONFIG_IP1000 is not set
@@ -680,27 +694,15 @@
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
 # CONFIG_SIS190 is not set
-CONFIG_SKGE=y
-CONFIG_SKY2=y
-# CONFIG_SK98LIN is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
 # CONFIG_VIA_VELOCITY is not set
-CONFIG_TIGON3=y
+# CONFIG_TIGON3 is not set
 # CONFIG_BNX2 is not set
 CONFIG_MV643XX_ETH=y
 # CONFIG_QLA3XXX is not set
 # CONFIG_ATL1 is not set
-CONFIG_NETDEV_10000=y
-# CONFIG_CHELSIO_T1 is not set
-# CONFIG_CHELSIO_T3 is not set
-# CONFIG_IXGBE is not set
-# CONFIG_IXGB is not set
-# CONFIG_S2IO is not set
-# CONFIG_MYRI10GE is not set
-# CONFIG_NETXEN_NIC is not set
-# CONFIG_NIU is not set
-# CONFIG_MLX4_CORE is not set
-# CONFIG_TEHUTI is not set
-# CONFIG_BNX2X is not set
+# CONFIG_NETDEV_10000 is not set
 # CONFIG_TR is not set
 
 #
@@ -708,6 +710,7 @@
 #
 # CONFIG_WLAN_PRE80211 is not set
 # CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
 
 #
 # USB Network Adapters
@@ -738,12 +741,9 @@
 #
 # Userland interfaces
 #
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_MOUSEDEV is not set
 # CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_EVDEV is not set
+CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
@@ -765,10 +765,8 @@
 #
 # Character devices
 #
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
-# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
 # CONFIG_SERIAL_NONSTANDARD is not set
 # CONFIG_NOZOMI is not set
 
@@ -777,7 +775,7 @@
 #
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_PCI=y
+# CONFIG_SERIAL_8250_PCI is not set
 CONFIG_SERIAL_8250_NR_UARTS=4
 CONFIG_SERIAL_8250_RUNTIME_UARTS=2
 # CONFIG_SERIAL_8250_EXTENDED is not set
@@ -792,7 +790,7 @@
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=16
 # CONFIG_IPMI_HANDLER is not set
-CONFIG_HW_RANDOM=m
+# CONFIG_HW_RANDOM is not set
 # CONFIG_NVRAM is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -804,13 +802,6 @@
 CONFIG_I2C_CHARDEV=y
 
 #
-# I2C Algorithms
-#
-# CONFIG_I2C_ALGOBIT is not set
-# CONFIG_I2C_ALGOPCF is not set
-# CONFIG_I2C_ALGOPCA is not set
-
-#
 # I2C Hardware Bus support
 #
 # CONFIG_I2C_ALI1535 is not set
@@ -837,6 +828,7 @@
 # CONFIG_I2C_VIA is not set
 # CONFIG_I2C_VIAPRO is not set
 # CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
 CONFIG_I2C_MV64XXX=y
 
 #
@@ -847,19 +839,13 @@
 # CONFIG_SENSORS_PCF8574 is not set
 # CONFIG_PCF8575 is not set
 # CONFIG_SENSORS_PCF8591 is not set
-# CONFIG_TPS65010 is not set
 # CONFIG_SENSORS_MAX6875 is not set
 # CONFIG_SENSORS_TSL2550 is not set
 # CONFIG_I2C_DEBUG_CORE is not set
 # CONFIG_I2C_DEBUG_ALGO is not set
 # CONFIG_I2C_DEBUG_BUS is not set
 # CONFIG_I2C_DEBUG_CHIP is not set
-
-#
-# SPI support
-#
 # CONFIG_SPI is not set
-# CONFIG_SPI_MASTER is not set
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 CONFIG_HWMON=y
@@ -872,6 +858,7 @@
 # CONFIG_SENSORS_ADM1031 is not set
 # CONFIG_SENSORS_ADM9240 is not set
 # CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
 # CONFIG_SENSORS_ATXP1 is not set
 # CONFIG_SENSORS_DS1621 is not set
 # CONFIG_SENSORS_I5K_AMB is not set
@@ -901,6 +888,7 @@
 # CONFIG_SENSORS_SMSC47M1 is not set
 # CONFIG_SENSORS_SMSC47M192 is not set
 # CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
 # CONFIG_SENSORS_THMC50 is not set
 # CONFIG_SENSORS_VIA686A is not set
 # CONFIG_SENSORS_VT1211 is not set
@@ -910,6 +898,7 @@
 # CONFIG_SENSORS_W83792D is not set
 # CONFIG_SENSORS_W83793 is not set
 # CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
 # CONFIG_SENSORS_W83627HF is not set
 # CONFIG_SENSORS_W83627EHF is not set
 # CONFIG_HWMON_DEBUG_CHIP is not set
@@ -925,14 +914,24 @@
 # Multifunction device drivers
 #
 # CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_PASIC3 is not set
 
 #
 # Multimedia devices
 #
+
+#
+# Multimedia core support
+#
 # CONFIG_VIDEO_DEV is not set
 # CONFIG_DVB_CORE is not set
-CONFIG_DAB=y
-# CONFIG_USB_DABUSB is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
 
 #
 # Graphics support
@@ -949,12 +948,6 @@
 # CONFIG_DISPLAY_SUPPORT is not set
 
 #
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-
-#
 # Sound
 #
 # CONFIG_SOUND is not set
@@ -985,14 +978,18 @@
 CONFIG_USB_DEVICE_CLASS=y
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
 
 #
 # USB Host Controller Drivers
 #
+# CONFIG_USB_C67X00_HCD is not set
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_ROOT_HUB_TT=y
 CONFIG_USB_EHCI_TT_NEWSCHED=y
 # CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
 # CONFIG_USB_OHCI_HCD is not set
 # CONFIG_USB_UHCI_HCD is not set
 # CONFIG_USB_SL811_HCD is not set
@@ -1003,6 +1000,7 @@
 #
 # CONFIG_USB_ACM is not set
 CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
 
 #
 # NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
@@ -1022,7 +1020,9 @@
 CONFIG_USB_STORAGE_SDDR55=y
 CONFIG_USB_STORAGE_JUMPSHOT=y
 # CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
 # CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
 # CONFIG_USB_LIBUSUAL is not set
 
 #
@@ -1060,6 +1060,7 @@
 # CONFIG_USB_TRANCEVIBRATOR is not set
 # CONFIG_USB_IOWARRIOR is not set
 # CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
 # CONFIG_USB_GADGET is not set
 # CONFIG_MMC is not set
 CONFIG_NEW_LEDS=y
@@ -1076,6 +1077,7 @@
 CONFIG_LEDS_TRIGGERS=y
 CONFIG_LEDS_TRIGGER_TIMER=y
 CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_HCTOSYS=y
@@ -1105,6 +1107,7 @@
 # CONFIG_RTC_DRV_PCF8583 is not set
 CONFIG_RTC_DRV_M41T80=y
 # CONFIG_RTC_DRV_M41T80_WDT is not set
+# CONFIG_RTC_DRV_S35390A is not set
 
 #
 # SPI RTC drivers
@@ -1125,6 +1128,7 @@
 #
 # on-CPU RTC drivers
 #
+# CONFIG_UIO is not set
 
 #
 # File systems
@@ -1140,14 +1144,11 @@
 # CONFIG_JFS_FS is not set
 # CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
-# CONFIG_GFS2_FS is not set
 # CONFIG_OCFS2_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
+CONFIG_DNOTIFY=y
 CONFIG_INOTIFY=y
 CONFIG_INOTIFY_USER=y
 # CONFIG_QUOTA is not set
-CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_FUSE_FS is not set
@@ -1155,8 +1156,8 @@
 #
 # CD-ROM/DVD Filesystems
 #
-CONFIG_ISO9660_FS=y
-# CONFIG_JOLIET is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
 # CONFIG_ZISOFS is not set
 CONFIG_UDF_FS=m
 CONFIG_UDF_NLS=y
@@ -1205,8 +1206,10 @@
 # CONFIG_JFFS2_RUBIN is not set
 CONFIG_CRAMFS=y
 # CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
@@ -1214,7 +1217,6 @@
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
-# CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
@@ -1241,14 +1243,13 @@
 # CONFIG_MAC_PARTITION is not set
 CONFIG_MSDOS_PARTITION=y
 CONFIG_BSD_DISKLABEL=y
-CONFIG_MINIX_SUBPARTITION=y
-CONFIG_SOLARIS_X86_PARTITION=y
-CONFIG_UNIXWARE_DISKLABEL=y
-CONFIG_LDM_PARTITION=y
-CONFIG_LDM_DEBUG=y
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
 # CONFIG_SGI_PARTITION is not set
 # CONFIG_ULTRIX_PARTITION is not set
-CONFIG_SUN_PARTITION=y
+# CONFIG_SUN_PARTITION is not set
 # CONFIG_KARMA_PARTITION is not set
 # CONFIG_EFI_PARTITION is not set
 # CONFIG_SYSV68_PARTITION is not set
@@ -1300,15 +1301,48 @@
 # CONFIG_PRINTK_TIME is not set
 CONFIG_ENABLE_WARN_DEPRECATED=y
 CONFIG_ENABLE_MUST_CHECK=y
-# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
 # CONFIG_UNUSED_SYMBOLS is not set
 # CONFIG_DEBUG_FS is not set
 # CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_KERNEL is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
 # CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
 CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
 # CONFIG_SAMPLES is not set
 CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
 
 #
 # Security options
@@ -1317,50 +1351,79 @@
 # CONFIG_SECURITY is not set
 # CONFIG_SECURITY_FILE_CAPABILITIES is not set
 CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
 CONFIG_CRYPTO_ALGAPI=m
 CONFIG_CRYPTO_BLKCIPHER=m
-# CONFIG_CRYPTO_SEQIV is not set
 CONFIG_CRYPTO_MANAGER=m
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
 # CONFIG_CRYPTO_HMAC is not set
 # CONFIG_CRYPTO_XCBC is not set
-# CONFIG_CRYPTO_NULL is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
 # CONFIG_CRYPTO_MD4 is not set
 # CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
 # CONFIG_CRYPTO_SHA1 is not set
 # CONFIG_CRYPTO_SHA256 is not set
 # CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_WP512 is not set
 # CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_GF128MUL is not set
-CONFIG_CRYPTO_ECB=m
-CONFIG_CRYPTO_CBC=m
-CONFIG_CRYPTO_PCBC=m
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_XTS is not set
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_TWOFISH is not set
-# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
 # CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
 # CONFIG_CRYPTO_CAST5 is not set
 # CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
 # CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_SEED is not set
 # CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
 # CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_TEST is not set
-# CONFIG_CRYPTO_AUTHENC is not set
 # CONFIG_CRYPTO_LZO is not set
 CONFIG_CRYPTO_HW=y
 # CONFIG_CRYPTO_DEV_HIFN_795X is not set
@@ -1369,12 +1432,14 @@
 # Library routines
 #
 CONFIG_BITREVERSE=y
-CONFIG_CRC_CCITT=y
-CONFIG_CRC16=y
-# CONFIG_CRC_ITU_T is not set
+# CONFIG_GENERIC_FIND_FIRST_BIT is not set
+# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC_ITU_T=m
 CONFIG_CRC32=y
 # CONFIG_CRC7 is not set
-CONFIG_LIBCRC32C=y
+# CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
 CONFIG_PLIST=y
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -36,6 +36,7 @@
 #ifdef CONFIG_STACKTRACE
 struct stack_trace_data {
 	struct stack_trace *trace;
+	unsigned int no_sched_functions;
 	unsigned int skip;
 };
 
@@ -43,27 +44,52 @@
 {
 	struct stack_trace_data *data = d;
 	struct stack_trace *trace = data->trace;
+	unsigned long addr = frame->lr;
 
+	if (data->no_sched_functions && in_sched_functions(addr))
+		return 0;
 	if (data->skip) {
 		data->skip--;
 		return 0;
 	}
 
-	trace->entries[trace->nr_entries++] = frame->lr;
+	trace->entries[trace->nr_entries++] = addr;
 
 	return trace->nr_entries >= trace->max_entries;
 }
 
-void save_stack_trace(struct stack_trace *trace)
+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
 	struct stack_trace_data data;
 	unsigned long fp, base;
 
 	data.trace = trace;
 	data.skip = trace->skip;
-	base = (unsigned long)task_stack_page(current);
-	asm("mov %0, fp" : "=r" (fp));
+	base = (unsigned long)task_stack_page(tsk);
+
+	if (tsk != current) {
+#ifdef CONFIG_SMP
+		/*
+		 * What guarantees do we have here that 'tsk'
+		 * is not running on another CPU?
+		 */
+		BUG();
+#else
+		data.no_sched_functions = 1;
+		fp = thread_saved_fp(tsk);
+#endif
+	} else {
+		data.no_sched_functions = 0;
+		asm("mov %0, fp" : "=r" (fp));
+	}
 
 	walk_stackframe(fp, base, base + THREAD_SIZE, save_trace, &data);
+	if (trace->nr_entries < trace->max_entries)
+		trace->entries[trace->nr_entries++] = ULONG_MAX;
+}
+
+void save_stack_trace(struct stack_trace *trace)
+{
+	save_stack_trace_tsk(current, trace);
 }
 #endif
--- a/arch/arm/lib/copy_template.S
+++ b/arch/arm/lib/copy_template.S
@@ -13,14 +13,6 @@
  */
 
 /*
- * This can be used to enable code to cacheline align the source pointer.
- * Experiments on tested architectures (StrongARM and XScale) didn't show
- * this a worthwhile thing to do.  That might be different in the future.
- */
-//#define CALGN(code...)	code
-#define CALGN(code...)
-
-/*
  * Theory of operation
  * -------------------
  *
@@ -82,7 +74,7 @@
 		stmfd	sp!, {r5 - r8}
 		blt	5f
 
-	CALGN(	ands	ip, r1, #31		)
+	CALGN(	ands	ip, r0, #31		)
 	CALGN(	rsb	r3, ip, #32		)
 	CALGN(	sbcnes	r4, r3, r2		)  @ C is always set here
 	CALGN(	bcs	2f			)
@@ -168,7 +160,7 @@
 		subs	r2, r2, #28
 		blt	14f
 
-	CALGN(	ands	ip, r1, #31		)
+	CALGN(	ands	ip, r0, #31		)
 	CALGN(	rsb	ip, ip, #32		)
 	CALGN(	sbcnes	r4, ip, r2		)  @ C is always set here
 	CALGN(	subcc	r2, r2, ip		)
--- a/arch/arm/lib/memmove.S
+++ b/arch/arm/lib/memmove.S
@@ -13,14 +13,6 @@
 #include <linux/linkage.h>
 #include <asm/assembler.h>
 
-/*
- * This can be used to enable code to cacheline align the source pointer.
- * Experiments on tested architectures (StrongARM and XScale) didn't show
- * this a worthwhile thing to do.  That might be different in the future.
- */
-//#define CALGN(code...)        code
-#define CALGN(code...)
-
 		.text
 
 /*
@@ -55,11 +47,12 @@
 		stmfd	sp!, {r5 - r8}
 		blt	5f
 
-	CALGN(	ands	ip, r1, #31		)
+	CALGN(	ands	ip, r0, #31		)
 	CALGN(	sbcnes	r4, ip, r2		)  @ C is always set here
 	CALGN(	bcs	2f			)
 	CALGN(	adr	r4, 6f			)
 	CALGN(	subs	r2, r2, ip		)  @ C is set here
+	CALGN(	rsb	ip, ip, #32		)
 	CALGN(	add	pc, r4, ip		)
 
 	PLD(	pld	[r1, #-4]		)
@@ -138,8 +131,7 @@
 		subs	r2, r2, #28
 		blt	14f
 
-	CALGN(	ands	ip, r1, #31		)
-	CALGN(	rsb	ip, ip, #32		)
+	CALGN(	ands	ip, r0, #31		)
 	CALGN(	sbcnes	r4, ip, r2		)  @ C is always set here
 	CALGN(	subcc	r2, r2, ip		)
 	CALGN(	bcc	15f			)
--- a/arch/arm/lib/memset.S
+++ b/arch/arm/lib/memset.S
@@ -39,6 +39,9 @@
 	mov	r3, r1
 	cmp	r2, #16
 	blt	4f
+
+#if ! CALGN(1)+0
+
 /*
  * We need an extra register for this loop - save the return address and
  * use the LR
@@ -64,6 +67,49 @@
 	stmneia	r0!, {r1, r3, ip, lr}
 	ldr	lr, [sp], #4
 
+#else
+
+/*
+ * This version aligns the destination pointer in order to write
+ * whole cache lines at once.
+ */
+
+	stmfd	sp!, {r4-r7, lr}
+	mov	r4, r1
+	mov	r5, r1
+	mov	r6, r1
+	mov	r7, r1
+	mov	ip, r1
+	mov	lr, r1
+
+	cmp	r2, #96
+	tstgt	r0, #31
+	ble	3f
+
+	and	ip, r0, #31
+	rsb	ip, ip, #32
+	sub	r2, r2, ip
+	movs	ip, ip, lsl #(32 - 4)
+	stmcsia	r0!, {r4, r5, r6, r7}
+	stmmiia	r0!, {r4, r5}
+	tst	ip, #(1 << 30)
+	mov	ip, r1
+	strne	r1, [r0], #4
+
+3:	subs	r2, r2, #64
+	stmgeia	r0!, {r1, r3-r7, ip, lr}
+	stmgeia	r0!, {r1, r3-r7, ip, lr}
+	bgt	3b
+	ldmeqfd	sp!, {r4-r7, pc}
+
+	tst	r2, #32
+	stmneia	r0!, {r1, r3-r7, ip, lr}
+	tst	r2, #16
+	stmneia	r0!, {r4-r7}
+	ldmfd	sp!, {r4-r7, lr}
+
+#endif
+
 4:	tst	r2, #8
 	stmneia	r0!, {r1, r3}
 	tst	r2, #4
--- a/arch/arm/lib/memzero.S
+++ b/arch/arm/lib/memzero.S
@@ -39,6 +39,9 @@
  */
 	cmp	r1, #16			@ 1 we can skip this chunk if we
 	blt	4f			@ 1 have < 16 bytes
+
+#if ! CALGN(1)+0
+
 /*
  * We need an extra register for this loop - save the return address and
  * use the LR
@@ -64,6 +67,47 @@
 	stmneia	r0!, {r2, r3, ip, lr}	@ 4
 	ldr	lr, [sp], #4		@ 1
 
+#else
+
+/*
+ * This version aligns the destination pointer in order to write
+ * whole cache lines at once.
+ */
+
+	stmfd	sp!, {r4-r7, lr}
+	mov	r4, r2
+	mov	r5, r2
+	mov	r6, r2
+	mov	r7, r2
+	mov	ip, r2
+	mov	lr, r2
+
+	cmp	r1, #96
+	andgts	ip, r0, #31
+	ble	3f
+
+	rsb	ip, ip, #32
+	sub	r1, r1, ip
+	movs	ip, ip, lsl #(32 - 4)
+	stmcsia	r0!, {r4, r5, r6, r7}
+	stmmiia	r0!, {r4, r5}
+	movs	ip, ip, lsl #2
+	strcs	r2, [r0], #4
+
+3:	subs	r1, r1, #64
+	stmgeia	r0!, {r2-r7, ip, lr}
+	stmgeia	r0!, {r2-r7, ip, lr}
+	bgt	3b
+	ldmeqfd	sp!, {r4-r7, pc}
+
+	tst	r1, #32
+	stmneia	r0!, {r2-r7, ip, lr}
+	tst	r1, #16
+	stmneia	r0!, {r4-r7}
+	ldmfd	sp!, {r4-r7, lr}
+
+#endif
+
 4:	tst	r1, #8			@ 1 8 bytes or more?
 	stmneia	r0!, {r2, r3}		@ 2
 	tst	r1, #4			@ 1 4 bytes or more?
--- /dev/null
+++ b/arch/arm/mach-kirkwood/Kconfig
@@ -0,0 +1,25 @@
+if ARCH_KIRKWOOD
+
+menu "Marvell Kirkwood Implementations"
+
+config MACH_DB88F6281_BP
+	bool "Marvell DB-88F6281-BP Development Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell DB-88F6281-BP Development Board.
+
+config MACH_RD88F6192_NAS
+	bool "Marvell RD-88F6192-NAS Reference Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell RD-88F6192-NAS Reference Board.
+
+config MACH_RD88F6281
+	bool "Marvell RD-88F6281 Reference Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell RD-88F6281 Reference Board.
+
+endmenu
+
+endif
--- /dev/null
+++ b/arch/arm/mach-kirkwood/Makefile
@@ -0,0 +1,5 @@
+obj-y				+= common.o addr-map.o irq.o pcie.o
+
+obj-$(CONFIG_MACH_DB88F6281_BP)		+= db88f6281-bp-setup.o
+obj-$(CONFIG_MACH_RD88F6192_NAS)	+= rd88f6192-nas-setup.o
+obj-$(CONFIG_MACH_RD88F6192_NAS)	+= rd88f6281-setup.o
--- /dev/null
+++ b/arch/arm/mach-kirkwood/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
--- /dev/null
+++ b/arch/arm/mach-kirkwood/addr-map.c
@@ -0,0 +1,139 @@
+/*
+ * arch/arm/mach-kirkwood/addr-map.c
+ *
+ * Address map functions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mbus.h>
+#include <linux/io.h>
+#include <asm/hardware.h>
+#include "common.h"
+
+/*
+ * Generic Address Decode Windows bit settings
+ */
+#define TARGET_DDR		0
+#define TARGET_DEV_BUS		1
+#define TARGET_PCIE		4
+#define ATTR_DEV_SPI_ROM	0x1e
+#define ATTR_DEV_BOOT		0x1d
+#define ATTR_DEV_NAND		0x2f
+#define ATTR_DEV_CS3		0x37
+#define ATTR_DEV_CS2		0x3b
+#define ATTR_DEV_CS1		0x3d
+#define ATTR_DEV_CS0		0x3e
+#define ATTR_PCIE_IO		0xe0
+#define ATTR_PCIE_MEM		0xe8
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define DDR_BASE_CS_OFF(n)	(0x0000 + ((n) << 3))
+#define DDR_SIZE_CS_OFF(n)	(0x0004 + ((n) << 3))
+
+/*
+ * CPU Address Decode Windows registers
+ */
+#define WIN_OFF(n)		(BRIDGE_VIRT_BASE + 0x0000 + ((n) << 4))
+#define WIN_CTRL_OFF		0x0000
+#define WIN_BASE_OFF		0x0004
+#define WIN_REMAP_LO_OFF	0x0008
+#define WIN_REMAP_HI_OFF	0x000c
+
+
+struct mbus_dram_target_info kirkwood_mbus_dram_info;
+
+static int __init cpu_win_can_remap(int win)
+{
+	if (win < 4)
+		return 1;
+
+	return 0;
+}
+
+static void __init setup_cpu_win(int win, u32 base, u32 size,
+				 u8 target, u8 attr, int remap)
+{
+	void __iomem *addr = (void __iomem *)WIN_OFF(win);
+	u32 ctrl;
+
+	base &= 0xffff0000;
+	ctrl = ((size - 1) & 0xffff0000) | (attr << 8) | (target << 4) | 1;
+
+	writel(base, addr + WIN_BASE_OFF);
+	writel(ctrl, addr + WIN_CTRL_OFF);
+	if (cpu_win_can_remap(win)) {
+		if (remap < 0)
+			remap = base;
+
+		writel(remap & 0xffff0000, addr + WIN_REMAP_LO_OFF);
+		writel(0, addr + WIN_REMAP_HI_OFF);
+	}
+}
+
+void __init kirkwood_setup_cpu_mbus(void)
+{
+	void __iomem *addr;
+	int i;
+	int cs;
+
+	/*
+	 * First, disable and clear windows.
+	 */
+	for (i = 0; i < 8; i++) {
+		addr = (void __iomem *)WIN_OFF(i);
+
+		writel(0, addr + WIN_BASE_OFF);
+		writel(0, addr + WIN_CTRL_OFF);
+		if (cpu_win_can_remap(i)) {
+			writel(0, addr + WIN_REMAP_LO_OFF);
+			writel(0, addr + WIN_REMAP_HI_OFF);
+		}
+	}
+
+	/*
+	 * Setup windows for PCIe IO+MEM space.
+	 */
+	setup_cpu_win(0, KIRKWOOD_PCIE_IO_PHYS_BASE, KIRKWOOD_PCIE_IO_SIZE,
+		      TARGET_PCIE, ATTR_PCIE_IO, KIRKWOOD_PCIE_IO_BUS_BASE);
+	setup_cpu_win(1, KIRKWOOD_PCIE_MEM_PHYS_BASE, KIRKWOOD_PCIE_MEM_SIZE,
+		      TARGET_PCIE, ATTR_PCIE_MEM, -1);
+
+	/*
+	 * Setup window for NAND controller.
+	 */
+	setup_cpu_win(2, KIRKWOOD_NAND_MEM_PHYS_BASE, KIRKWOOD_NAND_MEM_SIZE,
+		      TARGET_DEV_BUS, ATTR_DEV_NAND, -1);
+
+	/*
+	 * Setup MBUS dram target info.
+	 */
+	kirkwood_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+
+	addr = (void __iomem *)DDR_WINDOW_CPU_BASE;
+
+	for (i = 0, cs = 0; i < 4; i++) {
+		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
+		u32 size = readl(addr + DDR_SIZE_CS_OFF(i));
+
+		/*
+		 * Chip select enabled?
+		 */
+		if (size & 1) {
+			struct mbus_dram_window *w;
+
+			w = &kirkwood_mbus_dram_info.cs[cs++];
+			w->cs_index = i;
+			w->mbus_attr = 0xf & ~(1 << i);
+			w->base = base & 0xffff0000;
+			w->size = (size | 0x0000ffff) + 1;
+		}
+	}
+	kirkwood_mbus_dram_info.num_cs = cs;
+}
--- /dev/null
+++ b/arch/arm/mach-kirkwood/common.c
@@ -0,0 +1,326 @@
+/*
+ * arch/arm/mach-kirkwood/common.c
+ *
+ * Core functions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/mbus.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/ata_platform.h>
+#include <asm/page.h>
+#include <asm/timex.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/arch/kirkwood.h>
+#include <asm/plat-orion/cache-feroceon-l2.h>
+#include <asm/plat-orion/ehci-orion.h>
+#include <asm/plat-orion/orion_nand.h>
+#include <asm/plat-orion/time.h>
+#include "common.h"
+
+/*****************************************************************************
+ * I/O Address Mapping
+ ****************************************************************************/
+static struct map_desc kirkwood_io_desc[] __initdata = {
+	{
+		.virtual	= KIRKWOOD_PCIE_IO_VIRT_BASE,
+		.pfn		= __phys_to_pfn(KIRKWOOD_PCIE_IO_PHYS_BASE),
+		.length		= KIRKWOOD_PCIE_IO_SIZE,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= KIRKWOOD_REGS_VIRT_BASE,
+		.pfn		= __phys_to_pfn(KIRKWOOD_REGS_PHYS_BASE),
+		.length		= KIRKWOOD_REGS_SIZE,
+		.type		= MT_DEVICE,
+	},
+};
+
+void __init kirkwood_map_io(void)
+{
+	iotable_init(kirkwood_io_desc, ARRAY_SIZE(kirkwood_io_desc));
+}
+
+
+/*****************************************************************************
+ * EHCI
+ ****************************************************************************/
+static struct orion_ehci_data kirkwood_ehci_data = {
+	.dram		= &kirkwood_mbus_dram_info,
+};
+
+static u64 ehci_dmamask = 0xffffffffUL;
+
+
+/*****************************************************************************
+ * EHCI0
+ ****************************************************************************/
+static struct resource kirkwood_ehci_resources[] = {
+	{
+		.start	= USB_PHYS_BASE,
+		.end	= USB_PHYS_BASE + 0x0fff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_KIRKWOOD_USB,
+		.end	= IRQ_KIRKWOOD_USB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device kirkwood_ehci = {
+	.name		= "orion-ehci",
+	.id		= 0,
+	.dev		= {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &kirkwood_ehci_data,
+	},
+	.resource	= kirkwood_ehci_resources,
+	.num_resources	= ARRAY_SIZE(kirkwood_ehci_resources),
+};
+
+void __init kirkwood_ehci_init(void)
+{
+	platform_device_register(&kirkwood_ehci);
+}
+
+
+/*****************************************************************************
+ * GE00
+ ****************************************************************************/
+struct mv643xx_eth_shared_platform_data kirkwood_ge00_shared_data = {
+	.t_clk		= KIRKWOOD_TCLK,
+	.dram		= &kirkwood_mbus_dram_info,
+};
+
+static struct resource kirkwood_ge00_shared_resources[] = {
+	{
+		.name	= "ge00 base",
+		.start	= GE00_PHYS_BASE + 0x2000,
+		.end	= GE00_PHYS_BASE + 0x3fff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device kirkwood_ge00_shared = {
+	.name		= MV643XX_ETH_SHARED_NAME,
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &kirkwood_ge00_shared_data,
+	},
+	.num_resources	= 1,
+	.resource	= kirkwood_ge00_shared_resources,
+};
+
+static struct resource kirkwood_ge00_resources[] = {
+	{
+		.name	= "ge00 irq",
+		.start	= IRQ_KIRKWOOD_GE00_SUM,
+		.end	= IRQ_KIRKWOOD_GE00_SUM,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device kirkwood_ge00 = {
+	.name		= MV643XX_ETH_NAME,
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= kirkwood_ge00_resources,
+};
+
+void __init kirkwood_ge00_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	eth_data->shared = &kirkwood_ge00_shared;
+	kirkwood_ge00.dev.platform_data = eth_data;
+
+	platform_device_register(&kirkwood_ge00_shared);
+	platform_device_register(&kirkwood_ge00);
+}
+
+
+/*****************************************************************************
+ * SoC RTC
+ ****************************************************************************/
+static struct resource kirkwood_rtc_resource = {
+	.start	= RTC_PHYS_BASE,
+	.end	= RTC_PHYS_BASE + SZ_16 - 1,
+	.flags	= IORESOURCE_MEM,
+};
+
+void __init kirkwood_rtc_init(void)
+{
+	platform_device_register_simple("rtc-mv", -1, &kirkwood_rtc_resource, 1);
+}
+
+
+/*****************************************************************************
+ * SATA
+ ****************************************************************************/
+static struct resource kirkwood_sata_resources[] = {
+	{
+		.name	= "sata base",
+		.start	= SATA_PHYS_BASE,
+		.end	= SATA_PHYS_BASE + 0x5000 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "sata irq",
+		.start	= IRQ_KIRKWOOD_SATA,
+		.end	= IRQ_KIRKWOOD_SATA,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device kirkwood_sata = {
+	.name		= "sata_mv",
+	.id		= 0,
+	.dev		= {
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(kirkwood_sata_resources),
+	.resource	= kirkwood_sata_resources,
+};
+
+void __init kirkwood_sata_init(struct mv_sata_platform_data *sata_data)
+{
+	sata_data->dram = &kirkwood_mbus_dram_info;
+	kirkwood_sata.dev.platform_data = sata_data;
+	platform_device_register(&kirkwood_sata);
+}
+
+
+/*****************************************************************************
+ * UART0
+ ****************************************************************************/
+static struct plat_serial8250_port kirkwood_uart0_data[] = {
+	{
+		.mapbase	= UART0_PHYS_BASE,
+		.membase	= (char *)UART0_VIRT_BASE,
+		.irq		= IRQ_KIRKWOOD_UART_0,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= KIRKWOOD_TCLK,
+	}, {
+	},
+};
+
+static struct resource kirkwood_uart0_resources[] = {
+	{
+		.start		= UART0_PHYS_BASE,
+		.end		= UART0_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_KIRKWOOD_UART_0,
+		.end		= IRQ_KIRKWOOD_UART_0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device kirkwood_uart0 = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= kirkwood_uart0_data,
+	},
+	.resource		= kirkwood_uart0_resources,
+	.num_resources		= ARRAY_SIZE(kirkwood_uart0_resources),
+};
+
+void __init kirkwood_uart0_init(void)
+{
+	platform_device_register(&kirkwood_uart0);
+}
+
+
+/*****************************************************************************
+ * UART1
+ ****************************************************************************/
+static struct plat_serial8250_port kirkwood_uart1_data[] = {
+	{
+		.mapbase	= UART1_PHYS_BASE,
+		.membase	= (char *)UART1_VIRT_BASE,
+		.irq		= IRQ_KIRKWOOD_UART_1,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= KIRKWOOD_TCLK,
+	}, {
+	},
+};
+
+static struct resource kirkwood_uart1_resources[] = {
+	{
+		.start		= UART1_PHYS_BASE,
+		.end		= UART1_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_KIRKWOOD_UART_1,
+		.end		= IRQ_KIRKWOOD_UART_1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device kirkwood_uart1 = {
+	.name			= "serial8250",
+	.id			= 1,
+	.dev			= {
+		.platform_data	= kirkwood_uart1_data,
+	},
+	.resource		= kirkwood_uart1_resources,
+	.num_resources		= ARRAY_SIZE(kirkwood_uart1_resources),
+};
+
+void __init kirkwood_uart1_init(void)
+{
+	platform_device_register(&kirkwood_uart1);
+}
+
+
+/*****************************************************************************
+ * Time handling
+ ****************************************************************************/
+static void kirkwood_timer_init(void)
+{
+	orion_time_init(IRQ_KIRKWOOD_BRIDGE, KIRKWOOD_TCLK);
+}
+
+struct sys_timer kirkwood_timer = {
+	.init = kirkwood_timer_init,
+};
+
+
+/*****************************************************************************
+ * General
+ ****************************************************************************/
+static char * __init kirkwood_id(void)
+{
+	switch (readl(DEVICE_ID) & 0x3) {
+	case 0:
+		return "88F6180";
+	case 1:
+		return "88F6192";
+	case 2:
+		return "88F6281";
+	}
+
+	return "unknown 88F6000 variant";
+}
+
+void __init kirkwood_init(void)
+{
+	printk(KERN_INFO "Kirkwood: %s, TCLK=%d.\n",
+		kirkwood_id(), KIRKWOOD_TCLK);
+
+	kirkwood_setup_cpu_mbus();
+
+#ifdef CONFIG_CACHE_FEROCEON_L2
+	feroceon_l2_init(1);
+#endif
+}
--- /dev/null
+++ b/arch/arm/mach-kirkwood/common.h
@@ -0,0 +1,42 @@
+/*
+ * arch/arm/mach-kirkwood/common.h
+ *
+ * Core functions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ARCH_KIRKWOOD_COMMON_H
+#define __ARCH_KIRKWOOD_COMMON_H
+
+struct mv643xx_eth_platform_data;
+struct mv_sata_platform_data;
+
+/*
+ * Basic Kirkwood init functions used early by machine-setup.
+ */
+void kirkwood_map_io(void);
+void kirkwood_init(void);
+void kirkwood_init_irq(void);
+
+extern struct mbus_dram_target_info kirkwood_mbus_dram_info;
+void kirkwood_setup_cpu_mbus(void);
+void kirkwood_setup_pcie_io_win(int window, u32 base, u32 size,
+				int maj, int min);
+void kirkwood_setup_pcie_mem_win(int window, u32 base, u32 size,
+				 int maj, int min);
+
+void kirkwood_ehci_init(void);
+void kirkwood_ge00_init(struct mv643xx_eth_platform_data *eth_data);
+void kirkwood_pcie_init(void);
+void kirkwood_rtc_init(void);
+void kirkwood_sata_init(struct mv_sata_platform_data *sata_data);
+void kirkwood_uart0_init(void);
+void kirkwood_uart1_init(void);
+
+extern struct sys_timer kirkwood_timer;
+
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-kirkwood/db88f6281-bp-setup.c
@@ -0,0 +1,68 @@
+/*
+ * arch/arm/mach-kirkwood/db88f6281-bp-setup.c
+ *
+ * Marvell DB-88F6281-BP Development Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/nand.h>
+#include <linux/timer.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/kirkwood.h>
+#include "common.h"
+
+static struct mv643xx_eth_platform_data db88f6281_ge00_data = {
+	.phy_addr	= 8,
+};
+
+static struct mv_sata_platform_data db88f6281_sata_data = {
+	.n_ports	= 2,
+};
+
+static void __init db88f6281_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&db88f6281_ge00_data);
+	kirkwood_rtc_init();
+	kirkwood_sata_init(&db88f6281_sata_data);
+	kirkwood_uart0_init();
+	kirkwood_uart1_init();
+}
+
+static int __init db88f6281_pci_init(void)
+{
+	if (machine_is_db88f6281_bp())
+		kirkwood_pcie_init();
+
+	return 0;
+}
+subsys_initcall(db88f6281_pci_init);
+
+MACHINE_START(DB88F6281_BP, "Marvell DB-88F6281-BP Development Board")
+	/* Maintainer: Saeed Bishara <saeed@marvell.com> */
+	.phys_io	= KIRKWOOD_REGS_PHYS_BASE,
+	.io_pg_offst	= ((KIRKWOOD_REGS_VIRT_BASE) >> 18) & 0xfffc,
+	.boot_params	= 0x00000100,
+	.init_machine	= db88f6281_init,
+	.map_io		= kirkwood_map_io,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-kirkwood/irq.c
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/mach-kirkwood/irq.c
+ *
+ * Kirkwood IRQ handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <asm/plat-orion/irq.h>
+#include "common.h"
+
+void __init kirkwood_init_irq(void)
+{
+	orion_irq_init(0, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF));
+	orion_irq_init(32, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF));
+}
--- /dev/null
+++ b/arch/arm/mach-kirkwood/pcie.c
@@ -0,0 +1,180 @@
+/*
+ * arch/arm/mach-kirkwood/pcie.c
+ *
+ * PCIe functions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mbus.h>
+#include <asm/mach/pci.h>
+#include <asm/plat-orion/pcie.h>
+#include "common.h"
+
+
+#define PCIE_BASE	((void __iomem *)PCIE_VIRT_BASE)
+
+static int pcie_valid_config(int bus, int dev)
+{
+	/*
+	 * Don't go out when trying to access --
+	 * 1. nonexisting device on local bus
+	 * 2. where there's no device connected (no link)
+	 */
+	if (bus == 0 && dev == 0)
+		return 1;
+
+	if (!orion_pcie_link_up(PCIE_BASE))
+		return 0;
+
+	if (bus == 0 && dev != 1)
+		return 0;
+
+	return 1;
+}
+
+
+/*
+ * PCIe config cycles are done by programming the PCIE_CONF_ADDR register
+ * and then reading the PCIE_CONF_DATA register. Need to make sure these
+ * transactions are atomic.
+ */
+static DEFINE_SPINLOCK(kirkwood_pcie_lock);
+
+static int pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+			int size, u32 *val)
+{
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(bus->number, PCI_SLOT(devfn)) == 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	spin_lock_irqsave(&kirkwood_pcie_lock, flags);
+	ret = orion_pcie_rd_conf(PCIE_BASE, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&kirkwood_pcie_lock, flags);
+
+	return ret;
+}
+
+static int pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+			int where, int size, u32 val)
+{
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(bus->number, PCI_SLOT(devfn)) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&kirkwood_pcie_lock, flags);
+	ret = orion_pcie_wr_conf(PCIE_BASE, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&kirkwood_pcie_lock, flags);
+
+	return ret;
+}
+
+static struct pci_ops pcie_ops = {
+	.read = pcie_rd_conf,
+	.write = pcie_wr_conf,
+};
+
+
+static int kirkwood_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+
+	/*
+	 * Generic PCIe unit setup.
+	 */
+	orion_pcie_setup(PCIE_BASE, &kirkwood_mbus_dram_info);
+
+	/*
+	 * Request resources.
+	 */
+	res = kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+		panic("pcie_setup unable to alloc resources");
+
+	/*
+	 * IORESOURCE_IO
+	 */
+	res[0].name = "PCIe I/O Space";
+	res[0].flags = IORESOURCE_IO;
+	res[0].start = KIRKWOOD_PCIE_IO_PHYS_BASE;
+	res[0].end = res[0].start + KIRKWOOD_PCIE_IO_SIZE - 1;
+	if (request_resource(&ioport_resource, &res[0]))
+		panic("Request PCIe IO resource failed\n");
+	sys->resource[0] = &res[0];
+
+	/*
+	 * IORESOURCE_MEM
+	 */
+	res[1].name = "PCIe Memory Space";
+	res[1].flags = IORESOURCE_MEM;
+	res[1].start = KIRKWOOD_PCIE_MEM_PHYS_BASE;
+	res[1].end = res[1].start + KIRKWOOD_PCIE_MEM_SIZE - 1;
+	if (request_resource(&iomem_resource, &res[1]))
+		panic("Request PCIe Memory resource failed\n");
+	sys->resource[1] = &res[1];
+
+	sys->resource[2] = NULL;
+	sys->io_offset = 0;
+
+	return 1;
+}
+
+static void __devinit rc_pci_fixup(struct pci_dev *dev)
+{
+	/*
+	 * Prevent enumeration of root complex.
+	 */
+	if (dev->bus->parent == NULL && dev->devfn == 0) {
+		int i;
+
+		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+			dev->resource[i].start = 0;
+			dev->resource[i].end   = 0;
+			dev->resource[i].flags = 0;
+		}
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
+
+static struct pci_bus __init *
+kirkwood_pcie_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_bus *bus;
+
+	if (nr == 0) {
+		bus = pci_scan_bus(sys->busnr, &pcie_ops, sys);
+	} else {
+		bus = NULL;
+		BUG();
+	}
+
+	return bus;
+}
+
+static int __init kirkwood_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_KIRKWOOD_PCIE;
+}
+
+static struct hw_pci kirkwood_pci __initdata = {
+	.nr_controllers	= 1,
+	.swizzle	= pci_std_swizzle,
+	.setup		= kirkwood_pcie_setup,
+	.scan		= kirkwood_pcie_scan_bus,
+	.map_irq	= kirkwood_pcie_map_irq,
+};
+
+void __init kirkwood_pcie_init(void)
+{
+	pci_common_init(&kirkwood_pci);
+}
--- /dev/null
+++ b/arch/arm/mach-kirkwood/rd88f6192-nas-setup.c
@@ -0,0 +1,69 @@
+/*
+ * arch/arm/mach-kirkwood/rd88f6192-nas-setup.c
+ *
+ * Marvell RD-88F6192-NAS Reference Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/nand.h>
+#include <linux/timer.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/kirkwood.h>
+#include "common.h"
+
+#define RD88F6192_GPIO_USB_VBUS		10
+
+static struct mv643xx_eth_platform_data rd88f6192_ge00_data = {
+	.phy_addr	= 8,
+};
+
+static struct mv_sata_platform_data rd88f6192_sata_data = {
+	.n_ports	= 2,
+};
+
+static void __init rd88f6192_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&rd88f6192_ge00_data);
+	kirkwood_rtc_init();
+	kirkwood_sata_init(&rd88f6192_sata_data);
+	kirkwood_uart0_init();
+}
+
+static int __init rd88f6192_pci_init(void)
+{
+	if (machine_is_rd88f6192_nas())
+		kirkwood_pcie_init();
+
+	return 0;
+}
+subsys_initcall(rd88f6192_pci_init);
+
+MACHINE_START(RD88F6192_NAS, "Marvell RD-88F6192-NAS Development Board")
+	/* Maintainer: Saeed Bishara <saeed@marvell.com> */
+	.phys_io	= KIRKWOOD_REGS_PHYS_BASE,
+	.io_pg_offst	= ((KIRKWOOD_REGS_VIRT_BASE) >> 18) & 0xfffc,
+	.boot_params	= 0x00000100,
+	.init_machine	= rd88f6192_init,
+	.map_io		= kirkwood_map_io,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-kirkwood/rd88f6281-setup.c
@@ -0,0 +1,112 @@
+/*
+ * arch/arm/mach-kirkwood/rd88f6281-setup.c
+ *
+ * Marvell RD-88F6281 Reference Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/nand.h>
+#include <linux/timer.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/kirkwood.h>
+#include <asm/plat-orion/orion_nand.h>
+#include "common.h"
+
+static struct mtd_partition rd88f6281_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_2M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct resource rd88f6281_nand_resource = {
+	.flags		= IORESOURCE_MEM,
+	.start		= KIRKWOOD_NAND_MEM_PHYS_BASE,
+	.end		= KIRKWOOD_NAND_MEM_PHYS_BASE +
+			  KIRKWOOD_NAND_MEM_SIZE - 1,
+};
+
+static struct orion_nand_data rd88f6281_nand_data = {
+	.parts		= rd88f6281_nand_parts,
+	.nr_parts	= ARRAY_SIZE(rd88f6281_nand_parts),
+	.cle		= 0,
+	.ale		= 1,
+	.width		= 8,
+};
+
+static struct platform_device rd88f6281_nand_flash = {
+	.name		= "orion_nand",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &rd88f6281_nand_data,
+	},
+	.resource	= &rd88f6281_nand_resource,
+	.num_resources	= 1,
+};
+
+static struct mv643xx_eth_platform_data rd88f6281_ge00_data = {
+	.phy_addr	= -1,
+};
+
+static struct mv_sata_platform_data rd88f6281_sata_data = {
+	.n_ports	= 2,
+};
+
+static void __init rd88f6281_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&rd88f6281_ge00_data);
+	kirkwood_rtc_init();
+	kirkwood_sata_init(&rd88f6281_sata_data);
+	kirkwood_uart0_init();
+	kirkwood_uart1_init();
+
+	platform_device_register(&rd88f6281_nand_flash);
+}
+
+static int __init rd88f6281_pci_init(void)
+{
+	if (machine_is_rd88f6281())
+		kirkwood_pcie_init();
+
+	return 0;
+}
+subsys_initcall(rd88f6281_pci_init);
+
+MACHINE_START(RD88F6281, "Marvell RD-88F6281 Reference Board")
+	/* Maintainer: Saeed Bishara <saeed@marvell.com> */
+	.phys_io	= KIRKWOOD_REGS_PHYS_BASE,
+	.io_pg_offst	= ((KIRKWOOD_REGS_VIRT_BASE) >> 18) & 0xfffc,
+	.boot_params	= 0x00000100,
+	.init_machine	= rd88f6281_init,
+	.map_io		= kirkwood_map_io,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-loki/Kconfig
@@ -0,0 +1,13 @@
+if ARCH_LOKI
+
+menu "Marvell Loki (88RC8480) Implementations"
+
+config MACH_LB88RC8480
+	bool "Marvell LB88RC8480 Development Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell LB88RC8480 Development Board.
+
+endmenu
+
+endif
--- /dev/null
+++ b/arch/arm/mach-loki/Makefile
@@ -0,0 +1,3 @@
+obj-y				+= common.o addr-map.o irq.o
+
+obj-$(CONFIG_MACH_LB88RC8480)	+= lb88rc8480-setup.o
--- /dev/null
+++ b/arch/arm/mach-loki/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
--- /dev/null
+++ b/arch/arm/mach-loki/addr-map.c
@@ -0,0 +1,121 @@
+/*
+ * arch/arm/mach-loki/addr-map.c
+ *
+ * Address map functions for Marvell Loki (88RC8480) SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mbus.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include "common.h"
+
+/*
+ * Generic Address Decode Windows bit settings
+ */
+#define TARGET_DDR		0
+#define TARGET_DEV_BUS		1
+#define TARGET_PCIE0		3
+#define TARGET_PCIE1		4
+#define ATTR_DEV_BOOT		0x0f
+#define ATTR_DEV_CS2		0x1b
+#define ATTR_DEV_CS1		0x1d
+#define ATTR_DEV_CS0		0x1e
+#define ATTR_PCIE_IO		0x51
+#define ATTR_PCIE_MEM		0x59
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define DDR_SIZE_CS(n)		DDR_REG(0x1500 + ((n) << 3))
+#define DDR_BASE_CS(n)		DDR_REG(0x1504 + ((n) << 3))
+
+/*
+ * CPU Address Decode Windows registers
+ */
+#define CPU_WIN_CTRL(n)		BRIDGE_REG(0x000 | ((n) << 4))
+#define CPU_WIN_BASE(n)		BRIDGE_REG(0x004 | ((n) << 4))
+#define CPU_WIN_REMAP_LO(n)	BRIDGE_REG(0x008 | ((n) << 4))
+#define CPU_WIN_REMAP_HI(n)	BRIDGE_REG(0x00c | ((n) << 4))
+
+
+struct mbus_dram_target_info loki_mbus_dram_info;
+
+static void __init setup_cpu_win(int win, u32 base, u32 size,
+				 u8 target, u8 attr, int remap)
+{
+	u32 ctrl;
+
+	base &= 0xffff0000;
+	ctrl = ((size - 1) & 0xffff0000) | (attr << 8) | (1 << 5) | target;
+
+	writel(base, CPU_WIN_BASE(win));
+	writel(ctrl, CPU_WIN_CTRL(win));
+	if (win < 2) {
+		if (remap < 0)
+			remap = base;
+
+		writel(remap & 0xffff0000, CPU_WIN_REMAP_LO(win));
+		writel(0, CPU_WIN_REMAP_HI(win));
+	}
+}
+
+void __init loki_setup_cpu_mbus(void)
+{
+	int i;
+	int cs;
+
+	/*
+	 * First, disable and clear windows.
+	 */
+	for (i = 0; i < 8; i++) {
+		writel(0, CPU_WIN_BASE(i));
+		writel(0, CPU_WIN_CTRL(i));
+		if (i < 2) {
+			writel(0, CPU_WIN_REMAP_LO(i));
+			writel(0, CPU_WIN_REMAP_HI(i));
+		}
+	}
+
+	/*
+	 * Setup windows for PCIe IO+MEM space.
+	 */
+	setup_cpu_win(2, LOKI_PCIE0_MEM_PHYS_BASE, LOKI_PCIE0_MEM_SIZE,
+		      TARGET_PCIE0, ATTR_PCIE_MEM, -1);
+	setup_cpu_win(3, LOKI_PCIE1_MEM_PHYS_BASE, LOKI_PCIE1_MEM_SIZE,
+		      TARGET_PCIE1, ATTR_PCIE_MEM, -1);
+
+	/*
+	 * Setup MBUS dram target info.
+	 */
+	loki_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+
+	for (i = 0, cs = 0; i < 4; i++) {
+		u32 base = readl(DDR_BASE_CS(i));
+		u32 size = readl(DDR_SIZE_CS(i));
+
+		/*
+		 * Chip select enabled?
+		 */
+		if (size & 1) {
+			struct mbus_dram_window *w;
+
+			w = &loki_mbus_dram_info.cs[cs++];
+			w->cs_index = i;
+			w->mbus_attr = 0xf & ~(1 << i);
+			w->base = base & 0xffff0000;
+			w->size = (size | 0x0000ffff) + 1;
+		}
+	}
+	loki_mbus_dram_info.num_cs = cs;
+}
+
+void __init loki_setup_dev_boot_win(u32 base, u32 size)
+{
+	setup_cpu_win(4, base, size, TARGET_DEV_BUS, ATTR_DEV_BOOT, -1);
+}
--- /dev/null
+++ b/arch/arm/mach-loki/common.c
@@ -0,0 +1,305 @@
+/*
+ * arch/arm/mach-loki/common.c
+ *
+ * Core functions for Marvell Loki (88RC8480) SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/mbus.h>
+#include <linux/mv643xx_eth.h>
+#include <asm/page.h>
+#include <asm/timex.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/arch/loki.h>
+#include <asm/plat-orion/orion_nand.h>
+#include <asm/plat-orion/time.h>
+#include "common.h"
+
+/*****************************************************************************
+ * I/O Address Mapping
+ ****************************************************************************/
+static struct map_desc loki_io_desc[] __initdata = {
+	{
+		.virtual	= LOKI_REGS_VIRT_BASE,
+		.pfn		= __phys_to_pfn(LOKI_REGS_PHYS_BASE),
+		.length		= LOKI_REGS_SIZE,
+		.type		= MT_DEVICE,
+	},
+};
+
+void __init loki_map_io(void)
+{
+	iotable_init(loki_io_desc, ARRAY_SIZE(loki_io_desc));
+}
+
+
+/*****************************************************************************
+ * GE0
+ ****************************************************************************/
+struct mv643xx_eth_shared_platform_data loki_ge0_shared_data = {
+	.t_clk		= LOKI_TCLK,
+	.dram		= &loki_mbus_dram_info,
+};
+
+static struct resource loki_ge0_shared_resources[] = {
+	{
+		.name	= "ge0 base",
+		.start	= GE0_PHYS_BASE + 0x2000,
+		.end	= GE0_PHYS_BASE + 0x3fff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device loki_ge0_shared = {
+	.name		= MV643XX_ETH_SHARED_NAME,
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &loki_ge0_shared_data,
+	},
+	.num_resources	= 1,
+	.resource	= loki_ge0_shared_resources,
+};
+
+static struct resource loki_ge0_resources[] = {
+	{
+		.name	= "ge0 irq",
+		.start	= IRQ_LOKI_GBE_A_INT,
+		.end	= IRQ_LOKI_GBE_A_INT,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device loki_ge0 = {
+	.name		= MV643XX_ETH_NAME,
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= loki_ge0_resources,
+};
+
+void __init loki_ge0_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	eth_data->shared = &loki_ge0_shared;
+	loki_ge0.dev.platform_data = eth_data;
+
+	writel(0x00079220, GE0_VIRT_BASE + 0x20b0);
+	platform_device_register(&loki_ge0_shared);
+	platform_device_register(&loki_ge0);
+}
+
+
+/*****************************************************************************
+ * GE1
+ ****************************************************************************/
+struct mv643xx_eth_shared_platform_data loki_ge1_shared_data = {
+	.t_clk		= LOKI_TCLK,
+	.dram		= &loki_mbus_dram_info,
+};
+
+static struct resource loki_ge1_shared_resources[] = {
+	{
+		.name	= "ge1 base",
+		.start	= GE1_PHYS_BASE + 0x2000,
+		.end	= GE1_PHYS_BASE + 0x3fff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device loki_ge1_shared = {
+	.name		= MV643XX_ETH_SHARED_NAME,
+	.id		= 1,
+	.dev		= {
+		.platform_data	= &loki_ge1_shared_data,
+	},
+	.num_resources	= 1,
+	.resource	= loki_ge1_shared_resources,
+};
+
+static struct resource loki_ge1_resources[] = {
+	{
+		.name	= "ge1 irq",
+		.start	= IRQ_LOKI_GBE_B_INT,
+		.end	= IRQ_LOKI_GBE_B_INT,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device loki_ge1 = {
+	.name		= MV643XX_ETH_NAME,
+	.id		= 1,
+	.num_resources	= 1,
+	.resource	= loki_ge1_resources,
+};
+
+void __init loki_ge1_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	eth_data->shared = &loki_ge1_shared;
+	loki_ge1.dev.platform_data = eth_data;
+
+	writel(0x00079220, GE1_VIRT_BASE + 0x20b0);
+	platform_device_register(&loki_ge1_shared);
+	platform_device_register(&loki_ge1);
+}
+
+
+/*****************************************************************************
+ * SAS/SATA
+ ****************************************************************************/
+static struct resource loki_sas_resources[] = {
+	{
+		.name	= "mvsas0 mem",
+		.start	= SAS0_PHYS_BASE,
+		.end	= SAS0_PHYS_BASE + 0x01ff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "mvsas0 irq",
+		.start	= IRQ_LOKI_SAS_A,
+		.end	= IRQ_LOKI_SAS_A,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.name	= "mvsas1 mem",
+		.start	= SAS1_PHYS_BASE,
+		.end	= SAS1_PHYS_BASE + 0x01ff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "mvsas1 irq",
+		.start	= IRQ_LOKI_SAS_B,
+		.end	= IRQ_LOKI_SAS_B,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device loki_sas = {
+	.name		= "mvsas",
+	.id		= 0,
+	.dev		= {
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(loki_sas_resources),
+	.resource	= loki_sas_resources,
+};
+
+void __init loki_sas_init(void)
+{
+	writel(0x8300f707, DDR_REG(0x1424));
+	platform_device_register(&loki_sas);
+}
+
+
+/*****************************************************************************
+ * UART0
+ ****************************************************************************/
+static struct plat_serial8250_port loki_uart0_data[] = {
+	{
+		.mapbase	= UART0_PHYS_BASE,
+		.membase	= (char *)UART0_VIRT_BASE,
+		.irq		= IRQ_LOKI_UART0,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= LOKI_TCLK,
+	}, {
+	},
+};
+
+static struct resource loki_uart0_resources[] = {
+	{
+		.start		= UART0_PHYS_BASE,
+		.end		= UART0_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_LOKI_UART0,
+		.end		= IRQ_LOKI_UART0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device loki_uart0 = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= loki_uart0_data,
+	},
+	.resource		= loki_uart0_resources,
+	.num_resources		= ARRAY_SIZE(loki_uart0_resources),
+};
+
+void __init loki_uart0_init(void)
+{
+	platform_device_register(&loki_uart0);
+}
+
+
+/*****************************************************************************
+ * UART1
+ ****************************************************************************/
+static struct plat_serial8250_port loki_uart1_data[] = {
+	{
+		.mapbase	= UART1_PHYS_BASE,
+		.membase	= (char *)UART1_VIRT_BASE,
+		.irq		= IRQ_LOKI_UART1,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= LOKI_TCLK,
+	}, {
+	},
+};
+
+static struct resource loki_uart1_resources[] = {
+	{
+		.start		= UART1_PHYS_BASE,
+		.end		= UART1_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_LOKI_UART1,
+		.end		= IRQ_LOKI_UART1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device loki_uart1 = {
+	.name			= "serial8250",
+	.id			= 1,
+	.dev			= {
+		.platform_data	= loki_uart1_data,
+	},
+	.resource		= loki_uart1_resources,
+	.num_resources		= ARRAY_SIZE(loki_uart1_resources),
+};
+
+void __init loki_uart1_init(void)
+{
+	platform_device_register(&loki_uart1);
+}
+
+
+/*****************************************************************************
+ * Time handling
+ ****************************************************************************/
+static void loki_timer_init(void)
+{
+	orion_time_init(IRQ_LOKI_BRIDGE, LOKI_TCLK);
+}
+
+struct sys_timer loki_timer = {
+	.init = loki_timer_init,
+};
+
+
+/*****************************************************************************
+ * General
+ ****************************************************************************/
+void __init loki_init(void)
+{
+	printk(KERN_INFO "Loki ID: 88RC8480. TCLK=%d.\n", LOKI_TCLK);
+
+	loki_setup_cpu_mbus();
+}
--- /dev/null
+++ b/arch/arm/mach-loki/common.h
@@ -0,0 +1,36 @@
+/*
+ * arch/arm/mach-loki/common.h
+ *
+ * Core functions for Marvell Loki (88RC8480) SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ARCH_LOKI_COMMON_H
+#define __ARCH_LOKI_COMMON_H
+
+struct mv643xx_eth_platform_data;
+
+/*
+ * Basic Loki init functions used early by machine-setup.
+ */
+void loki_map_io(void);
+void loki_init(void);
+void loki_init_irq(void);
+
+extern struct mbus_dram_target_info loki_mbus_dram_info;
+void loki_setup_cpu_mbus(void);
+void loki_setup_dev_boot_win(u32 base, u32 size);
+
+void loki_ge0_init(struct mv643xx_eth_platform_data *eth_data);
+void loki_ge1_init(struct mv643xx_eth_platform_data *eth_data);
+void loki_sas_init(void);
+void loki_uart0_init(void);
+void loki_uart1_init(void);
+
+extern struct sys_timer loki_timer;
+
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-loki/irq.c
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/mach-loki/irq.c
+ *
+ * Marvell Loki (88RC8480) IRQ handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+#include <asm/plat-orion/irq.h>
+#include "common.h"
+
+void __init loki_init_irq(void)
+{
+	orion_irq_init(0, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_OFF));
+}
--- /dev/null
+++ b/arch/arm/mach-loki/lb88rc8480-setup.c
@@ -0,0 +1,100 @@
+/*
+ * arch/arm/mach-loki/lb88rc8480-setup.c
+ *
+ * Marvell LB88RC8480 Development Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/nand.h>
+#include <linux/timer.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/arch/loki.h>
+#include "common.h"
+
+#define LB88RC8480_FLASH_BOOT_CS_BASE	0xf8000000
+#define LB88RC8480_FLASH_BOOT_CS_SIZE	SZ_128M
+
+#define LB88RC8480_NOR_BOOT_BASE	0xff000000
+#define LB88RC8480_NOR_BOOT_SIZE	SZ_16M
+
+static struct mtd_partition lb88rc8480_boot_flash_parts[] = {
+	{
+		.name	= "kernel",
+		.offset	= 0,
+		.size	= SZ_2M,
+	}, {
+		.name	= "root-fs",
+		.offset	= SZ_2M,
+		.size	= (SZ_8M + SZ_4M + SZ_1M),
+	}, {
+		.name	= "u-boot",
+		.offset	= (SZ_8M + SZ_4M + SZ_2M + SZ_1M),
+		.size	= SZ_1M,
+	},
+};
+
+static struct physmap_flash_data lb88rc8480_boot_flash_data = {
+	.parts		= lb88rc8480_boot_flash_parts,
+	.nr_parts	= ARRAY_SIZE(lb88rc8480_boot_flash_parts),
+	.width		= 1,	/* 8 bit bus width */
+};
+
+static struct resource lb88rc8480_boot_flash_resource = {
+	.flags	= IORESOURCE_MEM,
+	.start	= LB88RC8480_NOR_BOOT_BASE,
+	.end	= LB88RC8480_NOR_BOOT_BASE + LB88RC8480_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device lb88rc8480_boot_flash = {
+	.name	= "physmap-flash",
+	.id	= 0,
+	.dev	= {
+		.platform_data	= &lb88rc8480_boot_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &lb88rc8480_boot_flash_resource,
+};
+
+static struct mv643xx_eth_platform_data lb88rc8480_ge0_data = {
+	.phy_addr	= 1,
+	.mac_addr	= { 0x00, 0x50, 0x43, 0x11, 0x22, 0x33 },
+};
+
+static void __init lb88rc8480_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	loki_init();
+
+	loki_ge0_init(&lb88rc8480_ge0_data);
+	loki_sas_init();
+	loki_uart0_init();
+	loki_uart1_init();
+
+	loki_setup_dev_boot_win(LB88RC8480_FLASH_BOOT_CS_BASE,
+				LB88RC8480_FLASH_BOOT_CS_SIZE);
+	platform_device_register(&lb88rc8480_boot_flash);
+}
+
+MACHINE_START(LB88RC8480, "Marvell LB88RC8480 Development Board")
+	/* Maintainer: Ke Wei <kewei@marvell.com> */
+	.phys_io	= LOKI_REGS_PHYS_BASE,
+	.io_pg_offst	= ((LOKI_REGS_VIRT_BASE) >> 18) & 0xfffc,
+	.boot_params	= 0x00000100,
+	.init_machine	= lb88rc8480_init,
+	.map_io		= loki_map_io,
+	.init_irq	= loki_init_irq,
+	.timer		= &loki_timer,
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/Kconfig
@@ -0,0 +1,13 @@
+if ARCH_MV78XX0
+
+menu "Marvell MV78xx0 Implementations"
+
+config MACH_DB78X00_BP
+	bool "Marvell DB-78x00-BP Development Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell DB-78x00-BP Development Board.
+
+endmenu
+
+endif
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/Makefile
@@ -0,0 +1,2 @@
+obj-y				+= common.o addr-map.o irq.o pcie.o
+obj-$(CONFIG_MACH_DB78X00_BP)	+= db78x00-bp-setup.o
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/addr-map.c
@@ -0,0 +1,156 @@
+/*
+ * arch/arm/mach-mv78xx0/addr-map.c
+ *
+ * Address map functions for Marvell MV78xx0 SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mbus.h>
+#include <asm/io.h>
+#include "common.h"
+
+/*
+ * Generic Address Decode Windows bit settings
+ */
+#define TARGET_DDR		0
+#define TARGET_DEV_BUS		1
+#define TARGET_PCIE0		4
+#define TARGET_PCIE1		8
+#define TARGET_PCIE(i)		((i) ? TARGET_PCIE1 : TARGET_PCIE0)
+#define ATTR_DEV_SPI_ROM	0x1f
+#define ATTR_DEV_BOOT		0x2f
+#define ATTR_DEV_CS3		0x37
+#define ATTR_DEV_CS2		0x3b
+#define ATTR_DEV_CS1		0x3d
+#define ATTR_DEV_CS0		0x3e
+#define ATTR_PCIE_IO(l)		(0xf0 & ~(0x10 << (l)))
+#define ATTR_PCIE_MEM(l)	(0xf8 & ~(0x10 << (l)))
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define DDR_BASE_CS_OFF(n)	(0x0000 + ((n) << 3))
+#define DDR_SIZE_CS_OFF(n)	(0x0004 + ((n) << 3))
+
+/*
+ * CPU Address Decode Windows registers
+ */
+#define WIN0_OFF(n)		(BRIDGE_VIRT_BASE + 0x0000 + ((n) << 4))
+#define WIN8_OFF(n)		(BRIDGE_VIRT_BASE + 0x0900 + (((n) - 8) << 4))
+#define WIN_CTRL_OFF		0x0000
+#define WIN_BASE_OFF		0x0004
+#define WIN_REMAP_LO_OFF	0x0008
+#define WIN_REMAP_HI_OFF	0x000c
+
+
+struct mbus_dram_target_info mv78xx0_mbus_dram_info;
+
+static void __init __iomem *win_cfg_base(int win)
+{
+	/*
+	 * Find the control register base address for this window.
+	 *
+	 * BRIDGE_VIRT_BASE points to the right (CPU0's or CPU1's)
+	 * MBUS bridge depending on which CPU core we're running on,
+	 * so we don't need to take that into account here.
+	 */
+
+	return (void __iomem *)((win < 8) ? WIN0_OFF(win) : WIN8_OFF(win));
+}
+
+static int __init cpu_win_can_remap(int win)
+{
+	if (win < 8)
+		return 1;
+
+	return 0;
+}
+
+static void __init setup_cpu_win(int win, u32 base, u32 size,
+				 u8 target, u8 attr, int remap)
+{
+	void __iomem *addr = win_cfg_base(win);
+	u32 ctrl;
+
+	base &= 0xffff0000;
+	ctrl = ((size - 1) & 0xffff0000) | (attr << 8) | (target << 4) | 1;
+
+	writel(base, addr + WIN_BASE_OFF);
+	writel(ctrl, addr + WIN_CTRL_OFF);
+	if (cpu_win_can_remap(win)) {
+		if (remap < 0)
+			remap = base;
+
+		writel(remap & 0xffff0000, addr + WIN_REMAP_LO_OFF);
+		writel(0, addr + WIN_REMAP_HI_OFF);
+	}
+}
+
+void __init mv78xx0_setup_cpu_mbus(void)
+{
+	void __iomem *addr;
+	int i;
+	int cs;
+
+	/*
+	 * First, disable and clear windows.
+	 */
+	for (i = 0; i < 14; i++) {
+		addr = win_cfg_base(i);
+
+		writel(0, addr + WIN_BASE_OFF);
+		writel(0, addr + WIN_CTRL_OFF);
+		if (cpu_win_can_remap(i)) {
+			writel(0, addr + WIN_REMAP_LO_OFF);
+			writel(0, addr + WIN_REMAP_HI_OFF);
+		}
+	}
+
+	/*
+	 * Setup MBUS dram target info.
+	 */
+	mv78xx0_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+
+	if (mv78xx0_core_index() == 0)
+		addr = (void __iomem *)DDR_WINDOW_CPU0_BASE;
+	else
+		addr = (void __iomem *)DDR_WINDOW_CPU1_BASE;
+
+	for (i = 0, cs = 0; i < 4; i++) {
+		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
+		u32 size = readl(addr + DDR_SIZE_CS_OFF(i));
+
+		/*
+		 * Chip select enabled?
+		 */
+		if (size & 1) {
+			struct mbus_dram_window *w;
+
+			w = &mv78xx0_mbus_dram_info.cs[cs++];
+			w->cs_index = i;
+			w->mbus_attr = 0xf & ~(1 << i);
+			w->base = base & 0xffff0000;
+			w->size = (size | 0x0000ffff) + 1;
+		}
+	}
+	mv78xx0_mbus_dram_info.num_cs = cs;
+}
+
+void __init mv78xx0_setup_pcie_io_win(int window, u32 base, u32 size,
+				      int maj, int min)
+{
+	setup_cpu_win(window, base, size, TARGET_PCIE(maj),
+		      ATTR_PCIE_IO(min), -1);
+}
+
+void __init mv78xx0_setup_pcie_mem_win(int window, u32 base, u32 size,
+				       int maj, int min)
+{
+	setup_cpu_win(window, base, size, TARGET_PCIE(maj),
+		      ATTR_PCIE_MEM(min), -1);
+}
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/common.c
@@ -0,0 +1,754 @@
+/*
+ * arch/arm/mach-mv78xx0/common.c
+ *
+ * Core functions for Marvell MV78xx0 SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/mbus.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/ata_platform.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <asm/arch/mv78xx0.h>
+#include <asm/plat-orion/cache-feroceon-l2.h>
+#include <asm/plat-orion/ehci-orion.h>
+#include <asm/plat-orion/orion_nand.h>
+#include <asm/plat-orion/time.h>
+#include "common.h"
+
+
+/*****************************************************************************
+ * Common bits
+ ****************************************************************************/
+int mv78xx0_core_index(void)
+{
+	u32 extra;
+
+	/*
+	 * Read Extra Features register.
+	 */
+	__asm__("mrc p15, 1, %0, c15, c1, 0" : "=r" (extra));
+
+	return !!(extra & 0x00004000);
+}
+
+static int get_hclk(void)
+{
+	int hclk;
+
+	/*
+	 * HCLK tick rate is configured by DEV_D[7:5] pins.
+	 */
+	switch ((readl(SAMPLE_AT_RESET_LOW) >> 5) & 7) {
+	case 0:
+		hclk = 166666667;
+		break;
+	case 1:
+		hclk = 200000000;
+		break;
+	case 2:
+		hclk = 266666667;
+		break;
+	case 3:
+		hclk = 333333333;
+		break;
+	case 4:
+		hclk = 400000000;
+		break;
+	default:
+		panic("unknown HCLK PLL setting: %.8x\n",
+			readl(SAMPLE_AT_RESET_LOW));
+	}
+
+	return hclk;
+}
+
+static void get_pclk_l2clk(int hclk, int core_index, int *pclk, int *l2clk)
+{
+	u32 cfg;
+
+	/*
+	 * Core #0 PCLK/L2CLK is configured by bits [13:8], core #1
+	 * PCLK/L2CLK by bits [19:14].
+	 */
+	if (core_index == 0) {
+		cfg = (readl(SAMPLE_AT_RESET_LOW) >> 8) & 0x3f;
+	} else {
+		cfg = (readl(SAMPLE_AT_RESET_LOW) >> 14) & 0x3f;
+	}
+
+	/*
+	 * Bits [11:8] ([17:14] for core #1) configure the PCLK:HCLK
+	 * ratio (1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6).
+	 */
+	*pclk = ((u64)hclk * (2 + (cfg & 0xf))) >> 1;
+
+	/*
+	 * Bits [13:12] ([19:18] for core #1) configure the PCLK:L2CLK
+	 * ratio (1, 2, 3).
+	 */
+	*l2clk = *pclk / (((cfg >> 4) & 3) + 1);
+}
+
+static int get_tclk(void)
+{
+	int tclk;
+
+	/*
+	 * TCLK tick rate is configured by DEV_A[2:0] strap pins.
+	 */
+	switch ((readl(SAMPLE_AT_RESET_HIGH) >> 6) & 7) {
+	case 1:
+		tclk = 166666667;
+		break;
+	case 3:
+		tclk = 200000000;
+		break;
+	default:
+		panic("unknown TCLK PLL setting: %.8x\n",
+			readl(SAMPLE_AT_RESET_HIGH));
+	}
+
+	return tclk;
+}
+
+
+/*****************************************************************************
+ * I/O Address Mapping
+ ****************************************************************************/
+static struct map_desc mv78xx0_io_desc[] __initdata = {
+	{
+		.virtual	= MV78XX0_CORE_REGS_VIRT_BASE,
+		.pfn		= 0,
+		.length		= MV78XX0_CORE_REGS_SIZE,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= MV78XX0_PCIE_IO_VIRT_BASE(0),
+		.pfn		= __phys_to_pfn(MV78XX0_PCIE_IO_PHYS_BASE(0)),
+		.length		= MV78XX0_PCIE_IO_SIZE * 8,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= MV78XX0_REGS_VIRT_BASE,
+		.pfn		= __phys_to_pfn(MV78XX0_REGS_PHYS_BASE),
+		.length		= MV78XX0_REGS_SIZE,
+		.type		= MT_DEVICE,
+	},
+};
+
+void __init mv78xx0_map_io(void)
+{
+	unsigned long phys;
+
+	/*
+	 * Map the right set of per-core registers depending on
+	 * which core we are running on.
+	 */
+	if (mv78xx0_core_index() == 0) {
+		phys = MV78XX0_CORE0_REGS_PHYS_BASE;
+	} else {
+		phys = MV78XX0_CORE1_REGS_PHYS_BASE;
+	}
+	mv78xx0_io_desc[0].pfn = __phys_to_pfn(phys);
+
+	iotable_init(mv78xx0_io_desc, ARRAY_SIZE(mv78xx0_io_desc));
+}
+
+
+/*****************************************************************************
+ * EHCI
+ ****************************************************************************/
+static struct orion_ehci_data mv78xx0_ehci_data = {
+	.dram		= &mv78xx0_mbus_dram_info,
+};
+
+static u64 ehci_dmamask = 0xffffffffUL;
+
+
+/*****************************************************************************
+ * EHCI0
+ ****************************************************************************/
+static struct resource mv78xx0_ehci0_resources[] = {
+	{
+		.start	= USB0_PHYS_BASE,
+		.end	= USB0_PHYS_BASE + 0x0fff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_MV78XX0_USB_0,
+		.end	= IRQ_MV78XX0_USB_0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_ehci0 = {
+	.name		= "orion-ehci",
+	.id		= 0,
+	.dev		= {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &mv78xx0_ehci_data,
+	},
+	.resource	= mv78xx0_ehci0_resources,
+	.num_resources	= ARRAY_SIZE(mv78xx0_ehci0_resources),
+};
+
+void __init mv78xx0_ehci0_init(void)
+{
+	platform_device_register(&mv78xx0_ehci0);
+}
+
+
+/*****************************************************************************
+ * EHCI1
+ ****************************************************************************/
+static struct resource mv78xx0_ehci1_resources[] = {
+	{
+		.start	= USB1_PHYS_BASE,
+		.end	= USB1_PHYS_BASE + 0x0fff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_MV78XX0_USB_1,
+		.end	= IRQ_MV78XX0_USB_1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_ehci1 = {
+	.name		= "orion-ehci",
+	.id		= 1,
+	.dev		= {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &mv78xx0_ehci_data,
+	},
+	.resource	= mv78xx0_ehci1_resources,
+	.num_resources	= ARRAY_SIZE(mv78xx0_ehci1_resources),
+};
+
+void __init mv78xx0_ehci1_init(void)
+{
+	platform_device_register(&mv78xx0_ehci1);
+}
+
+
+/*****************************************************************************
+ * EHCI2
+ ****************************************************************************/
+static struct resource mv78xx0_ehci2_resources[] = {
+	{
+		.start	= USB2_PHYS_BASE,
+		.end	= USB2_PHYS_BASE + 0x0fff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_MV78XX0_USB_2,
+		.end	= IRQ_MV78XX0_USB_2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_ehci2 = {
+	.name		= "orion-ehci",
+	.id		= 2,
+	.dev		= {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &mv78xx0_ehci_data,
+	},
+	.resource	= mv78xx0_ehci2_resources,
+	.num_resources	= ARRAY_SIZE(mv78xx0_ehci2_resources),
+};
+
+void __init mv78xx0_ehci2_init(void)
+{
+	platform_device_register(&mv78xx0_ehci2);
+}
+
+
+/*****************************************************************************
+ * GE00
+ ****************************************************************************/
+struct mv643xx_eth_shared_platform_data mv78xx0_ge00_shared_data = {
+	.t_clk		= 0,
+	.dram		= &mv78xx0_mbus_dram_info,
+};
+
+static struct resource mv78xx0_ge00_shared_resources[] = {
+	{
+		.name	= "ge00 base",
+		.start	= GE00_PHYS_BASE + 0x2000,
+		.end	= GE00_PHYS_BASE + 0x3fff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device mv78xx0_ge00_shared = {
+	.name		= MV643XX_ETH_SHARED_NAME,
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &mv78xx0_ge00_shared_data,
+	},
+	.num_resources	= 1,
+	.resource	= mv78xx0_ge00_shared_resources,
+};
+
+static struct resource mv78xx0_ge00_resources[] = {
+	{
+		.name	= "ge00 irq",
+		.start	= IRQ_MV78XX0_GE00_SUM,
+		.end	= IRQ_MV78XX0_GE00_SUM,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_ge00 = {
+	.name		= MV643XX_ETH_NAME,
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= mv78xx0_ge00_resources,
+};
+
+void __init mv78xx0_ge00_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	eth_data->shared = &mv78xx0_ge00_shared;
+	mv78xx0_ge00.dev.platform_data = eth_data;
+
+	platform_device_register(&mv78xx0_ge00_shared);
+	platform_device_register(&mv78xx0_ge00);
+}
+
+
+/*****************************************************************************
+ * GE01
+ ****************************************************************************/
+struct mv643xx_eth_shared_platform_data mv78xx0_ge01_shared_data = {
+	.t_clk		= 0,
+	.dram		= &mv78xx0_mbus_dram_info,
+};
+
+static struct resource mv78xx0_ge01_shared_resources[] = {
+	{
+		.name	= "ge01 base",
+		.start	= GE01_PHYS_BASE + 0x2000,
+		.end	= GE01_PHYS_BASE + 0x3fff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device mv78xx0_ge01_shared = {
+	.name		= MV643XX_ETH_SHARED_NAME,
+	.id		= 1,
+	.dev		= {
+		.platform_data	= &mv78xx0_ge01_shared_data,
+	},
+	.num_resources	= 1,
+	.resource	= mv78xx0_ge01_shared_resources,
+};
+
+static struct resource mv78xx0_ge01_resources[] = {
+	{
+		.name	= "ge01 irq",
+		.start	= IRQ_MV78XX0_GE01_SUM,
+		.end	= IRQ_MV78XX0_GE01_SUM,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_ge01 = {
+	.name		= MV643XX_ETH_NAME,
+	.id		= 1,
+	.num_resources	= 1,
+	.resource	= mv78xx0_ge01_resources,
+};
+
+void __init mv78xx0_ge01_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	eth_data->shared = &mv78xx0_ge01_shared;
+	eth_data->shared_smi = &mv78xx0_ge00_shared;
+	mv78xx0_ge01.dev.platform_data = eth_data;
+
+	platform_device_register(&mv78xx0_ge01_shared);
+	platform_device_register(&mv78xx0_ge01);
+}
+
+
+/*****************************************************************************
+ * GE10
+ ****************************************************************************/
+struct mv643xx_eth_shared_platform_data mv78xx0_ge10_shared_data = {
+	.t_clk		= 0,
+	.dram		= &mv78xx0_mbus_dram_info,
+};
+
+static struct resource mv78xx0_ge10_shared_resources[] = {
+	{
+		.name	= "ge10 base",
+		.start	= GE10_PHYS_BASE + 0x2000,
+		.end	= GE10_PHYS_BASE + 0x3fff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device mv78xx0_ge10_shared = {
+	.name		= MV643XX_ETH_SHARED_NAME,
+	.id		= 2,
+	.dev		= {
+		.platform_data	= &mv78xx0_ge10_shared_data,
+	},
+	.num_resources	= 1,
+	.resource	= mv78xx0_ge10_shared_resources,
+};
+
+static struct resource mv78xx0_ge10_resources[] = {
+	{
+		.name	= "ge10 irq",
+		.start	= IRQ_MV78XX0_GE10_SUM,
+		.end	= IRQ_MV78XX0_GE10_SUM,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_ge10 = {
+	.name		= MV643XX_ETH_NAME,
+	.id		= 2,
+	.num_resources	= 1,
+	.resource	= mv78xx0_ge10_resources,
+};
+
+void __init mv78xx0_ge10_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	eth_data->shared = &mv78xx0_ge10_shared;
+	eth_data->shared_smi = &mv78xx0_ge00_shared;
+	mv78xx0_ge10.dev.platform_data = eth_data;
+
+	platform_device_register(&mv78xx0_ge10_shared);
+	platform_device_register(&mv78xx0_ge10);
+}
+
+
+/*****************************************************************************
+ * GE11
+ ****************************************************************************/
+struct mv643xx_eth_shared_platform_data mv78xx0_ge11_shared_data = {
+	.t_clk		= 0,
+	.dram		= &mv78xx0_mbus_dram_info,
+};
+
+static struct resource mv78xx0_ge11_shared_resources[] = {
+	{
+		.name	= "ge11 base",
+		.start	= GE11_PHYS_BASE + 0x2000,
+		.end	= GE11_PHYS_BASE + 0x3fff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device mv78xx0_ge11_shared = {
+	.name		= MV643XX_ETH_SHARED_NAME,
+	.id		= 3,
+	.dev		= {
+		.platform_data	= &mv78xx0_ge11_shared_data,
+	},
+	.num_resources	= 1,
+	.resource	= mv78xx0_ge11_shared_resources,
+};
+
+static struct resource mv78xx0_ge11_resources[] = {
+	{
+		.name	= "ge11 irq",
+		.start	= IRQ_MV78XX0_GE11_SUM,
+		.end	= IRQ_MV78XX0_GE11_SUM,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_ge11 = {
+	.name		= MV643XX_ETH_NAME,
+	.id		= 3,
+	.num_resources	= 1,
+	.resource	= mv78xx0_ge11_resources,
+};
+
+void __init mv78xx0_ge11_init(struct mv643xx_eth_platform_data *eth_data)
+{
+	eth_data->shared = &mv78xx0_ge11_shared;
+	eth_data->shared_smi = &mv78xx0_ge00_shared;
+	mv78xx0_ge11.dev.platform_data = eth_data;
+
+	platform_device_register(&mv78xx0_ge11_shared);
+	platform_device_register(&mv78xx0_ge11);
+}
+
+
+/*****************************************************************************
+ * SATA
+ ****************************************************************************/
+static struct resource mv78xx0_sata_resources[] = {
+	{
+		.name	= "sata base",
+		.start	= SATA_PHYS_BASE,
+		.end	= SATA_PHYS_BASE + 0x5000 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "sata irq",
+		.start	= IRQ_MV78XX0_SATA,
+		.end	= IRQ_MV78XX0_SATA,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_sata = {
+	.name		= "sata_mv",
+	.id		= 0,
+	.dev		= {
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(mv78xx0_sata_resources),
+	.resource	= mv78xx0_sata_resources,
+};
+
+void __init mv78xx0_sata_init(struct mv_sata_platform_data *sata_data)
+{
+	sata_data->dram = &mv78xx0_mbus_dram_info;
+	mv78xx0_sata.dev.platform_data = sata_data;
+	platform_device_register(&mv78xx0_sata);
+}
+
+
+/*****************************************************************************
+ * UART0
+ ****************************************************************************/
+static struct plat_serial8250_port mv78xx0_uart0_data[] = {
+	{
+		.mapbase	= UART0_PHYS_BASE,
+		.membase	= (char *)UART0_VIRT_BASE,
+		.irq		= IRQ_MV78XX0_UART_0,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource mv78xx0_uart0_resources[] = {
+	{
+		.start		= UART0_PHYS_BASE,
+		.end		= UART0_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_MV78XX0_UART_0,
+		.end		= IRQ_MV78XX0_UART_0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_uart0 = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= mv78xx0_uart0_data,
+	},
+	.resource		= mv78xx0_uart0_resources,
+	.num_resources		= ARRAY_SIZE(mv78xx0_uart0_resources),
+};
+
+void __init mv78xx0_uart0_init(void)
+{
+	platform_device_register(&mv78xx0_uart0);
+}
+
+
+/*****************************************************************************
+ * UART1
+ ****************************************************************************/
+static struct plat_serial8250_port mv78xx0_uart1_data[] = {
+	{
+		.mapbase	= UART1_PHYS_BASE,
+		.membase	= (char *)UART1_VIRT_BASE,
+		.irq		= IRQ_MV78XX0_UART_1,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource mv78xx0_uart1_resources[] = {
+	{
+		.start		= UART1_PHYS_BASE,
+		.end		= UART1_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_MV78XX0_UART_1,
+		.end		= IRQ_MV78XX0_UART_1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_uart1 = {
+	.name			= "serial8250",
+	.id			= 1,
+	.dev			= {
+		.platform_data	= mv78xx0_uart1_data,
+	},
+	.resource		= mv78xx0_uart1_resources,
+	.num_resources		= ARRAY_SIZE(mv78xx0_uart1_resources),
+};
+
+void __init mv78xx0_uart1_init(void)
+{
+	platform_device_register(&mv78xx0_uart1);
+}
+
+
+/*****************************************************************************
+ * UART2
+ ****************************************************************************/
+static struct plat_serial8250_port mv78xx0_uart2_data[] = {
+	{
+		.mapbase	= UART2_PHYS_BASE,
+		.membase	= (char *)UART2_VIRT_BASE,
+		.irq		= IRQ_MV78XX0_UART_2,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource mv78xx0_uart2_resources[] = {
+	{
+		.start		= UART2_PHYS_BASE,
+		.end		= UART2_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_MV78XX0_UART_2,
+		.end		= IRQ_MV78XX0_UART_2,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_uart2 = {
+	.name			= "serial8250",
+	.id			= 2,
+	.dev			= {
+		.platform_data	= mv78xx0_uart2_data,
+	},
+	.resource		= mv78xx0_uart2_resources,
+	.num_resources		= ARRAY_SIZE(mv78xx0_uart2_resources),
+};
+
+void __init mv78xx0_uart2_init(void)
+{
+	platform_device_register(&mv78xx0_uart2);
+}
+
+
+/*****************************************************************************
+ * UART3
+ ****************************************************************************/
+static struct plat_serial8250_port mv78xx0_uart3_data[] = {
+	{
+		.mapbase	= UART3_PHYS_BASE,
+		.membase	= (char *)UART3_VIRT_BASE,
+		.irq		= IRQ_MV78XX0_UART_3,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource mv78xx0_uart3_resources[] = {
+	{
+		.start		= UART3_PHYS_BASE,
+		.end		= UART3_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_MV78XX0_UART_3,
+		.end		= IRQ_MV78XX0_UART_3,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mv78xx0_uart3 = {
+	.name			= "serial8250",
+	.id			= 3,
+	.dev			= {
+		.platform_data	= mv78xx0_uart3_data,
+	},
+	.resource		= mv78xx0_uart3_resources,
+	.num_resources		= ARRAY_SIZE(mv78xx0_uart3_resources),
+};
+
+void __init mv78xx0_uart3_init(void)
+{
+	platform_device_register(&mv78xx0_uart3);
+}
+
+
+/*****************************************************************************
+ * Time handling
+ ****************************************************************************/
+static void mv78xx0_timer_init(void)
+{
+	orion_time_init(IRQ_MV78XX0_TIMER_1, get_tclk());
+}
+
+struct sys_timer mv78xx0_timer = {
+	.init = mv78xx0_timer_init,
+};
+
+
+/*****************************************************************************
+ * General
+ ****************************************************************************/
+static int __init is_l2_writethrough(void)
+{
+	return !!(readl(CPU_CONTROL) & L2_WRITETHROUGH);
+}
+
+void __init mv78xx0_init(void)
+{
+	int core_index;
+	int hclk;
+	int pclk;
+	int l2clk;
+	int tclk;
+
+	core_index = mv78xx0_core_index();
+	hclk = get_hclk();
+	get_pclk_l2clk(hclk, core_index, &pclk, &l2clk);
+	tclk = get_tclk();
+
+	printk(KERN_INFO "MV78xx0 core #%d, ", core_index);
+	printk("PCLK = %dMHz, ", (pclk + 499999) / 1000000);
+	printk("L2 = %dMHz, ", (l2clk + 499999) / 1000000);
+	printk("HCLK = %dMHz, ", (hclk + 499999) / 1000000);
+	printk("TCLK = %dMHz\n", (tclk + 499999) / 1000000);
+
+	mv78xx0_setup_cpu_mbus();
+
+#ifdef CONFIG_CACHE_FEROCEON_L2
+	feroceon_l2_init(is_l2_writethrough());
+#endif
+
+	mv78xx0_ge00_shared_data.t_clk = tclk;
+	mv78xx0_ge01_shared_data.t_clk = tclk;
+	mv78xx0_ge10_shared_data.t_clk = tclk;
+	mv78xx0_ge11_shared_data.t_clk = tclk;
+	mv78xx0_uart0_data[0].uartclk = tclk;
+	mv78xx0_uart1_data[0].uartclk = tclk;
+	mv78xx0_uart2_data[0].uartclk = tclk;
+	mv78xx0_uart3_data[0].uartclk = tclk;
+}
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/common.h
@@ -0,0 +1,49 @@
+/*
+ * arch/arm/mach-mv78xx0/common.h
+ *
+ * Core functions for Marvell MV78xx0 SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ARCH_MV78XX0_COMMON_H
+#define __ARCH_MV78XX0_COMMON_H
+
+struct mv643xx_eth_platform_data;
+struct mv_sata_platform_data;
+
+/*
+ * Basic MV78xx0 init functions used early by machine-setup.
+ */
+int mv78xx0_core_index(void);
+void mv78xx0_map_io(void);
+void mv78xx0_init(void);
+void mv78xx0_init_irq(void);
+
+extern struct mbus_dram_target_info mv78xx0_mbus_dram_info;
+void mv78xx0_setup_cpu_mbus(void);
+void mv78xx0_setup_pcie_io_win(int window, u32 base, u32 size,
+			       int maj, int min);
+void mv78xx0_setup_pcie_mem_win(int window, u32 base, u32 size,
+				int maj, int min);
+
+void mv78xx0_ehci0_init(void);
+void mv78xx0_ehci1_init(void);
+void mv78xx0_ehci2_init(void);
+void mv78xx0_ge00_init(struct mv643xx_eth_platform_data *eth_data);
+void mv78xx0_ge01_init(struct mv643xx_eth_platform_data *eth_data);
+void mv78xx0_ge10_init(struct mv643xx_eth_platform_data *eth_data);
+void mv78xx0_ge11_init(struct mv643xx_eth_platform_data *eth_data);
+void mv78xx0_pcie_init(int init_port0, int init_port1);
+void mv78xx0_sata_init(struct mv_sata_platform_data *sata_data);
+void mv78xx0_uart0_init(void);
+void mv78xx0_uart1_init(void);
+void mv78xx0_uart2_init(void);
+void mv78xx0_uart3_init(void);
+
+extern struct sys_timer mv78xx0_timer;
+
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/db78x00-bp-setup.c
@@ -0,0 +1,94 @@
+/*
+ * arch/arm/mach-mv78xx0/db78x00-bp-setup.c
+ *
+ * Marvell DB-78x00-BP Development Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <asm/arch/mv78xx0.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include "common.h"
+
+static struct mv643xx_eth_platform_data db78x00_ge00_data = {
+	.phy_addr	= 8,
+};
+
+static struct mv643xx_eth_platform_data db78x00_ge01_data = {
+	.phy_addr	= 9,
+};
+
+static struct mv643xx_eth_platform_data db78x00_ge10_data = {
+	.phy_addr	= -1,
+};
+
+static struct mv643xx_eth_platform_data db78x00_ge11_data = {
+	.phy_addr	= -1,
+};
+
+static struct mv_sata_platform_data db78x00_sata_data = {
+	.n_ports	= 2,
+};
+
+static void __init db78x00_init(void)
+{
+	/*
+	 * Basic MV78xx0 setup. Needs to be called early.
+	 */
+	mv78xx0_init();
+
+	/*
+	 * Partition on-chip peripherals between the two CPU cores.
+	 */
+	if (mv78xx0_core_index() == 0) {
+		mv78xx0_ehci0_init();
+		mv78xx0_ehci1_init();
+		mv78xx0_ehci2_init();
+		mv78xx0_ge00_init(&db78x00_ge00_data);
+		mv78xx0_ge01_init(&db78x00_ge01_data);
+		mv78xx0_ge10_init(&db78x00_ge10_data);
+		mv78xx0_ge11_init(&db78x00_ge11_data);
+		mv78xx0_sata_init(&db78x00_sata_data);
+		mv78xx0_uart0_init();
+		mv78xx0_uart2_init();
+	} else {
+		mv78xx0_uart1_init();
+		mv78xx0_uart3_init();
+	}
+}
+
+static int __init db78x00_pci_init(void)
+{
+	if (machine_is_db78x00_bp()) {
+		/*
+		 * Assign the x16 PCIe slot on the board to CPU core
+		 * #0, and let CPU core #1 have the four x1 slots.
+		 */
+		if (mv78xx0_core_index() == 0)
+			mv78xx0_pcie_init(0, 1);
+		else
+			mv78xx0_pcie_init(1, 0);
+	}
+
+	return 0;
+}
+subsys_initcall(db78x00_pci_init);
+
+MACHINE_START(DB78X00_BP, "Marvell DB-78x00-BP Development Board")
+	/* Maintainer: Lennert Buytenhek <buytenh@marvell.com> */
+	.phys_io	= MV78XX0_REGS_PHYS_BASE,
+	.io_pg_offst	= ((MV78XX0_REGS_VIRT_BASE) >> 18) & 0xfffc,
+	.boot_params	= 0x00000100,
+	.init_machine	= db78x00_init,
+	.map_io		= mv78xx0_map_io,
+	.init_irq	= mv78xx0_init_irq,
+	.timer		= &mv78xx0_timer,
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/irq.c
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/mach-mv78xx0/irq.c
+ *
+ * MV78xx0 IRQ handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <asm/arch/mv78xx0.h>
+#include <asm/plat-orion/irq.h>
+#include "common.h"
+
+void __init mv78xx0_init_irq(void)
+{
+	orion_irq_init(0, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF));
+	orion_irq_init(32, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF));
+}
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -0,0 +1,312 @@
+/*
+ * arch/arm/mach-mv78xx0/pcie.c
+ *
+ * PCIe functions for Marvell MV78xx0 SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mbus.h>
+#include <asm/mach/pci.h>
+#include <asm/plat-orion/pcie.h>
+#include "common.h"
+
+struct pcie_port {
+	u8			maj;
+	u8			min;
+	u8			root_bus_nr;
+	void __iomem		*base;
+	spinlock_t		conf_lock;
+	char			io_space_name[16];
+	char			mem_space_name[16];
+	struct resource		res[2];
+};
+
+static struct pcie_port pcie_port[8];
+static int num_pcie_ports;
+static struct resource pcie_io_space;
+static struct resource pcie_mem_space;
+
+
+static void __init mv78xx0_pcie_preinit(void)
+{
+	int i;
+	u32 size_each;
+	u32 start;
+	int win;
+
+	pcie_io_space.name = "PCIe I/O Space";
+	pcie_io_space.start = MV78XX0_PCIE_IO_PHYS_BASE(0);
+	pcie_io_space.end =
+		MV78XX0_PCIE_IO_PHYS_BASE(0) + MV78XX0_PCIE_IO_SIZE * 8 - 1;
+	pcie_io_space.flags = IORESOURCE_IO;
+	if (request_resource(&iomem_resource, &pcie_io_space))
+		panic("can't allocate PCIe I/O space");
+
+	pcie_mem_space.name = "PCIe MEM Space";
+	pcie_mem_space.start = MV78XX0_PCIE_MEM_PHYS_BASE;
+	pcie_mem_space.end =
+		MV78XX0_PCIE_MEM_PHYS_BASE + MV78XX0_PCIE_MEM_SIZE - 1;
+	pcie_mem_space.flags = IORESOURCE_MEM;
+	if (request_resource(&iomem_resource, &pcie_mem_space))
+		panic("can't allocate PCIe MEM space");
+
+	for (i = 0; i < num_pcie_ports; i++) {
+		struct pcie_port *pp = pcie_port + i;
+
+		snprintf(pp->io_space_name, sizeof(pp->io_space_name),
+			"PCIe %d.%d I/O", pp->maj, pp->min);
+		pp->io_space_name[sizeof(pp->io_space_name) - 1] = 0;
+		pp->res[0].name = pp->io_space_name;
+		pp->res[0].start = MV78XX0_PCIE_IO_PHYS_BASE(i);
+		pp->res[0].end = pp->res[0].start + MV78XX0_PCIE_IO_SIZE - 1;
+		pp->res[0].flags = IORESOURCE_IO;
+
+		snprintf(pp->mem_space_name, sizeof(pp->mem_space_name),
+			"PCIe %d.%d MEM", pp->maj, pp->min);
+		pp->mem_space_name[sizeof(pp->mem_space_name) - 1] = 0;
+		pp->res[1].name = pp->mem_space_name;
+		pp->res[1].flags = IORESOURCE_MEM;
+	}
+
+	switch (num_pcie_ports) {
+	case 0:
+		size_each = 0;
+		break;
+
+	case 1:
+		size_each = 0x30000000;
+		break;
+
+	case 2 ... 3:
+		size_each = 0x10000000;
+		break;
+
+	case 4 ... 6:
+		size_each = 0x08000000;
+		break;
+
+	case 7:
+		size_each = 0x04000000;
+		break;
+
+	default:
+		panic("invalid number of PCIe ports");
+	}
+
+	start = MV78XX0_PCIE_MEM_PHYS_BASE;
+	for (i = 0; i < num_pcie_ports; i++) {
+		struct pcie_port *pp = pcie_port + i;
+
+		pp->res[1].start = start;
+		pp->res[1].end = start + size_each - 1;
+		start += size_each;
+	}
+
+	for (i = 0; i < num_pcie_ports; i++) {
+		struct pcie_port *pp = pcie_port + i;
+
+		if (request_resource(&pcie_io_space, &pp->res[0]))
+			panic("can't allocate PCIe I/O sub-space");
+
+		if (request_resource(&pcie_mem_space, &pp->res[1]))
+			panic("can't allocate PCIe MEM sub-space");
+	}
+
+	win = 0;
+	for (i = 0; i < num_pcie_ports; i++) {
+		struct pcie_port *pp = pcie_port + i;
+
+		mv78xx0_setup_pcie_io_win(win++, pp->res[0].start,
+			pp->res[0].end - pp->res[0].start + 1,
+			pp->maj, pp->min);
+
+		mv78xx0_setup_pcie_mem_win(win++, pp->res[1].start,
+			pp->res[1].end - pp->res[1].start + 1,
+			pp->maj, pp->min);
+	}
+}
+
+static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct pcie_port *pp;
+
+	if (nr >= num_pcie_ports)
+		return 0;
+
+	pp = &pcie_port[nr];
+	pp->root_bus_nr = sys->busnr;
+
+	/*
+	 * Generic PCIe unit setup.
+	 */
+	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
+	orion_pcie_setup(pp->base, &mv78xx0_mbus_dram_info);
+
+	sys->resource[0] = &pp->res[0];
+	sys->resource[1] = &pp->res[1];
+	sys->resource[2] = NULL;
+
+	return 1;
+}
+
+static struct pcie_port *bus_to_port(int bus)
+{
+	int i;
+
+	for (i = num_pcie_ports - 1; i >= 0; i--) {
+		int rbus = pcie_port[i].root_bus_nr;
+		if (rbus != -1 && rbus <= bus)
+			break;
+	}
+
+	return i >= 0 ? pcie_port + i : NULL;
+}
+
+static int pcie_valid_config(struct pcie_port *pp, int bus, int dev)
+{
+	/*
+	 * Don't go out when trying to access nonexisting devices
+	 * on the local bus.
+	 */
+	if (bus == pp->root_bus_nr && dev > 1)
+		return 0;
+
+	return 1;
+}
+
+static int pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+			int size, u32 *val)
+{
+	struct pcie_port *pp = bus_to_port(bus->number);
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	spin_lock_irqsave(&pp->conf_lock, flags);
+	ret = orion_pcie_rd_conf(pp->base, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&pp->conf_lock, flags);
+
+	return ret;
+}
+
+static int pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+			int where, int size, u32 val)
+{
+	struct pcie_port *pp = bus_to_port(bus->number);
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&pp->conf_lock, flags);
+	ret = orion_pcie_wr_conf(pp->base, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&pp->conf_lock, flags);
+
+	return ret;
+}
+
+static struct pci_ops pcie_ops = {
+	.read = pcie_rd_conf,
+	.write = pcie_wr_conf,
+};
+
+static void __devinit rc_pci_fixup(struct pci_dev *dev)
+{
+	/*
+	 * Prevent enumeration of root complex.
+	 */
+	if (dev->bus->parent == NULL && dev->devfn == 0) {
+		int i;
+
+		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+			dev->resource[i].start = 0;
+			dev->resource[i].end   = 0;
+			dev->resource[i].flags = 0;
+		}
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
+
+static struct pci_bus __init *
+mv78xx0_pcie_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_bus *bus;
+
+	if (nr < num_pcie_ports) {
+		bus = pci_scan_bus(sys->busnr, &pcie_ops, sys);
+	} else {
+		bus = NULL;
+		BUG();
+	}
+
+	return bus;
+}
+
+static int __init mv78xx0_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	struct pcie_port *pp = bus_to_port(dev->bus->number);
+
+	return IRQ_MV78XX0_PCIE_00 + (pp->maj << 2) + pp->min;
+}
+
+static struct hw_pci mv78xx0_pci __initdata = {
+	.nr_controllers	= 8,
+	.preinit	= mv78xx0_pcie_preinit,
+	.swizzle	= pci_std_swizzle,
+	.setup		= mv78xx0_pcie_setup,
+	.scan		= mv78xx0_pcie_scan_bus,
+	.map_irq	= mv78xx0_pcie_map_irq,
+};
+
+static void __init add_pcie_port(int maj, int min, unsigned long base)
+{
+	printk(KERN_INFO "MV78xx0 PCIe port %d.%d: ", maj, min);
+
+	if (orion_pcie_link_up((void __iomem *)base)) {
+		struct pcie_port *pp = &pcie_port[num_pcie_ports++];
+
+		printk("link up\n");
+
+		pp->maj = maj;
+		pp->min = min;
+		pp->root_bus_nr = -1;
+		pp->base = (void __iomem *)base;
+		spin_lock_init(&pp->conf_lock);
+		memset(pp->res, 0, sizeof(pp->res));
+	} else {
+		printk("link down, ignoring\n");
+	}
+}
+
+void __init mv78xx0_pcie_init(int init_port0, int init_port1)
+{
+	if (init_port0) {
+		add_pcie_port(0, 0, PCIE00_VIRT_BASE);
+		if (!orion_pcie_x4_mode((void __iomem *)PCIE00_VIRT_BASE)) {
+			add_pcie_port(0, 1, PCIE01_VIRT_BASE);
+			add_pcie_port(0, 2, PCIE02_VIRT_BASE);
+			add_pcie_port(0, 3, PCIE03_VIRT_BASE);
+		}
+	}
+
+	if (init_port1) {
+		add_pcie_port(1, 0, PCIE10_VIRT_BASE);
+		if (!orion_pcie_x4_mode((void __iomem *)PCIE10_VIRT_BASE)) {
+			add_pcie_port(1, 1, PCIE11_VIRT_BASE);
+			add_pcie_port(1, 2, PCIE12_VIRT_BASE);
+			add_pcie_port(1, 3, PCIE13_VIRT_BASE);
+		}
+	}
+
+	pci_common_init(&mv78xx0_pci);
+}
--- a/arch/arm/mach-orion5x/Kconfig
+++ b/arch/arm/mach-orion5x/Kconfig
@@ -44,6 +44,36 @@
 	  Buffalo Linkstation Pro/Live platform. Both v1 and
 	  v2 devices are supported.
 
+config MACH_TS409
+	bool "QNAP TS-409"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  QNAP TS-409 platform.
+
+config MACH_WRT350N_V2
+	bool "Linksys WRT350N v2"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Linksys WRT350N v2 platform.
+
+config MACH_TS78XX
+	bool "Technologic Systems TS-78xx"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Technologic Systems TS-78xx platform.
+
+config MACH_MV2120
+	bool "HP Media Vault mv2120"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  HP Media Vault mv2120 or mv5100.
+
+config MACH_MSS2
+	bool "Maxtor Shared Storage II"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Maxtor Shared Storage II platform.
+
 endmenu
 
 endif
--- a/arch/arm/mach-orion5x/Makefile
+++ b/arch/arm/mach-orion5x/Makefile
@@ -1,7 +1,12 @@
-obj-y				+= common.o addr-map.o pci.o gpio.o irq.o
+obj-y				+= common.o addr-map.o pci.o gpio.o irq.o mpp.o
 obj-$(CONFIG_MACH_DB88F5281)	+= db88f5281-setup.o
 obj-$(CONFIG_MACH_RD88F5182)	+= rd88f5182-setup.o
 obj-$(CONFIG_MACH_KUROBOX_PRO)	+= kurobox_pro-setup.o
 obj-$(CONFIG_MACH_LINKSTATION_PRO) += kurobox_pro-setup.o
 obj-$(CONFIG_MACH_DNS323)	+= dns323-setup.o
-obj-$(CONFIG_MACH_TS209)	+= ts209-setup.o
+obj-$(CONFIG_MACH_TS209)	+= ts209-setup.o tsx09-common.o
+obj-$(CONFIG_MACH_TS409)	+= ts409-setup.o tsx09-common.o
+obj-$(CONFIG_MACH_WRT350N_V2)	+= wrt350n-v2-setup.o
+obj-$(CONFIG_MACH_TS78XX)	+= ts78xx-setup.o
+obj-$(CONFIG_MACH_MV2120)	+= mv2120-setup.o
+obj-$(CONFIG_MACH_MSS2)		+= mss2-setup.o
--- a/arch/arm/mach-orion5x/addr-map.c
+++ b/arch/arm/mach-orion5x/addr-map.c
@@ -70,6 +70,7 @@
 
 
 struct mbus_dram_target_info orion5x_mbus_dram_info;
+static int __initdata win_alloc_count;
 
 static int __init orion5x_cpu_win_can_remap(int win)
 {
@@ -87,16 +88,22 @@
 static void __init setup_cpu_win(int win, u32 base, u32 size,
 				 u8 target, u8 attr, int remap)
 {
-	orion5x_write(CPU_WIN_BASE(win), base & 0xffff0000);
-	orion5x_write(CPU_WIN_CTRL(win),
-		((size - 1) & 0xffff0000) | (attr << 8) | (target << 4) | 1);
+	if (win >= 8) {
+		printk(KERN_ERR "setup_cpu_win: trying to allocate "
+				"window %d\n", win);
+		return;
+	}
+
+	writel(base & 0xffff0000, CPU_WIN_BASE(win));
+	writel(((size - 1) & 0xffff0000) | (attr << 8) | (target << 4) | 1,
+		CPU_WIN_CTRL(win));
 
 	if (orion5x_cpu_win_can_remap(win)) {
 		if (remap < 0)
 			remap = base;
 
-		orion5x_write(CPU_WIN_REMAP_LO(win), remap & 0xffff0000);
-		orion5x_write(CPU_WIN_REMAP_HI(win), 0);
+		writel(remap & 0xffff0000, CPU_WIN_REMAP_LO(win));
+		writel(0, CPU_WIN_REMAP_HI(win));
 	}
 }
 
@@ -109,11 +116,11 @@
 	 * First, disable and clear windows.
 	 */
 	for (i = 0; i < 8; i++) {
-		orion5x_write(CPU_WIN_BASE(i), 0);
-		orion5x_write(CPU_WIN_CTRL(i), 0);
+		writel(0, CPU_WIN_BASE(i));
+		writel(0, CPU_WIN_CTRL(i));
 		if (orion5x_cpu_win_can_remap(i)) {
-			orion5x_write(CPU_WIN_REMAP_LO(i), 0);
-			orion5x_write(CPU_WIN_REMAP_HI(i), 0);
+			writel(0, CPU_WIN_REMAP_LO(i));
+			writel(0, CPU_WIN_REMAP_HI(i));
 		}
 	}
 
@@ -128,6 +135,7 @@
 		TARGET_PCIE, ATTR_PCIE_MEM, -1);
 	setup_cpu_win(3, ORION5X_PCI_MEM_PHYS_BASE, ORION5X_PCI_MEM_SIZE,
 		TARGET_PCI, ATTR_PCI_MEM, -1);
+	win_alloc_count = 4;
 
 	/*
 	 * Setup MBUS dram target info.
@@ -147,8 +155,8 @@
 			w = &orion5x_mbus_dram_info.cs[cs++];
 			w->cs_index = i;
 			w->mbus_attr = 0xf & ~(1 << i);
-			w->base = base & 0xff000000;
-			w->size = (size | 0x00ffffff) + 1;
+			w->base = base & 0xffff0000;
+			w->size = (size | 0x0000ffff) + 1;
 		}
 	}
 	orion5x_mbus_dram_info.num_cs = cs;
@@ -156,25 +164,30 @@
 
 void __init orion5x_setup_dev_boot_win(u32 base, u32 size)
 {
-	setup_cpu_win(4, base, size, TARGET_DEV_BUS, ATTR_DEV_BOOT, -1);
+	setup_cpu_win(win_alloc_count++, base, size,
+		      TARGET_DEV_BUS, ATTR_DEV_BOOT, -1);
 }
 
 void __init orion5x_setup_dev0_win(u32 base, u32 size)
 {
-	setup_cpu_win(5, base, size, TARGET_DEV_BUS, ATTR_DEV_CS0, -1);
+	setup_cpu_win(win_alloc_count++, base, size,
+		      TARGET_DEV_BUS, ATTR_DEV_CS0, -1);
 }
 
 void __init orion5x_setup_dev1_win(u32 base, u32 size)
 {
-	setup_cpu_win(6, base, size, TARGET_DEV_BUS, ATTR_DEV_CS1, -1);
+	setup_cpu_win(win_alloc_count++, base, size,
+		      TARGET_DEV_BUS, ATTR_DEV_CS1, -1);
 }
 
 void __init orion5x_setup_dev2_win(u32 base, u32 size)
 {
-	setup_cpu_win(7, base, size, TARGET_DEV_BUS, ATTR_DEV_CS2, -1);
+	setup_cpu_win(win_alloc_count++, base, size,
+		      TARGET_DEV_BUS, ATTR_DEV_CS2, -1);
 }
 
 void __init orion5x_setup_pcie_wa_win(u32 base, u32 size)
 {
-	setup_cpu_win(7, base, size, TARGET_PCIE, ATTR_PCIE_WA, -1);
+	setup_cpu_win(win_alloc_count++, base, size,
+		      TARGET_PCIE, ATTR_PCIE_WA, -1);
 }
--- a/arch/arm/mach-orion5x/common.c
+++ b/arch/arm/mach-orion5x/common.c
@@ -39,25 +39,22 @@
 		.virtual	= ORION5X_REGS_VIRT_BASE,
 		.pfn		= __phys_to_pfn(ORION5X_REGS_PHYS_BASE),
 		.length		= ORION5X_REGS_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
+		.type		= MT_DEVICE,
+	}, {
 		.virtual	= ORION5X_PCIE_IO_VIRT_BASE,
 		.pfn		= __phys_to_pfn(ORION5X_PCIE_IO_PHYS_BASE),
 		.length		= ORION5X_PCIE_IO_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
+		.type		= MT_DEVICE,
+	}, {
 		.virtual	= ORION5X_PCI_IO_VIRT_BASE,
 		.pfn		= __phys_to_pfn(ORION5X_PCI_IO_PHYS_BASE),
 		.length		= ORION5X_PCI_IO_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
+		.type		= MT_DEVICE,
+	}, {
 		.virtual	= ORION5X_PCIE_WA_VIRT_BASE,
 		.pfn		= __phys_to_pfn(ORION5X_PCIE_WA_PHYS_BASE),
 		.length		= ORION5X_PCIE_WA_SIZE,
-		.type		= MT_DEVICE
+		.type		= MT_DEVICE,
 	},
 };
 
@@ -66,101 +63,32 @@
 	iotable_init(orion5x_io_desc, ARRAY_SIZE(orion5x_io_desc));
 }
 
+
 /*****************************************************************************
- * UART
+ * EHCI
  ****************************************************************************/
-
-static struct resource orion5x_uart_resources[] = {
-	{
-		.start		= UART0_PHYS_BASE,
-		.end		= UART0_PHYS_BASE + 0xff,
-		.flags		= IORESOURCE_MEM,
-	},
-	{
-		.start		= IRQ_ORION5X_UART0,
-		.end		= IRQ_ORION5X_UART0,
-		.flags		= IORESOURCE_IRQ,
-	},
-	{
-		.start		= UART1_PHYS_BASE,
-		.end		= UART1_PHYS_BASE + 0xff,
-		.flags		= IORESOURCE_MEM,
-	},
-	{
-		.start		= IRQ_ORION5X_UART1,
-		.end		= IRQ_ORION5X_UART1,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct plat_serial8250_port orion5x_uart_data[] = {
-	{
-		.mapbase	= UART0_PHYS_BASE,
-		.membase	= (char *)UART0_VIRT_BASE,
-		.irq		= IRQ_ORION5X_UART0,
-		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-		.uartclk	= ORION5X_TCLK,
-	},
-	{
-		.mapbase	= UART1_PHYS_BASE,
-		.membase	= (char *)UART1_VIRT_BASE,
-		.irq		= IRQ_ORION5X_UART1,
-		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-		.uartclk	= ORION5X_TCLK,
-	},
-	{ },
+static struct orion_ehci_data orion5x_ehci_data = {
+	.dram		= &orion5x_mbus_dram_info,
 };
 
-static struct platform_device orion5x_uart = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= orion5x_uart_data,
-	},
-	.resource		= orion5x_uart_resources,
-	.num_resources		= ARRAY_SIZE(orion5x_uart_resources),
-};
+static u64 ehci_dmamask = 0xffffffffUL;
 
-/*******************************************************************************
- * USB Controller - 2 interfaces
- ******************************************************************************/
 
+/*****************************************************************************
+ * EHCI0
+ ****************************************************************************/
 static struct resource orion5x_ehci0_resources[] = {
 	{
 		.start	= ORION5X_USB0_PHYS_BASE,
 		.end	= ORION5X_USB0_PHYS_BASE + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM,
-	},
-	{
+	}, {
 		.start	= IRQ_ORION5X_USB0_CTRL,
 		.end	= IRQ_ORION5X_USB0_CTRL,
 		.flags	= IORESOURCE_IRQ,
 	},
 };
 
-static struct resource orion5x_ehci1_resources[] = {
-	{
-		.start	= ORION5X_USB1_PHYS_BASE,
-		.end	= ORION5X_USB1_PHYS_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= IRQ_ORION5X_USB1_CTRL,
-		.end	= IRQ_ORION5X_USB1_CTRL,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct orion_ehci_data orion5x_ehci_data = {
-	.dram		= &orion5x_mbus_dram_info,
-};
-
-static u64 ehci_dmamask = 0xffffffffUL;
-
 static struct platform_device orion5x_ehci0 = {
 	.name		= "orion-ehci",
 	.id		= 0,
@@ -173,6 +101,27 @@
 	.num_resources	= ARRAY_SIZE(orion5x_ehci0_resources),
 };
 
+void __init orion5x_ehci0_init(void)
+{
+	platform_device_register(&orion5x_ehci0);
+}
+
+
+/*****************************************************************************
+ * EHCI1
+ ****************************************************************************/
+static struct resource orion5x_ehci1_resources[] = {
+	{
+		.start	= ORION5X_USB1_PHYS_BASE,
+		.end	= ORION5X_USB1_PHYS_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_ORION5X_USB1_CTRL,
+		.end	= IRQ_ORION5X_USB1_CTRL,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
 static struct platform_device orion5x_ehci1 = {
 	.name		= "orion-ehci",
 	.id		= 1,
@@ -185,11 +134,15 @@
 	.num_resources	= ARRAY_SIZE(orion5x_ehci1_resources),
 };
 
+void __init orion5x_ehci1_init(void)
+{
+	platform_device_register(&orion5x_ehci1);
+}
+
+
 /*****************************************************************************
- * Gigabit Ethernet port
- * (The Orion and Discovery (MV643xx) families use the same Ethernet driver)
+ * GigE
  ****************************************************************************/
-
 struct mv643xx_eth_shared_platform_data orion5x_eth_shared_data = {
 	.dram		= &orion5x_mbus_dram_info,
 	.t_clk		= ORION5X_TCLK,
@@ -219,7 +172,7 @@
 		.start	= IRQ_ORION5X_ETH_SUM,
 		.end	= IRQ_ORION5X_ETH_SUM,
 		.flags	= IORESOURCE_IRQ,
-	}
+	},
 };
 
 static struct platform_device orion5x_eth = {
@@ -238,11 +191,10 @@
 	platform_device_register(&orion5x_eth);
 }
 
+
 /*****************************************************************************
- * I2C controller
- * (The Orion and Discovery (MV643xx) families share the same I2C controller)
+ * I2C
  ****************************************************************************/
-
 static struct mv64xxx_i2c_pdata orion5x_i2c_pdata = {
 	.freq_m		= 8, /* assumes 166 MHz TCLK */
 	.freq_n		= 3,
@@ -251,16 +203,15 @@
 
 static struct resource orion5x_i2c_resources[] = {
 	{
-		.name   = "i2c base",
-		.start  = I2C_PHYS_BASE,
-		.end    = I2C_PHYS_BASE + 0x20 -1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.name   = "i2c irq",
-		.start  = IRQ_ORION5X_I2C,
-		.end    = IRQ_ORION5X_I2C,
-		.flags  = IORESOURCE_IRQ,
+		.name	= "i2c base",
+		.start	= I2C_PHYS_BASE,
+		.end	= I2C_PHYS_BASE + 0x1f,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "i2c irq",
+		.start	= IRQ_ORION5X_I2C,
+		.end	= IRQ_ORION5X_I2C,
+		.flags	= IORESOURCE_IRQ,
 	},
 };
 
@@ -270,36 +221,41 @@
 	.num_resources	= ARRAY_SIZE(orion5x_i2c_resources),
 	.resource	= orion5x_i2c_resources,
 	.dev		= {
-		.platform_data = &orion5x_i2c_pdata,
+		.platform_data	= &orion5x_i2c_pdata,
 	},
 };
 
+void __init orion5x_i2c_init(void)
+{
+	platform_device_register(&orion5x_i2c);
+}
+
+
 /*****************************************************************************
- * Sata port
+ * SATA
  ****************************************************************************/
 static struct resource orion5x_sata_resources[] = {
-        {
-                .name   = "sata base",
-                .start  = ORION5X_SATA_PHYS_BASE,
-                .end    = ORION5X_SATA_PHYS_BASE + 0x5000 - 1,
-                .flags  = IORESOURCE_MEM,
-        },
 	{
-                .name   = "sata irq",
-                .start  = IRQ_ORION5X_SATA,
-                .end    = IRQ_ORION5X_SATA,
-                .flags  = IORESOURCE_IRQ,
-        },
+		.name	= "sata base",
+		.start	= ORION5X_SATA_PHYS_BASE,
+		.end	= ORION5X_SATA_PHYS_BASE + 0x5000 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "sata irq",
+		.start	= IRQ_ORION5X_SATA,
+		.end	= IRQ_ORION5X_SATA,
+		.flags	= IORESOURCE_IRQ,
+	},
 };
 
 static struct platform_device orion5x_sata = {
-	.name           = "sata_mv",
-	.id             = 0,
+	.name		= "sata_mv",
+	.id		= 0,
 	.dev		= {
 		.coherent_dma_mask	= 0xffffffff,
 	},
-	.num_resources  = ARRAY_SIZE(orion5x_sata_resources),
-	.resource       = orion5x_sata_resources,
+	.num_resources	= ARRAY_SIZE(orion5x_sata_resources),
+	.resource	= orion5x_sata_resources,
 };
 
 void __init orion5x_sata_init(struct mv_sata_platform_data *sata_data)
@@ -309,23 +265,111 @@
 	platform_device_register(&orion5x_sata);
 }
 
+
 /*****************************************************************************
- * Time handling
+ * UART0
+ ****************************************************************************/
+static struct plat_serial8250_port orion5x_uart0_data[] = {
+	{
+		.mapbase	= UART0_PHYS_BASE,
+		.membase	= (char *)UART0_VIRT_BASE,
+		.irq		= IRQ_ORION5X_UART0,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= ORION5X_TCLK,
+	}, {
+	},
+};
+
+static struct resource orion5x_uart0_resources[] = {
+	{
+		.start		= UART0_PHYS_BASE,
+		.end		= UART0_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_ORION5X_UART0,
+		.end		= IRQ_ORION5X_UART0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device orion5x_uart0 = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev			= {
+		.platform_data	= orion5x_uart0_data,
+	},
+	.resource		= orion5x_uart0_resources,
+	.num_resources		= ARRAY_SIZE(orion5x_uart0_resources),
+};
+
+void __init orion5x_uart0_init(void)
+{
+	platform_device_register(&orion5x_uart0);
+}
+
+
+/*****************************************************************************
+ * UART1
  ****************************************************************************/
+static struct plat_serial8250_port orion5x_uart1_data[] = {
+	{
+		.mapbase	= UART1_PHYS_BASE,
+		.membase	= (char *)UART1_VIRT_BASE,
+		.irq		= IRQ_ORION5X_UART1,
+		.flags		= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= ORION5X_TCLK,
+	}, {
+	},
+};
+
+static struct resource orion5x_uart1_resources[] = {
+	{
+		.start		= UART1_PHYS_BASE,
+		.end		= UART1_PHYS_BASE + 0xff,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_ORION5X_UART1,
+		.end		= IRQ_ORION5X_UART1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device orion5x_uart1 = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM1,
+	.dev			= {
+		.platform_data	= orion5x_uart1_data,
+	},
+	.resource		= orion5x_uart1_resources,
+	.num_resources		= ARRAY_SIZE(orion5x_uart1_resources),
+};
+
+void __init orion5x_uart1_init(void)
+{
+	platform_device_register(&orion5x_uart1);
+}
+
 
+/*****************************************************************************
+ * Time handling
+ ****************************************************************************/
 static void orion5x_timer_init(void)
 {
 	orion_time_init(IRQ_ORION5X_BRIDGE, ORION5X_TCLK);
 }
 
 struct sys_timer orion5x_timer = {
-        .init = orion5x_timer_init,
+	.init = orion5x_timer_init,
 };
 
+
 /*****************************************************************************
  * General
  ****************************************************************************/
-
 /*
  * Identify device ID and rev from PCIe configuration header space '0'.
  */
@@ -350,8 +394,10 @@
 	} else if (*dev == MV88F5181_DEV_ID) {
 		if (*rev == MV88F5181_REV_B1) {
 			*dev_name = "MV88F5181-Rev-B1";
+		} else if (*rev == MV88F5181L_REV_A1) {
+			*dev_name = "MV88F5181L-Rev-A1";
 		} else {
-			*dev_name = "MV88F5181-Rev-Unsupported";
+			*dev_name = "MV88F5181(L)-Rev-Unsupported";
 		}
 	} else {
 		*dev_name = "Device-Unknown";
@@ -370,15 +416,6 @@
 	 * Setup Orion address map
 	 */
 	orion5x_setup_cpu_mbus_bridge();
-
-	/*
-	 * Register devices.
-	 */
-	platform_device_register(&orion5x_uart);
-	platform_device_register(&orion5x_ehci0);
-	if (dev == MV88F5182_DEV_ID)
-		platform_device_register(&orion5x_ehci1);
-	platform_device_register(&orion5x_i2c);
 }
 
 /*
--- a/arch/arm/mach-orion5x/common.h
+++ b/arch/arm/mach-orion5x/common.h
@@ -1,10 +1,12 @@
 #ifndef __ARCH_ORION5X_COMMON_H
 #define __ARCH_ORION5X_COMMON_H
 
+struct mv643xx_eth_platform_data;
+struct mv_sata_platform_data;
+
 /*
  * Basic Orion init functions used early by machine-setup.
  */
-
 void orion5x_map_io(void);
 void orion5x_init_irq(void);
 void orion5x_init(void);
@@ -23,13 +25,19 @@
 void orion5x_setup_dev2_win(u32 base, u32 size);
 void orion5x_setup_pcie_wa_win(u32 base, u32 size);
 
+void orion5x_ehci0_init(void);
+void orion5x_ehci1_init(void);
+void orion5x_eth_init(struct mv643xx_eth_platform_data *eth_data);
+void orion5x_i2c_init(void);
+void orion5x_sata_init(struct mv_sata_platform_data *sata_data);
+void orion5x_uart0_init(void);
+void orion5x_uart1_init(void);
+
 /*
- * Shared code used internally by other Orion core functions.
- * (/mach-orion/pci.c)
+ * PCIe/PCI functions.
  */
-
-struct pci_sys_data;
 struct pci_bus;
+struct pci_sys_data;
 
 void orion5x_pcie_id(u32 *dev, u32 *rev);
 int orion5x_pci_sys_setup(int nr, struct pci_sys_data *sys);
@@ -40,26 +48,9 @@
  * Valid GPIO pins according to MPP setup, used by machine-setup.
  * (/mach-orion/gpio.c).
  */
-
-void orion5x_gpio_set_valid_pins(u32 pins);
+void orion5x_gpio_set_valid(unsigned pin, int valid);
 void gpio_display(void);	/* debug */
 
-/*
- * Pull in Orion Ethernet platform_data, used by machine-setup
- */
-
-struct mv643xx_eth_platform_data;
-
-void orion5x_eth_init(struct mv643xx_eth_platform_data *eth_data);
-
-/*
- * Orion Sata platform_data, used by machine-setup
- */
-
-struct mv_sata_platform_data;
-
-void orion5x_sata_init(struct mv_sata_platform_data *sata_data);
-
 struct machine_desc;
 struct meminfo;
 struct tag;
--- a/arch/arm/mach-orion5x/db88f5281-setup.c
+++ b/arch/arm/mach-orion5x/db88f5281-setup.c
@@ -27,6 +27,7 @@
 #include <asm/arch/orion5x.h>
 #include <asm/plat-orion/orion_nand.h>
 #include "common.h"
+#include "mpp.h"
 
 /*****************************************************************************
  * DB-88F5281 on board devices
@@ -86,7 +87,7 @@
 	.name		= "physmap-flash",
 	.id		= 0,
 	.dev		= {
-		.platform_data = &db88f5281_boot_flash_data,
+		.platform_data	= &db88f5281_boot_flash_data,
 	},
 	.num_resources	= 1,
 	.resource	= &db88f5281_boot_flash_resource,
@@ -110,7 +111,7 @@
 	.name		= "physmap-flash",
 	.id		= 1,
 	.dev		= {
-		.platform_data = &db88f5281_nor_flash_data,
+		.platform_data	= &db88f5281_nor_flash_data,
 	},
 	.num_resources	= 1,
 	.resource	= &db88f5281_nor_flash_resource,
@@ -125,18 +126,15 @@
 		.name = "kernel",
 		.offset = 0,
 		.size = SZ_2M,
-	},
-	{
+	}, {
 		.name = "root",
 		.offset = SZ_2M,
 		.size = (SZ_16M - SZ_2M),
-	},
-	{
+	}, {
 		.name = "user",
 		.offset = SZ_16M,
 		.size = SZ_8M,
-	},
-	{
+	}, {
 		.name = "recovery",
 		.offset = (SZ_16M + SZ_8M),
 		.size = SZ_8M,
@@ -288,7 +286,6 @@
  ****************************************************************************/
 static struct mv643xx_eth_platform_data db88f5281_eth_data = {
 	.phy_addr	= 8,
-	.force_phy_addr = 1,
 };
 
 /*****************************************************************************
@@ -301,11 +298,28 @@
 /*****************************************************************************
  * General Setup
  ****************************************************************************/
-
-static struct platform_device *db88f5281_devs[] __initdata = {
-	&db88f5281_boot_flash,
-	&db88f5281_nor_flash,
-	&db88f5281_nand_flash,
+static struct orion5x_mpp_mode db88f5281_mpp_modes[] __initdata = {
+	{  0, MPP_GPIO },		/* USB Over Current */
+	{  1, MPP_GPIO },		/* USB Vbat input */
+	{  2, MPP_PCI_ARB },		/* PCI_REQn[2] */
+	{  3, MPP_PCI_ARB },		/* PCI_GNTn[2] */
+	{  4, MPP_PCI_ARB },		/* PCI_REQn[3] */
+	{  5, MPP_PCI_ARB },		/* PCI_GNTn[3] */
+	{  6, MPP_GPIO },		/* JP0, CON17.2 */
+	{  7, MPP_GPIO },		/* JP1, CON17.1 */
+	{  8, MPP_GPIO },		/* JP2, CON11.2 */
+	{  9, MPP_GPIO },		/* JP3, CON11.3 */
+	{ 10, MPP_GPIO },		/* RTC int */
+	{ 11, MPP_GPIO },		/* Baud Rate Generator */
+	{ 12, MPP_GPIO },		/* PCI int 1 */
+	{ 13, MPP_GPIO },		/* PCI int 2 */
+	{ 14, MPP_NAND },		/* NAND_REn[2] */
+	{ 15, MPP_NAND },		/* NAND_WEn[2] */
+	{ 16, MPP_UART },		/* UART1_RX */
+	{ 17, MPP_UART },		/* UART1_TX */
+	{ 18, MPP_UART },		/* UART1_CTSn */
+	{ 19, MPP_UART },		/* UART1_RTSn */
+	{ -1 },
 };
 
 static void __init db88f5281_init(void)
@@ -315,39 +329,31 @@
 	 */
 	orion5x_init();
 
+	orion5x_mpp_conf(db88f5281_mpp_modes);
+	writel(0, MPP_DEV_CTRL);		/* DEV_D[31:16] */
+
 	/*
-	 * Setup the CPU address decode windows for our on-board devices
+	 * Configure peripherals.
 	 */
+	orion5x_ehci0_init();
+	orion5x_eth_init(&db88f5281_eth_data);
+	orion5x_i2c_init();
+	orion5x_uart0_init();
+	orion5x_uart1_init();
+
 	orion5x_setup_dev_boot_win(DB88F5281_NOR_BOOT_BASE,
 				DB88F5281_NOR_BOOT_SIZE);
+	platform_device_register(&db88f5281_boot_flash);
+
 	orion5x_setup_dev0_win(DB88F5281_7SEG_BASE, DB88F5281_7SEG_SIZE);
-	orion5x_setup_dev1_win(DB88F5281_NOR_BASE, DB88F5281_NOR_SIZE);
-	orion5x_setup_dev2_win(DB88F5281_NAND_BASE, DB88F5281_NAND_SIZE);
 
-	/*
-	 * Setup Multiplexing Pins:
-	 * MPP0: GPIO (USB Over Current)	MPP1: GPIO (USB Vbat input)
-	 * MPP2: PCI_REQn[2]			MPP3: PCI_GNTn[2]
-	 * MPP4: PCI_REQn[3]			MPP5: PCI_GNTn[3]
-	 * MPP6: GPIO (JP0, CON17.2)		MPP7: GPIO (JP1, CON17.1)
-	 * MPP8: GPIO (JP2, CON11.2)		MPP9: GPIO (JP3, CON11.3)
-	 * MPP10: GPIO (RTC int)		MPP11: GPIO (Baud Rate Generator)
-	 * MPP12: GPIO (PCI int 1)		MPP13: GPIO (PCI int 2)
-	 * MPP14: NAND_REn[2]			MPP15: NAND_WEn[2]
-	 * MPP16: UART1_RX			MPP17: UART1_TX
-	 * MPP18: UART1_CTS			MPP19: UART1_RTS
-	 * MPP-DEV: DEV_D[16:31]
-	 */
-	orion5x_write(MPP_0_7_CTRL, 0x00222203);
-	orion5x_write(MPP_8_15_CTRL, 0x44000000);
-	orion5x_write(MPP_16_19_CTRL, 0);
-	orion5x_write(MPP_DEV_CTRL, 0);
+	orion5x_setup_dev1_win(DB88F5281_NOR_BASE, DB88F5281_NOR_SIZE);
+	platform_device_register(&db88f5281_nor_flash);
 
-	orion5x_gpio_set_valid_pins(0x00003fc3);
+	orion5x_setup_dev2_win(DB88F5281_NAND_BASE, DB88F5281_NAND_SIZE);
+	platform_device_register(&db88f5281_nand_flash);
 
-	platform_add_devices(db88f5281_devs, ARRAY_SIZE(db88f5281_devs));
 	i2c_register_board_info(0, &db88f5281_i2c_rtc, 1);
-	orion5x_eth_init(&db88f5281_eth_data);
 }
 
 MACHINE_START(DB88F5281, "Marvell Orion-2 Development Board")
--- a/arch/arm/mach-orion5x/dns323-setup.c
+++ b/arch/arm/mach-orion5x/dns323-setup.c
@@ -27,6 +27,7 @@
 #include <asm/mach/pci.h>
 #include <asm/arch/orion5x.h>
 #include "common.h"
+#include "mpp.h"
 
 #define DNS323_GPIO_LED_RIGHT_AMBER	1
 #define DNS323_GPIO_LED_LEFT_AMBER	2
@@ -52,8 +53,6 @@
 	if (irq != -1)
 		return irq;
 
-	pr_err("%s: requested mapping for unknown device\n", __func__);
-
 	return -1;
 }
 
@@ -81,7 +80,6 @@
 
 static struct mv643xx_eth_platform_data dns323_eth_data = {
 	.phy_addr = 8,
-	.force_phy_addr = 1,
 };
 
 /****************************************************************************
@@ -119,7 +117,7 @@
 		.name	= "u-boot",
 		.size	= 0x00030000,
 		.offset	= 0x007d0000,
-	}
+	},
 };
 
 static struct physmap_flash_data dns323_nor_flash_data = {
@@ -137,7 +135,9 @@
 static struct platform_device dns323_nor_flash = {
 	.name		= "physmap-flash",
 	.id		= 0,
-	.dev		= { .platform_data = &dns323_nor_flash_data, },
+	.dev		= {
+		.platform_data	= &dns323_nor_flash_data,
+	},
 	.resource	= &dns323_nor_flash_resource,
 	.num_resources	= 1,
 };
@@ -170,7 +170,9 @@
 static struct platform_device dns323_gpio_leds = {
 	.name		= "leds-gpio",
 	.id		= -1,
-	.dev		= { .platform_data = &dns323_led_data, },
+	.dev		= {
+		.platform_data	= &dns323_led_data,
+	},
 };
 
 /****************************************************************************
@@ -183,35 +185,53 @@
 		.gpio		= DNS323_GPIO_KEY_RESET,
 		.desc		= "Reset Button",
 		.active_low	= 1,
-	},
-	{
+	}, {
 		.code		= KEY_POWER,
 		.gpio		= DNS323_GPIO_KEY_POWER,
 		.desc		= "Power Button",
 		.active_low	= 1,
-	}
+	},
 };
 
 static struct gpio_keys_platform_data dns323_button_data = {
 	.buttons	= dns323_buttons,
-	.nbuttons       = ARRAY_SIZE(dns323_buttons),
+	.nbuttons	= ARRAY_SIZE(dns323_buttons),
 };
 
 static struct platform_device dns323_button_device = {
 	.name		= "gpio-keys",
 	.id		= -1,
 	.num_resources	= 0,
-	.dev		= { .platform_data  = &dns323_button_data, },
+	.dev		= {
+		.platform_data	= &dns323_button_data,
+	},
 };
 
 /****************************************************************************
  * General Setup
  */
-
-static struct platform_device *dns323_plat_devices[] __initdata = {
-	&dns323_nor_flash,
-	&dns323_gpio_leds,
-	&dns323_button_device,
+static struct orion5x_mpp_mode dns323_mpp_modes[] __initdata = {
+	{  0, MPP_PCIE_RST_OUTn },
+	{  1, MPP_GPIO },		/* right amber LED (sata ch0) */
+	{  2, MPP_GPIO },		/* left amber LED (sata ch1) */
+	{  3, MPP_UNUSED },
+	{  4, MPP_GPIO },		/* power button LED */
+	{  5, MPP_GPIO },		/* power button LED */
+	{  6, MPP_GPIO },		/* GMT G751-2f overtemp */
+	{  7, MPP_GPIO },		/* M41T80 nIRQ/OUT/SQW */
+	{  8, MPP_GPIO },		/* triggers power off */
+	{  9, MPP_GPIO },		/* power button switch */
+	{ 10, MPP_GPIO },		/* reset button switch */
+	{ 11, MPP_UNUSED },
+	{ 12, MPP_UNUSED },
+	{ 13, MPP_UNUSED },
+	{ 14, MPP_UNUSED },
+	{ 15, MPP_UNUSED },
+	{ 16, MPP_UNUSED },
+	{ 17, MPP_UNUSED },
+	{ 18, MPP_UNUSED },
+	{ 19, MPP_UNUSED },
+	{ -1 },
 };
 
 /*
@@ -225,17 +245,15 @@
 static struct i2c_board_info __initdata dns323_i2c_devices[] = {
 	{
 		I2C_BOARD_INFO("g760a", 0x3e),
-	},
 #if 0
 	/* this entry requires the new-style driver model lm75 driver,
 	 * for the meantime "insmod lm75.ko force_lm75=0,0x48" is needed */
-	{
+	}, {
 		I2C_BOARD_INFO("g751", 0x48),
-	},
 #endif
-	{
+	}, {
 		I2C_BOARD_INFO("m41t80", 0x68),
-	}
+	},
 };
 
 /* DNS-323 specific power off method */
@@ -250,62 +268,35 @@
 	/* Setup basic Orion functions. Need to be called early. */
 	orion5x_init();
 
+	orion5x_mpp_conf(dns323_mpp_modes);
+	writel(0, MPP_DEV_CTRL);		/* DEV_D[31:16] */
+
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_eth_init(&dns323_eth_data);
+	orion5x_i2c_init();
+	orion5x_uart0_init();
+
 	/* setup flash mapping
 	 * CS3 holds a 8 MB Spansion S29GL064M90TFIR4
 	 */
 	orion5x_setup_dev_boot_win(DNS323_NOR_BOOT_BASE, DNS323_NOR_BOOT_SIZE);
+	platform_device_register(&dns323_nor_flash);
 
-	/* DNS-323 has a Marvell 88X7042 SATA controller attached via PCIe
-	 *
-	 * Open a special address decode windows for the PCIe WA.
-	 */
-	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
-				ORION5X_PCIE_WA_SIZE);
-
-	/* set MPP to 0 as D-Link's 2.6.12.6 kernel did */
-	orion5x_write(MPP_0_7_CTRL, 0);
-	orion5x_write(MPP_8_15_CTRL, 0);
-	orion5x_write(MPP_16_19_CTRL, 0);
-	orion5x_write(MPP_DEV_CTRL, 0);
-
-	/* Define used GPIO pins
-
-	  GPIO Map:
-
-	  |  0 |     | PEX_RST_OUT (not controlled by GPIO)
-	  |  1 | Out | right amber LED (= sata ch0 LED)  (low-active)
-	  |  2 | Out | left  amber LED (= sata ch1 LED)  (low-active)
-	  |  3 | Out | //unknown//
-	  |  4 | Out | power button LED (low-active, together with pin #5)
-	  |  5 | Out | power button LED (low-active, together with pin #4)
-	  |  6 | In  | GMT G751-2f overtemp. shutdown signal (low-active)
-	  |  7 | In  | M41T80 nIRQ/OUT/SQW signal
-	  |  8 | Out | triggers power off (high-active)
-	  |  9 | In  | power button switch (low-active)
-	  | 10 | In  | reset button switch (low-active)
-	  | 11 | Out | //unknown//
-	  | 12 | Out | //unknown//
-	  | 13 | Out | //unknown//
-	  | 14 | Out | //unknown//
-	  | 15 | Out | //unknown//
-	*/
-	orion5x_gpio_set_valid_pins(0x07f6);
-
-	/* register dns323 specific power-off method */
-	if ((gpio_request(DNS323_GPIO_POWER_OFF, "POWEROFF") != 0)
-	    || (gpio_direction_output(DNS323_GPIO_POWER_OFF, 0) != 0))
-		pr_err("DNS323: failed to setup power-off GPIO\n");
-
-	pm_power_off = dns323_power_off;
+	platform_device_register(&dns323_gpio_leds);
 
-	/* register flash and other platform devices */
-	platform_add_devices(dns323_plat_devices,
-			     ARRAY_SIZE(dns323_plat_devices));
+	platform_device_register(&dns323_button_device);
 
 	i2c_register_board_info(0, dns323_i2c_devices,
 				ARRAY_SIZE(dns323_i2c_devices));
 
-	orion5x_eth_init(&dns323_eth_data);
+	/* register dns323 specific power-off method */
+	if (gpio_request(DNS323_GPIO_POWER_OFF, "POWEROFF") != 0 ||
+	    gpio_direction_output(DNS323_GPIO_POWER_OFF, 0) != 0)
+		pr_err("DNS323: failed to setup power-off GPIO\n");
+	pm_power_off = dns323_power_off;
 }
 
 /* Warning: D-Link uses a wrong mach-type (=526) in their bootloader */
--- a/arch/arm/mach-orion5x/gpio.c
+++ b/arch/arm/mach-orion5x/gpio.c
@@ -24,9 +24,12 @@
 static unsigned long gpio_valid[BITS_TO_LONGS(GPIO_MAX)];
 static const char *gpio_label[GPIO_MAX];  /* non null for allocated GPIOs */
 
-void __init orion5x_gpio_set_valid_pins(u32 pins)
+void __init orion5x_gpio_set_valid(unsigned pin, int valid)
 {
-	gpio_valid[0] = pins;
+	if (valid)
+		__set_bit(pin, gpio_valid);
+	else
+		__clear_bit(pin, gpio_valid);
 }
 
 /*
@@ -93,10 +96,10 @@
 {
 	int val, mask = 1 << pin;
 
-	if (orion5x_read(GPIO_IO_CONF) & mask)
-		val = orion5x_read(GPIO_DATA_IN) ^ orion5x_read(GPIO_IN_POL);
+	if (readl(GPIO_IO_CONF) & mask)
+		val = readl(GPIO_DATA_IN) ^ readl(GPIO_IN_POL);
 	else
-		val = orion5x_read(GPIO_OUT);
+		val = readl(GPIO_OUT);
 
 	return val & mask;
 }
@@ -188,39 +191,39 @@
 			printk("GPIO, free\n");
 		} else {
 			printk("GPIO, used by %s, ", gpio_label[i]);
-			if (orion5x_read(GPIO_IO_CONF) & (1 << i)) {
+			if (readl(GPIO_IO_CONF) & (1 << i)) {
 				printk("input, active %s, level %s, edge %s\n",
-				((orion5x_read(GPIO_IN_POL) >> i) & 1) ? "low" : "high",
-				((orion5x_read(GPIO_LEVEL_MASK) >> i) & 1) ? "enabled" : "masked",
-				((orion5x_read(GPIO_EDGE_MASK) >> i) & 1) ? "enabled" : "masked");
+				((readl(GPIO_IN_POL) >> i) & 1) ? "low" : "high",
+				((readl(GPIO_LEVEL_MASK) >> i) & 1) ? "enabled" : "masked",
+				((readl(GPIO_EDGE_MASK) >> i) & 1) ? "enabled" : "masked");
 			} else {
-				printk("output, val=%d\n", (orion5x_read(GPIO_OUT) >> i) & 1);
+				printk("output, val=%d\n", (readl(GPIO_OUT) >> i) & 1);
 			}
 		}
 	}
 
 	printk(KERN_DEBUG "MPP_0_7_CTRL (0x%08x) = 0x%08x\n",
-				MPP_0_7_CTRL, orion5x_read(MPP_0_7_CTRL));
+				MPP_0_7_CTRL, readl(MPP_0_7_CTRL));
 	printk(KERN_DEBUG "MPP_8_15_CTRL (0x%08x) = 0x%08x\n",
-				MPP_8_15_CTRL, orion5x_read(MPP_8_15_CTRL));
+				MPP_8_15_CTRL, readl(MPP_8_15_CTRL));
 	printk(KERN_DEBUG "MPP_16_19_CTRL (0x%08x) = 0x%08x\n",
-				MPP_16_19_CTRL, orion5x_read(MPP_16_19_CTRL));
+				MPP_16_19_CTRL, readl(MPP_16_19_CTRL));
 	printk(KERN_DEBUG "MPP_DEV_CTRL (0x%08x) = 0x%08x\n",
-				MPP_DEV_CTRL, orion5x_read(MPP_DEV_CTRL));
+				MPP_DEV_CTRL, readl(MPP_DEV_CTRL));
 	printk(KERN_DEBUG "GPIO_OUT (0x%08x) = 0x%08x\n",
-				GPIO_OUT, orion5x_read(GPIO_OUT));
+				GPIO_OUT, readl(GPIO_OUT));
 	printk(KERN_DEBUG "GPIO_IO_CONF (0x%08x) = 0x%08x\n",
-				GPIO_IO_CONF, orion5x_read(GPIO_IO_CONF));
+				GPIO_IO_CONF, readl(GPIO_IO_CONF));
 	printk(KERN_DEBUG "GPIO_BLINK_EN (0x%08x) = 0x%08x\n",
-				GPIO_BLINK_EN, orion5x_read(GPIO_BLINK_EN));
+				GPIO_BLINK_EN, readl(GPIO_BLINK_EN));
 	printk(KERN_DEBUG "GPIO_IN_POL (0x%08x) = 0x%08x\n",
-				GPIO_IN_POL, orion5x_read(GPIO_IN_POL));
+				GPIO_IN_POL, readl(GPIO_IN_POL));
 	printk(KERN_DEBUG "GPIO_DATA_IN (0x%08x) = 0x%08x\n",
-				GPIO_DATA_IN, orion5x_read(GPIO_DATA_IN));
+				GPIO_DATA_IN, readl(GPIO_DATA_IN));
 	printk(KERN_DEBUG "GPIO_LEVEL_MASK (0x%08x) = 0x%08x\n",
-				GPIO_LEVEL_MASK, orion5x_read(GPIO_LEVEL_MASK));
+				GPIO_LEVEL_MASK, readl(GPIO_LEVEL_MASK));
 	printk(KERN_DEBUG "GPIO_EDGE_CAUSE (0x%08x) = 0x%08x\n",
-				GPIO_EDGE_CAUSE, orion5x_read(GPIO_EDGE_CAUSE));
+				GPIO_EDGE_CAUSE, readl(GPIO_EDGE_CAUSE));
 	printk(KERN_DEBUG "GPIO_EDGE_MASK (0x%08x) = 0x%08x\n",
-				GPIO_EDGE_MASK, orion5x_read(GPIO_EDGE_MASK));
+				GPIO_EDGE_MASK, readl(GPIO_EDGE_MASK));
 }
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -82,7 +82,7 @@
 	int pin = irq_to_gpio(irq);
 	struct irq_desc *desc;
 
-	if ((orion5x_read(GPIO_IO_CONF) & (1 << pin)) == 0) {
+	if ((readl(GPIO_IO_CONF) & (1 << pin)) == 0) {
 		printk(KERN_ERR "orion5x_gpio_set_irq_type failed "
 				"(irq %d, pin %d).\n", irq, pin);
 		return -EINVAL;
@@ -117,7 +117,7 @@
 		/*
 		 * set initial polarity based on current input level
 		 */
-		if ((orion5x_read(GPIO_IN_POL) ^ orion5x_read(GPIO_DATA_IN))
+		if ((readl(GPIO_IN_POL) ^ readl(GPIO_DATA_IN))
 		    & (1 << pin))
 			orion5x_setbits(GPIO_IN_POL, (1 << pin)); /* falling */
 		else
@@ -149,8 +149,8 @@
 
 	BUG_ON(irq < IRQ_ORION5X_GPIO_0_7 || irq > IRQ_ORION5X_GPIO_24_31);
 	offs = (irq - IRQ_ORION5X_GPIO_0_7) * 8;
-	cause = (orion5x_read(GPIO_DATA_IN) & orion5x_read(GPIO_LEVEL_MASK)) |
-		(orion5x_read(GPIO_EDGE_CAUSE) & orion5x_read(GPIO_EDGE_MASK));
+	cause = (readl(GPIO_DATA_IN) & readl(GPIO_LEVEL_MASK)) |
+		(readl(GPIO_EDGE_CAUSE) & readl(GPIO_EDGE_MASK));
 
 	for (pin = offs; pin < offs + 8; pin++) {
 		if (cause & (1 << pin)) {
@@ -158,9 +158,9 @@
 			desc = irq_desc + irq;
 			if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQT_BOTHEDGE) {
 				/* Swap polarity (race with GPIO line) */
-				u32 polarity = orion5x_read(GPIO_IN_POL);
+				u32 polarity = readl(GPIO_IN_POL);
 				polarity ^= 1 << pin;
-				orion5x_write(GPIO_IN_POL, polarity);
+				writel(polarity, GPIO_IN_POL);
 			}
 			desc_handle_irq(irq, desc);
 		}
@@ -175,9 +175,9 @@
 	/*
 	 * Mask and clear GPIO IRQ interrupts
 	 */
-	orion5x_write(GPIO_LEVEL_MASK, 0x0);
-	orion5x_write(GPIO_EDGE_MASK, 0x0);
-	orion5x_write(GPIO_EDGE_CAUSE, 0x0);
+	writel(0x0, GPIO_LEVEL_MASK);
+	writel(0x0, GPIO_EDGE_MASK);
+	writel(0x0, GPIO_EDGE_CAUSE);
 
 	/*
 	 * Register chained level handlers for GPIO IRQs by default.
--- a/arch/arm/mach-orion5x/kurobox_pro-setup.c
+++ b/arch/arm/mach-orion5x/kurobox_pro-setup.c
@@ -13,10 +13,12 @@
 #include <linux/platform_device.h>
 #include <linux/pci.h>
 #include <linux/irq.h>
+#include <linux/delay.h>
 #include <linux/mtd/physmap.h>
 #include <linux/mtd/nand.h>
 #include <linux/mv643xx_eth.h>
 #include <linux/i2c.h>
+#include <linux/serial_reg.h>
 #include <linux/ata_platform.h>
 #include <asm/mach-types.h>
 #include <asm/gpio.h>
@@ -25,6 +27,7 @@
 #include <asm/arch/orion5x.h>
 #include <asm/plat-orion/orion_nand.h>
 #include "common.h"
+#include "mpp.h"
 
 /*****************************************************************************
  * KUROBOX-PRO Info
@@ -53,13 +56,11 @@
 		.name	= "uImage",
 		.offset	= 0,
 		.size	= SZ_4M,
-	},
-	{
+	}, {
 		.name	= "rootfs",
 		.offset	= SZ_4M,
 		.size	= SZ_64M,
-	},
-	{
+	}, {
 		.name	= "extra",
 		.offset	= SZ_4M + SZ_64M,
 		.size	= SZ_256M - (SZ_4M + SZ_64M),
@@ -132,8 +133,6 @@
 	/*
 	 * PCI isn't used on the Kuro
 	 */
-	printk(KERN_ERR "kurobox_pro_pci_map_irq failed, unknown bus\n");
-
 	return -1;
 }
 
@@ -161,7 +160,6 @@
 
 static struct mv643xx_eth_platform_data kurobox_pro_eth_data = {
 	.phy_addr	= 8,
-	.force_phy_addr = 1,
 };
 
 /*****************************************************************************
@@ -175,12 +173,169 @@
  * SATA
  ****************************************************************************/
 static struct mv_sata_platform_data kurobox_pro_sata_data = {
-	.n_ports        = 2,
+	.n_ports	= 2,
 };
 
 /*****************************************************************************
+ * Kurobox Pro specific power off method via UART1-attached microcontroller
+ ****************************************************************************/
+
+#define UART1_REG(x)	(UART1_VIRT_BASE + ((UART_##x) << 2))
+
+static int kurobox_pro_miconread(unsigned char *buf, int count)
+{
+	int i;
+	int timeout;
+
+	for (i = 0; i < count; i++) {
+		timeout = 10;
+
+		while (!(readl(UART1_REG(LSR)) & UART_LSR_DR)) {
+			if (--timeout == 0)
+				break;
+			udelay(1000);
+		}
+
+		if (timeout == 0)
+			break;
+		buf[i] = readl(UART1_REG(RX));
+	}
+
+	/* return read bytes */
+	return i;
+}
+
+static int kurobox_pro_miconwrite(const unsigned char *buf, int count)
+{
+	int i = 0;
+
+	while (count--) {
+		while (!(readl(UART1_REG(LSR)) & UART_LSR_THRE))
+			barrier();
+		writel(buf[i++], UART1_REG(TX));
+	}
+
+	return 0;
+}
+
+static int kurobox_pro_miconsend(const unsigned char *data, int count)
+{
+	int i;
+	unsigned char checksum = 0;
+	unsigned char recv_buf[40];
+	unsigned char send_buf[40];
+	unsigned char correct_ack[3];
+	int retry = 2;
+
+	/* Generate checksum */
+	for (i = 0; i < count; i++)
+		checksum -=  data[i];
+
+	do {
+		/* Send data */
+		kurobox_pro_miconwrite(data, count);
+
+		/* send checksum */
+		kurobox_pro_miconwrite(&checksum, 1);
+
+		if (kurobox_pro_miconread(recv_buf, sizeof(recv_buf)) <= 3) {
+			printk(KERN_ERR ">%s: receive failed.\n", __func__);
+
+			/* send preamble to clear the receive buffer */
+			memset(&send_buf, 0xff, sizeof(send_buf));
+			kurobox_pro_miconwrite(send_buf, sizeof(send_buf));
+
+			/* make dummy reads */
+			mdelay(100);
+			kurobox_pro_miconread(recv_buf, sizeof(recv_buf));
+		} else {
+			/* Generate expected ack */
+			correct_ack[0] = 0x01;
+			correct_ack[1] = data[1];
+			correct_ack[2] = 0x00;
+
+			/* checksum Check */
+			if ((recv_buf[0] + recv_buf[1] + recv_buf[2] +
+			     recv_buf[3]) & 0xFF) {
+				printk(KERN_ERR ">%s: Checksum Error : "
+					"Received data[%02x, %02x, %02x, %02x]"
+					"\n", __func__, recv_buf[0],
+					recv_buf[1], recv_buf[2], recv_buf[3]);
+			} else {
+				/* Check Received Data */
+				if (correct_ack[0] == recv_buf[0] &&
+				    correct_ack[1] == recv_buf[1] &&
+				    correct_ack[2] == recv_buf[2]) {
+					/* Interval for next command */
+					mdelay(10);
+
+					/* Receive ACK */
+					return 0;
+				}
+			}
+			/* Received NAK or illegal Data */
+			printk(KERN_ERR ">%s: Error : NAK or Illegal Data "
+					"Received\n", __func__);
+		}
+	} while (retry--);
+
+	/* Interval for next command */
+	mdelay(10);
+
+	return -1;
+}
+
+static void kurobox_pro_power_off(void)
+{
+	const unsigned char watchdogkill[]	= {0x01, 0x35, 0x00};
+	const unsigned char shutdownwait[]	= {0x00, 0x0c};
+	const unsigned char poweroff[]		= {0x00, 0x06};
+	/* 38400 baud divisor */
+	const unsigned divisor = ((ORION5X_TCLK + (8 * 38400)) / (16 * 38400));
+
+	pr_info("%s: triggering power-off...\n", __func__);
+
+	/* hijack uart1 and reset into sane state (38400,8n1,even parity) */
+	writel(0x83, UART1_REG(LCR));
+	writel(divisor & 0xff, UART1_REG(DLL));
+	writel((divisor >> 8) & 0xff, UART1_REG(DLM));
+	writel(0x1b, UART1_REG(LCR));
+	writel(0x00, UART1_REG(IER));
+	writel(0x07, UART1_REG(FCR));
+	writel(0x00, UART1_REG(MCR));
+
+	/* Send the commands to shutdown the Kurobox Pro */
+	kurobox_pro_miconsend(watchdogkill, sizeof(watchdogkill)) ;
+	kurobox_pro_miconsend(shutdownwait, sizeof(shutdownwait)) ;
+	kurobox_pro_miconsend(poweroff, sizeof(poweroff));
+}
+
+/*****************************************************************************
  * General Setup
  ****************************************************************************/
+static struct orion5x_mpp_mode kurobox_pro_mpp_modes[] __initdata = {
+	{  0, MPP_UNUSED },
+	{  1, MPP_UNUSED },
+	{  2, MPP_GPIO },		/* GPIO Micon */
+	{  3, MPP_GPIO },		/* GPIO Rtc */
+	{  4, MPP_UNUSED },
+	{  5, MPP_UNUSED },
+	{  6, MPP_NAND },		/* NAND Flash REn */
+	{  7, MPP_NAND },		/* NAND Flash WEn */
+	{  8, MPP_UNUSED },
+	{  9, MPP_UNUSED },
+	{ 10, MPP_UNUSED },
+	{ 11, MPP_UNUSED },
+	{ 12, MPP_SATA_LED },		/* SATA 0 presence */
+	{ 13, MPP_SATA_LED },		/* SATA 1 presence */
+	{ 14, MPP_SATA_LED },		/* SATA 0 active */
+	{ 15, MPP_SATA_LED },		/* SATA 1 active */
+	{ 16, MPP_UART },		/* UART1 RXD */
+	{ 17, MPP_UART },		/* UART1 TXD */
+	{ 18, MPP_UART },		/* UART1 CTSn */
+	{ 19, MPP_UART },		/* UART1 RTSn */
+	{ -1 },
+};
 
 static void __init kurobox_pro_init(void)
 {
@@ -189,46 +344,32 @@
 	 */
 	orion5x_init();
 
-	/*
-	 * Setup the CPU address decode windows for our devices
-	 */
-	orion5x_setup_dev_boot_win(KUROBOX_PRO_NOR_BOOT_BASE,
-				KUROBOX_PRO_NOR_BOOT_SIZE);
-	orion5x_setup_dev0_win(KUROBOX_PRO_NAND_BASE, KUROBOX_PRO_NAND_SIZE);
+	orion5x_mpp_conf(kurobox_pro_mpp_modes);
 
 	/*
-	 * Open a special address decode windows for the PCIe WA.
+	 * Configure peripherals.
 	 */
-	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
-				ORION5X_PCIE_WA_SIZE);
-
-	/*
-	 * Setup Multiplexing Pins --
-	 * MPP[0-1] Not used
-	 * MPP[2] GPIO Micon
-	 * MPP[3] GPIO RTC
-	 * MPP[4-5] Not used
-	 * MPP[6] Nand Flash REn
-	 * MPP[7] Nand Flash WEn
-	 * MPP[8-11] Not used
-	 * MPP[12] SATA 0 presence Indication
-	 * MPP[13] SATA 1 presence Indication
-	 * MPP[14] SATA 0 active Indication
-	 * MPP[15] SATA 1 active indication
-	 * MPP[16-19] Not used
-	 */
-	orion5x_write(MPP_0_7_CTRL, 0x44220003);
-	orion5x_write(MPP_8_15_CTRL, 0x55550000);
-	orion5x_write(MPP_16_19_CTRL, 0x0);
-
-	orion5x_gpio_set_valid_pins(0x0000000c);
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
+	orion5x_eth_init(&kurobox_pro_eth_data);
+	orion5x_i2c_init();
+	orion5x_sata_init(&kurobox_pro_sata_data);
+	orion5x_uart0_init();
 
+	orion5x_setup_dev_boot_win(KUROBOX_PRO_NOR_BOOT_BASE,
+				   KUROBOX_PRO_NOR_BOOT_SIZE);
 	platform_device_register(&kurobox_pro_nor_flash);
-	if (machine_is_kurobox_pro())
+
+	if (machine_is_kurobox_pro()) {
+		orion5x_setup_dev0_win(KUROBOX_PRO_NAND_BASE,
+				       KUROBOX_PRO_NAND_SIZE);
 		platform_device_register(&kurobox_pro_nand_flash);
+	}
+
 	i2c_register_board_info(0, &kurobox_pro_i2c_rtc, 1);
-	orion5x_eth_init(&kurobox_pro_eth_data);
-	orion5x_sata_init(&kurobox_pro_sata_data);
+
+	/* register Kurobox Pro specific power-off method */
+	pm_power_off = kurobox_pro_power_off;
 }
 
 #ifdef CONFIG_MACH_KUROBOX_PRO
--- /dev/null
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -0,0 +1,163 @@
+/*
+ * arch/arm/mach-orion5x/mpp.c
+ *
+ * MPP functions for Marvell Orion 5x SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mbus.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include "common.h"
+#include "mpp.h"
+
+static int is_5181l(void)
+{
+	u32 dev;
+	u32 rev;
+
+	orion5x_pcie_id(&dev, &rev);
+
+	return !!(dev == MV88F5181_DEV_ID && rev >= MV88F5181L_REV_A0);
+}
+
+static int is_5182(void)
+{
+	u32 dev;
+	u32 rev;
+
+	orion5x_pcie_id(&dev, &rev);
+
+	return !!(dev == MV88F5182_DEV_ID);
+}
+
+static int is_5281(void)
+{
+	u32 dev;
+	u32 rev;
+
+	orion5x_pcie_id(&dev, &rev);
+
+	return !!(dev == MV88F5281_DEV_ID);
+}
+
+static int __init determine_type_encoding(int mpp, enum orion5x_mpp_type type)
+{
+	switch (type) {
+	case MPP_UNUSED:
+	case MPP_GPIO:
+		if (mpp == 0)
+			return 3;
+		if (mpp >= 1 && mpp <= 15)
+			return 0;
+		if (mpp >= 16 && mpp <= 19) {
+			if (is_5182())
+				return 5;
+			if (type == MPP_UNUSED)
+				return 0;
+		}
+		return -1;
+
+	case MPP_PCIE_RST_OUTn:
+		if (mpp == 0)
+			return 0;
+		return -1;
+
+	case MPP_PCI_ARB:
+		if (mpp >= 0 && mpp <= 7)
+			return 2;
+		return -1;
+
+	case MPP_PCI_PMEn:
+		if (mpp == 2)
+			return 3;
+		return -1;
+
+	case MPP_GIGE:
+		if (mpp >= 8 && mpp <= 19)
+			return 1;
+		return -1;
+
+	case MPP_NAND:
+		if (is_5182() || is_5281()) {
+			if (mpp >= 4 && mpp <= 7)
+				return 4;
+			if (mpp >= 12 && mpp <= 17)
+				return 4;
+		}
+		return -1;
+
+	case MPP_PCI_CLK:
+		if (is_5181l() && mpp >= 6 && mpp <= 7)
+			return 5;
+		return -1;
+
+	case MPP_SATA_LED:
+		if (is_5182()) {
+			if (mpp >= 4 && mpp <= 7)
+				return 5;
+			if (mpp >= 12 && mpp <= 15)
+				return 5;
+		}
+		return -1;
+
+	case MPP_UART:
+		if (mpp >= 16 && mpp <= 19)
+			return 0;
+		return -1;
+	}
+
+	printk(KERN_INFO "unknown MPP type %d\n", type);
+
+	return -1;
+}
+
+void __init orion5x_mpp_conf(struct orion5x_mpp_mode *mode)
+{
+	u32 mpp_0_7_ctrl = readl(MPP_0_7_CTRL);
+	u32 mpp_8_15_ctrl = readl(MPP_8_15_CTRL);
+	u32 mpp_16_19_ctrl = readl(MPP_16_19_CTRL);
+
+	while (mode->mpp >= 0) {
+		u32 *reg;
+		int num_type;
+		int shift;
+
+		if (mode->mpp >= 0 && mode->mpp <= 7)
+			reg = &mpp_0_7_ctrl;
+		else if (mode->mpp >= 8 && mode->mpp <= 15)
+			reg = &mpp_8_15_ctrl;
+		else if (mode->mpp >= 16 && mode->mpp <= 19)
+			reg = &mpp_16_19_ctrl;
+		else {
+			printk(KERN_ERR "orion5x_mpp_conf: invalid MPP "
+					"(%d)\n", mode->mpp);
+			continue;
+		}
+
+		num_type = determine_type_encoding(mode->mpp, mode->type);
+		if (num_type < 0) {
+			printk(KERN_ERR "orion5x_mpp_conf: invalid MPP "
+					"combination (%d, %d)\n", mode->mpp,
+					mode->type);
+			continue;
+		}
+
+		shift = (mode->mpp & 7) << 2;
+		*reg &= ~(0xf << shift);
+		*reg |= (num_type & 0xf) << shift;
+
+		orion5x_gpio_set_valid(mode->mpp, !!(mode->type == MPP_GPIO));
+
+		mode++;
+	}
+
+	writel(mpp_0_7_ctrl, MPP_0_7_CTRL);
+	writel(mpp_8_15_ctrl, MPP_8_15_CTRL);
+	writel(mpp_16_19_ctrl, MPP_16_19_CTRL);
+}
--- /dev/null
+++ b/arch/arm/mach-orion5x/mpp.h
@@ -0,0 +1,74 @@
+#ifndef __ARCH_ORION5X_MPP_H
+#define __ARCH_ORION5X_MPP_H
+
+enum orion5x_mpp_type {
+	/*
+	 * This MPP is unused.
+	 */
+	MPP_UNUSED,
+
+	/*
+	 * This MPP pin is used as a generic GPIO pin.  Valid for
+	 * MPPs 0-15 and device bus data pins 16-31.  On 5182, also
+	 * valid for MPPs 16-19.
+	 */
+	MPP_GPIO,
+
+	/*
+	 * This MPP is used as PCIe_RST_OUTn pin.  Valid for
+	 * MPP 0 only.
+	 */
+	MPP_PCIE_RST_OUTn,
+
+	/*
+	 * This MPP is used as PCI arbiter pin (REQn/GNTn).
+	 * Valid for MPPs 0-7 only.
+	 */
+	MPP_PCI_ARB,
+
+	/*
+	 * This MPP is used as PCI_PMEn pin.  Valid for MPP 2 only.
+	 */
+	MPP_PCI_PMEn,
+
+	/*
+	 * This MPP is used as GigE half-duplex (COL, CRS) or GMII
+	 * (RXERR, CRS, TXERR, TXD[7:4], RXD[7:4]) pin.  Valid for
+	 * MPPs 8-19 only.
+	 */
+	MPP_GIGE,
+
+	/*
+	 * This MPP is used as NAND REn/WEn pin.  Valid for MPPs
+	 * 4-7 and 12-17 only, and only on the 5181l/5182/5281.
+	 */
+	MPP_NAND,
+
+	/*
+	 * This MPP is used as a PCI clock output pin.  Valid for
+	 * MPPs 6-7 only, and only on the 5181l.
+	 */
+	MPP_PCI_CLK,
+
+	/*
+	 * This MPP is used as a SATA presence/activity LED.
+	 * Valid for MPPs 4-7 and 12-15 only, and only on the 5182.
+	 */
+	MPP_SATA_LED,
+
+	/*
+	 * This MPP is used as UART1 RXD/TXD/CTSn/RTSn pin.
+	 * Valid for MPPs 16-19 only.
+	 */
+	MPP_UART,
+};
+
+struct orion5x_mpp_mode {
+	int			mpp;
+	enum orion5x_mpp_type	type;
+};
+
+void orion5x_mpp_conf(struct orion5x_mpp_mode *mode);
+
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-orion5x/mss2-setup.c
@@ -0,0 +1,270 @@
+/*
+ * Maxtor Shared Storage II Board Setup
+ *
+ * Maintainer: Sylver Bruneau <sylver.bruneau@googlemail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/leds.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/ata_platform.h>
+#include <linux/gpio.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/orion5x.h>
+#include "common.h"
+#include "mpp.h"
+
+#define MSS2_NOR_BOOT_BASE	0xff800000
+#define MSS2_NOR_BOOT_SIZE	SZ_256K
+
+/*****************************************************************************
+ * Maxtor Shared Storage II Info
+ ****************************************************************************/
+
+/*
+ * Maxtor Shared Storage II hardware :
+ * - Marvell 88F5182-A2 C500
+ * - Marvell 88E1111 Gigabit Ethernet PHY
+ * - RTC M41T81 (@0x68) on I2C bus
+ * - 256KB NOR flash
+ * - 64MB of RAM
+ */
+
+/*****************************************************************************
+ * 256KB NOR Flash on BOOT Device
+ ****************************************************************************/
+
+static struct physmap_flash_data mss2_nor_flash_data = {
+	.width		= 1,
+};
+
+static struct resource mss2_nor_flash_resource = {
+	.flags		= IORESOURCE_MEM,
+	.start		= MSS2_NOR_BOOT_BASE,
+	.end		= MSS2_NOR_BOOT_BASE + MSS2_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device mss2_nor_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &mss2_nor_flash_data,
+	},
+	.resource	= &mss2_nor_flash_resource,
+	.num_resources	= 1,
+};
+
+/****************************************************************************
+ * PCI setup
+ ****************************************************************************/
+static int __init mss2_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq;
+
+	/*
+	 * Check for devices with hard-wired IRQs.
+	 */
+	irq = orion5x_pci_map_irq(dev, slot, pin);
+	if (irq != -1)
+		return irq;
+
+	return -1;
+}
+
+static struct hw_pci mss2_pci __initdata = {
+	.nr_controllers = 2,
+	.swizzle	= pci_std_swizzle,
+	.setup		= orion5x_pci_sys_setup,
+	.scan		= orion5x_pci_sys_scan_bus,
+	.map_irq	= mss2_pci_map_irq,
+};
+
+static int __init mss2_pci_init(void)
+{
+	if (machine_is_mss2())
+		pci_common_init(&mss2_pci);
+
+	return 0;
+}
+subsys_initcall(mss2_pci_init);
+
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+
+static struct mv643xx_eth_platform_data mss2_eth_data = {
+	.phy_addr	= 8,
+};
+
+/*****************************************************************************
+ * SATA
+ ****************************************************************************/
+
+static struct mv_sata_platform_data mss2_sata_data = {
+	.n_ports	= 2,
+};
+
+/*****************************************************************************
+ * GPIO buttons
+ ****************************************************************************/
+
+#define MSS2_GPIO_KEY_RESET	12
+#define MSS2_GPIO_KEY_POWER	11
+
+static struct gpio_keys_button mss2_buttons[] = {
+	{
+		.code		= KEY_POWER,
+		.gpio		= MSS2_GPIO_KEY_POWER,
+		.desc		= "Power",
+		.active_low	= 1,
+	}, {
+		.code		= KEY_RESTART,
+		.gpio		= MSS2_GPIO_KEY_RESET,
+		.desc		= "Reset",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data mss2_button_data = {
+	.buttons	= mss2_buttons,
+	.nbuttons	= ARRAY_SIZE(mss2_buttons),
+};
+
+static struct platform_device mss2_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &mss2_button_data,
+	},
+};
+
+/*****************************************************************************
+ * RTC m41t81 on I2C bus
+ ****************************************************************************/
+
+#define MSS2_GPIO_RTC_IRQ	3
+
+static struct i2c_board_info __initdata mss2_i2c_rtc = {
+	I2C_BOARD_INFO("m41t81", 0x68),
+};
+
+/*****************************************************************************
+ * MSS2 power off method
+ ****************************************************************************/
+/*
+ * On the Maxtor Shared Storage II, the shutdown process is the following :
+ * - Userland modifies U-boot env to tell U-boot to go idle at next boot
+ * - The board reboots
+ * - U-boot starts and go into an idle mode until the user press "power"
+ */
+static void mss2_power_off(void)
+{
+	u32 reg;
+
+	/*
+	 * Enable and issue soft reset
+	 */
+	reg = readl(CPU_RESET_MASK);
+	reg |= 1 << 2;
+	writel(reg, CPU_RESET_MASK);
+
+	reg = readl(CPU_SOFT_RESET);
+	reg |= 1;
+	writel(reg, CPU_SOFT_RESET);
+}
+
+/****************************************************************************
+ * General Setup
+ ****************************************************************************/
+static struct orion5x_mpp_mode mss2_mpp_modes[] __initdata = {
+	{  0, MPP_GPIO },		/* Power LED */
+	{  1, MPP_GPIO },		/* Error LED */
+	{  2, MPP_UNUSED },
+	{  3, MPP_GPIO },		/* RTC interrupt */
+	{  4, MPP_GPIO },		/* HDD ind. (Single/Dual)*/
+	{  5, MPP_GPIO },		/* HD0 5V control */
+	{  6, MPP_GPIO },		/* HD0 12V control */
+	{  7, MPP_GPIO },		/* HD1 5V control */
+	{  8, MPP_GPIO },		/* HD1 12V control */
+	{  9, MPP_UNUSED },
+	{ 10, MPP_GPIO },		/* Fan control */
+	{ 11, MPP_GPIO },		/* Power button */
+	{ 12, MPP_GPIO },		/* Reset button */
+	{ 13, MPP_UNUSED },
+	{ 14, MPP_SATA_LED },		/* SATA 0 active */
+	{ 15, MPP_SATA_LED },		/* SATA 1 active */
+	{ 16, MPP_UNUSED },
+	{ 17, MPP_UNUSED },
+	{ 18, MPP_UNUSED },
+	{ 19, MPP_UNUSED },
+	{ -1 },
+};
+
+static void __init mss2_init(void)
+{
+	/* Setup basic Orion functions. Need to be called early. */
+	orion5x_init();
+
+	orion5x_mpp_conf(mss2_mpp_modes);
+
+	/*
+	 * MPP[20] Unused
+	 * MPP[21] PCI clock
+	 * MPP[22] USB 0 over current
+	 * MPP[23] USB 1 over current
+	 */
+
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
+	orion5x_eth_init(&mss2_eth_data);
+	orion5x_i2c_init();
+	orion5x_sata_init(&mss2_sata_data);
+	orion5x_uart0_init();
+
+	orion5x_setup_dev_boot_win(MSS2_NOR_BOOT_BASE, MSS2_NOR_BOOT_SIZE);
+	platform_device_register(&mss2_nor_flash);
+
+	platform_device_register(&mss2_button_device);
+
+	if (gpio_request(MSS2_GPIO_RTC_IRQ, "rtc") == 0) {
+		if (gpio_direction_input(MSS2_GPIO_RTC_IRQ) == 0)
+			mss2_i2c_rtc.irq = gpio_to_irq(MSS2_GPIO_RTC_IRQ);
+		else
+			gpio_free(MSS2_GPIO_RTC_IRQ);
+	}
+	i2c_register_board_info(0, &mss2_i2c_rtc, 1);
+
+	/* register mss2 specific power-off method */
+	pm_power_off = mss2_power_off;
+}
+
+MACHINE_START(MSS2, "Maxtor Shared Storage II")
+	/* Maintainer: Sylver Bruneau <sylver.bruneau@googlemail.com> */
+	.phys_io	= ORION5X_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= mss2_init,
+	.map_io		= orion5x_map_io,
+	.init_irq	= orion5x_init_irq,
+	.timer		= &orion5x_timer,
+	.fixup		= tag_fixup_mem32
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-orion5x/mv2120-setup.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2007 Herbert Valerio Riedel <hvr@gnu.org>
+ * Copyright (C) 2008 Martin Michlmayr <tbm@cyrius.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/leds.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/ata_platform.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/mach/arch.h>
+#include <asm/arch/orion5x.h>
+#include "common.h"
+#include "mpp.h"
+
+#define MV2120_NOR_BOOT_BASE	0xf4000000
+#define MV2120_NOR_BOOT_SIZE	SZ_512K
+
+#define MV2120_GPIO_RTC_IRQ	3
+#define MV2120_GPIO_KEY_RESET	17
+#define MV2120_GPIO_KEY_POWER	18
+#define MV2120_GPIO_POWER_OFF	19
+
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+static struct mv643xx_eth_platform_data mv2120_eth_data = {
+	.phy_addr	= 8,
+};
+
+static struct mv_sata_platform_data mv2120_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct mtd_partition mv2120_partitions[] = {
+	{
+		.name	= "firmware",
+		.size	= 0x00080000,
+		.offset	= 0,
+	},
+};
+
+static struct physmap_flash_data mv2120_nor_flash_data = {
+	.width		= 1,
+	.parts		= mv2120_partitions,
+	.nr_parts	= ARRAY_SIZE(mv2120_partitions)
+};
+
+static struct resource mv2120_nor_flash_resource = {
+	.flags		= IORESOURCE_MEM,
+	.start		= MV2120_NOR_BOOT_BASE,
+	.end		= MV2120_NOR_BOOT_BASE + MV2120_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device mv2120_nor_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &mv2120_nor_flash_data,
+	},
+	.resource	= &mv2120_nor_flash_resource,
+	.num_resources	= 1,
+};
+
+static struct gpio_keys_button mv2120_buttons[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= MV2120_GPIO_KEY_RESET,
+		.desc		= "reset",
+		.active_low	= 1,
+	}, {
+		.code		= KEY_POWER,
+		.gpio		= MV2120_GPIO_KEY_POWER,
+		.desc		= "power",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data mv2120_button_data = {
+	.buttons	= mv2120_buttons,
+	.nbuttons	= ARRAY_SIZE(mv2120_buttons),
+};
+
+static struct platform_device mv2120_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &mv2120_button_data,
+	},
+};
+
+
+/****************************************************************************
+ * General Setup
+ ****************************************************************************/
+static struct orion5x_mpp_mode mv2120_mpp_modes[] __initdata = {
+	{  0, MPP_GPIO },		/* Sys status LED */
+	{  1, MPP_GPIO },		/* Sys error LED */
+	{  2, MPP_GPIO },		/* OverTemp interrupt */
+	{  3, MPP_GPIO },		/* RTC interrupt */
+	{  4, MPP_GPIO },		/* V_LED 5V */
+	{  5, MPP_GPIO },		/* V_LED 3.3V */
+	{  6, MPP_UNUSED },
+	{  7, MPP_UNUSED },
+	{  8, MPP_GPIO },		/* SATA 0 fail LED */
+	{  9, MPP_GPIO },		/* SATA 1 fail LED */
+	{ 10, MPP_UNUSED },
+	{ 11, MPP_UNUSED },
+	{ 12, MPP_SATA_LED },		/* SATA 0 presence */
+	{ 13, MPP_SATA_LED },		/* SATA 1 presence */
+	{ 14, MPP_SATA_LED },		/* SATA 0 active */
+	{ 15, MPP_SATA_LED },		/* SATA 1 active */
+	{ 16, MPP_UNUSED },
+	{ 17, MPP_GPIO },		/* Reset button */
+	{ 18, MPP_GPIO },		/* Power button */
+	{ 19, MPP_GPIO },		/* Power off */
+	{ -1 },
+};
+
+static struct i2c_board_info __initdata mv2120_i2c_rtc = {
+	I2C_BOARD_INFO("rtc-pcf8563", 0x51),
+	.irq	= 0,
+};
+
+static void mv2120_power_off(void)
+{
+	pr_info("%s: triggering power-off...\n", __func__);
+	gpio_set_value(MV2120_GPIO_POWER_OFF, 0);
+}
+
+static void __init mv2120_init(void)
+{
+	/* Setup basic Orion functions. Need to be called early. */
+	orion5x_init();
+
+	orion5x_mpp_conf(mv2120_mpp_modes);
+
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
+	orion5x_eth_init(&mv2120_eth_data);
+	orion5x_i2c_init();
+	orion5x_sata_init(&mv2120_sata_data);
+	orion5x_uart0_init();
+
+	orion5x_setup_dev_boot_win(MV2120_NOR_BOOT_BASE, MV2120_NOR_BOOT_SIZE);
+	platform_device_register(&mv2120_nor_flash);
+
+	platform_device_register(&mv2120_button_device);
+
+	if (gpio_request(MV2120_GPIO_RTC_IRQ, "rtc") == 0) {
+		if (gpio_direction_input(MV2120_GPIO_RTC_IRQ) == 0)
+			mv2120_i2c_rtc.irq = gpio_to_irq(MV2120_GPIO_RTC_IRQ);
+		else
+			gpio_free(MV2120_GPIO_RTC_IRQ);
+	}
+	i2c_register_board_info(0, &mv2120_i2c_rtc, 1);
+
+	/* register mv2120 specific power-off method */
+	if (gpio_request(MV2120_GPIO_POWER_OFF, "POWEROFF") != 0 ||
+	    gpio_direction_output(MV2120_GPIO_POWER_OFF, 1) != 0)
+		pr_err("mv2120: failed to setup power-off GPIO\n");
+	pm_power_off = mv2120_power_off;
+}
+
+/* Warning: HP uses a wrong mach-type (=526) in their bootloader */
+MACHINE_START(MV2120, "HP Media Vault mv2120")
+	/* Maintainer: Martin Michlmayr <tbm@cyrius.com> */
+	.phys_io	= ORION5X_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= mv2120_init,
+	.map_io		= orion5x_map_io,
+	.init_irq	= orion5x_init_irq,
+	.timer		= &orion5x_timer,
+	.fixup		= tag_fixup_mem32
+MACHINE_END
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -152,6 +152,8 @@
 	if (dev == MV88F5181_DEV_ID || dev == MV88F5182_DEV_ID) {
 		printk(KERN_NOTICE "Applying Orion-1/Orion-NAS PCIe config "
 				   "read transaction workaround\n");
+		orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
+					  ORION5X_PCIE_WA_SIZE);
 		pcie_ops.read = pcie_rd_conf_wa;
 	}
 
@@ -240,13 +242,13 @@
  * PCI Address Decode Windows registers
  */
 #define PCI_BAR_SIZE_DDR_CS(n)	(((n) == 0) ? ORION5X_PCI_REG(0xc08) : \
-				((n) == 1) ? ORION5X_PCI_REG(0xd08) :  \
-				((n) == 2) ? ORION5X_PCI_REG(0xc0c) :  \
-				((n) == 3) ? ORION5X_PCI_REG(0xd0c) : 0)
-#define PCI_BAR_REMAP_DDR_CS(n)	(((n) ==0) ? ORION5X_PCI_REG(0xc48) :  \
-				((n) == 1) ? ORION5X_PCI_REG(0xd48) :  \
-				((n) == 2) ? ORION5X_PCI_REG(0xc4c) :  \
-				((n) == 3) ? ORION5X_PCI_REG(0xd4c) : 0)
+				 ((n) == 1) ? ORION5X_PCI_REG(0xd08) : \
+				 ((n) == 2) ? ORION5X_PCI_REG(0xc0c) : \
+				 ((n) == 3) ? ORION5X_PCI_REG(0xd0c) : 0)
+#define PCI_BAR_REMAP_DDR_CS(n)	(((n) == 0) ? ORION5X_PCI_REG(0xc48) : \
+				 ((n) == 1) ? ORION5X_PCI_REG(0xd48) : \
+				 ((n) == 2) ? ORION5X_PCI_REG(0xc4c) : \
+				 ((n) == 3) ? ORION5X_PCI_REG(0xd4c) : 0)
 #define PCI_BAR_ENABLE		ORION5X_PCI_REG(0xc3c)
 #define PCI_ADDR_DECODE_CTRL	ORION5X_PCI_REG(0xd3c)
 
@@ -266,7 +268,7 @@
 
 static int orion5x_pci_local_bus_nr(void)
 {
-	u32 conf = orion5x_read(PCI_P2P_CONF);
+	u32 conf = readl(PCI_P2P_CONF);
 	return((conf & PCI_P2P_BUS_MASK) >> PCI_P2P_BUS_OFFS);
 }
 
@@ -276,11 +278,11 @@
 	unsigned long flags;
 	spin_lock_irqsave(&orion5x_pci_lock, flags);
 
-	orion5x_write(PCI_CONF_ADDR, PCI_CONF_BUS(bus) |
-			PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
-			PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN);
+	writel(PCI_CONF_BUS(bus) |
+		PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
+		PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN, PCI_CONF_ADDR);
 
-	*val = orion5x_read(PCI_CONF_DATA);
+	*val = readl(PCI_CONF_DATA);
 
 	if (size == 1)
 		*val = (*val >> (8*(where & 0x3))) & 0xff;
@@ -300,9 +302,9 @@
 
 	spin_lock_irqsave(&orion5x_pci_lock, flags);
 
-	orion5x_write(PCI_CONF_ADDR, PCI_CONF_BUS(bus) |
-			PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
-			PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN);
+	writel(PCI_CONF_BUS(bus) |
+		PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
+		PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN, PCI_CONF_ADDR);
 
 	if (size == 4) {
 		__raw_writel(val, PCI_CONF_DATA);
@@ -353,9 +355,9 @@
 
 static void __init orion5x_pci_set_bus_nr(int nr)
 {
-	u32 p2p = orion5x_read(PCI_P2P_CONF);
+	u32 p2p = readl(PCI_P2P_CONF);
 
-	if (orion5x_read(PCI_MODE) & PCI_MODE_PCIX) {
+	if (readl(PCI_MODE) & PCI_MODE_PCIX) {
 		/*
 		 * PCI-X mode
 		 */
@@ -372,7 +374,7 @@
 		 */
 		p2p &= ~PCI_P2P_BUS_MASK;
 		p2p |= (nr << PCI_P2P_BUS_OFFS);
-		orion5x_write(PCI_P2P_CONF, p2p);
+		writel(p2p, PCI_P2P_CONF);
 	}
 }
 
@@ -399,7 +401,7 @@
 	 * First, disable windows.
 	 */
 	win_enable = 0xffffffff;
-	orion5x_write(PCI_BAR_ENABLE, win_enable);
+	writel(win_enable, PCI_BAR_ENABLE);
 
 	/*
 	 * Setup windows for DDR banks.
@@ -425,10 +427,10 @@
 		 */
 		reg = PCI_CONF_REG_BAR_HI_CS(cs->cs_index);
 		orion5x_pci_hw_wr_conf(bus, 0, func, reg, 4, 0);
-		orion5x_write(PCI_BAR_SIZE_DDR_CS(cs->cs_index),
-				(cs->size - 1) & 0xfffff000);
-		orion5x_write(PCI_BAR_REMAP_DDR_CS(cs->cs_index),
-				cs->base & 0xfffff000);
+		writel((cs->size - 1) & 0xfffff000,
+			PCI_BAR_SIZE_DDR_CS(cs->cs_index));
+		writel(cs->base & 0xfffff000,
+			PCI_BAR_REMAP_DDR_CS(cs->cs_index));
 
 		/*
 		 * Enable decode window for this chip select.
@@ -439,7 +441,7 @@
 	/*
 	 * Re-enable decode windows.
 	 */
-	orion5x_write(PCI_BAR_ENABLE, win_enable);
+	writel(win_enable, PCI_BAR_ENABLE);
 
 	/*
 	 * Disable automatic update of address remaping when writing to BARs.
--- a/arch/arm/mach-orion5x/rd88f5182-setup.c
+++ b/arch/arm/mach-orion5x/rd88f5182-setup.c
@@ -26,6 +26,7 @@
 #include <asm/mach/pci.h>
 #include <asm/arch/orion5x.h>
 #include "common.h"
+#include "mpp.h"
 
 /*****************************************************************************
  * RD-88F5182 Info
@@ -125,6 +126,7 @@
 
 		leds_event = rd88f5182_dbgled_event;
 	}
+
 	return 0;
 }
 
@@ -220,7 +222,6 @@
 
 static struct mv643xx_eth_platform_data rd88f5182_eth_data = {
 	.phy_addr	= 8,
-	.force_phy_addr = 1,
 };
 
 /*****************************************************************************
@@ -234,15 +235,34 @@
  * Sata
  ****************************************************************************/
 static struct mv_sata_platform_data rd88f5182_sata_data = {
-	.n_ports        = 2,
+	.n_ports	= 2,
 };
 
 /*****************************************************************************
  * General Setup
  ****************************************************************************/
-
-static struct platform_device *rd88f5182_devices[] __initdata = {
-	&rd88f5182_nor_flash,
+static struct orion5x_mpp_mode rd88f5182_mpp_modes[] __initdata = {
+	{  0, MPP_GPIO },		/* Debug Led */
+	{  1, MPP_GPIO },		/* Reset Switch */
+	{  2, MPP_UNUSED },
+	{  3, MPP_GPIO },		/* RTC Int */
+	{  4, MPP_GPIO },
+	{  5, MPP_GPIO },
+	{  6, MPP_GPIO },		/* PCI_intA */
+	{  7, MPP_GPIO },		/* PCI_intB */
+	{  8, MPP_UNUSED },
+	{  9, MPP_UNUSED },
+	{ 10, MPP_UNUSED },
+	{ 11, MPP_UNUSED },
+	{ 12, MPP_SATA_LED },		/* SATA 0 presence */
+	{ 13, MPP_SATA_LED },		/* SATA 1 presence */
+	{ 14, MPP_SATA_LED },		/* SATA 0 active */
+	{ 15, MPP_SATA_LED },		/* SATA 1 active */
+	{ 16, MPP_UNUSED },
+	{ 17, MPP_UNUSED },
+	{ 18, MPP_UNUSED },
+	{ 19, MPP_UNUSED },
+	{ -1 },
 };
 
 static void __init rd88f5182_init(void)
@@ -252,35 +272,9 @@
 	 */
 	orion5x_init();
 
-	/*
-	 * Setup the CPU address decode windows for our devices
-	 */
-	orion5x_setup_dev_boot_win(RD88F5182_NOR_BOOT_BASE,
-				RD88F5182_NOR_BOOT_SIZE);
-	orion5x_setup_dev1_win(RD88F5182_NOR_BASE, RD88F5182_NOR_SIZE);
-
-	/*
-	 * Open a special address decode windows for the PCIe WA.
-	 */
-	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
-				ORION5X_PCIE_WA_SIZE);
+	orion5x_mpp_conf(rd88f5182_mpp_modes);
 
 	/*
-	 * Setup Multiplexing Pins --
-	 * MPP[0] Debug Led (GPIO - Out)
-	 * MPP[1] Debug Led (GPIO - Out)
-	 * MPP[2] N/A
-	 * MPP[3] RTC_Int (GPIO - In)
-	 * MPP[4] GPIO
-	 * MPP[5] GPIO
-	 * MPP[6] PCI_intA (GPIO - In)
-	 * MPP[7] PCI_intB (GPIO - In)
-	 * MPP[8-11] N/A
-	 * MPP[12] SATA 0 presence Indication
-	 * MPP[13] SATA 1 presence Indication
-	 * MPP[14] SATA 0 active Indication
-	 * MPP[15] SATA 1 active indication
-	 * MPP[16-19] Not used
 	 * MPP[20] PCI Clock to MV88F5182
 	 * MPP[21] PCI Clock to mini PCI CON11
 	 * MPP[22] USB 0 over current indication
@@ -289,16 +283,23 @@
 	 * MPP[25] USB 0 over current enable
 	 */
 
-	orion5x_write(MPP_0_7_CTRL, 0x00000003);
-	orion5x_write(MPP_8_15_CTRL, 0x55550000);
-	orion5x_write(MPP_16_19_CTRL, 0x5555);
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
+	orion5x_eth_init(&rd88f5182_eth_data);
+	orion5x_i2c_init();
+	orion5x_sata_init(&rd88f5182_sata_data);
+	orion5x_uart0_init();
 
-	orion5x_gpio_set_valid_pins(0x000000fb);
+	orion5x_setup_dev_boot_win(RD88F5182_NOR_BOOT_BASE,
+				   RD88F5182_NOR_BOOT_SIZE);
+
+	orion5x_setup_dev1_win(RD88F5182_NOR_BASE, RD88F5182_NOR_SIZE);
+	platform_device_register(&rd88f5182_nor_flash);
 
-	platform_add_devices(rd88f5182_devices, ARRAY_SIZE(rd88f5182_devices));
 	i2c_register_board_info(0, &rd88f5182_i2c_rtc, 1);
-	orion5x_eth_init(&rd88f5182_eth_data);
-	orion5x_sata_init(&rd88f5182_sata_data);
 }
 
 MACHINE_START(RD88F5182, "Marvell Orion-NAS Reference Design")
--- a/arch/arm/mach-orion5x/ts209-setup.c
+++ b/arch/arm/mach-orion5x/ts209-setup.c
@@ -28,6 +28,8 @@
 #include <asm/mach/pci.h>
 #include <asm/arch/orion5x.h>
 #include "common.h"
+#include "mpp.h"
+#include "tsx09-common.h"
 
 #define QNAP_TS209_NOR_BOOT_BASE 0xf4000000
 #define QNAP_TS209_NOR_BOOT_SIZE SZ_8M
@@ -47,52 +49,54 @@
  ***************************************************************************/
 static struct mtd_partition qnap_ts209_partitions[] = {
 	{
-		.name       = "U-Boot",
-		.size       = 0x00080000,
-		.offset     = 0x00780000,
-		.mask_flags = MTD_WRITEABLE,
+		.name		= "U-Boot",
+		.size		= 0x00080000,
+		.offset		= 0x00780000,
+		.mask_flags	= MTD_WRITEABLE,
 	}, {
-		.name   = "Kernel",
-		.size   = 0x00200000,
-		.offset = 0,
+		.name		= "Kernel",
+		.size		= 0x00200000,
+		.offset		= 0,
 	}, {
-		.name   = "RootFS1",
-		.size   = 0x00400000,
-		.offset = 0x00200000,
+		.name		= "RootFS1",
+		.size		= 0x00400000,
+		.offset		= 0x00200000,
 	}, {
-		.name   = "RootFS2",
-		.size   = 0x00100000,
-		.offset = 0x00600000,
+		.name		= "RootFS2",
+		.size		= 0x00100000,
+		.offset		= 0x00600000,
 	}, {
-		.name   = "U-Boot Config",
-		.size   = 0x00020000,
-		.offset = 0x00760000,
+		.name		= "U-Boot Config",
+		.size		= 0x00020000,
+		.offset		= 0x00760000,
 	}, {
-		.name       = "NAS Config",
-		.size       = 0x00060000,
-		.offset     = 0x00700000,
-		.mask_flags = MTD_WRITEABLE,
-	}
+		.name		= "NAS Config",
+		.size		= 0x00060000,
+		.offset		= 0x00700000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
 };
 
 static struct physmap_flash_data qnap_ts209_nor_flash_data = {
-	.width    = 1,
-	.parts    = qnap_ts209_partitions,
-	.nr_parts = ARRAY_SIZE(qnap_ts209_partitions)
+	.width		= 1,
+	.parts		= qnap_ts209_partitions,
+	.nr_parts	= ARRAY_SIZE(qnap_ts209_partitions)
 };
 
 static struct resource qnap_ts209_nor_flash_resource = {
-	.flags = IORESOURCE_MEM,
-	.start = QNAP_TS209_NOR_BOOT_BASE,
-	.end   = QNAP_TS209_NOR_BOOT_BASE + QNAP_TS209_NOR_BOOT_SIZE - 1,
+	.flags	= IORESOURCE_MEM,
+	.start	= QNAP_TS209_NOR_BOOT_BASE,
+	.end	= QNAP_TS209_NOR_BOOT_BASE + QNAP_TS209_NOR_BOOT_SIZE - 1,
 };
 
 static struct platform_device qnap_ts209_nor_flash = {
-	.name          = "physmap-flash",
-	.id            = 0,
-	.dev           = { .platform_data = &qnap_ts209_nor_flash_data, },
-	.resource      = &qnap_ts209_nor_flash_resource,
-	.num_resources = 1,
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &qnap_ts209_nor_flash_data,
+	},
+	.resource	= &qnap_ts209_nor_flash_resource,
+	.num_resources	= 1,
 };
 
 /*****************************************************************************
@@ -164,12 +168,12 @@
 }
 
 static struct hw_pci qnap_ts209_pci __initdata = {
-	.nr_controllers = 2,
-	.preinit        = qnap_ts209_pci_preinit,
-	.swizzle        = pci_std_swizzle,
-	.setup          = orion5x_pci_sys_setup,
-	.scan           = orion5x_pci_sys_scan_bus,
-	.map_irq        = qnap_ts209_pci_map_irq,
+	.nr_controllers	= 2,
+	.preinit	= qnap_ts209_pci_preinit,
+	.swizzle	= pci_std_swizzle,
+	.setup		= orion5x_pci_sys_setup,
+	.scan		= orion5x_pci_sys_scan_bus,
+	.map_irq	= qnap_ts209_pci_map_irq,
 };
 
 static int __init qnap_ts209_pci_init(void)
@@ -183,96 +187,6 @@
 subsys_initcall(qnap_ts209_pci_init);
 
 /*****************************************************************************
- * Ethernet
- ****************************************************************************/
-
-static struct mv643xx_eth_platform_data qnap_ts209_eth_data = {
-	.phy_addr       = 8,
-	.force_phy_addr = 1,
-};
-
-static int __init parse_hex_nibble(char n)
-{
-	if (n >= '0' && n <= '9')
-		return n - '0';
-
-	if (n >= 'A' && n <= 'F')
-		return n - 'A' + 10;
-
-	if (n >= 'a' && n <= 'f')
-		return n - 'a' + 10;
-
-	return -1;
-}
-
-static int __init parse_hex_byte(const char *b)
-{
-	int hi;
-	int lo;
-
-	hi = parse_hex_nibble(b[0]);
-	lo = parse_hex_nibble(b[1]);
-
-	if (hi < 0 || lo < 0)
-		return -1;
-
-	return (hi << 4) | lo;
-}
-
-static int __init check_mac_addr(const char *addr_str)
-{
-	u_int8_t addr[6];
-	int i;
-
-	for (i = 0; i < 6; i++) {
-		int byte;
-
-		/*
-		 * Enforce "xx:xx:xx:xx:xx:xx\n" format.
-		 */
-		if (addr_str[(i * 3) + 2] != ((i < 5) ? ':' : '\n'))
-			return -1;
-
-		byte = parse_hex_byte(addr_str + (i * 3));
-		if (byte < 0)
-			return -1;
-		addr[i] = byte;
-	}
-
-	printk(KERN_INFO "ts209: found ethernet mac address ");
-	for (i = 0; i < 6; i++)
-		printk("%.2x%s", addr[i], (i < 5) ? ":" : ".\n");
-
-	memcpy(qnap_ts209_eth_data.mac_addr, addr, 6);
-
-	return 0;
-}
-
-/*
- * The 'NAS Config' flash partition has an ext2 filesystem which
- * contains a file that has the ethernet MAC address in plain text
- * (format "xx:xx:xx:xx:xx:xx\n".)
- */
-static void __init ts209_find_mac_addr(void)
-{
-	unsigned long addr;
-
-	for (addr = 0x00700000; addr < 0x00760000; addr += 1024) {
-		char *nor_page;
-		int ret = 0;
-
-		nor_page = ioremap(QNAP_TS209_NOR_BOOT_BASE + addr, 1024);
-		if (nor_page != NULL) {
-			ret = check_mac_addr(nor_page);
-			iounmap(nor_page);
-		}
-
-		if (ret == 0)
-			break;
-	}
-}
-
-/*****************************************************************************
  * RTC S35390A on I2C bus
  ****************************************************************************/
 
@@ -280,7 +194,7 @@
 
 static struct i2c_board_info __initdata qnap_ts209_i2c_rtc = {
 	I2C_BOARD_INFO("s35390a", 0x30),
-       .irq         = 0,
+	.irq	= 0,
 };
 
 /****************************************************************************
@@ -297,70 +211,63 @@
 		.gpio		= QNAP_TS209_GPIO_KEY_MEDIA,
 		.desc		= "USB Copy Button",
 		.active_low	= 1,
-	},
-	{
+	}, {
 		.code		= KEY_POWER,
 		.gpio		= QNAP_TS209_GPIO_KEY_RESET,
 		.desc		= "Reset Button",
 		.active_low	= 1,
-	}
+	},
 };
 
 static struct gpio_keys_platform_data qnap_ts209_button_data = {
 	.buttons	= qnap_ts209_buttons,
-	.nbuttons       = ARRAY_SIZE(qnap_ts209_buttons),
+	.nbuttons	= ARRAY_SIZE(qnap_ts209_buttons),
 };
 
 static struct platform_device qnap_ts209_button_device = {
 	.name		= "gpio-keys",
 	.id		= -1,
 	.num_resources	= 0,
-	.dev		= { .platform_data  = &qnap_ts209_button_data, },
+	.dev		= {
+		.platform_data	= &qnap_ts209_button_data,
+	},
 };
 
 /*****************************************************************************
  * SATA
  ****************************************************************************/
 static struct mv_sata_platform_data qnap_ts209_sata_data = {
-	.n_ports        = 2,
+	.n_ports	= 2,
 };
 
 /*****************************************************************************
 
  * General Setup
  ****************************************************************************/
-
-static struct platform_device *qnap_ts209_devices[] __initdata = {
-	&qnap_ts209_nor_flash,
-	&qnap_ts209_button_device,
+static struct orion5x_mpp_mode ts209_mpp_modes[] __initdata = {
+	{  0, MPP_UNUSED },
+	{  1, MPP_GPIO },		/* USB copy button */
+	{  2, MPP_GPIO },		/* Load defaults button */
+	{  3, MPP_GPIO },		/* GPIO RTC */
+	{  4, MPP_UNUSED },
+	{  5, MPP_UNUSED },
+	{  6, MPP_GPIO },		/* PCI Int A */
+	{  7, MPP_GPIO },		/* PCI Int B */
+	{  8, MPP_UNUSED },
+	{  9, MPP_UNUSED },
+	{ 10, MPP_UNUSED },
+	{ 11, MPP_UNUSED },
+	{ 12, MPP_SATA_LED },		/* SATA 0 presence */
+	{ 13, MPP_SATA_LED },		/* SATA 1 presence */
+	{ 14, MPP_SATA_LED },		/* SATA 0 active */
+	{ 15, MPP_SATA_LED },		/* SATA 1 active */
+	{ 16, MPP_UART },		/* UART1 RXD */
+	{ 17, MPP_UART },		/* UART1 TXD */
+	{ 18, MPP_GPIO },		/* SW_RST */
+	{ 19, MPP_UNUSED },
+	{ -1 },
 };
 
-/*
- * QNAP TS-[12]09 specific power off method via UART1-attached PIC
- */
-
-#define UART1_REG(x)  (UART1_VIRT_BASE + ((UART_##x) << 2))
-
-static void qnap_ts209_power_off(void)
-{
-	/* 19200 baud divisor */
-	const unsigned divisor = ((ORION5X_TCLK + (8 * 19200)) / (16 * 19200));
-
-	pr_info("%s: triggering power-off...\n", __func__);
-
-	/* hijack uart1 and reset into sane state (19200,8n1) */
-	orion5x_write(UART1_REG(LCR), 0x83);
-	orion5x_write(UART1_REG(DLL), divisor & 0xff);
-	orion5x_write(UART1_REG(DLM), (divisor >> 8) & 0xff);
-	orion5x_write(UART1_REG(LCR), 0x03);
-	orion5x_write(UART1_REG(IER), 0x00);
-	orion5x_write(UART1_REG(FCR), 0x00);
-	orion5x_write(UART1_REG(MCR), 0x00);
-
-	/* send the power-off command 'A' to PIC */
-	orion5x_write(UART1_REG(TX), 'A');
-}
-
 static void __init qnap_ts209_init(void)
 {
 	/*
@@ -368,51 +275,33 @@
 	 */
 	orion5x_init();
 
-	/*
-	 * Setup flash mapping
-	 */
-	orion5x_setup_dev_boot_win(QNAP_TS209_NOR_BOOT_BASE,
-			    QNAP_TS209_NOR_BOOT_SIZE);
-
-	/*
-	 * Open a special address decode windows for the PCIe WA.
-	 */
-	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
-				ORION5X_PCIE_WA_SIZE);
+	orion5x_mpp_conf(ts209_mpp_modes);
 
 	/*
-	 * Setup Multiplexing Pins --
-	 * MPP[0] Reserved
-	 * MPP[1] USB copy button (0 active)
-	 * MPP[2] Load defaults button (0 active)
-	 * MPP[3] GPIO RTC
-	 * MPP[4-5] Reserved
-	 * MPP[6] PCI Int A
-	 * MPP[7] PCI Int B
-	 * MPP[8-11] Reserved
-	 * MPP[12] SATA 0 presence
-	 * MPP[13] SATA 1 presence
-	 * MPP[14] SATA 0 active
-	 * MPP[15] SATA 1 active
-	 * MPP[16] UART1 RXD
-	 * MPP[17] UART1 TXD
-	 * MPP[18] SW_RST (0 active)
-	 * MPP[19] Reserved
 	 * MPP[20] PCI clock 0
 	 * MPP[21] PCI clock 1
 	 * MPP[22] USB 0 over current
 	 * MPP[23-25] Reserved
 	 */
-	orion5x_write(MPP_0_7_CTRL, 0x3);
-	orion5x_write(MPP_8_15_CTRL, 0x55550000);
-	orion5x_write(MPP_16_19_CTRL, 0x5500);
-	orion5x_gpio_set_valid_pins(0x3cc0fff);
 
-	/* register ts209 specific power-off method */
-	pm_power_off = qnap_ts209_power_off;
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
+	qnap_tsx09_find_mac_addr(QNAP_TS209_NOR_BOOT_BASE +
+				 qnap_ts209_partitions[5].offset,
+				 qnap_ts209_partitions[5].size);
+	orion5x_eth_init(&qnap_tsx09_eth_data);
+	orion5x_i2c_init();
+	orion5x_sata_init(&qnap_ts209_sata_data);
+	orion5x_uart0_init();
+
+	orion5x_setup_dev_boot_win(QNAP_TS209_NOR_BOOT_BASE,
+				   QNAP_TS209_NOR_BOOT_SIZE);
+	platform_device_register(&qnap_ts209_nor_flash);
 
-	platform_add_devices(qnap_ts209_devices,
-				ARRAY_SIZE(qnap_ts209_devices));
+	platform_device_register(&qnap_ts209_button_device);
 
 	/* Get RTC IRQ and register the chip */
 	if (gpio_request(TS209_RTC_GPIO, "rtc") == 0) {
@@ -425,14 +314,12 @@
 		pr_warning("qnap_ts209_init: failed to get RTC IRQ\n");
 	i2c_register_board_info(0, &qnap_ts209_i2c_rtc, 1);
 
-	ts209_find_mac_addr();
-	orion5x_eth_init(&qnap_ts209_eth_data);
-
-	orion5x_sata_init(&qnap_ts209_sata_data);
+	/* register tsx09 specific power-off method */
+	pm_power_off = qnap_tsx09_power_off;
 }
 
 MACHINE_START(TS209, "QNAP TS-109/TS-209")
-	/* Maintainer:  Byron Bradley <byron.bbradley@gmail.com> */
+	/* Maintainer: Byron Bradley <byron.bbradley@gmail.com> */
 	.phys_io	= ORION5X_REGS_PHYS_BASE,
 	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
 	.boot_params	= 0x00000100,
--- /dev/null
+++ b/arch/arm/mach-orion5x/ts409-setup.c
@@ -0,0 +1,273 @@
+/*
+ * QNAP TS-409 Board Setup
+ *
+ * Maintainer: Sylver Bruneau <sylver.bruneau@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/serial_reg.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/orion5x.h>
+#include "common.h"
+#include "mpp.h"
+#include "tsx09-common.h"
+
+/*****************************************************************************
+ * QNAP TS-409 Info
+ ****************************************************************************/
+
+/*
+ * QNAP TS-409 hardware :
+ * - Marvell 88F5281-D0
+ * - Marvell 88SX7042 SATA controller (PCIe)
+ * - Marvell 88E1118 Gigabit Ethernet PHY
+ * - RTC S35390A (@0x30) on I2C bus
+ * - 8MB NOR flash
+ * - 256MB of DDR-2 RAM
+ */
+
+/*
+ * 8MB NOR flash Device bus boot chip select
+ */
+
+#define QNAP_TS409_NOR_BOOT_BASE 0xff800000
+#define QNAP_TS409_NOR_BOOT_SIZE SZ_8M
+
+/****************************************************************************
+ * 8MiB NOR flash. The struct mtd_partition is not in the same order as the
+ *     partitions on the device because we want to keep compatability with
+ *     existing QNAP firmware.
+ *
+ * Layout as used by QNAP:
+ *  [2] 0x00000000-0x00200000 : "Kernel"
+ *  [3] 0x00200000-0x00600000 : "RootFS1"
+ *  [4] 0x00600000-0x00700000 : "RootFS2"
+ *  [6] 0x00700000-0x00760000 : "NAS Config" (read-only)
+ *  [5] 0x00760000-0x00780000 : "U-Boot Config"
+ *  [1] 0x00780000-0x00800000 : "U-Boot" (read-only)
+ ***************************************************************************/
+static struct mtd_partition qnap_ts409_partitions[] = {
+	{
+		.name		= "U-Boot",
+		.size		= 0x00080000,
+		.offset		= 0x00780000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "Kernel",
+		.size		= 0x00200000,
+		.offset		= 0,
+	}, {
+		.name		= "RootFS1",
+		.size		= 0x00400000,
+		.offset		= 0x00200000,
+	}, {
+		.name		= "RootFS2",
+		.size		= 0x00100000,
+		.offset		= 0x00600000,
+	}, {
+		.name		= "U-Boot Config",
+		.size		= 0x00020000,
+		.offset		= 0x00760000,
+	}, {
+		.name		= "NAS Config",
+		.size		= 0x00060000,
+		.offset		= 0x00700000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+};
+
+static struct physmap_flash_data qnap_ts409_nor_flash_data = {
+	.width		= 1,
+	.parts		= qnap_ts409_partitions,
+	.nr_parts	= ARRAY_SIZE(qnap_ts409_partitions)
+};
+
+static struct resource qnap_ts409_nor_flash_resource = {
+	.flags	= IORESOURCE_MEM,
+	.start	= QNAP_TS409_NOR_BOOT_BASE,
+	.end	= QNAP_TS409_NOR_BOOT_BASE + QNAP_TS409_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device qnap_ts409_nor_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= { .platform_data = &qnap_ts409_nor_flash_data, },
+	.num_resources	= 1,
+	.resource	= &qnap_ts409_nor_flash_resource,
+};
+
+/*****************************************************************************
+ * PCI
+ ****************************************************************************/
+
+static int __init qnap_ts409_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq;
+
+	/*
+	 * Check for devices with hard-wired IRQs.
+	 */
+	irq = orion5x_pci_map_irq(dev, slot, pin);
+	if (irq != -1)
+		return irq;
+
+	/*
+	 * PCI isn't used on the TS-409
+	 */
+	return -1;
+}
+
+static struct hw_pci qnap_ts409_pci __initdata = {
+	.nr_controllers	= 2,
+	.swizzle	= pci_std_swizzle,
+	.setup		= orion5x_pci_sys_setup,
+	.scan		= orion5x_pci_sys_scan_bus,
+	.map_irq	= qnap_ts409_pci_map_irq,
+};
+
+static int __init qnap_ts409_pci_init(void)
+{
+	if (machine_is_ts409())
+		pci_common_init(&qnap_ts409_pci);
+
+	return 0;
+}
+
+subsys_initcall(qnap_ts409_pci_init);
+
+/*****************************************************************************
+ * RTC S35390A on I2C bus
+ ****************************************************************************/
+
+#define TS409_RTC_GPIO	10
+
+static struct i2c_board_info __initdata qnap_ts409_i2c_rtc = {
+	I2C_BOARD_INFO("s35390a", 0x30),
+};
+
+/****************************************************************************
+ * GPIO Attached Keys
+ *     Power button is attached to the PIC microcontroller
+ ****************************************************************************/
+
+#define QNAP_TS409_GPIO_KEY_MEDIA	15
+
+static struct gpio_keys_button qnap_ts409_buttons[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= QNAP_TS409_GPIO_KEY_MEDIA,
+		.desc		= "USB Copy Button",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data qnap_ts409_button_data = {
+	.buttons	= qnap_ts409_buttons,
+	.nbuttons	= ARRAY_SIZE(qnap_ts409_buttons),
+};
+
+static struct platform_device qnap_ts409_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &qnap_ts409_button_data,
+	},
+};
+
+/*****************************************************************************
+ * General Setup
+ ****************************************************************************/
+static struct orion5x_mpp_mode ts409_mpp_modes[] __initdata = {
+	{  0, MPP_UNUSED },
+	{  1, MPP_UNUSED },
+	{  2, MPP_UNUSED },
+	{  3, MPP_UNUSED },
+	{  4, MPP_GPIO },		/* HDD 1 status */
+	{  5, MPP_GPIO },		/* HDD 2 status */
+	{  6, MPP_GPIO },		/* HDD 3 status */
+	{  7, MPP_GPIO },		/* HDD 4 status */
+	{  8, MPP_UNUSED },
+	{  9, MPP_UNUSED },
+	{ 10, MPP_GPIO },		/* RTC int */
+	{ 11, MPP_UNUSED },
+	{ 12, MPP_UNUSED },
+	{ 13, MPP_UNUSED },
+	{ 14, MPP_GPIO },		/* SW_RST */
+	{ 15, MPP_GPIO },		/* USB copy button */
+	{ 16, MPP_UART },		/* UART1 RXD */
+	{ 17, MPP_UART },		/* UART1 TXD */
+	{ 18, MPP_UNUSED },
+	{ 19, MPP_UNUSED },
+	{ -1 },
+};
+
+static void __init qnap_ts409_init(void)
+{
+	/*
+	 * Setup basic Orion functions. Need to be called early.
+	 */
+	orion5x_init();
+
+	orion5x_mpp_conf(ts409_mpp_modes);
+
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	qnap_tsx09_find_mac_addr(QNAP_TS409_NOR_BOOT_BASE +
+				 qnap_ts409_partitions[5].offset,
+				 qnap_ts409_partitions[5].size);
+	orion5x_eth_init(&qnap_tsx09_eth_data);
+	orion5x_i2c_init();
+	orion5x_uart0_init();
+
+	orion5x_setup_dev_boot_win(QNAP_TS409_NOR_BOOT_BASE,
+				   QNAP_TS409_NOR_BOOT_SIZE);
+	platform_device_register(&qnap_ts409_nor_flash);
+
+	platform_device_register(&qnap_ts409_button_device);
+
+	/* Get RTC IRQ and register the chip */
+	if (gpio_request(TS409_RTC_GPIO, "rtc") == 0) {
+		if (gpio_direction_input(TS409_RTC_GPIO) == 0)
+			qnap_ts409_i2c_rtc.irq = gpio_to_irq(TS409_RTC_GPIO);
+		else
+			gpio_free(TS409_RTC_GPIO);
+	}
+	if (qnap_ts409_i2c_rtc.irq == 0)
+		pr_warning("qnap_ts409_init: failed to get RTC IRQ\n");
+	i2c_register_board_info(0, &qnap_ts409_i2c_rtc, 1);
+
+	/* register tsx09 specific power-off method */
+	pm_power_off = qnap_tsx09_power_off;
+}
+
+MACHINE_START(TS409, "QNAP TS-409")
+	/* Maintainer:  Sylver Bruneau <sylver.bruneau@gmail.com> */
+	.phys_io	= ORION5X_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= qnap_ts409_init,
+	.map_io		= orion5x_map_io,
+	.init_irq	= orion5x_init_irq,
+	.timer		= &orion5x_timer,
+	.fixup		= tag_fixup_mem32,
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-orion5x/ts78xx-setup.c
@@ -0,0 +1,277 @@
+/*
+ * arch/arm/mach-orion5x/ts78xx-setup.c
+ *
+ * Maintainer: Alexander Clouter <alex@digriz.org.uk>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/ata_platform.h>
+#include <linux/m48t86.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/arch/orion5x.h>
+#include "common.h"
+#include "mpp.h"
+
+/*****************************************************************************
+ * TS-78xx Info
+ ****************************************************************************/
+
+/*
+ * FPGA - lives where the PCI bus would be at ORION5X_PCI_MEM_PHYS_BASE
+ */
+#define TS78XX_FPGA_REGS_PHYS_BASE	0xe8000000
+#define TS78XX_FPGA_REGS_VIRT_BASE	0xff900000
+#define TS78XX_FPGA_REGS_SIZE		SZ_1M
+
+#define TS78XX_FPGA_REGS_SYSCON_ID	(TS78XX_FPGA_REGS_VIRT_BASE | 0x000)
+#define TS78XX_FPGA_REGS_SYSCON_LCDI	(TS78XX_FPGA_REGS_VIRT_BASE | 0x004)
+#define TS78XX_FPGA_REGS_SYSCON_LCDO	(TS78XX_FPGA_REGS_VIRT_BASE | 0x008)
+
+#define TS78XX_FPGA_REGS_RTC_CTRL	(TS78XX_FPGA_REGS_VIRT_BASE | 0x808)
+#define TS78XX_FPGA_REGS_RTC_DATA	(TS78XX_FPGA_REGS_VIRT_BASE | 0x80c)
+
+/*
+ * 512kB NOR flash Device
+ */
+#define TS78XX_NOR_BOOT_BASE		0xff800000
+#define TS78XX_NOR_BOOT_SIZE		SZ_512K
+
+/*****************************************************************************
+ * I/O Address Mapping
+ ****************************************************************************/
+static struct map_desc ts78xx_io_desc[] __initdata = {
+	{
+		.virtual	= TS78XX_FPGA_REGS_VIRT_BASE,
+		.pfn		= __phys_to_pfn(TS78XX_FPGA_REGS_PHYS_BASE),
+		.length		= TS78XX_FPGA_REGS_SIZE,
+		.type		= MT_DEVICE,
+	},
+};
+
+void __init ts78xx_map_io(void)
+{
+	orion5x_map_io();
+	iotable_init(ts78xx_io_desc, ARRAY_SIZE(ts78xx_io_desc));
+}
+
+/*****************************************************************************
+ * 512kB NOR Boot Flash - the chip is a M25P40
+ ****************************************************************************/
+static struct mtd_partition ts78xx_nor_boot_flash_resources[] = {
+	{
+		.name		= "ts-bootrom",
+		.offset		= 0,
+		/* only the first 256kB is used */
+		.size		= SZ_256K,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+};
+
+static struct physmap_flash_data ts78xx_nor_boot_flash_data = {
+	.width		= 1,
+	.parts		= ts78xx_nor_boot_flash_resources,
+	.nr_parts	= ARRAY_SIZE(ts78xx_nor_boot_flash_resources),
+};
+
+static struct resource ts78xx_nor_boot_flash_resource = {
+	.flags		= IORESOURCE_MEM,
+	.start		= TS78XX_NOR_BOOT_BASE,
+	.end		= TS78XX_NOR_BOOT_BASE + TS78XX_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device ts78xx_nor_boot_flash = {
+	.name		= "physmap-flash",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &ts78xx_nor_boot_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &ts78xx_nor_boot_flash_resource,
+};
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+static struct mv643xx_eth_platform_data ts78xx_eth_data = {
+	.phy_addr	= 0,
+	.force_phy_addr = 1,
+};
+
+/*****************************************************************************
+ * RTC M48T86 - nicked^Wborrowed from arch/arm/mach-ep93xx/ts72xx.c
+ ****************************************************************************/
+#ifdef CONFIG_RTC_DRV_M48T86
+static unsigned char ts78xx_rtc_readbyte(unsigned long addr)
+{
+	writeb(addr, TS78XX_FPGA_REGS_RTC_CTRL);
+	return readb(TS78XX_FPGA_REGS_RTC_DATA);
+}
+
+static void ts78xx_rtc_writebyte(unsigned char value, unsigned long addr)
+{
+	writeb(addr, TS78XX_FPGA_REGS_RTC_CTRL);
+	writeb(value, TS78XX_FPGA_REGS_RTC_DATA);
+}
+
+static struct m48t86_ops ts78xx_rtc_ops = {
+	.readbyte	= ts78xx_rtc_readbyte,
+	.writebyte	= ts78xx_rtc_writebyte,
+};
+
+static struct platform_device ts78xx_rtc_device = {
+	.name		= "rtc-m48t86",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &ts78xx_rtc_ops,
+	},
+	.num_resources	= 0,
+};
+
+/*
+ * TS uses some of the user storage space on the RTC chip so see if it is
+ * present; as it's an optional feature at purchase time and not all boards
+ * will have it present
+ *
+ * I've used the method TS use in their rtc7800.c example for the detection
+ *
+ * TODO: track down a guinea pig without an RTC to see if we can work out a
+ * 		better RTC detection routine
+ */
+static int __init ts78xx_rtc_init(void)
+{
+	unsigned char tmp_rtc0, tmp_rtc1;
+
+	tmp_rtc0 = ts78xx_rtc_readbyte(126);
+	tmp_rtc1 = ts78xx_rtc_readbyte(127);
+
+	ts78xx_rtc_writebyte(0x00, 126);
+	ts78xx_rtc_writebyte(0x55, 127);
+	if (ts78xx_rtc_readbyte(127) == 0x55) {
+		ts78xx_rtc_writebyte(0xaa, 127);
+		if (ts78xx_rtc_readbyte(127) == 0xaa
+				&& ts78xx_rtc_readbyte(126) == 0x00) {
+			ts78xx_rtc_writebyte(tmp_rtc0, 126);
+			ts78xx_rtc_writebyte(tmp_rtc1, 127);
+			platform_device_register(&ts78xx_rtc_device);
+			return 1;
+		}
+	}
+
+	return 0;
+};
+#else
+static int __init ts78xx_rtc_init(void)
+{
+	return 0;
+}
+#endif
+
+/*****************************************************************************
+ * SATA
+ ****************************************************************************/
+static struct mv_sata_platform_data ts78xx_sata_data = {
+	.n_ports	= 2,
+};
+
+/*****************************************************************************
+ * print some information regarding the board
+ ****************************************************************************/
+static void __init ts78xx_print_board_id(void)
+{
+	unsigned int board_info;
+
+	board_info = readl(TS78XX_FPGA_REGS_SYSCON_ID);
+	printk(KERN_INFO "TS-78xx Info: FPGA rev=%.2x, Board Magic=%.6x, ",
+				board_info & 0xff,
+				(board_info >> 8) & 0xffffff);
+	board_info = readl(TS78XX_FPGA_REGS_SYSCON_LCDI);
+	printk("JP1=%d, JP2=%d\n",
+				(board_info >> 30) & 0x1,
+				(board_info >> 31) & 0x1);
+};
+
+/*****************************************************************************
+ * General Setup
+ ****************************************************************************/
+static struct orion5x_mpp_mode ts78xx_mpp_modes[] __initdata = {
+	{  0, MPP_UNUSED },
+	{  1, MPP_GPIO },		/* JTAG Clock */
+	{  2, MPP_GPIO },		/* JTAG Data In */
+	{  3, MPP_GPIO },		/* Lat ECP2 256 FPGA - PB2B */
+	{  4, MPP_GPIO },		/* JTAG Data Out */
+	{  5, MPP_GPIO },		/* JTAG TMS */
+	{  6, MPP_GPIO },		/* Lat ECP2 256 FPGA - PB31A_CLK4+ */
+	{  7, MPP_GPIO },		/* Lat ECP2 256 FPGA - PB22B */
+	{  8, MPP_UNUSED },
+	{  9, MPP_UNUSED },
+	{ 10, MPP_UNUSED },
+	{ 11, MPP_UNUSED },
+	{ 12, MPP_UNUSED },
+	{ 13, MPP_UNUSED },
+	{ 14, MPP_UNUSED },
+	{ 15, MPP_UNUSED },
+	{ 16, MPP_UART },
+	{ 17, MPP_UART },
+	{ 18, MPP_UART },
+	{ 19, MPP_UART },
+	{ -1 },
+};
+
+static void __init ts78xx_init(void)
+{
+	/*
+	 * Setup basic Orion functions. Need to be called early.
+	 */
+	orion5x_init();
+
+	ts78xx_print_board_id();
+
+	orion5x_mpp_conf(ts78xx_mpp_modes);
+
+	/*
+	 * MPP[20] PCI Clock Out 1
+	 * MPP[21] PCI Clock Out 0
+	 * MPP[22] Unused
+	 * MPP[23] Unused
+	 * MPP[24] Unused
+	 * MPP[25] Unused
+	 */
+
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_ehci1_init();
+	orion5x_eth_init(&ts78xx_eth_data);
+	orion5x_sata_init(&ts78xx_sata_data);
+	orion5x_uart0_init();
+	orion5x_uart1_init();
+
+	orion5x_setup_dev_boot_win(TS78XX_NOR_BOOT_BASE,
+				   TS78XX_NOR_BOOT_SIZE);
+	platform_device_register(&ts78xx_nor_boot_flash);
+
+	if (!ts78xx_rtc_init())
+		printk(KERN_INFO "TS-78xx RTC not detected or enabled\n");
+}
+
+MACHINE_START(TS78XX, "Technologic Systems TS-78xx SBC")
+	/* Maintainer: Alexander Clouter <alex@digriz.org.uk> */
+	.phys_io	= ORION5X_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= ts78xx_init,
+	.map_io		= ts78xx_map_io,
+	.init_irq	= orion5x_init_irq,
+	.timer		= &orion5x_timer,
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-orion5x/tsx09-common.c
@@ -0,0 +1,132 @@
+/*
+ * QNAP TS-x09 Boards common functions
+ *
+ * Maintainers: Lennert Buytenhek <buytenh@marvell.com>
+ *		Byron Bradley <byron.bbradley@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/serial_reg.h>
+#include "tsx09-common.h"
+
+/*****************************************************************************
+ * QNAP TS-x09 specific power off method via UART1-attached PIC
+ ****************************************************************************/
+
+#define UART1_REG(x)	(UART1_VIRT_BASE + ((UART_##x) << 2))
+
+void qnap_tsx09_power_off(void)
+{
+	/* 19200 baud divisor */
+	const unsigned divisor = ((ORION5X_TCLK + (8 * 19200)) / (16 * 19200));
+
+	pr_info("%s: triggering power-off...\n", __func__);
+
+	/* hijack uart1 and reset into sane state (19200,8n1) */
+	writel(0x83, UART1_REG(LCR));
+	writel(divisor & 0xff, UART1_REG(DLL));
+	writel((divisor >> 8) & 0xff, UART1_REG(DLM));
+	writel(0x03, UART1_REG(LCR));
+	writel(0x00, UART1_REG(IER));
+	writel(0x00, UART1_REG(FCR));
+	writel(0x00, UART1_REG(MCR));
+
+	/* send the power-off command 'A' to PIC */
+	writel('A', UART1_REG(TX));
+}
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+
+struct mv643xx_eth_platform_data qnap_tsx09_eth_data = {
+	.phy_addr	= 8,
+};
+
+static int __init qnap_tsx09_parse_hex_nibble(char n)
+{
+	if (n >= '0' && n <= '9')
+		return n - '0';
+
+	if (n >= 'A' && n <= 'F')
+		return n - 'A' + 10;
+
+	if (n >= 'a' && n <= 'f')
+		return n - 'a' + 10;
+
+	return -1;
+}
+
+static int __init qnap_tsx09_parse_hex_byte(const char *b)
+{
+	int hi;
+	int lo;
+
+	hi = qnap_tsx09_parse_hex_nibble(b[0]);
+	lo = qnap_tsx09_parse_hex_nibble(b[1]);
+
+	if (hi < 0 || lo < 0)
+		return -1;
+
+	return (hi << 4) | lo;
+}
+
+static int __init qnap_tsx09_check_mac_addr(const char *addr_str)
+{
+	u_int8_t addr[6];
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int byte;
+
+		/*
+		 * Enforce "xx:xx:xx:xx:xx:xx\n" format.
+		 */
+		if (addr_str[(i * 3) + 2] != ((i < 5) ? ':' : '\n'))
+			return -1;
+
+		byte = qnap_tsx09_parse_hex_byte(addr_str + (i * 3));
+		if (byte < 0)
+			return -1;
+		addr[i] = byte;
+	}
+
+	printk(KERN_INFO "tsx09: found ethernet mac address ");
+	for (i = 0; i < 6; i++)
+		printk("%.2x%s", addr[i], (i < 5) ? ":" : ".\n");
+
+	memcpy(qnap_tsx09_eth_data.mac_addr, addr, 6);
+
+	return 0;
+}
+
+/*
+ * The 'NAS Config' flash partition has an ext2 filesystem which
+ * contains a file that has the ethernet MAC address in plain text
+ * (format "xx:xx:xx:xx:xx:xx\n").
+ */
+void __init qnap_tsx09_find_mac_addr(u32 mem_base, u32 size)
+{
+	unsigned long addr;
+
+	for (addr = mem_base; addr < (mem_base + size); addr += 1024) {
+		char *nor_page;
+		int ret = 0;
+
+		nor_page = ioremap(addr, 1024);
+		if (nor_page != NULL) {
+			ret = qnap_tsx09_check_mac_addr(nor_page);
+			iounmap(nor_page);
+		}
+
+		if (ret == 0)
+			break;
+	}
+}
--- /dev/null
+++ b/arch/arm/mach-orion5x/tsx09-common.h
@@ -0,0 +1,20 @@
+#ifndef __ARCH_ORION5X_TSX09_COMMON_H
+#define __ARCH_ORION5X_TSX09_COMMON_H
+
+/*
+ * QNAP TS-x09 Boards power-off function
+ */
+extern void qnap_tsx09_power_off(void);
+
+/*
+ * QNAP TS-x09 Boards function to find Ethernet MAC address in flash memory
+ */
+extern void __init qnap_tsx09_find_mac_addr(u32 mem_base, u32 size);
+
+/*
+ * QNAP TS-x09 Boards ethernet declaration
+ */
+extern struct mv643xx_eth_platform_data qnap_tsx09_eth_data;
+
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-orion5x/wrt350n-v2-setup.c
@@ -0,0 +1,173 @@
+/*
+ * arch/arm/mach-orion5x/wrt350n-v2-setup.c
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mv643xx_eth.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/orion5x.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct orion5x_mpp_mode wrt350n_v2_mpp_modes[] __initdata = {
+	{  0, MPP_GPIO },		/* Power LED green (0=on) */
+	{  1, MPP_GPIO },		/* Security LED (0=on) */
+	{  2, MPP_GPIO },		/* Internal Button (0=on) */
+	{  3, MPP_GPIO },		/* Reset Button (0=on) */
+	{  4, MPP_GPIO },		/* PCI int */
+	{  5, MPP_GPIO },		/* Power LED orange (0=on) */
+	{  6, MPP_GPIO },		/* USB LED (0=on) */
+	{  7, MPP_GPIO },		/* Wireless LED (0=on) */
+	{  8, MPP_UNUSED },		/* ??? */
+	{  9, MPP_GIGE },		/* GE_RXERR */
+	{ 10, MPP_UNUSED },		/* ??? */
+	{ 11, MPP_UNUSED },		/* ??? */
+	{ 12, MPP_GIGE },		/* GE_TXD[4] */
+	{ 13, MPP_GIGE },		/* GE_TXD[5] */
+	{ 14, MPP_GIGE },		/* GE_TXD[6] */
+	{ 15, MPP_GIGE },		/* GE_TXD[7] */
+	{ 16, MPP_GIGE },		/* GE_RXD[4] */
+	{ 17, MPP_GIGE },		/* GE_RXD[5] */
+	{ 18, MPP_GIGE },		/* GE_RXD[6] */
+	{ 19, MPP_GIGE },		/* GE_RXD[7] */
+	{ -1 },
+};
+
+/*
+ * 8M NOR flash Device bus boot chip select
+ */
+#define WRT350N_V2_NOR_BOOT_BASE	0xf4000000
+#define WRT350N_V2_NOR_BOOT_SIZE	SZ_8M
+
+static struct mtd_partition wrt350n_v2_nor_flash_partitions[] = {
+	{
+		.name		= "kernel",
+		.offset		= 0x00000000,
+		.size		= 0x00760000,
+	}, {
+		.name		= "rootfs",
+		.offset		= 0x001a0000,
+		.size		= 0x005c0000,
+	}, {
+		.name		= "lang",
+		.offset		= 0x00760000,
+		.size		= 0x00040000,
+	}, {
+		.name		= "nvram",
+		.offset		= 0x007a0000,
+		.size		= 0x00020000,
+	}, {
+		.name		= "u-boot",
+		.offset		= 0x007c0000,
+		.size		= 0x00040000,
+	},
+};
+
+static struct physmap_flash_data wrt350n_v2_nor_flash_data = {
+	.width		= 1,
+	.parts		= wrt350n_v2_nor_flash_partitions,
+	.nr_parts	= ARRAY_SIZE(wrt350n_v2_nor_flash_partitions),
+};
+
+static struct resource wrt350n_v2_nor_flash_resource = {
+	.flags		= IORESOURCE_MEM,
+	.start		= WRT350N_V2_NOR_BOOT_BASE,
+	.end		= WRT350N_V2_NOR_BOOT_BASE + WRT350N_V2_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device wrt350n_v2_nor_flash = {
+	.name			= "physmap-flash",
+	.id			= 0,
+	.dev		= {
+		.platform_data	= &wrt350n_v2_nor_flash_data,
+	},
+	.num_resources		= 1,
+	.resource		= &wrt350n_v2_nor_flash_resource,
+};
+
+static struct mv643xx_eth_platform_data wrt350n_v2_eth_data = {
+	.phy_addr	= -1,
+};
+
+static void __init wrt350n_v2_init(void)
+{
+	/*
+	 * Setup basic Orion functions. Need to be called early.
+	 */
+	orion5x_init();
+
+	orion5x_mpp_conf(wrt350n_v2_mpp_modes);
+
+	/*
+	 * Configure peripherals.
+	 */
+	orion5x_ehci0_init();
+	orion5x_eth_init(&wrt350n_v2_eth_data);
+	orion5x_uart0_init();
+
+	orion5x_setup_dev_boot_win(WRT350N_V2_NOR_BOOT_BASE,
+				   WRT350N_V2_NOR_BOOT_SIZE);
+	platform_device_register(&wrt350n_v2_nor_flash);
+}
+
+static int __init wrt350n_v2_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq;
+
+	/*
+	 * Check for devices with hard-wired IRQs.
+	 */
+	irq = orion5x_pci_map_irq(dev, slot, pin);
+	if (irq != -1)
+		return irq;
+
+	/*
+	 * Mini-PCI slot.
+	 */
+	if (slot == 7)
+		return gpio_to_irq(4);
+
+	return -1;
+}
+
+static struct hw_pci wrt350n_v2_pci __initdata = {
+	.nr_controllers	= 2,
+	.swizzle	= pci_std_swizzle,
+	.setup		= orion5x_pci_sys_setup,
+	.scan		= orion5x_pci_sys_scan_bus,
+	.map_irq	= wrt350n_v2_pci_map_irq,
+};
+
+static int __init wrt350n_v2_pci_init(void)
+{
+	if (machine_is_wrt350n_v2())
+		pci_common_init(&wrt350n_v2_pci);
+
+	return 0;
+}
+subsys_initcall(wrt350n_v2_pci_init);
+
+MACHINE_START(WRT350N_V2, "Linksys WRT350N v2")
+	/* Maintainer: Lennert Buytenhek <buytenh@marvell.com> */
+	.phys_io	= ORION5X_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= wrt350n_v2_init,
+	.map_io		= orion5x_map_io,
+	.init_irq	= orion5x_init_irq,
+	.timer		= &orion5x_timer,
+	.fixup		= tag_fixup_mem32,
+MACHINE_END
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -365,7 +365,7 @@
 # Feroceon
 config CPU_FEROCEON
 	bool
-	depends on ARCH_ORION5X
+	depends on ARCH_ORION5X || ARCH_LOKI || ARCH_KIRKWOOD || ARCH_MV78XX0
 	default y
 	select CPU_32v5
 	select CPU_ABRT_EV5T
@@ -373,7 +373,7 @@
 	select CPU_CACHE_VIVT
 	select CPU_CP15_MMU
 	select CPU_COPY_FEROCEON if MMU
-	select CPU_TLB_V4WBI if MMU
+	select CPU_TLB_FEROCEON if MMU
 
 config CPU_FEROCEON_OLD_ID
 	bool "Accept early Feroceon cores with an ARM926 ID"
@@ -551,6 +551,11 @@
 	  ARM Architecture Version 4 TLB with writeback cache and invalidate
 	  instruction cache entry.
 
+config CPU_TLB_FEROCEON
+	bool
+	help
+	  Feroceon TLB (v4wbi with non-outer-cachable page table walks).
+
 config CPU_TLB_V6
 	bool
 
@@ -709,6 +714,14 @@
 	bool
 	default n
 
+config CACHE_FEROCEON_L2
+	bool "Enable the Feroceon L2 cache controller"
+	depends on ARCH_KIRKWOOD || ARCH_MV78XX0
+	default y
+	select OUTER_CACHE
+	help
+	  This option enables the Feroceon L2 cache controller.
+
 config CACHE_L2X0
 	bool "Enable the L2x0 outer cache controller"
 	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176
--- a/arch/arm/mm/Makefile
+++ b/arch/arm/mm/Makefile
@@ -46,6 +46,7 @@
 obj-$(CONFIG_CPU_TLB_V4WT)	+= tlb-v4.o
 obj-$(CONFIG_CPU_TLB_V4WB)	+= tlb-v4wb.o
 obj-$(CONFIG_CPU_TLB_V4WBI)	+= tlb-v4wbi.o
+obj-$(CONFIG_CPU_TLB_FEROCEON)	+= tlb-v4wbi.o	# reuse v4wbi TLB functions
 obj-$(CONFIG_CPU_TLB_V6)	+= tlb-v6.o
 obj-$(CONFIG_CPU_TLB_V7)	+= tlb-v7.o
 
@@ -73,4 +74,5 @@
 obj-$(CONFIG_CPU_V6)		+= proc-v6.o
 obj-$(CONFIG_CPU_V7)		+= proc-v7.o
 
+obj-$(CONFIG_CACHE_FEROCEON_L2)	+= cache-feroceon-l2.o
 obj-$(CONFIG_CACHE_L2X0)	+= cache-l2x0.o
--- /dev/null
+++ b/arch/arm/mm/cache-feroceon-l2.c
@@ -0,0 +1,318 @@
+/*
+ * arch/arm/mm/cache-feroceon-l2.c - Feroceon L2 cache controller support
+ *
+ * Copyright (C) 2008 Marvell Semiconductor
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * References:
+ * - Unified Layer 2 Cache for Feroceon CPU Cores,
+ *   Document ID MV-S104858-00, Rev. A, October 23 2007.
+ */
+
+#include <linux/init.h>
+#include <asm/cacheflush.h>
+#include <asm/plat-orion/cache-feroceon-l2.h>
+
+
+/*
+ * Low-level cache maintenance operations.
+ *
+ * As well as the regular 'clean/invalidate/flush L2 cache line by
+ * MVA' instructions, the Feroceon L2 cache controller also features
+ * 'clean/invalidate L2 range by MVA' operations.
+ *
+ * Cache range operations are initiated by writing the start and
+ * end addresses to successive cp15 registers, and process every
+ * cache line whose first byte address lies in the inclusive range
+ * [start:end].
+ *
+ * The cache range operations stall the CPU pipeline until completion.
+ *
+ * The range operations require two successive cp15 writes, in
+ * between which we don't want to be preempted.
+ */
+static inline void l2_clean_pa(unsigned long addr)
+{
+	__asm__("mcr p15, 1, %0, c15, c9, 3" : : "r" (addr));
+}
+
+static inline void l2_clean_mva_range(unsigned long start, unsigned long end)
+{
+	unsigned long flags;
+
+	/*
+	 * Make sure 'start' and 'end' reference the same page, as
+	 * L2 is PIPT and range operations only do a TLB lookup on
+	 * the start address.
+	 */
+	BUG_ON((start ^ end) & ~(PAGE_SIZE - 1));
+
+	raw_local_irq_save(flags);
+	__asm__("mcr p15, 1, %0, c15, c9, 4" : : "r" (start));
+	__asm__("mcr p15, 1, %0, c15, c9, 5" : : "r" (end));
+	raw_local_irq_restore(flags);
+}
+
+static inline void l2_clean_pa_range(unsigned long start, unsigned long end)
+{
+	l2_clean_mva_range(__phys_to_virt(start), __phys_to_virt(end));
+}
+
+static inline void l2_clean_inv_pa(unsigned long addr)
+{
+	__asm__("mcr p15, 1, %0, c15, c10, 3" : : "r" (addr));
+}
+
+static inline void l2_inv_pa(unsigned long addr)
+{
+	__asm__("mcr p15, 1, %0, c15, c11, 3" : : "r" (addr));
+}
+
+static inline void l2_inv_mva_range(unsigned long start, unsigned long end)
+{
+	unsigned long flags;
+
+	/*
+	 * Make sure 'start' and 'end' reference the same page, as
+	 * L2 is PIPT and range operations only do a TLB lookup on
+	 * the start address.
+	 */
+	BUG_ON((start ^ end) & ~(PAGE_SIZE - 1));
+
+	raw_local_irq_save(flags);
+	__asm__("mcr p15, 1, %0, c15, c11, 4" : : "r" (start));
+	__asm__("mcr p15, 1, %0, c15, c11, 5" : : "r" (end));
+	raw_local_irq_restore(flags);
+}
+
+static inline void l2_inv_pa_range(unsigned long start, unsigned long end)
+{
+	l2_inv_mva_range(__phys_to_virt(start), __phys_to_virt(end));
+}
+
+
+/*
+ * Linux primitives.
+ *
+ * Note that the end addresses passed to Linux primitives are
+ * noninclusive, while the hardware cache range operations use
+ * inclusive start and end addresses.
+ */
+#define CACHE_LINE_SIZE		32
+#define MAX_RANGE_SIZE		1024
+
+static int l2_wt_override;
+
+static unsigned long calc_range_end(unsigned long start, unsigned long end)
+{
+	unsigned long range_end;
+
+	BUG_ON(start & (CACHE_LINE_SIZE - 1));
+	BUG_ON(end & (CACHE_LINE_SIZE - 1));
+
+	/*
+	 * Try to process all cache lines between 'start' and 'end'.
+	 */
+	range_end = end;
+
+	/*
+	 * Limit the number of cache lines processed at once,
+	 * since cache range operations stall the CPU pipeline
+	 * until completion.
+	 */
+	if (range_end > start + MAX_RANGE_SIZE)
+		range_end = start + MAX_RANGE_SIZE;
+
+	/*
+	 * Cache range operations can't straddle a page boundary.
+	 */
+	if (range_end > (start | (PAGE_SIZE - 1)) + 1)
+		range_end = (start | (PAGE_SIZE - 1)) + 1;
+
+	return range_end;
+}
+
+static void feroceon_l2_inv_range(unsigned long start, unsigned long end)
+{
+	/*
+	 * Clean and invalidate partial first cache line.
+	 */
+	if (start & (CACHE_LINE_SIZE - 1)) {
+		l2_clean_inv_pa(start & ~(CACHE_LINE_SIZE - 1));
+		start = (start | (CACHE_LINE_SIZE - 1)) + 1;
+	}
+
+	/*
+	 * Clean and invalidate partial last cache line.
+	 */
+	if (end & (CACHE_LINE_SIZE - 1)) {
+		l2_clean_inv_pa(end & ~(CACHE_LINE_SIZE - 1));
+		end &= ~(CACHE_LINE_SIZE - 1);
+	}
+
+	/*
+	 * Invalidate all full cache lines between 'start' and 'end'.
+	 */
+	while (start != end) {
+		unsigned long range_end = calc_range_end(start, end);
+		l2_inv_pa_range(start, range_end - CACHE_LINE_SIZE);
+		start = range_end;
+	}
+
+	dsb();
+}
+
+static void feroceon_l2_clean_range(unsigned long start, unsigned long end)
+{
+	/*
+	 * If L2 is forced to WT, the L2 will always be clean and we
+	 * don't need to do anything here.
+	 */
+	if (!l2_wt_override) {
+		start &= ~(CACHE_LINE_SIZE - 1);
+		end = (end + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1);
+		while (start != end) {
+			unsigned long range_end = calc_range_end(start, end);
+			l2_clean_pa_range(start, range_end - CACHE_LINE_SIZE);
+			start = range_end;
+		}
+	}
+
+	dsb();
+}
+
+static void feroceon_l2_flush_range(unsigned long start, unsigned long end)
+{
+	start &= ~(CACHE_LINE_SIZE - 1);
+	end = (end + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1);
+	while (start != end) {
+		unsigned long range_end = calc_range_end(start, end);
+		if (!l2_wt_override)
+			l2_clean_pa_range(start, range_end - CACHE_LINE_SIZE);
+		l2_inv_pa_range(start, range_end - CACHE_LINE_SIZE);
+		start = range_end;
+	}
+
+	dsb();
+}
+
+
+/*
+ * Routines to disable and re-enable the D-cache and I-cache at run
+ * time.  These are necessary because the L2 cache can only be enabled
+ * or disabled while the L1 Dcache and Icache are both disabled.
+ */
+static void __init invalidate_and_disable_dcache(void)
+{
+	u32 cr;
+
+	cr = get_cr();
+	if (cr & CR_C) {
+		unsigned long flags;
+
+		raw_local_irq_save(flags);
+		flush_cache_all();
+		set_cr(cr & ~CR_C);
+		raw_local_irq_restore(flags);
+	}
+}
+
+static void __init enable_dcache(void)
+{
+	u32 cr;
+
+	cr = get_cr();
+	if (!(cr & CR_C))
+		set_cr(cr | CR_C);
+}
+
+static void __init __invalidate_icache(void)
+{
+	int dummy;
+
+	__asm__ __volatile__("mcr p15, 0, %0, c7, c5, 0\n" : "=r" (dummy));
+}
+
+static void __init invalidate_and_disable_icache(void)
+{
+	u32 cr;
+
+	cr = get_cr();
+	if (cr & CR_I) {
+		set_cr(cr & ~CR_I);
+		__invalidate_icache();
+	}
+}
+
+static void __init enable_icache(void)
+{
+	u32 cr;
+
+	cr = get_cr();
+	if (!(cr & CR_I))
+		set_cr(cr | CR_I);
+}
+
+static inline u32 read_extra_features(void)
+{
+	u32 u;
+
+	__asm__("mrc p15, 1, %0, c15, c1, 0" : "=r" (u));
+
+	return u;
+}
+
+static inline void write_extra_features(u32 u)
+{
+	__asm__("mcr p15, 1, %0, c15, c1, 0" : : "r" (u));
+}
+
+static void __init disable_l2_prefetch(void)
+{
+	u32 u;
+
+	/*
+	 * Read the CPU Extra Features register and verify that the
+	 * Disable L2 Prefetch bit is set.
+	 */
+	u = read_extra_features();
+	if (!(u & 0x01000000)) {
+		printk(KERN_INFO "Feroceon L2: Disabling L2 prefetch.\n");
+		write_extra_features(u | 0x01000000);
+	}
+}
+
+static void __init enable_l2(void)
+{
+	u32 u;
+
+	u = read_extra_features();
+	if (!(u & 0x00400000)) {
+		printk(KERN_INFO "Feroceon L2: Enabling L2\n");
+
+		invalidate_and_disable_dcache();
+		invalidate_and_disable_icache();
+		write_extra_features(u | 0x00400000);
+		enable_icache();
+		enable_dcache();
+	}
+}
+
+void __init feroceon_l2_init(int __l2_wt_override)
+{
+	l2_wt_override = __l2_wt_override;
+
+	disable_l2_prefetch();
+
+	outer_cache.inv_range = feroceon_l2_inv_range;
+	outer_cache.clean_range = feroceon_l2_clean_range;
+	outer_cache.flush_range = feroceon_l2_flush_range;
+
+	enable_l2();
+
+	printk(KERN_INFO "Feroceon L2: Cache support initialised%s.\n",
+			 l2_wt_override ? ", in WT override mode" : "");
+}
--- a/arch/arm/mm/proc-feroceon.S
+++ b/arch/arm/mm/proc-feroceon.S
@@ -44,11 +44,31 @@
  */
 #define CACHE_DLINESIZE	32
 
+	.bss
+	.align 3
+__cache_params_loc:
+	.space	8
+
 	.text
+__cache_params:
+	.word	__cache_params_loc
+
 /*
  * cpu_feroceon_proc_init()
  */
 ENTRY(cpu_feroceon_proc_init)
+	mrc	p15, 0, r0, c0, c0, 1		@ read cache type register
+	ldr	r1, __cache_params
+	mov	r2, #(16 << 5)
+	tst	r0, #(1 << 16)			@ get way
+	mov	r0, r0, lsr #18			@ get cache size order
+	movne	r3, #((4 - 1) << 30)		@ 4-way
+	and	r0, r0, #0xf
+	moveq	r3, #0				@ 1-way
+	mov	r2, r2, lsl r0			@ actual cache size
+	movne	r2, r2, lsr #2			@ turned into # of sets
+	sub	r2, r2, #(1 << 5)
+	stmia	r1, {r2, r3}
 	mov	pc, lr
 
 /*
@@ -59,6 +79,13 @@
 	mov	ip, #PSR_F_BIT | PSR_I_BIT | SVC_MODE
 	msr	cpsr_c, ip
 	bl	feroceon_flush_kern_cache_all
+
+#if defined(CONFIG_CACHE_FEROCEON_L2) && !defined(CONFIG_L2_CACHE_WRITETHROUGH)
+	mov	r0, #0
+	mcr	p15, 1, r0, c15, c9, 0		@ clean L2
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+#endif
+
 	mrc	p15, 0, r0, c1, c0, 0		@ ctrl register
 	bic	r0, r0, #0x1000			@ ...i............
 	bic	r0, r0, #0x000e			@ ............wca.
@@ -117,11 +144,19 @@
  */
 ENTRY(feroceon_flush_kern_cache_all)
 	mov	r2, #VM_EXEC
-	mov	ip, #0
+
 __flush_whole_cache:
-1:	mrc	p15, 0, r15, c7, c14, 3 	@ test,clean,invalidate
-	bne	1b
+	ldr	r1, __cache_params
+	ldmia	r1, {r1, r3}
+1:	orr	ip, r1, r3
+2:	mcr	p15, 0, ip, c7, c14, 2		@ clean + invalidate D set/way
+	subs	ip, ip, #(1 << 30)		@ next way
+	bcs	2b
+	subs	r1, r1, #(1 << 5)		@ next set
+	bcs	1b
+
 	tst	r2, #VM_EXEC
+	mov	ip, #0
 	mcrne	p15, 0, ip, c7, c5, 0		@ invalidate I cache
 	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
 	mov	pc, lr
@@ -138,7 +173,6 @@
  */
 	.align	5
 ENTRY(feroceon_flush_user_cache_range)
-	mov	ip, #0
 	sub	r3, r1, r0			@ calculate total size
 	cmp	r3, #CACHE_DLIMIT
 	bgt	__flush_whole_cache
@@ -152,6 +186,7 @@
 	cmp	r0, r1
 	blo	1b
 	tst	r2, #VM_EXEC
+	mov	ip, #0
 	mcrne	p15, 0, ip, c7, c10, 4		@ drain WB
 	mov	pc, lr
 
@@ -209,6 +244,20 @@
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
 
+	.align	5
+ENTRY(feroceon_range_flush_kern_dcache_page)
+	mrs	r2, cpsr
+	add	r1, r0, #PAGE_SZ - CACHE_DLINESIZE	@ top addr is inclusive
+	orr	r3, r2, #PSR_I_BIT
+	msr	cpsr_c, r3			@ disable interrupts
+	mcr	p15, 5, r0, c15, c15, 0		@ D clean/inv range start
+	mcr	p15, 5, r1, c15, c15, 1		@ D clean/inv range top
+	msr	cpsr_c, r2			@ restore interrupts
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
 /*
  *	dma_inv_range(start, end)
  *
@@ -225,10 +274,10 @@
 	.align	5
 ENTRY(feroceon_dma_inv_range)
 	tst	r0, #CACHE_DLINESIZE - 1
+	bic	r0, r0, #CACHE_DLINESIZE - 1
 	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
 	tst	r1, #CACHE_DLINESIZE - 1
 	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
-	bic	r0, r0, #CACHE_DLINESIZE - 1
 1:	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D entry
 	add	r0, r0, #CACHE_DLINESIZE
 	cmp	r0, r1
@@ -236,6 +285,22 @@
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
 
+	.align	5
+ENTRY(feroceon_range_dma_inv_range)
+	mrs	r2, cpsr
+	tst	r0, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r0, c7, c10, 1		@ clean D entry
+	tst	r1, #CACHE_DLINESIZE - 1
+	mcrne	p15, 0, r1, c7, c10, 1		@ clean D entry
+	cmp	r1, r0
+	subne	r1, r1, #1			@ top address is inclusive
+	orr	r3, r2, #PSR_I_BIT
+	msr	cpsr_c, r3			@ disable interrupts
+	mcr	p15, 5, r0, c15, c14, 0		@ D inv range start
+	mcr	p15, 5, r1, c15, c14, 1		@ D inv range top
+	msr	cpsr_c, r2			@ restore interrupts
+	mov	pc, lr
+
 /*
  *	dma_clean_range(start, end)
  *
@@ -256,6 +321,19 @@
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
 
+	.align	5
+ENTRY(feroceon_range_dma_clean_range)
+	mrs	r2, cpsr
+	cmp	r1, r0
+	subne	r1, r1, #1			@ top address is inclusive
+	orr	r3, r2, #PSR_I_BIT
+	msr	cpsr_c, r3			@ disable interrupts
+	mcr	p15, 5, r0, c15, c13, 0		@ D clean range start
+	mcr	p15, 5, r1, c15, c13, 1		@ D clean range top
+	msr	cpsr_c, r2			@ restore interrupts
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
 /*
  *	dma_flush_range(start, end)
  *
@@ -274,6 +352,19 @@
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
 
+	.align	5
+ENTRY(feroceon_range_dma_flush_range)
+	mrs	r2, cpsr
+	cmp	r1, r0
+	subne	r1, r1, #1			@ top address is inclusive
+	orr	r3, r2, #PSR_I_BIT
+	msr	cpsr_c, r3			@ disable interrupts
+	mcr	p15, 5, r0, c15, c15, 0		@ D clean/inv range start
+	mcr	p15, 5, r1, c15, c15, 1		@ D clean/inv range top
+	msr	cpsr_c, r2			@ restore interrupts
+	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
+	mov	pc, lr
+
 ENTRY(feroceon_cache_fns)
 	.long	feroceon_flush_kern_cache_all
 	.long	feroceon_flush_user_cache_all
@@ -285,12 +376,33 @@
 	.long	feroceon_dma_clean_range
 	.long	feroceon_dma_flush_range
 
+ENTRY(feroceon_range_cache_fns)
+	.long	feroceon_flush_kern_cache_all
+	.long	feroceon_flush_user_cache_all
+	.long	feroceon_flush_user_cache_range
+	.long	feroceon_coherent_kern_range
+	.long	feroceon_coherent_user_range
+	.long	feroceon_range_flush_kern_dcache_page
+	.long	feroceon_range_dma_inv_range
+	.long	feroceon_range_dma_clean_range
+	.long	feroceon_range_dma_flush_range
+
 	.align	5
 ENTRY(cpu_feroceon_dcache_clean_area)
+#if defined(CONFIG_CACHE_FEROCEON_L2) && !defined(CONFIG_L2_CACHE_WRITETHROUGH)
+	mov	r2, r0
+	mov	r3, r1
+#endif
 1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
 	add	r0, r0, #CACHE_DLINESIZE
 	subs	r1, r1, #CACHE_DLINESIZE
 	bhi	1b
+#if defined(CONFIG_CACHE_FEROCEON_L2) && !defined(CONFIG_L2_CACHE_WRITETHROUGH)
+1:	mcr	p15, 1, r2, c15, c9, 1		@ clean L2 entry
+	add	r2, r2, #CACHE_DLINESIZE
+	subs	r3, r3, #CACHE_DLINESIZE
+	bhi	1b
+#endif
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 	mov	pc, lr
 
@@ -306,16 +418,25 @@
 	.align	5
 ENTRY(cpu_feroceon_switch_mm)
 #ifdef CONFIG_MMU
-	mov	ip, #0
-@ && 'Clean & Invalidate whole DCache'
-1:	mrc	p15, 0, r15, c7, c14, 3 	@ test,clean,invalidate
-	bne	1b
-	mcr	p15, 0, ip, c7, c5, 0		@ invalidate I cache
-	mcr	p15, 0, ip, c7, c10, 4		@ drain WB
+	/*
+	 * Note: we wish to call __flush_whole_cache but we need to preserve
+	 * lr to do so.  The only way without touching main memory is to
+	 * use r2 which is normally used to test the VM_EXEC flag, and
+	 * compensate locally for the skipped ops if it is not set.
+	 */
+	mov	r2, lr				@ abuse r2 to preserve lr
+	bl	__flush_whole_cache
+	@ if r2 contains the VM_EXEC bit then the next 2 ops are done already
+	tst	r2, #VM_EXEC
+	mcreq	p15, 0, ip, c7, c5, 0		@ invalidate I cache
+	mcreq	p15, 0, ip, c7, c10, 4		@ drain WB
+
 	mcr	p15, 0, r0, c2, c0, 0		@ load page table pointer
 	mcr	p15, 0, ip, c8, c7, 0		@ invalidate I & D TLBs
-#endif
+	mov	pc, r2
+#else
 	mov	pc, lr
+#endif
 
 /*
  * cpu_feroceon_set_pte_ext(ptep, pte, ext)
@@ -345,6 +466,9 @@
 	str	r2, [r0]			@ hardware version
 	mov	r0, r0
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+#if defined(CONFIG_CACHE_FEROCEON_L2) && !defined(CONFIG_L2_CACHE_WRITETHROUGH)
+	mcr	p15, 1, r0, c15, c9, 1		@ clean L2 entry
+#endif
 	mcr	p15, 0, r0, c7, c10, 4		@ drain WB
 #endif
 	mov	pc, lr
@@ -414,6 +538,21 @@
 	.asciz	"Feroceon"
 	.size	cpu_feroceon_name, . - cpu_feroceon_name
 
+	.type	cpu_88fr531_name, #object
+cpu_88fr531_name:
+	.asciz	"Feroceon 88FR531-vd"
+	.size	cpu_88fr531_name, . - cpu_88fr531_name
+
+	.type	cpu_88fr571_name, #object
+cpu_88fr571_name:
+	.asciz	"Feroceon 88FR571-vd"
+	.size	cpu_88fr571_name, . - cpu_88fr571_name
+
+	.type	cpu_88fr131_name, #object
+cpu_88fr131_name:
+	.asciz	"Feroceon 88FR131"
+	.size	cpu_88fr131_name, . - cpu_88fr131_name
+
 	.align
 
 	.section ".proc.info.init", #alloc, #execinstr
@@ -421,15 +560,15 @@
 #ifdef CONFIG_CPU_FEROCEON_OLD_ID
 	.type	__feroceon_old_id_proc_info,#object
 __feroceon_old_id_proc_info:
-	.long	0x41069260
-	.long	0xfffffff0
-	.long   PMD_TYPE_SECT | \
+	.long	0x41009260
+	.long	0xff00fff0
+	.long	PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
-	.long   PMD_TYPE_SECT | \
+	.long	PMD_TYPE_SECT | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
@@ -445,17 +584,17 @@
 	.size	__feroceon_old_id_proc_info, . - __feroceon_old_id_proc_info
 #endif
 
-	.type	__feroceon_proc_info,#object
-__feroceon_proc_info:
+	.type	__88fr531_proc_info,#object
+__88fr531_proc_info:
 	.long	0x56055310
 	.long	0xfffffff0
-	.long   PMD_TYPE_SECT | \
+	.long	PMD_TYPE_SECT | \
 		PMD_SECT_BUFFERABLE | \
 		PMD_SECT_CACHEABLE | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
-	.long   PMD_TYPE_SECT | \
+	.long	PMD_TYPE_SECT | \
 		PMD_BIT4 | \
 		PMD_SECT_AP_WRITE | \
 		PMD_SECT_AP_READ
@@ -463,9 +602,59 @@
 	.long	cpu_arch_name
 	.long	cpu_elf_name
 	.long	HWCAP_SWP|HWCAP_HALF|HWCAP_THUMB|HWCAP_FAST_MULT|HWCAP_EDSP
-	.long	cpu_feroceon_name
+	.long	cpu_88fr531_name
 	.long	feroceon_processor_functions
 	.long	v4wbi_tlb_fns
 	.long	feroceon_user_fns
 	.long	feroceon_cache_fns
-	.size	__feroceon_proc_info, . - __feroceon_proc_info
+	.size	__88fr531_proc_info, . - __88fr531_proc_info
+
+	.type	__88fr571_proc_info,#object
+__88fr571_proc_info:
+	.long	0x56155710
+	.long	0xfffffff0
+	.long	PMD_TYPE_SECT | \
+		PMD_SECT_BUFFERABLE | \
+		PMD_SECT_CACHEABLE | \
+		PMD_BIT4 | \
+		PMD_SECT_AP_WRITE | \
+		PMD_SECT_AP_READ
+	.long	PMD_TYPE_SECT | \
+		PMD_BIT4 | \
+		PMD_SECT_AP_WRITE | \
+		PMD_SECT_AP_READ
+	b	__feroceon_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP|HWCAP_HALF|HWCAP_THUMB|HWCAP_FAST_MULT|HWCAP_EDSP
+	.long	cpu_88fr571_name
+	.long	feroceon_processor_functions
+	.long	v4wbi_tlb_fns
+	.long	feroceon_user_fns
+	.long	feroceon_range_cache_fns
+	.size	__88fr571_proc_info, . - __88fr571_proc_info
+
+	.type	__88fr131_proc_info,#object
+__88fr131_proc_info:
+	.long	0x56251310
+	.long	0xfffffff0
+	.long	PMD_TYPE_SECT | \
+		PMD_SECT_BUFFERABLE | \
+		PMD_SECT_CACHEABLE | \
+		PMD_BIT4 | \
+		PMD_SECT_AP_WRITE | \
+		PMD_SECT_AP_READ
+	.long	PMD_TYPE_SECT | \
+		PMD_BIT4 | \
+		PMD_SECT_AP_WRITE | \
+		PMD_SECT_AP_READ
+	b	__feroceon_setup
+	.long	cpu_arch_name
+	.long	cpu_elf_name
+	.long	HWCAP_SWP|HWCAP_HALF|HWCAP_THUMB|HWCAP_FAST_MULT|HWCAP_EDSP
+	.long	cpu_88fr131_name
+	.long	feroceon_processor_functions
+	.long	v4wbi_tlb_fns
+	.long	feroceon_user_fns
+	.long	feroceon_range_cache_fns
+	.size	__88fr131_proc_info, . - __88fr131_proc_info
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -36,8 +36,8 @@
 
 static struct irq_chip orion_irq_chip = {
 	.name		= "orion_irq",
-	.ack		= orion_irq_mask,
 	.mask		= orion_irq_mask,
+	.mask_ack	= orion_irq_mask,
 	.unmask		= orion_irq_unmask,
 };
 
@@ -59,6 +59,7 @@
 		set_irq_chip(irq, &orion_irq_chip);
 		set_irq_chip_data(irq, maskaddr);
 		set_irq_handler(irq, handle_level_irq);
+		irq_desc[irq].status |= IRQ_LEVEL;
 		set_irq_flags(irq, IRQF_VALID);
 	}
 }
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -39,6 +39,7 @@
 #define PCIE_CONF_DATA_OFF	0x18fc
 #define PCIE_MASK_OFF		0x1910
 #define PCIE_CTRL_OFF		0x1a00
+#define  PCIE_CTRL_X1_MODE		0x0001
 #define PCIE_STAT_OFF		0x1a04
 #define  PCIE_STAT_DEV_OFFS		20
 #define  PCIE_STAT_DEV_MASK		0x1f
@@ -62,6 +63,11 @@
 	return !(readl(base + PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);
 }
 
+int __init orion_pcie_x4_mode(void __iomem *base)
+{
+	return !(readl(base + PCIE_CTRL_OFF) & PCIE_CTRL_X1_MODE);
+}
+
 int orion_pcie_get_local_bus_nr(void __iomem *base)
 {
 	u32 stat = readl(base + PCIE_STAT_OFF);
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -74,7 +74,7 @@
 	/*
 	 * Clear and enable clockevent timer interrupt.
 	 */
-	writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+	writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
 
 	u = readl(BRIDGE_MASK);
 	u |= BRIDGE_INT_TIMER1;
@@ -138,7 +138,7 @@
 		/*
 		 * ACK pending timer interrupt.
 		 */
-		writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+		writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
 
 	}
 	local_irq_restore(flags);
@@ -159,7 +159,7 @@
 	/*
 	 * ACK timer interrupt and call event handler.
 	 */
-	writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+	writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
 	orion_clkevt.event_handler(&orion_clkevt);
 
 	return IRQ_HANDLED;
--- a/drivers/net/mv643xx_eth.c
+++ b/drivers/net/mv643xx_eth.c
@@ -34,406 +34,145 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
+
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
 #include <linux/in.h>
-#include <linux/ip.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #include <linux/etherdevice.h>
-
-#include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/ethtool.h>
 #include <linux/platform_device.h>
-
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
 #include <linux/mii.h>
-
 #include <linux/mv643xx_eth.h>
-
 #include <asm/io.h>
 #include <asm/types.h>
-#include <asm/pgtable.h>
 #include <asm/system.h>
-#include <asm/delay.h>
-#include <asm/dma-mapping.h>
 
-#define MV643XX_CHECKSUM_OFFLOAD_TX
-#define MV643XX_NAPI
-#define MV643XX_TX_FAST_REFILL
-#undef	MV643XX_COAL
-
-#define MV643XX_TX_COAL 100
-#ifdef MV643XX_COAL
-#define MV643XX_RX_COAL 100
-#endif
+static char mv643xx_eth_driver_name[] = "mv643xx_eth";
+static char mv643xx_eth_driver_version[] = "1.1";
 
-#ifdef MV643XX_CHECKSUM_OFFLOAD_TX
+#define MV643XX_ETH_CHECKSUM_OFFLOAD_TX
+#define MV643XX_ETH_NAPI
+#define MV643XX_ETH_TX_FAST_REFILL
+
+#ifdef MV643XX_ETH_CHECKSUM_OFFLOAD_TX
 #define MAX_DESCS_PER_SKB	(MAX_SKB_FRAGS + 1)
 #else
 #define MAX_DESCS_PER_SKB	1
 #endif
 
-#define ETH_VLAN_HLEN		4
-#define ETH_FCS_LEN		4
-#define ETH_HW_IP_ALIGN		2		/* hw aligns IP header */
-#define ETH_WRAPPER_LEN		(ETH_HW_IP_ALIGN + ETH_HLEN + \
-					ETH_VLAN_HLEN + ETH_FCS_LEN)
-#define ETH_RX_SKB_SIZE		(dev->mtu + ETH_WRAPPER_LEN + \
-					dma_get_cache_alignment())
-
 /*
  * Registers shared between all ports.
  */
-#define PHY_ADDR_REG				0x0000
-#define SMI_REG					0x0004
-#define WINDOW_BASE(i)				(0x0200 + ((i) << 3))
-#define WINDOW_SIZE(i)				(0x0204 + ((i) << 3))
-#define WINDOW_REMAP_HIGH(i)			(0x0280 + ((i) << 2))
-#define WINDOW_BAR_ENABLE			0x0290
-#define WINDOW_PROTECT(i)			(0x0294 + ((i) << 4))
+#define PHY_ADDR			0x0000
+#define SMI_REG				0x0004
+#define WINDOW_BASE(w)			(0x0200 + ((w) << 3))
+#define WINDOW_SIZE(w)			(0x0204 + ((w) << 3))
+#define WINDOW_REMAP_HIGH(w)		(0x0280 + ((w) << 2))
+#define WINDOW_BAR_ENABLE		0x0290
+#define WINDOW_PROTECT(w)		(0x0294 + ((w) << 4))
 
 /*
  * Per-port registers.
  */
-#define PORT_CONFIG_REG(p)				(0x0400 + ((p) << 10))
-#define PORT_CONFIG_EXTEND_REG(p)			(0x0404 + ((p) << 10))
-#define MAC_ADDR_LOW(p)					(0x0414 + ((p) << 10))
-#define MAC_ADDR_HIGH(p)				(0x0418 + ((p) << 10))
-#define SDMA_CONFIG_REG(p)				(0x041c + ((p) << 10))
-#define PORT_SERIAL_CONTROL_REG(p)			(0x043c + ((p) << 10))
-#define PORT_STATUS_REG(p)				(0x0444 + ((p) << 10))
-#define TRANSMIT_QUEUE_COMMAND_REG(p)			(0x0448 + ((p) << 10))
-#define MAXIMUM_TRANSMIT_UNIT(p)			(0x0458 + ((p) << 10))
-#define INTERRUPT_CAUSE_REG(p)				(0x0460 + ((p) << 10))
-#define INTERRUPT_CAUSE_EXTEND_REG(p)			(0x0464 + ((p) << 10))
-#define INTERRUPT_MASK_REG(p)				(0x0468 + ((p) << 10))
-#define INTERRUPT_EXTEND_MASK_REG(p)			(0x046c + ((p) << 10))
-#define TX_FIFO_URGENT_THRESHOLD_REG(p)			(0x0474 + ((p) << 10))
-#define RX_CURRENT_QUEUE_DESC_PTR_0(p)			(0x060c + ((p) << 10))
-#define RECEIVE_QUEUE_COMMAND_REG(p)			(0x0680 + ((p) << 10))
-#define TX_CURRENT_QUEUE_DESC_PTR_0(p)			(0x06c0 + ((p) << 10))
-#define MIB_COUNTERS_BASE(p)				(0x1000 + ((p) << 7))
-#define DA_FILTER_SPECIAL_MULTICAST_TABLE_BASE(p)	(0x1400 + ((p) << 10))
-#define DA_FILTER_OTHER_MULTICAST_TABLE_BASE(p)		(0x1500 + ((p) << 10))
-#define DA_FILTER_UNICAST_TABLE_BASE(p)			(0x1600 + ((p) << 10))
-
-/* These macros describe Ethernet Port configuration reg (Px_cR) bits */
-#define UNICAST_NORMAL_MODE		(0 << 0)
-#define UNICAST_PROMISCUOUS_MODE	(1 << 0)
-#define DEFAULT_RX_QUEUE(queue)		((queue) << 1)
-#define DEFAULT_RX_ARP_QUEUE(queue)	((queue) << 4)
-#define RECEIVE_BC_IF_NOT_IP_OR_ARP	(0 << 7)
-#define REJECT_BC_IF_NOT_IP_OR_ARP	(1 << 7)
-#define RECEIVE_BC_IF_IP		(0 << 8)
-#define REJECT_BC_IF_IP			(1 << 8)
-#define RECEIVE_BC_IF_ARP		(0 << 9)
-#define REJECT_BC_IF_ARP		(1 << 9)
-#define TX_AM_NO_UPDATE_ERROR_SUMMARY	(1 << 12)
-#define CAPTURE_TCP_FRAMES_DIS		(0 << 14)
-#define CAPTURE_TCP_FRAMES_EN		(1 << 14)
-#define CAPTURE_UDP_FRAMES_DIS		(0 << 15)
-#define CAPTURE_UDP_FRAMES_EN		(1 << 15)
-#define DEFAULT_RX_TCP_QUEUE(queue)	((queue) << 16)
-#define DEFAULT_RX_UDP_QUEUE(queue)	((queue) << 19)
-#define DEFAULT_RX_BPDU_QUEUE(queue)	((queue) << 22)
-
-#define PORT_CONFIG_DEFAULT_VALUE			\
-		UNICAST_NORMAL_MODE		|	\
-		DEFAULT_RX_QUEUE(0)		|	\
-		DEFAULT_RX_ARP_QUEUE(0)		|	\
-		RECEIVE_BC_IF_NOT_IP_OR_ARP	|	\
-		RECEIVE_BC_IF_IP		|	\
-		RECEIVE_BC_IF_ARP		|	\
-		CAPTURE_TCP_FRAMES_DIS		|	\
-		CAPTURE_UDP_FRAMES_DIS		|	\
-		DEFAULT_RX_TCP_QUEUE(0)		|	\
-		DEFAULT_RX_UDP_QUEUE(0)		|	\
-		DEFAULT_RX_BPDU_QUEUE(0)
-
-/* These macros describe Ethernet Port configuration extend reg (Px_cXR) bits*/
-#define CLASSIFY_EN				(1 << 0)
-#define SPAN_BPDU_PACKETS_AS_NORMAL		(0 << 1)
-#define SPAN_BPDU_PACKETS_TO_RX_QUEUE_7		(1 << 1)
-#define PARTITION_DISABLE			(0 << 2)
-#define PARTITION_ENABLE			(1 << 2)
-
-#define PORT_CONFIG_EXTEND_DEFAULT_VALUE		\
-		SPAN_BPDU_PACKETS_AS_NORMAL	|	\
-		PARTITION_DISABLE
-
-/* These macros describe Ethernet Port Sdma configuration reg (SDCR) bits */
-#define RIFB				(1 << 0)
-#define RX_BURST_SIZE_1_64BIT		(0 << 1)
-#define RX_BURST_SIZE_2_64BIT		(1 << 1)
+#define PORT_CONFIG(p)			(0x0400 + ((p) << 10))
+#define  UNICAST_PROMISCUOUS_MODE	0x00000001
+#define PORT_CONFIG_EXT(p)		(0x0404 + ((p) << 10))
+#define MAC_ADDR_LOW(p)			(0x0414 + ((p) << 10))
+#define MAC_ADDR_HIGH(p)		(0x0418 + ((p) << 10))
+#define SDMA_CONFIG(p)			(0x041c + ((p) << 10))
+#define PORT_SERIAL_CONTROL(p)		(0x043c + ((p) << 10))
+#define PORT_STATUS(p)			(0x0444 + ((p) << 10))
+#define  TX_FIFO_EMPTY			0x00000400
+#define TXQ_COMMAND(p)			(0x0448 + ((p) << 10))
+#define TXQ_FIX_PRIO_CONF(p)		(0x044c + ((p) << 10))
+#define TX_BW_RATE(p)			(0x0450 + ((p) << 10))
+#define TX_BW_MTU(p)			(0x0458 + ((p) << 10))
+#define TX_BW_BURST(p)			(0x045c + ((p) << 10))
+#define INT_CAUSE(p)			(0x0460 + ((p) << 10))
+#define  INT_TX_END			0x07f80000
+#define  INT_RX				0x0007fbfc
+#define  INT_EXT			0x00000002
+#define INT_CAUSE_EXT(p)		(0x0464 + ((p) << 10))
+#define  INT_EXT_LINK			0x00100000
+#define  INT_EXT_PHY			0x00010000
+#define  INT_EXT_TX_ERROR_0		0x00000100
+#define  INT_EXT_TX_0			0x00000001
+#define  INT_EXT_TX			0x0000ffff
+#define INT_MASK(p)			(0x0468 + ((p) << 10))
+#define INT_MASK_EXT(p)			(0x046c + ((p) << 10))
+#define TX_FIFO_URGENT_THRESHOLD(p)	(0x0474 + ((p) << 10))
+#define TXQ_FIX_PRIO_CONF_MOVED(p)	(0x04dc + ((p) << 10))
+#define TX_BW_RATE_MOVED(p)		(0x04e0 + ((p) << 10))
+#define TX_BW_MTU_MOVED(p)		(0x04e8 + ((p) << 10))
+#define TX_BW_BURST_MOVED(p)		(0x04ec + ((p) << 10))
+#define RXQ_CURRENT_DESC_PTR(p, q)	(0x060c + ((p) << 10) + ((q) << 4))
+#define RXQ_COMMAND(p)			(0x0680 + ((p) << 10))
+#define TXQ_CURRENT_DESC_PTR(p, q)	(0x06c0 + ((p) << 10) + ((q) << 2))
+#define TXQ_BW_TOKENS(p, q)		(0x0700 + ((p) << 10) + ((q) << 4))
+#define TXQ_BW_CONF(p, q)		(0x0704 + ((p) << 10) + ((q) << 4))
+#define TXQ_BW_WRR_CONF(p, q)		(0x0708 + ((p) << 10) + ((q) << 4))
+#define MIB_COUNTERS(p)			(0x1000 + ((p) << 7))
+#define SPECIAL_MCAST_TABLE(p)		(0x1400 + ((p) << 10))
+#define OTHER_MCAST_TABLE(p)		(0x1500 + ((p) << 10))
+#define UNICAST_TABLE(p)		(0x1600 + ((p) << 10))
+
+
+/*
+ * SDMA configuration register.
+ */
 #define RX_BURST_SIZE_4_64BIT		(2 << 1)
-#define RX_BURST_SIZE_8_64BIT		(3 << 1)
-#define RX_BURST_SIZE_16_64BIT		(4 << 1)
 #define BLM_RX_NO_SWAP			(1 << 4)
-#define BLM_RX_BYTE_SWAP		(0 << 4)
 #define BLM_TX_NO_SWAP			(1 << 5)
-#define BLM_TX_BYTE_SWAP		(0 << 5)
-#define DESCRIPTORS_BYTE_SWAP		(1 << 6)
-#define DESCRIPTORS_NO_SWAP		(0 << 6)
-#define IPG_INT_RX(value)		(((value) & 0x3fff) << 8)
-#define TX_BURST_SIZE_1_64BIT		(0 << 22)
-#define TX_BURST_SIZE_2_64BIT		(1 << 22)
 #define TX_BURST_SIZE_4_64BIT		(2 << 22)
-#define TX_BURST_SIZE_8_64BIT		(3 << 22)
-#define TX_BURST_SIZE_16_64BIT		(4 << 22)
 
 #if defined(__BIG_ENDIAN)
 #define PORT_SDMA_CONFIG_DEFAULT_VALUE		\
 		RX_BURST_SIZE_4_64BIT	|	\
-		IPG_INT_RX(0)		|	\
 		TX_BURST_SIZE_4_64BIT
 #elif defined(__LITTLE_ENDIAN)
 #define PORT_SDMA_CONFIG_DEFAULT_VALUE		\
 		RX_BURST_SIZE_4_64BIT	|	\
 		BLM_RX_NO_SWAP		|	\
 		BLM_TX_NO_SWAP		|	\
-		IPG_INT_RX(0)		|	\
 		TX_BURST_SIZE_4_64BIT
 #else
 #error One of __BIG_ENDIAN or __LITTLE_ENDIAN must be defined
 #endif
 
-/* These macros describe Ethernet Port serial control reg (PSCR) bits */
-#define SERIAL_PORT_DISABLE			(0 << 0)
-#define SERIAL_PORT_ENABLE			(1 << 0)
-#define DO_NOT_FORCE_LINK_PASS			(0 << 1)
-#define FORCE_LINK_PASS				(1 << 1)
-#define ENABLE_AUTO_NEG_FOR_DUPLX		(0 << 2)
-#define DISABLE_AUTO_NEG_FOR_DUPLX		(1 << 2)
-#define ENABLE_AUTO_NEG_FOR_FLOW_CTRL		(0 << 3)
-#define DISABLE_AUTO_NEG_FOR_FLOW_CTRL		(1 << 3)
-#define ADV_NO_FLOW_CTRL			(0 << 4)
-#define ADV_SYMMETRIC_FLOW_CTRL			(1 << 4)
-#define FORCE_FC_MODE_NO_PAUSE_DIS_TX		(0 << 5)
-#define FORCE_FC_MODE_TX_PAUSE_DIS		(1 << 5)
-#define FORCE_BP_MODE_NO_JAM			(0 << 7)
-#define FORCE_BP_MODE_JAM_TX			(1 << 7)
-#define FORCE_BP_MODE_JAM_TX_ON_RX_ERR		(2 << 7)
-#define SERIAL_PORT_CONTROL_RESERVED		(1 << 9)
-#define FORCE_LINK_FAIL				(0 << 10)
-#define DO_NOT_FORCE_LINK_FAIL			(1 << 10)
-#define RETRANSMIT_16_ATTEMPTS			(0 << 11)
-#define RETRANSMIT_FOREVER			(1 << 11)
-#define ENABLE_AUTO_NEG_SPEED_GMII		(0 << 13)
-#define DISABLE_AUTO_NEG_SPEED_GMII		(1 << 13)
-#define DTE_ADV_0				(0 << 14)
-#define DTE_ADV_1				(1 << 14)
-#define DISABLE_AUTO_NEG_BYPASS			(0 << 15)
-#define ENABLE_AUTO_NEG_BYPASS			(1 << 15)
-#define AUTO_NEG_NO_CHANGE			(0 << 16)
-#define RESTART_AUTO_NEG			(1 << 16)
-#define MAX_RX_PACKET_1518BYTE			(0 << 17)
+
+/*
+ * Port serial control register.
+ */
+#define SET_MII_SPEED_TO_100			(1 << 24)
+#define SET_GMII_SPEED_TO_1000			(1 << 23)
+#define SET_FULL_DUPLEX_MODE			(1 << 21)
 #define MAX_RX_PACKET_1522BYTE			(1 << 17)
-#define MAX_RX_PACKET_1552BYTE			(2 << 17)
-#define MAX_RX_PACKET_9022BYTE			(3 << 17)
-#define MAX_RX_PACKET_9192BYTE			(4 << 17)
 #define MAX_RX_PACKET_9700BYTE			(5 << 17)
 #define MAX_RX_PACKET_MASK			(7 << 17)
-#define CLR_EXT_LOOPBACK			(0 << 20)
-#define SET_EXT_LOOPBACK			(1 << 20)
-#define SET_HALF_DUPLEX_MODE			(0 << 21)
-#define SET_FULL_DUPLEX_MODE			(1 << 21)
-#define DISABLE_FLOW_CTRL_TX_RX_IN_FULL_DUPLEX	(0 << 22)
-#define ENABLE_FLOW_CTRL_TX_RX_IN_FULL_DUPLEX	(1 << 22)
-#define SET_GMII_SPEED_TO_10_100		(0 << 23)
-#define SET_GMII_SPEED_TO_1000			(1 << 23)
-#define SET_MII_SPEED_TO_10			(0 << 24)
-#define SET_MII_SPEED_TO_100			(1 << 24)
+#define DISABLE_AUTO_NEG_SPEED_GMII		(1 << 13)
+#define DO_NOT_FORCE_LINK_FAIL			(1 << 10)
+#define SERIAL_PORT_CONTROL_RESERVED		(1 << 9)
+#define DISABLE_AUTO_NEG_FOR_FLOW_CTRL		(1 << 3)
+#define DISABLE_AUTO_NEG_FOR_DUPLEX		(1 << 2)
+#define FORCE_LINK_PASS				(1 << 1)
+#define SERIAL_PORT_ENABLE			(1 << 0)
+
+#define DEFAULT_RX_QUEUE_SIZE		400
+#define DEFAULT_TX_QUEUE_SIZE		800
 
-#define PORT_SERIAL_CONTROL_DEFAULT_VALUE		\
-		DO_NOT_FORCE_LINK_PASS		|	\
-		ENABLE_AUTO_NEG_FOR_DUPLX	|	\
-		DISABLE_AUTO_NEG_FOR_FLOW_CTRL	|	\
-		ADV_SYMMETRIC_FLOW_CTRL		|	\
-		FORCE_FC_MODE_NO_PAUSE_DIS_TX	|	\
-		FORCE_BP_MODE_NO_JAM		|	\
-		(1 << 9) /* reserved */		|	\
-		DO_NOT_FORCE_LINK_FAIL		|	\
-		RETRANSMIT_16_ATTEMPTS		|	\
-		ENABLE_AUTO_NEG_SPEED_GMII	|	\
-		DTE_ADV_0			|	\
-		DISABLE_AUTO_NEG_BYPASS		|	\
-		AUTO_NEG_NO_CHANGE		|	\
-		MAX_RX_PACKET_9700BYTE		|	\
-		CLR_EXT_LOOPBACK		|	\
-		SET_FULL_DUPLEX_MODE		|	\
-		ENABLE_FLOW_CTRL_TX_RX_IN_FULL_DUPLEX
-
-/* These macros describe Ethernet Serial Status reg (PSR) bits */
-#define PORT_STATUS_MODE_10_BIT		(1 << 0)
-#define PORT_STATUS_LINK_UP		(1 << 1)
-#define PORT_STATUS_FULL_DUPLEX		(1 << 2)
-#define PORT_STATUS_FLOW_CONTROL	(1 << 3)
-#define PORT_STATUS_GMII_1000		(1 << 4)
-#define PORT_STATUS_MII_100		(1 << 5)
-/* PSR bit 6 is undocumented */
-#define PORT_STATUS_TX_IN_PROGRESS	(1 << 7)
-#define PORT_STATUS_AUTONEG_BYPASSED	(1 << 8)
-#define PORT_STATUS_PARTITION		(1 << 9)
-#define PORT_STATUS_TX_FIFO_EMPTY	(1 << 10)
-/* PSR bits 11-31 are reserved */
-
-#define PORT_DEFAULT_TRANSMIT_QUEUE_SIZE	800
-#define PORT_DEFAULT_RECEIVE_QUEUE_SIZE		400
-
-#define DESC_SIZE				64
-
-#define ETH_RX_QUEUES_ENABLED	(1 << 0)	/* use only Q0 for receive */
-#define ETH_TX_QUEUES_ENABLED	(1 << 0)	/* use only Q0 for transmit */
-
-#define ETH_INT_CAUSE_RX_DONE	(ETH_RX_QUEUES_ENABLED << 2)
-#define ETH_INT_CAUSE_RX_ERROR	(ETH_RX_QUEUES_ENABLED << 9)
-#define ETH_INT_CAUSE_RX	(ETH_INT_CAUSE_RX_DONE | ETH_INT_CAUSE_RX_ERROR)
-#define ETH_INT_CAUSE_EXT	0x00000002
-#define ETH_INT_UNMASK_ALL	(ETH_INT_CAUSE_RX | ETH_INT_CAUSE_EXT)
-
-#define ETH_INT_CAUSE_TX_DONE	(ETH_TX_QUEUES_ENABLED << 0)
-#define ETH_INT_CAUSE_TX_ERROR	(ETH_TX_QUEUES_ENABLED << 8)
-#define ETH_INT_CAUSE_TX	(ETH_INT_CAUSE_TX_DONE | ETH_INT_CAUSE_TX_ERROR)
-#define ETH_INT_CAUSE_PHY	0x00010000
-#define ETH_INT_CAUSE_STATE	0x00100000
-#define ETH_INT_UNMASK_ALL_EXT	(ETH_INT_CAUSE_TX | ETH_INT_CAUSE_PHY | \
-					ETH_INT_CAUSE_STATE)
-
-#define ETH_INT_MASK_ALL	0x00000000
-#define ETH_INT_MASK_ALL_EXT	0x00000000
-
-#define PHY_WAIT_ITERATIONS	1000	/* 1000 iterations * 10uS = 10mS max */
-#define PHY_WAIT_MICRO_SECONDS	10
-
-/* Buffer offset from buffer pointer */
-#define RX_BUF_OFFSET				0x2
-
-/* Gigabit Ethernet Unit Global Registers */
-
-/* MIB Counters register definitions */
-#define ETH_MIB_GOOD_OCTETS_RECEIVED_LOW	0x0
-#define ETH_MIB_GOOD_OCTETS_RECEIVED_HIGH	0x4
-#define ETH_MIB_BAD_OCTETS_RECEIVED		0x8
-#define ETH_MIB_INTERNAL_MAC_TRANSMIT_ERR	0xc
-#define ETH_MIB_GOOD_FRAMES_RECEIVED		0x10
-#define ETH_MIB_BAD_FRAMES_RECEIVED		0x14
-#define ETH_MIB_BROADCAST_FRAMES_RECEIVED	0x18
-#define ETH_MIB_MULTICAST_FRAMES_RECEIVED	0x1c
-#define ETH_MIB_FRAMES_64_OCTETS		0x20
-#define ETH_MIB_FRAMES_65_TO_127_OCTETS		0x24
-#define ETH_MIB_FRAMES_128_TO_255_OCTETS	0x28
-#define ETH_MIB_FRAMES_256_TO_511_OCTETS	0x2c
-#define ETH_MIB_FRAMES_512_TO_1023_OCTETS	0x30
-#define ETH_MIB_FRAMES_1024_TO_MAX_OCTETS	0x34
-#define ETH_MIB_GOOD_OCTETS_SENT_LOW		0x38
-#define ETH_MIB_GOOD_OCTETS_SENT_HIGH		0x3c
-#define ETH_MIB_GOOD_FRAMES_SENT		0x40
-#define ETH_MIB_EXCESSIVE_COLLISION		0x44
-#define ETH_MIB_MULTICAST_FRAMES_SENT		0x48
-#define ETH_MIB_BROADCAST_FRAMES_SENT		0x4c
-#define ETH_MIB_UNREC_MAC_CONTROL_RECEIVED	0x50
-#define ETH_MIB_FC_SENT				0x54
-#define ETH_MIB_GOOD_FC_RECEIVED		0x58
-#define ETH_MIB_BAD_FC_RECEIVED			0x5c
-#define ETH_MIB_UNDERSIZE_RECEIVED		0x60
-#define ETH_MIB_FRAGMENTS_RECEIVED		0x64
-#define ETH_MIB_OVERSIZE_RECEIVED		0x68
-#define ETH_MIB_JABBER_RECEIVED			0x6c
-#define ETH_MIB_MAC_RECEIVE_ERROR		0x70
-#define ETH_MIB_BAD_CRC_EVENT			0x74
-#define ETH_MIB_COLLISION			0x78
-#define ETH_MIB_LATE_COLLISION			0x7c
-
-/* Port serial status reg (PSR) */
-#define ETH_INTERFACE_PCM			0x00000001
-#define ETH_LINK_IS_UP				0x00000002
-#define ETH_PORT_AT_FULL_DUPLEX			0x00000004
-#define ETH_RX_FLOW_CTRL_ENABLED		0x00000008
-#define ETH_GMII_SPEED_1000			0x00000010
-#define ETH_MII_SPEED_100			0x00000020
-#define ETH_TX_IN_PROGRESS			0x00000080
-#define ETH_BYPASS_ACTIVE			0x00000100
-#define ETH_PORT_AT_PARTITION_STATE		0x00000200
-#define ETH_PORT_TX_FIFO_EMPTY			0x00000400
-
-/* SMI reg */
-#define ETH_SMI_BUSY		0x10000000	/* 0 - Write, 1 - Read	*/
-#define ETH_SMI_READ_VALID	0x08000000	/* 0 - Write, 1 - Read	*/
-#define ETH_SMI_OPCODE_WRITE	0		/* Completion of Read	*/
-#define ETH_SMI_OPCODE_READ	0x04000000	/* Operation is in progress */
-
-/* Interrupt Cause Register Bit Definitions */
-
-/* SDMA command status fields macros */
-
-/* Tx & Rx descriptors status */
-#define ETH_ERROR_SUMMARY			0x00000001
-
-/* Tx & Rx descriptors command */
-#define ETH_BUFFER_OWNED_BY_DMA			0x80000000
-
-/* Tx descriptors status */
-#define ETH_LC_ERROR				0
-#define ETH_UR_ERROR				0x00000002
-#define ETH_RL_ERROR				0x00000004
-#define ETH_LLC_SNAP_FORMAT			0x00000200
-
-/* Rx descriptors status */
-#define ETH_OVERRUN_ERROR			0x00000002
-#define ETH_MAX_FRAME_LENGTH_ERROR		0x00000004
-#define ETH_RESOURCE_ERROR			0x00000006
-#define ETH_VLAN_TAGGED				0x00080000
-#define ETH_BPDU_FRAME				0x00100000
-#define ETH_UDP_FRAME_OVER_IP_V_4		0x00200000
-#define ETH_OTHER_FRAME_TYPE			0x00400000
-#define ETH_LAYER_2_IS_ETH_V_2			0x00800000
-#define ETH_FRAME_TYPE_IP_V_4			0x01000000
-#define ETH_FRAME_HEADER_OK			0x02000000
-#define ETH_RX_LAST_DESC			0x04000000
-#define ETH_RX_FIRST_DESC			0x08000000
-#define ETH_UNKNOWN_DESTINATION_ADDR		0x10000000
-#define ETH_RX_ENABLE_INTERRUPT			0x20000000
-#define ETH_LAYER_4_CHECKSUM_OK			0x40000000
-
-/* Rx descriptors byte count */
-#define ETH_FRAME_FRAGMENTED			0x00000004
-
-/* Tx descriptors command */
-#define ETH_LAYER_4_CHECKSUM_FIRST_DESC		0x00000400
-#define ETH_FRAME_SET_TO_VLAN			0x00008000
-#define ETH_UDP_FRAME				0x00010000
-#define ETH_GEN_TCP_UDP_CHECKSUM		0x00020000
-#define ETH_GEN_IP_V_4_CHECKSUM			0x00040000
-#define ETH_ZERO_PADDING			0x00080000
-#define ETH_TX_LAST_DESC			0x00100000
-#define ETH_TX_FIRST_DESC			0x00200000
-#define ETH_GEN_CRC				0x00400000
-#define ETH_TX_ENABLE_INTERRUPT			0x00800000
-#define ETH_AUTO_MODE				0x40000000
-
-#define ETH_TX_IHL_SHIFT			11
-
-/* typedefs */
-
-typedef enum _eth_func_ret_status {
-	ETH_OK,			/* Returned as expected.		*/
-	ETH_ERROR,		/* Fundamental error.			*/
-	ETH_RETRY,		/* Could not process request. Try later.*/
-	ETH_END_OF_JOB,		/* Ring has nothing to process.		*/
-	ETH_QUEUE_FULL,		/* Ring resource error.			*/
-	ETH_QUEUE_LAST_RESOURCE	/* Ring resources about to exhaust.	*/
-} ETH_FUNC_RET_STATUS;
 
-/* These are for big-endian machines.  Little endian needs different
- * definitions.
+/*
+ * RX/TX descriptors.
  */
 #if defined(__BIG_ENDIAN)
-struct eth_rx_desc {
+struct rx_desc {
 	u16 byte_cnt;		/* Descriptor buffer byte count		*/
 	u16 buf_size;		/* Buffer size				*/
 	u32 cmd_sts;		/* Descriptor command status		*/
@@ -441,7 +180,7 @@
 	u32 buf_ptr;		/* Descriptor buffer pointer		*/
 };
 
-struct eth_tx_desc {
+struct tx_desc {
 	u16 byte_cnt;		/* buffer byte count			*/
 	u16 l4i_chk;		/* CPU provided TCP checksum		*/
 	u32 cmd_sts;		/* Command/status field			*/
@@ -449,7 +188,7 @@
 	u32 buf_ptr;		/* pointer to buffer for this descriptor*/
 };
 #elif defined(__LITTLE_ENDIAN)
-struct eth_rx_desc {
+struct rx_desc {
 	u32 cmd_sts;		/* Descriptor command status		*/
 	u16 buf_size;		/* Buffer size				*/
 	u16 byte_cnt;		/* Descriptor buffer byte count		*/
@@ -457,7 +196,7 @@
 	u32 next_desc_ptr;	/* Next descriptor pointer		*/
 };
 
-struct eth_tx_desc {
+struct tx_desc {
 	u32 cmd_sts;		/* Command/status field			*/
 	u16 l4i_chk;		/* CPU provided TCP checksum		*/
 	u16 byte_cnt;		/* buffer byte count			*/
@@ -468,18 +207,59 @@
 #error One of __BIG_ENDIAN or __LITTLE_ENDIAN must be defined
 #endif
 
-/* Unified struct for Rx and Tx operations. The user is not required to	*/
-/* be familier with neither Tx nor Rx descriptors.			*/
-struct pkt_info {
-	unsigned short byte_cnt;	/* Descriptor buffer byte count	*/
-	unsigned short l4i_chk;		/* Tx CPU provided TCP Checksum	*/
-	unsigned int cmd_sts;		/* Descriptor command status	*/
-	dma_addr_t buf_ptr;		/* Descriptor buffer pointer	*/
-	struct sk_buff *return_info;	/* User resource return information */
+/* RX & TX descriptor command */
+#define BUFFER_OWNED_BY_DMA		0x80000000
+
+/* RX & TX descriptor status */
+#define ERROR_SUMMARY			0x00000001
+
+/* RX descriptor status */
+#define LAYER_4_CHECKSUM_OK		0x40000000
+#define RX_ENABLE_INTERRUPT		0x20000000
+#define RX_FIRST_DESC			0x08000000
+#define RX_LAST_DESC			0x04000000
+
+/* TX descriptor command */
+#define TX_ENABLE_INTERRUPT		0x00800000
+#define GEN_CRC				0x00400000
+#define TX_FIRST_DESC			0x00200000
+#define TX_LAST_DESC			0x00100000
+#define ZERO_PADDING			0x00080000
+#define GEN_IP_V4_CHECKSUM		0x00040000
+#define GEN_TCP_UDP_CHECKSUM		0x00020000
+#define UDP_FRAME			0x00010000
+
+#define TX_IHL_SHIFT			11
+
+
+/* global *******************************************************************/
+struct mv643xx_eth_shared_private {
+	/*
+	 * Ethernet controller base address.
+	 */
+	void __iomem *base;
+
+	/*
+	 * Protects access to SMI_REG, which is shared between ports.
+	 */
+	spinlock_t phy_lock;
+
+	/*
+	 * Per-port MBUS window access register value.
+	 */
+	u32 win_protect;
+
+	/*
+	 * Hardware-specific parameters.
+	 */
+	unsigned int t_clk;
+	int extended_rx_coal_limit;
+	int tx_bw_control_moved;
 };
 
-/* Ethernet port specific information */
-struct mv643xx_mib_counters {
+
+/* per-port *****************************************************************/
+struct mib_counters {
 	u64 good_octets_received;
 	u32 bad_octets_received;
 	u32 internal_mac_transmit_err;
@@ -512,461 +292,282 @@
 	u32 late_collision;
 };
 
-struct mv643xx_shared_private {
-	void __iomem *eth_base;
-
-	/* used to protect SMI_REG, which is shared across ports */
-	spinlock_t phy_lock;
-
-	u32 win_protect;
-
-	unsigned int t_clk;
-};
-
-struct mv643xx_private {
-	struct mv643xx_shared_private *shared;
-	int port_num;			/* User Ethernet port number	*/
-
-	struct mv643xx_shared_private *shared_smi;
+struct rx_queue {
+	int index;
 
-	u32 rx_sram_addr;		/* Base address of rx sram area */
-	u32 rx_sram_size;		/* Size of rx sram area		*/
-	u32 tx_sram_addr;		/* Base address of tx sram area */
-	u32 tx_sram_size;		/* Size of tx sram area		*/
+	int rx_ring_size;
 
-	int rx_resource_err;		/* Rx ring resource error flag */
+	int rx_desc_count;
+	int rx_curr_desc;
+	int rx_used_desc;
 
-	/* Tx/Rx rings managment indexes fields. For driver use */
+	struct rx_desc *rx_desc_area;
+	dma_addr_t rx_desc_dma;
+	int rx_desc_area_size;
+	struct sk_buff **rx_skb;
 
-	/* Next available and first returning Rx resource */
-	int rx_curr_desc_q, rx_used_desc_q;
+	struct timer_list rx_oom;
+};
 
-	/* Next available and first returning Tx resource */
-	int tx_curr_desc_q, tx_used_desc_q;
+struct tx_queue {
+	int index;
 
-#ifdef MV643XX_TX_FAST_REFILL
-	u32 tx_clean_threshold;
-#endif
+	int tx_ring_size;
 
-	struct eth_rx_desc *p_rx_desc_area;
-	dma_addr_t rx_desc_dma;
-	int rx_desc_area_size;
-	struct sk_buff **rx_skb;
+	int tx_desc_count;
+	int tx_curr_desc;
+	int tx_used_desc;
 
-	struct eth_tx_desc *p_tx_desc_area;
+	struct tx_desc *tx_desc_area;
 	dma_addr_t tx_desc_dma;
 	int tx_desc_area_size;
 	struct sk_buff **tx_skb;
+};
 
-	struct work_struct tx_timeout_task;
+struct mv643xx_eth_private {
+	struct mv643xx_eth_shared_private *shared;
+	int port_num;
 
 	struct net_device *dev;
-	struct napi_struct napi;
-	struct net_device_stats stats;
-	struct mv643xx_mib_counters mib_counters;
+
+	struct mv643xx_eth_shared_private *shared_smi;
+	int phy_addr;
+
 	spinlock_t lock;
-	/* Size of Tx Ring per queue */
-	int tx_ring_size;
-	/* Number of tx descriptors in use */
-	int tx_desc_count;
-	/* Size of Rx Ring per queue */
-	int rx_ring_size;
-	/* Number of rx descriptors in use */
-	int rx_desc_count;
+
+	struct mib_counters mib_counters;
+	struct work_struct tx_timeout_task;
+	struct mii_if_info mii;
 
 	/*
-	 * Used in case RX Ring is empty, which can be caused when
-	 * system does not have resources (skb's)
+	 * RX state.
 	 */
-	struct timer_list timeout;
-
-	u32 rx_int_coal;
-	u32 tx_int_coal;
-	struct mii_if_info mii;
-};
+	int default_rx_ring_size;
+	unsigned long rx_desc_sram_addr;
+	int rx_desc_sram_size;
+	u8 rxq_mask;
+	int rxq_primary;
+	struct napi_struct napi;
+	struct rx_queue rxq[8];
 
-/* Static function declarations */
-static void eth_port_init(struct mv643xx_private *mp);
-static void eth_port_reset(struct mv643xx_private *mp);
-static void eth_port_start(struct net_device *dev);
-
-static void ethernet_phy_reset(struct mv643xx_private *mp);
-
-static void eth_port_write_smi_reg(struct mv643xx_private *mp,
-				   unsigned int phy_reg, unsigned int value);
-
-static void eth_port_read_smi_reg(struct mv643xx_private *mp,
-				  unsigned int phy_reg, unsigned int *value);
-
-static void eth_clear_mib_counters(struct mv643xx_private *mp);
-
-static ETH_FUNC_RET_STATUS eth_port_receive(struct mv643xx_private *mp,
-					    struct pkt_info *p_pkt_info);
-static ETH_FUNC_RET_STATUS eth_rx_return_buff(struct mv643xx_private *mp,
-					      struct pkt_info *p_pkt_info);
-
-static void eth_port_uc_addr_get(struct mv643xx_private *mp,
-				 unsigned char *p_addr);
-static void eth_port_uc_addr_set(struct mv643xx_private *mp,
-				 unsigned char *p_addr);
-static void eth_port_set_multicast_list(struct net_device *);
-static void mv643xx_eth_port_enable_tx(struct mv643xx_private *mp,
-						unsigned int queues);
-static void mv643xx_eth_port_enable_rx(struct mv643xx_private *mp,
-						unsigned int queues);
-static unsigned int mv643xx_eth_port_disable_tx(struct mv643xx_private *mp);
-static unsigned int mv643xx_eth_port_disable_rx(struct mv643xx_private *mp);
-static int mv643xx_eth_open(struct net_device *);
-static int mv643xx_eth_stop(struct net_device *);
-static void eth_port_init_mac_tables(struct mv643xx_private *mp);
-#ifdef MV643XX_NAPI
-static int mv643xx_poll(struct napi_struct *napi, int budget);
+	/*
+	 * TX state.
+	 */
+	int default_tx_ring_size;
+	unsigned long tx_desc_sram_addr;
+	int tx_desc_sram_size;
+	u8 txq_mask;
+	int txq_primary;
+	struct tx_queue txq[8];
+#ifdef MV643XX_ETH_TX_FAST_REFILL
+	int tx_clean_threshold;
 #endif
-static int ethernet_phy_get(struct mv643xx_private *mp);
-static void ethernet_phy_set(struct mv643xx_private *mp, int phy_addr);
-static int ethernet_phy_detect(struct mv643xx_private *mp);
-static int mv643xx_mdio_read(struct net_device *dev, int phy_id, int location);
-static void mv643xx_mdio_write(struct net_device *dev, int phy_id, int location, int val);
-static int mv643xx_eth_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
-static const struct ethtool_ops mv643xx_ethtool_ops;
+};
 
-static char mv643xx_driver_name[] = "mv643xx_eth";
-static char mv643xx_driver_version[] = "1.0";
 
-static inline u32 rdl(struct mv643xx_private *mp, int offset)
+/* port register accessors **************************************************/
+static inline u32 rdl(struct mv643xx_eth_private *mp, int offset)
 {
-	return readl(mp->shared->eth_base + offset);
+	return readl(mp->shared->base + offset);
 }
 
-static inline void wrl(struct mv643xx_private *mp, int offset, u32 data)
+static inline void wrl(struct mv643xx_eth_private *mp, int offset, u32 data)
 {
-	writel(data, mp->shared->eth_base + offset);
+	writel(data, mp->shared->base + offset);
 }
 
-/*
- * Changes MTU (maximum transfer unit) of the gigabit ethenret port
- *
- * Input :	pointer to ethernet interface network device structure
- *		new mtu size
- * Output :	0 upon success, -EINVAL upon failure
- */
-static int mv643xx_eth_change_mtu(struct net_device *dev, int new_mtu)
-{
-	if ((new_mtu > 9500) || (new_mtu < 64))
-		return -EINVAL;
-
-	dev->mtu = new_mtu;
-	if (!netif_running(dev))
-		return 0;
-
-	/*
-	 * Stop and then re-open the interface. This will allocate RX
-	 * skbs of the new MTU.
-	 * There is a possible danger that the open will not succeed,
-	 * due to memory being full, which might fail the open function.
-	 */
-	mv643xx_eth_stop(dev);
-	if (mv643xx_eth_open(dev)) {
-		printk(KERN_ERR "%s: Fatal error on opening device\n",
-			dev->name);
-	}
-
-	return 0;
-}
 
-/*
- * mv643xx_eth_rx_refill_descs
- *
- * Fills / refills RX queue on a certain gigabit ethernet port
- *
- * Input :	pointer to ethernet interface network device structure
- * Output :	N/A
- */
-static void mv643xx_eth_rx_refill_descs(struct net_device *dev)
+/* rxq/txq helper functions *************************************************/
+static struct mv643xx_eth_private *rxq_to_mp(struct rx_queue *rxq)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-	struct pkt_info pkt_info;
-	struct sk_buff *skb;
-	int unaligned;
-
-	while (mp->rx_desc_count < mp->rx_ring_size) {
-		skb = dev_alloc_skb(ETH_RX_SKB_SIZE + dma_get_cache_alignment());
-		if (!skb)
-			break;
-		mp->rx_desc_count++;
-		unaligned = (u32)skb->data & (dma_get_cache_alignment() - 1);
-		if (unaligned)
-			skb_reserve(skb, dma_get_cache_alignment() - unaligned);
-		pkt_info.cmd_sts = ETH_RX_ENABLE_INTERRUPT;
-		pkt_info.byte_cnt = ETH_RX_SKB_SIZE;
-		pkt_info.buf_ptr = dma_map_single(NULL, skb->data,
-					ETH_RX_SKB_SIZE, DMA_FROM_DEVICE);
-		pkt_info.return_info = skb;
-		if (eth_rx_return_buff(mp, &pkt_info) != ETH_OK) {
-			printk(KERN_ERR
-				"%s: Error allocating RX Ring\n", dev->name);
-			break;
-		}
-		skb_reserve(skb, ETH_HW_IP_ALIGN);
-	}
-	/*
-	 * If RX ring is empty of SKB, set a timer to try allocating
-	 * again at a later time.
-	 */
-	if (mp->rx_desc_count == 0) {
-		printk(KERN_INFO "%s: Rx ring is empty\n", dev->name);
-		mp->timeout.expires = jiffies + (HZ / 10);	/* 100 mSec */
-		add_timer(&mp->timeout);
-	}
+	return container_of(rxq, struct mv643xx_eth_private, rxq[rxq->index]);
 }
 
-/*
- * mv643xx_eth_rx_refill_descs_timer_wrapper
- *
- * Timer routine to wake up RX queue filling task. This function is
- * used only in case the RX queue is empty, and all alloc_skb has
- * failed (due to out of memory event).
- *
- * Input :	pointer to ethernet interface network device structure
- * Output :	N/A
- */
-static inline void mv643xx_eth_rx_refill_descs_timer_wrapper(unsigned long data)
+static struct mv643xx_eth_private *txq_to_mp(struct tx_queue *txq)
 {
-	mv643xx_eth_rx_refill_descs((struct net_device *)data);
+	return container_of(txq, struct mv643xx_eth_private, txq[txq->index]);
 }
 
-/*
- * mv643xx_eth_update_mac_address
- *
- * Update the MAC address of the port in the address table
- *
- * Input :	pointer to ethernet interface network device structure
- * Output :	N/A
- */
-static void mv643xx_eth_update_mac_address(struct net_device *dev)
+static void rxq_enable(struct rx_queue *rxq)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-
-	eth_port_init_mac_tables(mp);
-	eth_port_uc_addr_set(mp, dev->dev_addr);
+	struct mv643xx_eth_private *mp = rxq_to_mp(rxq);
+	wrl(mp, RXQ_COMMAND(mp->port_num), 1 << rxq->index);
 }
 
-/*
- * mv643xx_eth_set_rx_mode
- *
- * Change from promiscuos to regular rx mode
- *
- * Input :	pointer to ethernet interface network device structure
- * Output :	N/A
- */
-static void mv643xx_eth_set_rx_mode(struct net_device *dev)
+static void rxq_disable(struct rx_queue *rxq)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-	u32 config_reg;
-
-	config_reg = rdl(mp, PORT_CONFIG_REG(mp->port_num));
-	if (dev->flags & IFF_PROMISC)
-		config_reg |= (u32) UNICAST_PROMISCUOUS_MODE;
-	else
-		config_reg &= ~(u32) UNICAST_PROMISCUOUS_MODE;
-	wrl(mp, PORT_CONFIG_REG(mp->port_num), config_reg);
+	struct mv643xx_eth_private *mp = rxq_to_mp(rxq);
+	u8 mask = 1 << rxq->index;
 
-	eth_port_set_multicast_list(dev);
+	wrl(mp, RXQ_COMMAND(mp->port_num), mask << 8);
+	while (rdl(mp, RXQ_COMMAND(mp->port_num)) & mask)
+		udelay(10);
 }
 
-/*
- * mv643xx_eth_set_mac_address
- *
- * Change the interface's mac address.
- * No special hardware thing should be done because interface is always
- * put in promiscuous mode.
- *
- * Input :	pointer to ethernet interface network device structure and
- *		a pointer to the designated entry to be added to the cache.
- * Output :	zero upon success, negative upon failure
- */
-static int mv643xx_eth_set_mac_address(struct net_device *dev, void *addr)
+static void txq_enable(struct tx_queue *txq)
 {
-	int i;
-
-	for (i = 0; i < 6; i++)
-		/* +2 is for the offset of the HW addr type */
-		dev->dev_addr[i] = ((unsigned char *)addr)[i + 2];
-	mv643xx_eth_update_mac_address(dev);
-	return 0;
+	struct mv643xx_eth_private *mp = txq_to_mp(txq);
+	wrl(mp, TXQ_COMMAND(mp->port_num), 1 << txq->index);
 }
 
-/*
- * mv643xx_eth_tx_timeout
- *
- * Called upon a timeout on transmitting a packet
- *
- * Input :	pointer to ethernet interface network device structure.
- * Output :	N/A
- */
-static void mv643xx_eth_tx_timeout(struct net_device *dev)
+static void txq_disable(struct tx_queue *txq)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-
-	printk(KERN_INFO "%s: TX timeout  ", dev->name);
+	struct mv643xx_eth_private *mp = txq_to_mp(txq);
+	u8 mask = 1 << txq->index;
 
-	/* Do the reset outside of interrupt context */
-	schedule_work(&mp->tx_timeout_task);
+	wrl(mp, TXQ_COMMAND(mp->port_num), mask << 8);
+	while (rdl(mp, TXQ_COMMAND(mp->port_num)) & mask)
+		udelay(10);
 }
 
-/*
- * mv643xx_eth_tx_timeout_task
- *
- * Actual routine to reset the adapter when a timeout on Tx has occurred
- */
-static void mv643xx_eth_tx_timeout_task(struct work_struct *ugly)
+static void __txq_maybe_wake(struct tx_queue *txq)
 {
-	struct mv643xx_private *mp = container_of(ugly, struct mv643xx_private,
-						  tx_timeout_task);
-	struct net_device *dev = mp->dev;
+	struct mv643xx_eth_private *mp = txq_to_mp(txq);
 
-	if (!netif_running(dev))
-		return;
+	/*
+	 * netif_{stop,wake}_queue() flow control only applies to
+	 * the primary queue.
+	 */
+	BUG_ON(txq->index != mp->txq_primary);
 
-	netif_stop_queue(dev);
+	if (txq->tx_ring_size - txq->tx_desc_count >= MAX_DESCS_PER_SKB)
+		netif_wake_queue(mp->dev);
+}
 
-	eth_port_reset(mp);
-	eth_port_start(dev);
 
-	if (mp->tx_ring_size - mp->tx_desc_count >= MAX_DESCS_PER_SKB)
-		netif_wake_queue(dev);
-}
+/* rx ***********************************************************************/
+static void txq_reclaim(struct tx_queue *txq, int force);
 
-/**
- * mv643xx_eth_free_tx_descs - Free the tx desc data for completed descriptors
- *
- * If force is non-zero, frees uncompleted descriptors as well
- */
-static int mv643xx_eth_free_tx_descs(struct net_device *dev, int force)
+static void rxq_refill(struct rx_queue *rxq)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-	struct eth_tx_desc *desc;
-	u32 cmd_sts;
-	struct sk_buff *skb;
+	struct mv643xx_eth_private *mp = rxq_to_mp(rxq);
 	unsigned long flags;
-	int tx_index;
-	dma_addr_t addr;
-	int count;
-	int released = 0;
-
-	while (mp->tx_desc_count > 0) {
-		spin_lock_irqsave(&mp->lock, flags);
-
-		/* tx_desc_count might have changed before acquiring the lock */
-		if (mp->tx_desc_count <= 0) {
-			spin_unlock_irqrestore(&mp->lock, flags);
-			return released;
-		}
-
-		tx_index = mp->tx_used_desc_q;
-		desc = &mp->p_tx_desc_area[tx_index];
-		cmd_sts = desc->cmd_sts;
 
-		if (!force && (cmd_sts & ETH_BUFFER_OWNED_BY_DMA)) {
-			spin_unlock_irqrestore(&mp->lock, flags);
-			return released;
-		}
+	spin_lock_irqsave(&mp->lock, flags);
 
-		mp->tx_used_desc_q = (tx_index + 1) % mp->tx_ring_size;
-		mp->tx_desc_count--;
+	while (rxq->rx_desc_count < rxq->rx_ring_size) {
+		int skb_size;
+		struct sk_buff *skb;
+		int unaligned;
+		int rx;
 
-		addr = desc->buf_ptr;
-		count = desc->byte_cnt;
-		skb = mp->tx_skb[tx_index];
-		if (skb)
-			mp->tx_skb[tx_index] = NULL;
+		/*
+		 * Reserve 2+14 bytes for an ethernet header (the
+		 * hardware automatically prepends 2 bytes of dummy
+		 * data to each received packet), 4 bytes for a VLAN
+		 * header, and 4 bytes for the trailing FCS -- 24
+		 * bytes total.
+		 */
+		skb_size = mp->dev->mtu + 24;
 
-		if (cmd_sts & ETH_ERROR_SUMMARY) {
-			printk("%s: Error in TX\n", dev->name);
-			dev->stats.tx_errors++;
-		}
+		skb = dev_alloc_skb(skb_size + dma_get_cache_alignment() - 1);
+		if (skb == NULL)
+			break;
 
-		spin_unlock_irqrestore(&mp->lock, flags);
+		unaligned = (u32)skb->data & (dma_get_cache_alignment() - 1);
+		if (unaligned)
+			skb_reserve(skb, dma_get_cache_alignment() - unaligned);
 
-		if (cmd_sts & ETH_TX_FIRST_DESC)
-			dma_unmap_single(NULL, addr, count, DMA_TO_DEVICE);
-		else
-			dma_unmap_page(NULL, addr, count, DMA_TO_DEVICE);
+		rxq->rx_desc_count++;
+		rx = rxq->rx_used_desc;
+		rxq->rx_used_desc = (rx + 1) % rxq->rx_ring_size;
+
+		rxq->rx_desc_area[rx].buf_ptr = dma_map_single(NULL, skb->data,
+						skb_size, DMA_FROM_DEVICE);
+		rxq->rx_desc_area[rx].buf_size = skb_size;
+		rxq->rx_skb[rx] = skb;
+		wmb();
+		rxq->rx_desc_area[rx].cmd_sts = BUFFER_OWNED_BY_DMA |
+						RX_ENABLE_INTERRUPT;
+		wmb();
 
-		if (skb)
-			dev_kfree_skb_irq(skb);
+		/*
+		 * The hardware automatically prepends 2 bytes of
+		 * dummy data to each received packet, so that the
+		 * IP header ends up 16-byte aligned.
+		 */
+		skb_reserve(skb, 2);
+	}
 
-		released = 1;
+	if (rxq->rx_desc_count != rxq->rx_ring_size) {
+		rxq->rx_oom.expires = jiffies + (HZ / 10);
+		add_timer(&rxq->rx_oom);
 	}
 
-	return released;
+	spin_unlock_irqrestore(&mp->lock, flags);
 }
 
-static void mv643xx_eth_free_completed_tx_descs(struct net_device *dev)
+static inline void rxq_refill_timer_wrapper(unsigned long data)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-
-	if (mv643xx_eth_free_tx_descs(dev, 0) &&
-	    mp->tx_ring_size - mp->tx_desc_count >= MAX_DESCS_PER_SKB)
-		netif_wake_queue(dev);
+	rxq_refill((struct rx_queue *)data);
 }
 
-static void mv643xx_eth_free_all_tx_descs(struct net_device *dev)
+static int rxq_process(struct rx_queue *rxq, int budget)
 {
-	mv643xx_eth_free_tx_descs(dev, 1);
-}
+	struct mv643xx_eth_private *mp = rxq_to_mp(rxq);
+	struct net_device_stats *stats = &mp->dev->stats;
+	int rx;
 
-/*
- * mv643xx_eth_receive
- *
- * This function is forward packets that are received from the port's
- * queues toward kernel core or FastRoute them to another interface.
- *
- * Input :	dev - a pointer to the required interface
- *		max - maximum number to receive (0 means unlimted)
- *
- * Output :	number of served packets
- */
-static int mv643xx_eth_receive_queue(struct net_device *dev, int budget)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-	struct net_device_stats *stats = &dev->stats;
-	unsigned int received_packets = 0;
-	struct sk_buff *skb;
-	struct pkt_info pkt_info;
-
-	while (budget-- > 0 && eth_port_receive(mp, &pkt_info) == ETH_OK) {
-		dma_unmap_single(NULL, pkt_info.buf_ptr, ETH_RX_SKB_SIZE,
-							DMA_FROM_DEVICE);
-		mp->rx_desc_count--;
-		received_packets++;
+	rx = 0;
+	while (rx < budget) {
+		struct rx_desc *rx_desc;
+		unsigned int cmd_sts;
+		struct sk_buff *skb;
+		unsigned long flags;
+
+		spin_lock_irqsave(&mp->lock, flags);
+
+		rx_desc = &rxq->rx_desc_area[rxq->rx_curr_desc];
+
+		cmd_sts = rx_desc->cmd_sts;
+		if (cmd_sts & BUFFER_OWNED_BY_DMA) {
+			spin_unlock_irqrestore(&mp->lock, flags);
+			break;
+		}
+		rmb();
+
+		skb = rxq->rx_skb[rxq->rx_curr_desc];
+		rxq->rx_skb[rxq->rx_curr_desc] = NULL;
+
+		rxq->rx_curr_desc = (rxq->rx_curr_desc + 1) % rxq->rx_ring_size;
+
+		spin_unlock_irqrestore(&mp->lock, flags);
+
+		dma_unmap_single(NULL, rx_desc->buf_ptr + 2,
+				 mp->dev->mtu + 24, DMA_FROM_DEVICE);
+		rxq->rx_desc_count--;
+		rx++;
 
 		/*
 		 * Update statistics.
-		 * Note byte count includes 4 byte CRC count
+		 *
+		 * Note that the descriptor byte count includes 2 dummy
+		 * bytes automatically inserted by the hardware at the
+		 * start of the packet (which we don't count), and a 4
+		 * byte CRC at the end of the packet (which we do count).
 		 */
 		stats->rx_packets++;
-		stats->rx_bytes += pkt_info.byte_cnt;
-		skb = pkt_info.return_info;
+		stats->rx_bytes += rx_desc->byte_cnt - 2;
+
 		/*
-		 * In case received a packet without first / last bits on OR
-		 * the error summary bit is on, the packets needs to be dropeed.
+		 * In case we received a packet without first / last bits
+		 * on, or the error summary bit is set, the packet needs
+		 * to be dropped.
 		 */
-		if (((pkt_info.cmd_sts
-				& (ETH_RX_FIRST_DESC | ETH_RX_LAST_DESC)) !=
-					(ETH_RX_FIRST_DESC | ETH_RX_LAST_DESC))
-				|| (pkt_info.cmd_sts & ETH_ERROR_SUMMARY)) {
+		if (((cmd_sts & (RX_FIRST_DESC | RX_LAST_DESC)) !=
+					(RX_FIRST_DESC | RX_LAST_DESC))
+				|| (cmd_sts & ERROR_SUMMARY)) {
 			stats->rx_dropped++;
-			if ((pkt_info.cmd_sts & (ETH_RX_FIRST_DESC |
-							ETH_RX_LAST_DESC)) !=
-				(ETH_RX_FIRST_DESC | ETH_RX_LAST_DESC)) {
+
+			if ((cmd_sts & (RX_FIRST_DESC | RX_LAST_DESC)) !=
+				(RX_FIRST_DESC | RX_LAST_DESC)) {
 				if (net_ratelimit())
-					printk(KERN_ERR
-						"%s: Received packet spread "
-						"on multiple descriptors\n",
-						dev->name);
+					dev_printk(KERN_ERR, &mp->dev->dev,
+						   "received packet spanning "
+						   "multiple descriptors\n");
 			}
-			if (pkt_info.cmd_sts & ETH_ERROR_SUMMARY)
+
+			if (cmd_sts & ERROR_SUMMARY)
 				stats->rx_errors++;
 
 			dev_kfree_skb_irq(skb);
@@ -975,668 +576,120 @@
 			 * The -4 is for the CRC in the trailer of the
 			 * received packet
 			 */
-			skb_put(skb, pkt_info.byte_cnt - 4);
+			skb_put(skb, rx_desc->byte_cnt - 2 - 4);
 
-			if (pkt_info.cmd_sts & ETH_LAYER_4_CHECKSUM_OK) {
+			if (cmd_sts & LAYER_4_CHECKSUM_OK) {
 				skb->ip_summed = CHECKSUM_UNNECESSARY;
 				skb->csum = htons(
-					(pkt_info.cmd_sts & 0x0007fff8) >> 3);
+					(cmd_sts & 0x0007fff8) >> 3);
 			}
-			skb->protocol = eth_type_trans(skb, dev);
-#ifdef MV643XX_NAPI
+			skb->protocol = eth_type_trans(skb, mp->dev);
+#ifdef MV643XX_ETH_NAPI
 			netif_receive_skb(skb);
 #else
 			netif_rx(skb);
 #endif
 		}
-		dev->last_rx = jiffies;
+
+		mp->dev->last_rx = jiffies;
 	}
-	mv643xx_eth_rx_refill_descs(dev);	/* Fill RX ring with skb's */
 
-	return received_packets;
+	rxq_refill(rxq);
+
+	return rx;
 }
 
-/* Set the mv643xx port configuration register for the speed/duplex mode. */
-static void mv643xx_eth_update_pscr(struct net_device *dev,
-				    struct ethtool_cmd *ecmd)
+#ifdef MV643XX_ETH_NAPI
+static int mv643xx_eth_poll(struct napi_struct *napi, int budget)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-	int port_num = mp->port_num;
-	u32 o_pscr, n_pscr;
-	unsigned int queues;
+	struct mv643xx_eth_private *mp;
+	int rx;
+	int i;
 
-	o_pscr = rdl(mp, PORT_SERIAL_CONTROL_REG(port_num));
-	n_pscr = o_pscr;
+	mp = container_of(napi, struct mv643xx_eth_private, napi);
 
-	/* clear speed, duplex and rx buffer size fields */
-	n_pscr &= ~(SET_MII_SPEED_TO_100  |
-		   SET_GMII_SPEED_TO_1000 |
-		   SET_FULL_DUPLEX_MODE   |
-		   MAX_RX_PACKET_MASK);
-
-	if (ecmd->duplex == DUPLEX_FULL)
-		n_pscr |= SET_FULL_DUPLEX_MODE;
-
-	if (ecmd->speed == SPEED_1000)
-		n_pscr |= SET_GMII_SPEED_TO_1000 |
-			  MAX_RX_PACKET_9700BYTE;
-	else {
-		if (ecmd->speed == SPEED_100)
-			n_pscr |= SET_MII_SPEED_TO_100;
-		n_pscr |= MAX_RX_PACKET_1522BYTE;
-	}
-
-	if (n_pscr != o_pscr) {
-		if ((o_pscr & SERIAL_PORT_ENABLE) == 0)
-			wrl(mp, PORT_SERIAL_CONTROL_REG(port_num), n_pscr);
-		else {
-			queues = mv643xx_eth_port_disable_tx(mp);
+#ifdef MV643XX_ETH_TX_FAST_REFILL
+	if (++mp->tx_clean_threshold > 5) {
+		mp->tx_clean_threshold = 0;
+		for (i = 0; i < 8; i++)
+			if (mp->txq_mask & (1 << i))
+				txq_reclaim(mp->txq + i, 0);
+	}
+#endif
 
-			o_pscr &= ~SERIAL_PORT_ENABLE;
-			wrl(mp, PORT_SERIAL_CONTROL_REG(port_num), o_pscr);
-			wrl(mp, PORT_SERIAL_CONTROL_REG(port_num), n_pscr);
-			wrl(mp, PORT_SERIAL_CONTROL_REG(port_num), n_pscr);
-			if (queues)
-				mv643xx_eth_port_enable_tx(mp, queues);
-		}
+	rx = 0;
+	for (i = 7; rx < budget && i >= 0; i--)
+		if (mp->rxq_mask & (1 << i))
+			rx += rxq_process(mp->rxq + i, budget - rx);
+
+	if (rx < budget) {
+		netif_rx_complete(mp->dev, napi);
+		wrl(mp, INT_CAUSE(mp->port_num), 0);
+		wrl(mp, INT_CAUSE_EXT(mp->port_num), 0);
+		wrl(mp, INT_MASK(mp->port_num), INT_TX_END | INT_RX | INT_EXT);
 	}
+
+	return rx;
 }
+#endif
 
-/*
- * mv643xx_eth_int_handler
- *
- * Main interrupt handler for the gigbit ethernet ports
- *
- * Input :	irq	- irq number (not used)
- *		dev_id	- a pointer to the required interface's data structure
- *		regs	- not used
- * Output :	N/A
- */
 
-static irqreturn_t mv643xx_eth_int_handler(int irq, void *dev_id)
+/* tx ***********************************************************************/
+static inline unsigned int has_tiny_unaligned_frags(struct sk_buff *skb)
 {
-	struct net_device *dev = (struct net_device *)dev_id;
-	struct mv643xx_private *mp = netdev_priv(dev);
-	u32 eth_int_cause, eth_int_cause_ext = 0;
-	unsigned int port_num = mp->port_num;
-
-	/* Read interrupt cause registers */
-	eth_int_cause = rdl(mp, INTERRUPT_CAUSE_REG(port_num)) &
-						ETH_INT_UNMASK_ALL;
-	if (eth_int_cause & ETH_INT_CAUSE_EXT) {
-		eth_int_cause_ext = rdl(mp,
-			INTERRUPT_CAUSE_EXTEND_REG(port_num)) &
-						ETH_INT_UNMASK_ALL_EXT;
-		wrl(mp, INTERRUPT_CAUSE_EXTEND_REG(port_num),
-							~eth_int_cause_ext);
-	}
-
-	/* PHY status changed */
-	if (eth_int_cause_ext & (ETH_INT_CAUSE_PHY | ETH_INT_CAUSE_STATE)) {
-		struct ethtool_cmd cmd;
+	int frag;
 
-		if (mii_link_ok(&mp->mii)) {
-			mii_ethtool_gset(&mp->mii, &cmd);
-			mv643xx_eth_update_pscr(dev, &cmd);
-			mv643xx_eth_port_enable_tx(mp, ETH_TX_QUEUES_ENABLED);
-			if (!netif_carrier_ok(dev)) {
-				netif_carrier_on(dev);
-				if (mp->tx_ring_size - mp->tx_desc_count >=
-							MAX_DESCS_PER_SKB)
-					netif_wake_queue(dev);
-			}
-		} else if (netif_carrier_ok(dev)) {
-			netif_stop_queue(dev);
-			netif_carrier_off(dev);
-		}
+	for (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {
+		skb_frag_t *fragp = &skb_shinfo(skb)->frags[frag];
+		if (fragp->size <= 8 && fragp->page_offset & 7)
+			return 1;
 	}
 
-#ifdef MV643XX_NAPI
-	if (eth_int_cause & ETH_INT_CAUSE_RX) {
-		/* schedule the NAPI poll routine to maintain port */
-		wrl(mp, INTERRUPT_MASK_REG(port_num), ETH_INT_MASK_ALL);
+	return 0;
+}
 
-		/* wait for previous write to complete */
-		rdl(mp, INTERRUPT_MASK_REG(port_num));
+static int txq_alloc_desc_index(struct tx_queue *txq)
+{
+	int tx_desc_curr;
 
-		netif_rx_schedule(dev, &mp->napi);
-	}
-#else
-	if (eth_int_cause & ETH_INT_CAUSE_RX)
-		mv643xx_eth_receive_queue(dev, INT_MAX);
-#endif
-	if (eth_int_cause_ext & ETH_INT_CAUSE_TX)
-		mv643xx_eth_free_completed_tx_descs(dev);
+	BUG_ON(txq->tx_desc_count >= txq->tx_ring_size);
 
-	/*
-	 * If no real interrupt occured, exit.
-	 * This can happen when using gigE interrupt coalescing mechanism.
-	 */
-	if ((eth_int_cause == 0x0) && (eth_int_cause_ext == 0x0))
-		return IRQ_NONE;
+	tx_desc_curr = txq->tx_curr_desc;
+	txq->tx_curr_desc = (tx_desc_curr + 1) % txq->tx_ring_size;
 
-	return IRQ_HANDLED;
-}
-
-#ifdef MV643XX_COAL
-
-/*
- * eth_port_set_rx_coal - Sets coalescing interrupt mechanism on RX path
- *
- * DESCRIPTION:
- *	This routine sets the RX coalescing interrupt mechanism parameter.
- *	This parameter is a timeout counter, that counts in 64 t_clk
- *	chunks ; that when timeout event occurs a maskable interrupt
- *	occurs.
- *	The parameter is calculated using the tClk of the MV-643xx chip
- *	, and the required delay of the interrupt in usec.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet port
- *	unsigned int delay		Delay in usec
- *
- * OUTPUT:
- *	Interrupt coalescing mechanism value is set in MV-643xx chip.
- *
- * RETURN:
- *	The interrupt coalescing value set in the gigE port.
- *
- */
-static unsigned int eth_port_set_rx_coal(struct mv643xx_private *mp,
-					unsigned int delay)
-{
-	unsigned int port_num = mp->port_num;
-	unsigned int coal = ((mp->shared->t_clk / 1000000) * delay) / 64;
-
-	/* Set RX Coalescing mechanism */
-	wrl(mp, SDMA_CONFIG_REG(port_num),
-		((coal & 0x3fff) << 8) |
-		(rdl(mp, SDMA_CONFIG_REG(port_num))
-			& 0xffc000ff));
-
-	return coal;
-}
-#endif
-
-/*
- * eth_port_set_tx_coal - Sets coalescing interrupt mechanism on TX path
- *
- * DESCRIPTION:
- *	This routine sets the TX coalescing interrupt mechanism parameter.
- *	This parameter is a timeout counter, that counts in 64 t_clk
- *	chunks ; that when timeout event occurs a maskable interrupt
- *	occurs.
- *	The parameter is calculated using the t_cLK frequency of the
- *	MV-643xx chip and the required delay in the interrupt in uSec
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet port
- *	unsigned int delay		Delay in uSeconds
- *
- * OUTPUT:
- *	Interrupt coalescing mechanism value is set in MV-643xx chip.
- *
- * RETURN:
- *	The interrupt coalescing value set in the gigE port.
- *
- */
-static unsigned int eth_port_set_tx_coal(struct mv643xx_private *mp,
-					unsigned int delay)
-{
-	unsigned int coal = ((mp->shared->t_clk / 1000000) * delay) / 64;
-
-	/* Set TX Coalescing mechanism */
-	wrl(mp, TX_FIFO_URGENT_THRESHOLD_REG(mp->port_num), coal << 4);
-
-	return coal;
-}
-
-/*
- * ether_init_rx_desc_ring - Curve a Rx chain desc list and buffer in memory.
- *
- * DESCRIPTION:
- *	This function prepares a Rx chained list of descriptors and packet
- *	buffers in a form of a ring. The routine must be called after port
- *	initialization routine and before port start routine.
- *	The Ethernet SDMA engine uses CPU bus addresses to access the various
- *	devices in the system (i.e. DRAM). This function uses the ethernet
- *	struct 'virtual to physical' routine (set by the user) to set the ring
- *	with physical addresses.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port Control srtuct.
- *
- * OUTPUT:
- *	The routine updates the Ethernet port control struct with information
- *	regarding the Rx descriptors and buffers.
- *
- * RETURN:
- *	None.
- */
-static void ether_init_rx_desc_ring(struct mv643xx_private *mp)
-{
-	volatile struct eth_rx_desc *p_rx_desc;
-	int rx_desc_num = mp->rx_ring_size;
-	int i;
-
-	/* initialize the next_desc_ptr links in the Rx descriptors ring */
-	p_rx_desc = (struct eth_rx_desc *)mp->p_rx_desc_area;
-	for (i = 0; i < rx_desc_num; i++) {
-		p_rx_desc[i].next_desc_ptr = mp->rx_desc_dma +
-			((i + 1) % rx_desc_num) * sizeof(struct eth_rx_desc);
-	}
-
-	/* Save Rx desc pointer to driver struct. */
-	mp->rx_curr_desc_q = 0;
-	mp->rx_used_desc_q = 0;
-
-	mp->rx_desc_area_size = rx_desc_num * sizeof(struct eth_rx_desc);
-}
-
-/*
- * ether_init_tx_desc_ring - Curve a Tx chain desc list and buffer in memory.
- *
- * DESCRIPTION:
- *	This function prepares a Tx chained list of descriptors and packet
- *	buffers in a form of a ring. The routine must be called after port
- *	initialization routine and before port start routine.
- *	The Ethernet SDMA engine uses CPU bus addresses to access the various
- *	devices in the system (i.e. DRAM). This function uses the ethernet
- *	struct 'virtual to physical' routine (set by the user) to set the ring
- *	with physical addresses.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port Control srtuct.
- *
- * OUTPUT:
- *	The routine updates the Ethernet port control struct with information
- *	regarding the Tx descriptors and buffers.
- *
- * RETURN:
- *	None.
- */
-static void ether_init_tx_desc_ring(struct mv643xx_private *mp)
-{
-	int tx_desc_num = mp->tx_ring_size;
-	struct eth_tx_desc *p_tx_desc;
-	int i;
-
-	/* Initialize the next_desc_ptr links in the Tx descriptors ring */
-	p_tx_desc = (struct eth_tx_desc *)mp->p_tx_desc_area;
-	for (i = 0; i < tx_desc_num; i++) {
-		p_tx_desc[i].next_desc_ptr = mp->tx_desc_dma +
-			((i + 1) % tx_desc_num) * sizeof(struct eth_tx_desc);
-	}
-
-	mp->tx_curr_desc_q = 0;
-	mp->tx_used_desc_q = 0;
-
-	mp->tx_desc_area_size = tx_desc_num * sizeof(struct eth_tx_desc);
-}
-
-static int mv643xx_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-	int err;
-
-	spin_lock_irq(&mp->lock);
-	err = mii_ethtool_sset(&mp->mii, cmd);
-	spin_unlock_irq(&mp->lock);
-
-	return err;
-}
-
-static int mv643xx_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-	int err;
-
-	spin_lock_irq(&mp->lock);
-	err = mii_ethtool_gset(&mp->mii, cmd);
-	spin_unlock_irq(&mp->lock);
-
-	/* The PHY may support 1000baseT_Half, but the mv643xx does not */
-	cmd->supported &= ~SUPPORTED_1000baseT_Half;
-	cmd->advertising &= ~ADVERTISED_1000baseT_Half;
-
-	return err;
-}
-
-/*
- * mv643xx_eth_open
- *
- * This function is called when openning the network device. The function
- * should initialize all the hardware, initialize cyclic Rx/Tx
- * descriptors chain and buffers and allocate an IRQ to the network
- * device.
- *
- * Input :	a pointer to the network device structure
- *
- * Output :	zero of success , nonzero if fails.
- */
-
-static int mv643xx_eth_open(struct net_device *dev)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-	unsigned int port_num = mp->port_num;
-	unsigned int size;
-	int err;
-
-	/* Clear any pending ethernet port interrupts */
-	wrl(mp, INTERRUPT_CAUSE_REG(port_num), 0);
-	wrl(mp, INTERRUPT_CAUSE_EXTEND_REG(port_num), 0);
-	/* wait for previous write to complete */
-	rdl(mp, INTERRUPT_CAUSE_EXTEND_REG(port_num));
-
-	err = request_irq(dev->irq, mv643xx_eth_int_handler,
-			IRQF_SHARED | IRQF_SAMPLE_RANDOM, dev->name, dev);
-	if (err) {
-		printk(KERN_ERR "%s: Can not assign IRQ\n", dev->name);
-		return -EAGAIN;
-	}
-
-	eth_port_init(mp);
-
-	memset(&mp->timeout, 0, sizeof(struct timer_list));
-	mp->timeout.function = mv643xx_eth_rx_refill_descs_timer_wrapper;
-	mp->timeout.data = (unsigned long)dev;
-
-	/* Allocate RX and TX skb rings */
-	mp->rx_skb = kmalloc(sizeof(*mp->rx_skb) * mp->rx_ring_size,
-								GFP_KERNEL);
-	if (!mp->rx_skb) {
-		printk(KERN_ERR "%s: Cannot allocate Rx skb ring\n", dev->name);
-		err = -ENOMEM;
-		goto out_free_irq;
-	}
-	mp->tx_skb = kmalloc(sizeof(*mp->tx_skb) * mp->tx_ring_size,
-								GFP_KERNEL);
-	if (!mp->tx_skb) {
-		printk(KERN_ERR "%s: Cannot allocate Tx skb ring\n", dev->name);
-		err = -ENOMEM;
-		goto out_free_rx_skb;
-	}
-
-	/* Allocate TX ring */
-	mp->tx_desc_count = 0;
-	size = mp->tx_ring_size * sizeof(struct eth_tx_desc);
-	mp->tx_desc_area_size = size;
-
-	if (mp->tx_sram_size) {
-		mp->p_tx_desc_area = ioremap(mp->tx_sram_addr,
-							mp->tx_sram_size);
-		mp->tx_desc_dma = mp->tx_sram_addr;
-	} else
-		mp->p_tx_desc_area = dma_alloc_coherent(NULL, size,
-							&mp->tx_desc_dma,
-							GFP_KERNEL);
-
-	if (!mp->p_tx_desc_area) {
-		printk(KERN_ERR "%s: Cannot allocate Tx Ring (size %d bytes)\n",
-							dev->name, size);
-		err = -ENOMEM;
-		goto out_free_tx_skb;
-	}
-	BUG_ON((u32) mp->p_tx_desc_area & 0xf);	/* check 16-byte alignment */
-	memset((void *)mp->p_tx_desc_area, 0, mp->tx_desc_area_size);
-
-	ether_init_tx_desc_ring(mp);
-
-	/* Allocate RX ring */
-	mp->rx_desc_count = 0;
-	size = mp->rx_ring_size * sizeof(struct eth_rx_desc);
-	mp->rx_desc_area_size = size;
-
-	if (mp->rx_sram_size) {
-		mp->p_rx_desc_area = ioremap(mp->rx_sram_addr,
-							mp->rx_sram_size);
-		mp->rx_desc_dma = mp->rx_sram_addr;
-	} else
-		mp->p_rx_desc_area = dma_alloc_coherent(NULL, size,
-							&mp->rx_desc_dma,
-							GFP_KERNEL);
-
-	if (!mp->p_rx_desc_area) {
-		printk(KERN_ERR "%s: Cannot allocate Rx ring (size %d bytes)\n",
-							dev->name, size);
-		printk(KERN_ERR "%s: Freeing previously allocated TX queues...",
-							dev->name);
-		if (mp->rx_sram_size)
-			iounmap(mp->p_tx_desc_area);
-		else
-			dma_free_coherent(NULL, mp->tx_desc_area_size,
-					mp->p_tx_desc_area, mp->tx_desc_dma);
-		err = -ENOMEM;
-		goto out_free_tx_skb;
-	}
-	memset((void *)mp->p_rx_desc_area, 0, size);
-
-	ether_init_rx_desc_ring(mp);
-
-	mv643xx_eth_rx_refill_descs(dev);	/* Fill RX ring with skb's */
-
-#ifdef MV643XX_NAPI
-	napi_enable(&mp->napi);
-#endif
-
-	eth_port_start(dev);
-
-	/* Interrupt Coalescing */
-
-#ifdef MV643XX_COAL
-	mp->rx_int_coal =
-		eth_port_set_rx_coal(mp, MV643XX_RX_COAL);
-#endif
-
-	mp->tx_int_coal =
-		eth_port_set_tx_coal(mp, MV643XX_TX_COAL);
-
-	/* Unmask phy and link status changes interrupts */
-	wrl(mp, INTERRUPT_EXTEND_MASK_REG(port_num), ETH_INT_UNMASK_ALL_EXT);
-
-	/* Unmask RX buffer and TX end interrupt */
-	wrl(mp, INTERRUPT_MASK_REG(port_num), ETH_INT_UNMASK_ALL);
-
-	return 0;
-
-out_free_tx_skb:
-	kfree(mp->tx_skb);
-out_free_rx_skb:
-	kfree(mp->rx_skb);
-out_free_irq:
-	free_irq(dev->irq, dev);
-
-	return err;
-}
-
-static void mv643xx_eth_free_tx_rings(struct net_device *dev)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-
-	/* Stop Tx Queues */
-	mv643xx_eth_port_disable_tx(mp);
-
-	/* Free outstanding skb's on TX ring */
-	mv643xx_eth_free_all_tx_descs(dev);
-
-	BUG_ON(mp->tx_used_desc_q != mp->tx_curr_desc_q);
-
-	/* Free TX ring */
-	if (mp->tx_sram_size)
-		iounmap(mp->p_tx_desc_area);
-	else
-		dma_free_coherent(NULL, mp->tx_desc_area_size,
-				mp->p_tx_desc_area, mp->tx_desc_dma);
-}
-
-static void mv643xx_eth_free_rx_rings(struct net_device *dev)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-	int curr;
-
-	/* Stop RX Queues */
-	mv643xx_eth_port_disable_rx(mp);
-
-	/* Free preallocated skb's on RX rings */
-	for (curr = 0; mp->rx_desc_count && curr < mp->rx_ring_size; curr++) {
-		if (mp->rx_skb[curr]) {
-			dev_kfree_skb(mp->rx_skb[curr]);
-			mp->rx_desc_count--;
-		}
-	}
-
-	if (mp->rx_desc_count)
-		printk(KERN_ERR
-			"%s: Error in freeing Rx Ring. %d skb's still"
-			" stuck in RX Ring - ignoring them\n", dev->name,
-			mp->rx_desc_count);
-	/* Free RX ring */
-	if (mp->rx_sram_size)
-		iounmap(mp->p_rx_desc_area);
-	else
-		dma_free_coherent(NULL, mp->rx_desc_area_size,
-				mp->p_rx_desc_area, mp->rx_desc_dma);
-}
-
-/*
- * mv643xx_eth_stop
- *
- * This function is used when closing the network device.
- * It updates the hardware,
- * release all memory that holds buffers and descriptors and release the IRQ.
- * Input :	a pointer to the device structure
- * Output :	zero if success , nonzero if fails
- */
-
-static int mv643xx_eth_stop(struct net_device *dev)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-	unsigned int port_num = mp->port_num;
-
-	/* Mask all interrupts on ethernet port */
-	wrl(mp, INTERRUPT_MASK_REG(port_num), ETH_INT_MASK_ALL);
-	/* wait for previous write to complete */
-	rdl(mp, INTERRUPT_MASK_REG(port_num));
-
-#ifdef MV643XX_NAPI
-	napi_disable(&mp->napi);
-#endif
-	netif_carrier_off(dev);
-	netif_stop_queue(dev);
-
-	eth_port_reset(mp);
-
-	mv643xx_eth_free_tx_rings(dev);
-	mv643xx_eth_free_rx_rings(dev);
-
-	free_irq(dev->irq, dev);
-
-	return 0;
-}
-
-#ifdef MV643XX_NAPI
-/*
- * mv643xx_poll
- *
- * This function is used in case of NAPI
- */
-static int mv643xx_poll(struct napi_struct *napi, int budget)
-{
-	struct mv643xx_private *mp = container_of(napi, struct mv643xx_private, napi);
-	struct net_device *dev = mp->dev;
-	unsigned int port_num = mp->port_num;
-	int work_done;
-
-#ifdef MV643XX_TX_FAST_REFILL
-	if (++mp->tx_clean_threshold > 5) {
-		mv643xx_eth_free_completed_tx_descs(dev);
-		mp->tx_clean_threshold = 0;
-	}
-#endif
-
-	work_done = 0;
-	if ((rdl(mp, RX_CURRENT_QUEUE_DESC_PTR_0(port_num)))
-	    != (u32) mp->rx_used_desc_q)
-		work_done = mv643xx_eth_receive_queue(dev, budget);
-
-	if (work_done < budget) {
-		netif_rx_complete(dev, napi);
-		wrl(mp, INTERRUPT_CAUSE_REG(port_num), 0);
-		wrl(mp, INTERRUPT_CAUSE_EXTEND_REG(port_num), 0);
-		wrl(mp, INTERRUPT_MASK_REG(port_num), ETH_INT_UNMASK_ALL);
-	}
-
-	return work_done;
-}
-#endif
-
-/**
- * has_tiny_unaligned_frags - check if skb has any small, unaligned fragments
- *
- * Hardware can't handle unaligned fragments smaller than 9 bytes.
- * This helper function detects that case.
- */
-
-static inline unsigned int has_tiny_unaligned_frags(struct sk_buff *skb)
-{
-	unsigned int frag;
-	skb_frag_t *fragp;
-
-	for (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {
-		fragp = &skb_shinfo(skb)->frags[frag];
-		if (fragp->size <= 8 && fragp->page_offset & 0x7)
-			return 1;
-	}
-	return 0;
-}
-
-/**
- * eth_alloc_tx_desc_index - return the index of the next available tx desc
- */
-static int eth_alloc_tx_desc_index(struct mv643xx_private *mp)
-{
-	int tx_desc_curr;
-
-	BUG_ON(mp->tx_desc_count >= mp->tx_ring_size);
-
-	tx_desc_curr = mp->tx_curr_desc_q;
-	mp->tx_curr_desc_q = (tx_desc_curr + 1) % mp->tx_ring_size;
-
-	BUG_ON(mp->tx_curr_desc_q == mp->tx_used_desc_q);
+	BUG_ON(txq->tx_curr_desc == txq->tx_used_desc);
 
 	return tx_desc_curr;
 }
 
-/**
- * eth_tx_fill_frag_descs - fill tx hw descriptors for an skb's fragments.
- *
- * Ensure the data for each fragment to be transmitted is mapped properly,
- * then fill in descriptors in the tx hw queue.
- */
-static void eth_tx_fill_frag_descs(struct mv643xx_private *mp,
-				   struct sk_buff *skb)
+static void txq_submit_frag_skb(struct tx_queue *txq, struct sk_buff *skb)
 {
+	int nr_frags = skb_shinfo(skb)->nr_frags;
 	int frag;
-	int tx_index;
-	struct eth_tx_desc *desc;
-
-	for (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {
-		skb_frag_t *this_frag = &skb_shinfo(skb)->frags[frag];
 
-		tx_index = eth_alloc_tx_desc_index(mp);
-		desc = &mp->p_tx_desc_area[tx_index];
+	for (frag = 0; frag < nr_frags; frag++) {
+		skb_frag_t *this_frag;
+		int tx_index;
+		struct tx_desc *desc;
+
+		this_frag = &skb_shinfo(skb)->frags[frag];
+		tx_index = txq_alloc_desc_index(txq);
+		desc = &txq->tx_desc_area[tx_index];
 
-		desc->cmd_sts = ETH_BUFFER_OWNED_BY_DMA;
-		/* Last Frag enables interrupt and frees the skb */
-		if (frag == (skb_shinfo(skb)->nr_frags - 1)) {
-			desc->cmd_sts |= ETH_ZERO_PADDING |
-					 ETH_TX_LAST_DESC |
-					 ETH_TX_ENABLE_INTERRUPT;
-			mp->tx_skb[tx_index] = skb;
-		} else
-			mp->tx_skb[tx_index] = NULL;
+		/*
+		 * The last fragment will generate an interrupt
+		 * which will free the skb on TX completion.
+		 */
+		if (frag == nr_frags - 1) {
+			desc->cmd_sts = BUFFER_OWNED_BY_DMA |
+					ZERO_PADDING | TX_LAST_DESC |
+					TX_ENABLE_INTERRUPT;
+			txq->tx_skb[tx_index] = skb;
+		} else {
+			desc->cmd_sts = BUFFER_OWNED_BY_DMA;
+			txq->tx_skb[tx_index] = NULL;
+		}
 
-		desc = &mp->p_tx_desc_area[tx_index];
 		desc->l4i_chk = 0;
 		desc->byte_cnt = this_frag->size;
 		desc->buf_ptr = dma_map_page(NULL, this_frag->page,
@@ -1651,37 +704,28 @@
 	return (__force __be16)sum;
 }
 
-/**
- * eth_tx_submit_descs_for_skb - submit data from an skb to the tx hw
- *
- * Ensure the data for an skb to be transmitted is mapped properly,
- * then fill in descriptors in the tx hw queue and start the hardware.
- */
-static void eth_tx_submit_descs_for_skb(struct mv643xx_private *mp,
-					struct sk_buff *skb)
+static void txq_submit_skb(struct tx_queue *txq, struct sk_buff *skb)
 {
+	int nr_frags = skb_shinfo(skb)->nr_frags;
 	int tx_index;
-	struct eth_tx_desc *desc;
+	struct tx_desc *desc;
 	u32 cmd_sts;
 	int length;
-	int nr_frags = skb_shinfo(skb)->nr_frags;
 
-	cmd_sts = ETH_TX_FIRST_DESC | ETH_GEN_CRC | ETH_BUFFER_OWNED_BY_DMA;
+	cmd_sts = TX_FIRST_DESC | GEN_CRC | BUFFER_OWNED_BY_DMA;
 
-	tx_index = eth_alloc_tx_desc_index(mp);
-	desc = &mp->p_tx_desc_area[tx_index];
+	tx_index = txq_alloc_desc_index(txq);
+	desc = &txq->tx_desc_area[tx_index];
 
 	if (nr_frags) {
-		eth_tx_fill_frag_descs(mp, skb);
+		txq_submit_frag_skb(txq, skb);
 
 		length = skb_headlen(skb);
-		mp->tx_skb[tx_index] = NULL;
+		txq->tx_skb[tx_index] = NULL;
 	} else {
-		cmd_sts |= ETH_ZERO_PADDING |
-			   ETH_TX_LAST_DESC |
-			   ETH_TX_ENABLE_INTERRUPT;
+		cmd_sts |= ZERO_PADDING | TX_LAST_DESC | TX_ENABLE_INTERRUPT;
 		length = skb->len;
-		mp->tx_skb[tx_index] = skb;
+		txq->tx_skb[tx_index] = skb;
 	}
 
 	desc->byte_cnt = length;
@@ -1690,13 +734,13 @@
 	if (skb->ip_summed == CHECKSUM_PARTIAL) {
 		BUG_ON(skb->protocol != htons(ETH_P_IP));
 
-		cmd_sts |= ETH_GEN_TCP_UDP_CHECKSUM |
-			   ETH_GEN_IP_V_4_CHECKSUM  |
-			   ip_hdr(skb)->ihl << ETH_TX_IHL_SHIFT;
+		cmd_sts |= GEN_TCP_UDP_CHECKSUM |
+			   GEN_IP_V4_CHECKSUM   |
+			   ip_hdr(skb)->ihl << TX_IHL_SHIFT;
 
 		switch (ip_hdr(skb)->protocol) {
 		case IPPROTO_UDP:
-			cmd_sts |= ETH_UDP_FRAME;
+			cmd_sts |= UDP_FRAME;
 			desc->l4i_chk = ntohs(sum16_as_be(udp_hdr(skb)->check));
 			break;
 		case IPPROTO_TCP:
@@ -1707,7 +751,7 @@
 		}
 	} else {
 		/* Errata BTS #50, IHL must be 5 if no HW checksum */
-		cmd_sts |= 5 << ETH_TX_IHL_SHIFT;
+		cmd_sts |= 5 << TX_IHL_SHIFT;
 		desc->l4i_chk = 0;
 	}
 
@@ -1717,1649 +761,1818 @@
 
 	/* ensure all descriptors are written before poking hardware */
 	wmb();
-	mv643xx_eth_port_enable_tx(mp, ETH_TX_QUEUES_ENABLED);
+	txq_enable(txq);
 
-	mp->tx_desc_count += nr_frags + 1;
+	txq->tx_desc_count += nr_frags + 1;
 }
 
-/**
- * mv643xx_eth_start_xmit - queue an skb to the hardware for transmission
- *
- */
-static int mv643xx_eth_start_xmit(struct sk_buff *skb, struct net_device *dev)
+static int mv643xx_eth_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
 	struct net_device_stats *stats = &dev->stats;
+	struct tx_queue *txq;
 	unsigned long flags;
 
-	BUG_ON(netif_queue_stopped(dev));
-
 	if (has_tiny_unaligned_frags(skb) && __skb_linearize(skb)) {
 		stats->tx_dropped++;
-		printk(KERN_DEBUG "%s: failed to linearize tiny "
-				"unaligned fragment\n", dev->name);
+		dev_printk(KERN_DEBUG, &dev->dev,
+			   "failed to linearize skb with tiny "
+			   "unaligned fragment\n");
 		return NETDEV_TX_BUSY;
 	}
 
 	spin_lock_irqsave(&mp->lock, flags);
 
-	if (mp->tx_ring_size - mp->tx_desc_count < MAX_DESCS_PER_SKB) {
-		printk(KERN_ERR "%s: transmit with queue full\n", dev->name);
-		netif_stop_queue(dev);
+	txq = mp->txq + mp->txq_primary;
+
+	if (txq->tx_ring_size - txq->tx_desc_count < MAX_DESCS_PER_SKB) {
 		spin_unlock_irqrestore(&mp->lock, flags);
-		return NETDEV_TX_BUSY;
+		if (txq->index == mp->txq_primary && net_ratelimit())
+			dev_printk(KERN_ERR, &dev->dev,
+				   "primary tx queue full?!\n");
+		kfree_skb(skb);
+		return NETDEV_TX_OK;
 	}
 
-	eth_tx_submit_descs_for_skb(mp, skb);
+	txq_submit_skb(txq, skb);
 	stats->tx_bytes += skb->len;
 	stats->tx_packets++;
 	dev->trans_start = jiffies;
 
-	if (mp->tx_ring_size - mp->tx_desc_count < MAX_DESCS_PER_SKB)
-		netif_stop_queue(dev);
+	if (txq->index == mp->txq_primary) {
+		int entries_left;
+
+		entries_left = txq->tx_ring_size - txq->tx_desc_count;
+		if (entries_left < MAX_DESCS_PER_SKB)
+			netif_stop_queue(dev);
+	}
 
 	spin_unlock_irqrestore(&mp->lock, flags);
 
 	return NETDEV_TX_OK;
 }
 
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void mv643xx_netpoll(struct net_device *netdev)
+
+/* tx rate control **********************************************************/
+/*
+ * Set total maximum TX rate (shared by all TX queues for this port)
+ * to 'rate' bits per second, with a maximum burst of 'burst' bytes.
+ */
+static void tx_set_rate(struct mv643xx_eth_private *mp, int rate, int burst)
 {
-	struct mv643xx_private *mp = netdev_priv(netdev);
-	int port_num = mp->port_num;
+	int token_rate;
+	int mtu;
+	int bucket_size;
+
+	token_rate = ((rate / 1000) * 64) / (mp->shared->t_clk / 1000);
+	if (token_rate > 1023)
+		token_rate = 1023;
 
-	wrl(mp, INTERRUPT_MASK_REG(port_num), ETH_INT_MASK_ALL);
-	/* wait for previous write to complete */
-	rdl(mp, INTERRUPT_MASK_REG(port_num));
+	mtu = (mp->dev->mtu + 255) >> 8;
+	if (mtu > 63)
+		mtu = 63;
 
-	mv643xx_eth_int_handler(netdev->irq, netdev);
+	bucket_size = (burst + 255) >> 8;
+	if (bucket_size > 65535)
+		bucket_size = 65535;
 
-	wrl(mp, INTERRUPT_MASK_REG(port_num), ETH_INT_UNMASK_ALL);
+	if (mp->shared->tx_bw_control_moved) {
+		wrl(mp, TX_BW_RATE_MOVED(mp->port_num), token_rate);
+		wrl(mp, TX_BW_MTU_MOVED(mp->port_num), mtu);
+		wrl(mp, TX_BW_BURST_MOVED(mp->port_num), bucket_size);
+	} else {
+		wrl(mp, TX_BW_RATE(mp->port_num), token_rate);
+		wrl(mp, TX_BW_MTU(mp->port_num), mtu);
+		wrl(mp, TX_BW_BURST(mp->port_num), bucket_size);
+	}
 }
-#endif
 
-static void mv643xx_init_ethtool_cmd(struct net_device *dev, int phy_address,
-				     int speed, int duplex,
-				     struct ethtool_cmd *cmd)
+static void txq_set_rate(struct tx_queue *txq, int rate, int burst)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
+	struct mv643xx_eth_private *mp = txq_to_mp(txq);
+	int token_rate;
+	int bucket_size;
 
-	memset(cmd, 0, sizeof(*cmd));
+	token_rate = ((rate / 1000) * 64) / (mp->shared->t_clk / 1000);
+	if (token_rate > 1023)
+		token_rate = 1023;
 
-	cmd->port = PORT_MII;
-	cmd->transceiver = XCVR_INTERNAL;
-	cmd->phy_address = phy_address;
+	bucket_size = (burst + 255) >> 8;
+	if (bucket_size > 65535)
+		bucket_size = 65535;
 
-	if (speed == 0) {
-		cmd->autoneg = AUTONEG_ENABLE;
-		/* mii lib checks, but doesn't use speed on AUTONEG_ENABLE */
-		cmd->speed = SPEED_100;
-		cmd->advertising = ADVERTISED_10baseT_Half  |
-				   ADVERTISED_10baseT_Full  |
-				   ADVERTISED_100baseT_Half |
-				   ADVERTISED_100baseT_Full;
-		if (mp->mii.supports_gmii)
-			cmd->advertising |= ADVERTISED_1000baseT_Full;
-	} else {
-		cmd->autoneg = AUTONEG_DISABLE;
-		cmd->speed = speed;
-		cmd->duplex = duplex;
-	}
+	wrl(mp, TXQ_BW_TOKENS(mp->port_num, txq->index), token_rate << 14);
+	wrl(mp, TXQ_BW_CONF(mp->port_num, txq->index),
+			(bucket_size << 10) | token_rate);
 }
 
-/*/
- * mv643xx_eth_probe
- *
- * First function called after registering the network device.
- * It's purpose is to initialize the device as an ethernet device,
- * fill the ethernet device structure with pointers * to functions,
- * and set the MAC address of the interface
- *
- * Input :	struct device *
- * Output :	-ENOMEM if failed , 0 if success
- */
-static int mv643xx_eth_probe(struct platform_device *pdev)
+static void txq_set_fixed_prio_mode(struct tx_queue *txq)
 {
-	struct mv643xx_eth_platform_data *pd;
-	int port_num;
-	struct mv643xx_private *mp;
-	struct net_device *dev;
-	u8 *p;
-	struct resource *res;
-	int err;
-	struct ethtool_cmd cmd;
-	int duplex = DUPLEX_HALF;
-	int speed = 0;			/* default to auto-negotiation */
-	DECLARE_MAC_BUF(mac);
+	struct mv643xx_eth_private *mp = txq_to_mp(txq);
+	int off;
+	u32 val;
 
-	pd = pdev->dev.platform_data;
-	if (pd == NULL) {
-		printk(KERN_ERR "No mv643xx_eth_platform_data\n");
-		return -ENODEV;
-	}
+	/*
+	 * Turn on fixed priority mode.
+	 */
+	if (mp->shared->tx_bw_control_moved)
+		off = TXQ_FIX_PRIO_CONF_MOVED(mp->port_num);
+	else
+		off = TXQ_FIX_PRIO_CONF(mp->port_num);
 
-	if (pd->shared == NULL) {
-		printk(KERN_ERR "No mv643xx_eth_platform_data->shared\n");
-		return -ENODEV;
-	}
+	val = rdl(mp, off);
+	val |= 1 << txq->index;
+	wrl(mp, off, val);
+}
 
-	dev = alloc_etherdev(sizeof(struct mv643xx_private));
-	if (!dev)
-		return -ENOMEM;
+static void txq_set_wrr(struct tx_queue *txq, int weight)
+{
+	struct mv643xx_eth_private *mp = txq_to_mp(txq);
+	int off;
+	u32 val;
 
-	platform_set_drvdata(pdev, dev);
+	/*
+	 * Turn off fixed priority mode.
+	 */
+	if (mp->shared->tx_bw_control_moved)
+		off = TXQ_FIX_PRIO_CONF_MOVED(mp->port_num);
+	else
+		off = TXQ_FIX_PRIO_CONF(mp->port_num);
 
-	mp = netdev_priv(dev);
-	mp->dev = dev;
-#ifdef MV643XX_NAPI
-	netif_napi_add(dev, &mp->napi, mv643xx_poll, 64);
-#endif
+	val = rdl(mp, off);
+	val &= ~(1 << txq->index);
+	wrl(mp, off, val);
 
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	BUG_ON(!res);
-	dev->irq = res->start;
+	/*
+	 * Configure WRR weight for this queue.
+	 */
+	off = TXQ_BW_WRR_CONF(mp->port_num, txq->index);
 
-	dev->open = mv643xx_eth_open;
-	dev->stop = mv643xx_eth_stop;
-	dev->hard_start_xmit = mv643xx_eth_start_xmit;
-	dev->set_mac_address = mv643xx_eth_set_mac_address;
-	dev->set_multicast_list = mv643xx_eth_set_rx_mode;
+	val = rdl(mp, off);
+	val = (val & ~0xff) | (weight & 0xff);
+	wrl(mp, off, val);
+}
 
-	/* No need to Tx Timeout */
-	dev->tx_timeout = mv643xx_eth_tx_timeout;
 
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	dev->poll_controller = mv643xx_netpoll;
-#endif
+/* mii management interface *************************************************/
+#define SMI_BUSY		0x10000000
+#define SMI_READ_VALID		0x08000000
+#define SMI_OPCODE_READ		0x04000000
+#define SMI_OPCODE_WRITE	0x00000000
 
-	dev->watchdog_timeo = 2 * HZ;
-	dev->base_addr = 0;
-	dev->change_mtu = mv643xx_eth_change_mtu;
-	dev->do_ioctl = mv643xx_eth_do_ioctl;
-	SET_ETHTOOL_OPS(dev, &mv643xx_ethtool_ops);
+static void smi_reg_read(struct mv643xx_eth_private *mp, unsigned int addr,
+			 unsigned int reg, unsigned int *value)
+{
+	void __iomem *smi_reg = mp->shared_smi->base + SMI_REG;
+	unsigned long flags;
+	int i;
+
+	/* the SMI register is a shared resource */
+	spin_lock_irqsave(&mp->shared_smi->phy_lock, flags);
+
+	/* wait for the SMI register to become available */
+	for (i = 0; readl(smi_reg) & SMI_BUSY; i++) {
+		if (i == 1000) {
+			printk("%s: PHY busy timeout\n", mp->dev->name);
+			goto out;
+		}
+		udelay(10);
+	}
+
+	writel(SMI_OPCODE_READ | (reg << 21) | (addr << 16), smi_reg);
+
+	/* now wait for the data to be valid */
+	for (i = 0; !(readl(smi_reg) & SMI_READ_VALID); i++) {
+		if (i == 1000) {
+			printk("%s: PHY read timeout\n", mp->dev->name);
+			goto out;
+		}
+		udelay(10);
+	}
+
+	*value = readl(smi_reg) & 0xffff;
+out:
+	spin_unlock_irqrestore(&mp->shared_smi->phy_lock, flags);
+}
+
+static void smi_reg_write(struct mv643xx_eth_private *mp,
+			  unsigned int addr,
+			  unsigned int reg, unsigned int value)
+{
+	void __iomem *smi_reg = mp->shared_smi->base + SMI_REG;
+	unsigned long flags;
+	int i;
+
+	/* the SMI register is a shared resource */
+	spin_lock_irqsave(&mp->shared_smi->phy_lock, flags);
+
+	/* wait for the SMI register to become available */
+	for (i = 0; readl(smi_reg) & SMI_BUSY; i++) {
+		if (i == 1000) {
+			printk("%s: PHY busy timeout\n", mp->dev->name);
+			goto out;
+		}
+		udelay(10);
+	}
+
+	writel(SMI_OPCODE_WRITE | (reg << 21) |
+		(addr << 16) | (value & 0xffff), smi_reg);
+out:
+	spin_unlock_irqrestore(&mp->shared_smi->phy_lock, flags);
+}
+
+
+/* mib counters *************************************************************/
+static inline u32 mib_read(struct mv643xx_eth_private *mp, int offset)
+{
+	return rdl(mp, MIB_COUNTERS(mp->port_num) + offset);
+}
+
+static void mib_counters_clear(struct mv643xx_eth_private *mp)
+{
+	int i;
+
+	for (i = 0; i < 0x80; i += 4)
+		mib_read(mp, i);
+}
+
+static void mib_counters_update(struct mv643xx_eth_private *mp)
+{
+	struct mib_counters *p = &mp->mib_counters;
+
+	p->good_octets_received += mib_read(mp, 0x00);
+	p->good_octets_received += (u64)mib_read(mp, 0x04) << 32;
+	p->bad_octets_received += mib_read(mp, 0x08);
+	p->internal_mac_transmit_err += mib_read(mp, 0x0c);
+	p->good_frames_received += mib_read(mp, 0x10);
+	p->bad_frames_received += mib_read(mp, 0x14);
+	p->broadcast_frames_received += mib_read(mp, 0x18);
+	p->multicast_frames_received += mib_read(mp, 0x1c);
+	p->frames_64_octets += mib_read(mp, 0x20);
+	p->frames_65_to_127_octets += mib_read(mp, 0x24);
+	p->frames_128_to_255_octets += mib_read(mp, 0x28);
+	p->frames_256_to_511_octets += mib_read(mp, 0x2c);
+	p->frames_512_to_1023_octets += mib_read(mp, 0x30);
+	p->frames_1024_to_max_octets += mib_read(mp, 0x34);
+	p->good_octets_sent += mib_read(mp, 0x38);
+	p->good_octets_sent += (u64)mib_read(mp, 0x3c) << 32;
+	p->good_frames_sent += mib_read(mp, 0x40);
+	p->excessive_collision += mib_read(mp, 0x44);
+	p->multicast_frames_sent += mib_read(mp, 0x48);
+	p->broadcast_frames_sent += mib_read(mp, 0x4c);
+	p->unrec_mac_control_received += mib_read(mp, 0x50);
+	p->fc_sent += mib_read(mp, 0x54);
+	p->good_fc_received += mib_read(mp, 0x58);
+	p->bad_fc_received += mib_read(mp, 0x5c);
+	p->undersize_received += mib_read(mp, 0x60);
+	p->fragments_received += mib_read(mp, 0x64);
+	p->oversize_received += mib_read(mp, 0x68);
+	p->jabber_received += mib_read(mp, 0x6c);
+	p->mac_receive_error += mib_read(mp, 0x70);
+	p->bad_crc_event += mib_read(mp, 0x74);
+	p->collision += mib_read(mp, 0x78);
+	p->late_collision += mib_read(mp, 0x7c);
+}
+
+
+/* ethtool ******************************************************************/
+struct mv643xx_eth_stats {
+	char stat_string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int netdev_off;
+	int mp_off;
+};
+
+#define SSTAT(m)						\
+	{ #m, FIELD_SIZEOF(struct net_device_stats, m),		\
+	  offsetof(struct net_device, stats.m), -1 }
+
+#define MIBSTAT(m)						\
+	{ #m, FIELD_SIZEOF(struct mib_counters, m),		\
+	  -1, offsetof(struct mv643xx_eth_private, mib_counters.m) }
+
+static const struct mv643xx_eth_stats mv643xx_eth_stats[] = {
+	SSTAT(rx_packets),
+	SSTAT(tx_packets),
+	SSTAT(rx_bytes),
+	SSTAT(tx_bytes),
+	SSTAT(rx_errors),
+	SSTAT(tx_errors),
+	SSTAT(rx_dropped),
+	SSTAT(tx_dropped),
+	MIBSTAT(good_octets_received),
+	MIBSTAT(bad_octets_received),
+	MIBSTAT(internal_mac_transmit_err),
+	MIBSTAT(good_frames_received),
+	MIBSTAT(bad_frames_received),
+	MIBSTAT(broadcast_frames_received),
+	MIBSTAT(multicast_frames_received),
+	MIBSTAT(frames_64_octets),
+	MIBSTAT(frames_65_to_127_octets),
+	MIBSTAT(frames_128_to_255_octets),
+	MIBSTAT(frames_256_to_511_octets),
+	MIBSTAT(frames_512_to_1023_octets),
+	MIBSTAT(frames_1024_to_max_octets),
+	MIBSTAT(good_octets_sent),
+	MIBSTAT(good_frames_sent),
+	MIBSTAT(excessive_collision),
+	MIBSTAT(multicast_frames_sent),
+	MIBSTAT(broadcast_frames_sent),
+	MIBSTAT(unrec_mac_control_received),
+	MIBSTAT(fc_sent),
+	MIBSTAT(good_fc_received),
+	MIBSTAT(bad_fc_received),
+	MIBSTAT(undersize_received),
+	MIBSTAT(fragments_received),
+	MIBSTAT(oversize_received),
+	MIBSTAT(jabber_received),
+	MIBSTAT(mac_receive_error),
+	MIBSTAT(bad_crc_event),
+	MIBSTAT(collision),
+	MIBSTAT(late_collision),
+};
+
+static int mv643xx_eth_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	int err;
+
+	spin_lock_irq(&mp->lock);
+	err = mii_ethtool_gset(&mp->mii, cmd);
+	spin_unlock_irq(&mp->lock);
 
-#ifdef MV643XX_CHECKSUM_OFFLOAD_TX
-#ifdef MAX_SKB_FRAGS
 	/*
-	 * Zero copy can only work if we use Discovery II memory. Else, we will
-	 * have to map the buffers to ISA memory which is only 16 MB
+	 * The MAC does not support 1000baseT_Half.
 	 */
-	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM;
-#endif
-#endif
+	cmd->supported &= ~SUPPORTED_1000baseT_Half;
+	cmd->advertising &= ~ADVERTISED_1000baseT_Half;
 
-	/* Configure the timeout task */
-	INIT_WORK(&mp->tx_timeout_task, mv643xx_eth_tx_timeout_task);
+	return err;
+}
 
-	spin_lock_init(&mp->lock);
+static int mv643xx_eth_get_settings_phyless(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	cmd->supported = SUPPORTED_MII;
+	cmd->advertising = ADVERTISED_MII;
+	cmd->speed = SPEED_1000;
+	cmd->duplex = DUPLEX_FULL;
+	cmd->port = PORT_MII;
+	cmd->phy_address = 0;
+	cmd->transceiver = XCVR_INTERNAL;
+	cmd->autoneg = AUTONEG_DISABLE;
+	cmd->maxtxpkt = 1;
+	cmd->maxrxpkt = 1;
 
-	mp->shared = platform_get_drvdata(pd->shared);
-	port_num = mp->port_num = pd->port_number;
+	return 0;
+}
 
-	if (mp->shared->win_protect)
-		wrl(mp, WINDOW_PROTECT(port_num), mp->shared->win_protect);
+static int mv643xx_eth_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	int err;
 
-	mp->shared_smi = mp->shared;
-	if (pd->shared_smi != NULL)
-		mp->shared_smi = platform_get_drvdata(pd->shared_smi);
-
-	/* set default config values */
-	eth_port_uc_addr_get(mp, dev->dev_addr);
-	mp->rx_ring_size = PORT_DEFAULT_RECEIVE_QUEUE_SIZE;
-	mp->tx_ring_size = PORT_DEFAULT_TRANSMIT_QUEUE_SIZE;
+	/*
+	 * The MAC does not support 1000baseT_Half.
+	 */
+	cmd->advertising &= ~ADVERTISED_1000baseT_Half;
 
-	if (is_valid_ether_addr(pd->mac_addr))
-		memcpy(dev->dev_addr, pd->mac_addr, 6);
+	spin_lock_irq(&mp->lock);
+	err = mii_ethtool_sset(&mp->mii, cmd);
+	spin_unlock_irq(&mp->lock);
 
-	if (pd->phy_addr || pd->force_phy_addr)
-		ethernet_phy_set(mp, pd->phy_addr);
+	return err;
+}
 
-	if (pd->rx_queue_size)
-		mp->rx_ring_size = pd->rx_queue_size;
+static int mv643xx_eth_set_settings_phyless(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	return -EINVAL;
+}
 
-	if (pd->tx_queue_size)
-		mp->tx_ring_size = pd->tx_queue_size;
+static void mv643xx_eth_get_drvinfo(struct net_device *dev,
+				    struct ethtool_drvinfo *drvinfo)
+{
+	strncpy(drvinfo->driver,  mv643xx_eth_driver_name, 32);
+	strncpy(drvinfo->version, mv643xx_eth_driver_version, 32);
+	strncpy(drvinfo->fw_version, "N/A", 32);
+	strncpy(drvinfo->bus_info, "platform", 32);
+	drvinfo->n_stats = ARRAY_SIZE(mv643xx_eth_stats);
+}
+
+static int mv643xx_eth_nway_reset(struct net_device *dev)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
 
-	if (pd->tx_sram_size) {
-		mp->tx_sram_size = pd->tx_sram_size;
-		mp->tx_sram_addr = pd->tx_sram_addr;
+	return mii_nway_restart(&mp->mii);
+}
+
+static int mv643xx_eth_nway_reset_phyless(struct net_device *dev)
+{
+	return -EINVAL;
+}
+
+static u32 mv643xx_eth_get_link(struct net_device *dev)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+
+	return mii_link_ok(&mp->mii);
+}
+
+static u32 mv643xx_eth_get_link_phyless(struct net_device *dev)
+{
+	return 1;
+}
+
+static void mv643xx_eth_get_strings(struct net_device *dev,
+				    uint32_t stringset, uint8_t *data)
+{
+	int i;
+
+	if (stringset == ETH_SS_STATS) {
+		for (i = 0; i < ARRAY_SIZE(mv643xx_eth_stats); i++) {
+			memcpy(data + i * ETH_GSTRING_LEN,
+				mv643xx_eth_stats[i].stat_string,
+				ETH_GSTRING_LEN);
+		}
 	}
+}
+
+static void mv643xx_eth_get_ethtool_stats(struct net_device *dev,
+					  struct ethtool_stats *stats,
+					  uint64_t *data)
+{
+	struct mv643xx_eth_private *mp = dev->priv;
+	int i;
+
+	mib_counters_update(mp);
+
+	for (i = 0; i < ARRAY_SIZE(mv643xx_eth_stats); i++) {
+		const struct mv643xx_eth_stats *stat;
+		void *p;
+
+		stat = mv643xx_eth_stats + i;
+
+		if (stat->netdev_off >= 0)
+			p = ((void *)mp->dev) + stat->netdev_off;
+		else
+			p = ((void *)mp) + stat->mp_off;
 
-	if (pd->rx_sram_size) {
-		mp->rx_sram_size = pd->rx_sram_size;
-		mp->rx_sram_addr = pd->rx_sram_addr;
+		data[i] = (stat->sizeof_stat == 8) ?
+				*(uint64_t *)p : *(uint32_t *)p;
 	}
+}
 
-	duplex = pd->duplex;
-	speed = pd->speed;
+static int mv643xx_eth_get_sset_count(struct net_device *dev, int sset)
+{
+	if (sset == ETH_SS_STATS)
+		return ARRAY_SIZE(mv643xx_eth_stats);
 
-	/* Hook up MII support for ethtool */
-	mp->mii.dev = dev;
-	mp->mii.mdio_read = mv643xx_mdio_read;
-	mp->mii.mdio_write = mv643xx_mdio_write;
-	mp->mii.phy_id = ethernet_phy_get(mp);
-	mp->mii.phy_id_mask = 0x3f;
-	mp->mii.reg_num_mask = 0x1f;
+	return -EOPNOTSUPP;
+}
 
-	err = ethernet_phy_detect(mp);
-	if (err) {
-		pr_debug("%s: No PHY detected at addr %d\n",
-				dev->name, ethernet_phy_get(mp));
+static const struct ethtool_ops mv643xx_eth_ethtool_ops = {
+	.get_settings		= mv643xx_eth_get_settings,
+	.set_settings		= mv643xx_eth_set_settings,
+	.get_drvinfo		= mv643xx_eth_get_drvinfo,
+	.nway_reset		= mv643xx_eth_nway_reset,
+	.get_link		= mv643xx_eth_get_link,
+	.set_sg			= ethtool_op_set_sg,
+	.get_strings		= mv643xx_eth_get_strings,
+	.get_ethtool_stats	= mv643xx_eth_get_ethtool_stats,
+	.get_sset_count		= mv643xx_eth_get_sset_count,
+};
+
+static const struct ethtool_ops mv643xx_eth_ethtool_ops_phyless = {
+	.get_settings		= mv643xx_eth_get_settings_phyless,
+	.set_settings		= mv643xx_eth_set_settings_phyless,
+	.get_drvinfo		= mv643xx_eth_get_drvinfo,
+	.nway_reset		= mv643xx_eth_nway_reset_phyless,
+	.get_link		= mv643xx_eth_get_link_phyless,
+	.set_sg			= ethtool_op_set_sg,
+	.get_strings		= mv643xx_eth_get_strings,
+	.get_ethtool_stats	= mv643xx_eth_get_ethtool_stats,
+	.get_sset_count		= mv643xx_eth_get_sset_count,
+};
+
+
+/* address handling *********************************************************/
+static void uc_addr_get(struct mv643xx_eth_private *mp, unsigned char *addr)
+{
+	unsigned int mac_h;
+	unsigned int mac_l;
+
+	mac_h = rdl(mp, MAC_ADDR_HIGH(mp->port_num));
+	mac_l = rdl(mp, MAC_ADDR_LOW(mp->port_num));
+
+	addr[0] = (mac_h >> 24) & 0xff;
+	addr[1] = (mac_h >> 16) & 0xff;
+	addr[2] = (mac_h >> 8) & 0xff;
+	addr[3] = mac_h & 0xff;
+	addr[4] = (mac_l >> 8) & 0xff;
+	addr[5] = mac_l & 0xff;
+}
+
+static void init_mac_tables(struct mv643xx_eth_private *mp)
+{
+	int i;
+
+	for (i = 0; i < 0x100; i += 4) {
+		wrl(mp, SPECIAL_MCAST_TABLE(mp->port_num) + i, 0);
+		wrl(mp, OTHER_MCAST_TABLE(mp->port_num) + i, 0);
+	}
+
+	for (i = 0; i < 0x10; i += 4)
+		wrl(mp, UNICAST_TABLE(mp->port_num) + i, 0);
+}
+
+static void set_filter_table_entry(struct mv643xx_eth_private *mp,
+				   int table, unsigned char entry)
+{
+	unsigned int table_reg;
+
+	/* Set "accepts frame bit" at specified table entry */
+	table_reg = rdl(mp, table + (entry & 0xfc));
+	table_reg |= 0x01 << (8 * (entry & 3));
+	wrl(mp, table + (entry & 0xfc), table_reg);
+}
+
+static void uc_addr_set(struct mv643xx_eth_private *mp, unsigned char *addr)
+{
+	unsigned int mac_h;
+	unsigned int mac_l;
+	int table;
+
+	mac_l = (addr[4] << 8) | addr[5];
+	mac_h = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];
+
+	wrl(mp, MAC_ADDR_LOW(mp->port_num), mac_l);
+	wrl(mp, MAC_ADDR_HIGH(mp->port_num), mac_h);
+
+	table = UNICAST_TABLE(mp->port_num);
+	set_filter_table_entry(mp, table, addr[5] & 0x0f);
+}
+
+static int mv643xx_eth_set_mac_address(struct net_device *dev, void *addr)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+
+	/* +2 is for the offset of the HW addr type */
+	memcpy(dev->dev_addr, addr + 2, 6);
+
+	init_mac_tables(mp);
+	uc_addr_set(mp, dev->dev_addr);
+
+	return 0;
+}
+
+static int addr_crc(unsigned char *addr)
+{
+	int crc = 0;
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int j;
+
+		crc = (crc ^ addr[i]) << 8;
+		for (j = 7; j >= 0; j--) {
+			if (crc & (0x100 << j))
+				crc ^= 0x107 << j;
+		}
+	}
+
+	return crc;
+}
+
+static void mv643xx_eth_set_rx_mode(struct net_device *dev)
+{
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	u32 port_config;
+	struct dev_addr_list *addr;
+	int i;
+
+	port_config = rdl(mp, PORT_CONFIG(mp->port_num));
+	if (dev->flags & IFF_PROMISC)
+		port_config |= UNICAST_PROMISCUOUS_MODE;
+	else
+		port_config &= ~UNICAST_PROMISCUOUS_MODE;
+	wrl(mp, PORT_CONFIG(mp->port_num), port_config);
+
+	if (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {
+		int port_num = mp->port_num;
+		u32 accept = 0x01010101;
+
+		for (i = 0; i < 0x100; i += 4) {
+			wrl(mp, SPECIAL_MCAST_TABLE(port_num) + i, accept);
+			wrl(mp, OTHER_MCAST_TABLE(port_num) + i, accept);
+		}
+		return;
+	}
+
+	for (i = 0; i < 0x100; i += 4) {
+		wrl(mp, SPECIAL_MCAST_TABLE(mp->port_num) + i, 0);
+		wrl(mp, OTHER_MCAST_TABLE(mp->port_num) + i, 0);
+	}
+
+	for (addr = dev->mc_list; addr != NULL; addr = addr->next) {
+		u8 *a = addr->da_addr;
+		int table;
+
+		if (addr->da_addrlen != 6)
+			continue;
+
+		if (memcmp(a, "\x01\x00\x5e\x00\x00", 5) == 0) {
+			table = SPECIAL_MCAST_TABLE(mp->port_num);
+			set_filter_table_entry(mp, table, a[5]);
+		} else {
+			int crc = addr_crc(a);
+
+			table = OTHER_MCAST_TABLE(mp->port_num);
+			set_filter_table_entry(mp, table, crc);
+		}
+	}
+}
+
+
+/* rx/tx queue initialisation ***********************************************/
+static int rxq_init(struct mv643xx_eth_private *mp, int index)
+{
+	struct rx_queue *rxq = mp->rxq + index;
+	struct rx_desc *rx_desc;
+	int size;
+	int i;
+
+	rxq->index = index;
+
+	rxq->rx_ring_size = mp->default_rx_ring_size;
+
+	rxq->rx_desc_count = 0;
+	rxq->rx_curr_desc = 0;
+	rxq->rx_used_desc = 0;
+
+	size = rxq->rx_ring_size * sizeof(struct rx_desc);
+
+	if (index == mp->rxq_primary && size <= mp->rx_desc_sram_size) {
+		rxq->rx_desc_area = ioremap(mp->rx_desc_sram_addr,
+						mp->rx_desc_sram_size);
+		rxq->rx_desc_dma = mp->rx_desc_sram_addr;
+	} else {
+		rxq->rx_desc_area = dma_alloc_coherent(NULL, size,
+							&rxq->rx_desc_dma,
+							GFP_KERNEL);
+	}
+
+	if (rxq->rx_desc_area == NULL) {
+		dev_printk(KERN_ERR, &mp->dev->dev,
+			   "can't allocate rx ring (%d bytes)\n", size);
 		goto out;
 	}
+	memset(rxq->rx_desc_area, 0, size);
 
-	ethernet_phy_reset(mp);
-	mp->mii.supports_gmii = mii_check_gmii_support(&mp->mii);
-	mv643xx_init_ethtool_cmd(dev, mp->mii.phy_id, speed, duplex, &cmd);
-	mv643xx_eth_update_pscr(dev, &cmd);
-	mv643xx_set_settings(dev, &cmd);
+	rxq->rx_desc_area_size = size;
+	rxq->rx_skb = kmalloc(rxq->rx_ring_size * sizeof(*rxq->rx_skb),
+								GFP_KERNEL);
+	if (rxq->rx_skb == NULL) {
+		dev_printk(KERN_ERR, &mp->dev->dev,
+			   "can't allocate rx skb ring\n");
+		goto out_free;
+	}
 
-	SET_NETDEV_DEV(dev, &pdev->dev);
-	err = register_netdev(dev);
-	if (err)
+	rx_desc = (struct rx_desc *)rxq->rx_desc_area;
+	for (i = 0; i < rxq->rx_ring_size; i++) {
+		int nexti = (i + 1) % rxq->rx_ring_size;
+		rx_desc[i].next_desc_ptr = rxq->rx_desc_dma +
+					nexti * sizeof(struct rx_desc);
+	}
+
+	init_timer(&rxq->rx_oom);
+	rxq->rx_oom.data = (unsigned long)rxq;
+	rxq->rx_oom.function = rxq_refill_timer_wrapper;
+
+	return 0;
+
+
+out_free:
+	if (index == mp->rxq_primary && size <= mp->rx_desc_sram_size)
+		iounmap(rxq->rx_desc_area);
+	else
+		dma_free_coherent(NULL, size,
+				  rxq->rx_desc_area,
+				  rxq->rx_desc_dma);
+
+out:
+	return -ENOMEM;
+}
+
+static void rxq_deinit(struct rx_queue *rxq)
+{
+	struct mv643xx_eth_private *mp = rxq_to_mp(rxq);
+	int i;
+
+	rxq_disable(rxq);
+
+	del_timer_sync(&rxq->rx_oom);
+
+	for (i = 0; i < rxq->rx_ring_size; i++) {
+		if (rxq->rx_skb[i]) {
+			dev_kfree_skb(rxq->rx_skb[i]);
+			rxq->rx_desc_count--;
+		}
+	}
+
+	if (rxq->rx_desc_count) {
+		dev_printk(KERN_ERR, &mp->dev->dev,
+			   "error freeing rx ring -- %d skbs stuck\n",
+			   rxq->rx_desc_count);
+	}
+
+	if (rxq->index == mp->rxq_primary &&
+	    rxq->rx_desc_area_size <= mp->rx_desc_sram_size)
+		iounmap(rxq->rx_desc_area);
+	else
+		dma_free_coherent(NULL, rxq->rx_desc_area_size,
+				  rxq->rx_desc_area, rxq->rx_desc_dma);
+
+	kfree(rxq->rx_skb);
+}
+
+static int txq_init(struct mv643xx_eth_private *mp, int index)
+{
+	struct tx_queue *txq = mp->txq + index;
+	struct tx_desc *tx_desc;
+	int size;
+	int i;
+
+	txq->index = index;
+
+	txq->tx_ring_size = mp->default_tx_ring_size;
+
+	txq->tx_desc_count = 0;
+	txq->tx_curr_desc = 0;
+	txq->tx_used_desc = 0;
+
+	size = txq->tx_ring_size * sizeof(struct tx_desc);
+
+	if (index == mp->txq_primary && size <= mp->tx_desc_sram_size) {
+		txq->tx_desc_area = ioremap(mp->tx_desc_sram_addr,
+						mp->tx_desc_sram_size);
+		txq->tx_desc_dma = mp->tx_desc_sram_addr;
+	} else {
+		txq->tx_desc_area = dma_alloc_coherent(NULL, size,
+							&txq->tx_desc_dma,
+							GFP_KERNEL);
+	}
+
+	if (txq->tx_desc_area == NULL) {
+		dev_printk(KERN_ERR, &mp->dev->dev,
+			   "can't allocate tx ring (%d bytes)\n", size);
 		goto out;
+	}
+	memset(txq->tx_desc_area, 0, size);
 
-	p = dev->dev_addr;
-	printk(KERN_NOTICE
-		"%s: port %d with MAC address %s\n",
-		dev->name, port_num, print_mac(mac, p));
+	txq->tx_desc_area_size = size;
+	txq->tx_skb = kmalloc(txq->tx_ring_size * sizeof(*txq->tx_skb),
+								GFP_KERNEL);
+	if (txq->tx_skb == NULL) {
+		dev_printk(KERN_ERR, &mp->dev->dev,
+			   "can't allocate tx skb ring\n");
+		goto out_free;
+	}
 
-	if (dev->features & NETIF_F_SG)
-		printk(KERN_NOTICE "%s: Scatter Gather Enabled\n", dev->name);
+	tx_desc = (struct tx_desc *)txq->tx_desc_area;
+	for (i = 0; i < txq->tx_ring_size; i++) {
+		int nexti = (i + 1) % txq->tx_ring_size;
+		tx_desc[i].next_desc_ptr = txq->tx_desc_dma +
+					nexti * sizeof(struct tx_desc);
+	}
 
-	if (dev->features & NETIF_F_IP_CSUM)
-		printk(KERN_NOTICE "%s: TX TCP/IP Checksumming Supported\n",
-								dev->name);
+	return 0;
+
+
+out_free:
+	if (index == mp->txq_primary && size <= mp->tx_desc_sram_size)
+		iounmap(txq->tx_desc_area);
+	else
+		dma_free_coherent(NULL, size,
+				  txq->tx_desc_area,
+				  txq->tx_desc_dma);
+
+out:
+	return -ENOMEM;
+}
+
+static void txq_reclaim(struct tx_queue *txq, int force)
+{
+	struct mv643xx_eth_private *mp = txq_to_mp(txq);
+	unsigned long flags;
+
+	spin_lock_irqsave(&mp->lock, flags);
+	while (txq->tx_desc_count > 0) {
+		int tx_index;
+		struct tx_desc *desc;
+		u32 cmd_sts;
+		struct sk_buff *skb;
+		dma_addr_t addr;
+		int count;
+
+		tx_index = txq->tx_used_desc;
+		desc = &txq->tx_desc_area[tx_index];
+		cmd_sts = desc->cmd_sts;
+
+		if (!force && (cmd_sts & BUFFER_OWNED_BY_DMA))
+			break;
+
+		txq->tx_used_desc = (tx_index + 1) % txq->tx_ring_size;
+		txq->tx_desc_count--;
+
+		addr = desc->buf_ptr;
+		count = desc->byte_cnt;
+		skb = txq->tx_skb[tx_index];
+		txq->tx_skb[tx_index] = NULL;
+
+		if (cmd_sts & ERROR_SUMMARY) {
+			dev_printk(KERN_INFO, &mp->dev->dev, "tx error\n");
+			mp->dev->stats.tx_errors++;
+		}
+
+		/*
+		 * Drop mp->lock while we free the skb.
+		 */
+		spin_unlock_irqrestore(&mp->lock, flags);
 
-#ifdef MV643XX_CHECKSUM_OFFLOAD_TX
-	printk(KERN_NOTICE "%s: RX TCP/UDP Checksum Offload ON \n", dev->name);
+		if (cmd_sts & TX_FIRST_DESC)
+			dma_unmap_single(NULL, addr, count, DMA_TO_DEVICE);
+		else
+			dma_unmap_page(NULL, addr, count, DMA_TO_DEVICE);
+
+		if (skb)
+			dev_kfree_skb_irq(skb);
+
+		spin_lock_irqsave(&mp->lock, flags);
+	}
+	spin_unlock_irqrestore(&mp->lock, flags);
+}
+
+static void txq_deinit(struct tx_queue *txq)
+{
+	struct mv643xx_eth_private *mp = txq_to_mp(txq);
+
+	txq_disable(txq);
+	txq_reclaim(txq, 1);
+
+	BUG_ON(txq->tx_used_desc != txq->tx_curr_desc);
+
+	if (txq->index == mp->txq_primary &&
+	    txq->tx_desc_area_size <= mp->tx_desc_sram_size)
+		iounmap(txq->tx_desc_area);
+	else
+		dma_free_coherent(NULL, txq->tx_desc_area_size,
+				  txq->tx_desc_area, txq->tx_desc_dma);
+
+	kfree(txq->tx_skb);
+}
+
+
+/* netdev ops and related ***************************************************/
+static void update_pscr(struct mv643xx_eth_private *mp, int speed, int duplex)
+{
+	u32 pscr_o;
+	u32 pscr_n;
+
+	pscr_o = rdl(mp, PORT_SERIAL_CONTROL(mp->port_num));
+
+	/* clear speed, duplex and rx buffer size fields */
+	pscr_n = pscr_o & ~(SET_MII_SPEED_TO_100   |
+			    SET_GMII_SPEED_TO_1000 |
+			    SET_FULL_DUPLEX_MODE   |
+			    MAX_RX_PACKET_MASK);
+
+	if (speed == SPEED_1000) {
+		pscr_n |= SET_GMII_SPEED_TO_1000 | MAX_RX_PACKET_9700BYTE;
+	} else {
+		if (speed == SPEED_100)
+			pscr_n |= SET_MII_SPEED_TO_100;
+		pscr_n |= MAX_RX_PACKET_1522BYTE;
+	}
+
+	if (duplex == DUPLEX_FULL)
+		pscr_n |= SET_FULL_DUPLEX_MODE;
+
+	if (pscr_n != pscr_o) {
+		if ((pscr_o & SERIAL_PORT_ENABLE) == 0)
+			wrl(mp, PORT_SERIAL_CONTROL(mp->port_num), pscr_n);
+		else {
+			int i;
+
+			for (i = 0; i < 8; i++)
+				if (mp->txq_mask & (1 << i))
+					txq_disable(mp->txq + i);
+
+			pscr_o &= ~SERIAL_PORT_ENABLE;
+			wrl(mp, PORT_SERIAL_CONTROL(mp->port_num), pscr_o);
+			wrl(mp, PORT_SERIAL_CONTROL(mp->port_num), pscr_n);
+			wrl(mp, PORT_SERIAL_CONTROL(mp->port_num), pscr_n);
+
+			for (i = 0; i < 8; i++)
+				if (mp->txq_mask & (1 << i))
+					txq_enable(mp->txq + i);
+		}
+	}
+}
+
+static irqreturn_t mv643xx_eth_irq(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	u32 int_cause;
+	u32 int_cause_ext;
+	u32 txq_active;
+
+	int_cause = rdl(mp, INT_CAUSE(mp->port_num)) &
+			(INT_TX_END | INT_RX | INT_EXT);
+	if (int_cause == 0)
+		return IRQ_NONE;
+
+	int_cause_ext = 0;
+	if (int_cause & INT_EXT) {
+		int_cause_ext = rdl(mp, INT_CAUSE_EXT(mp->port_num))
+				& (INT_EXT_LINK | INT_EXT_PHY | INT_EXT_TX);
+		wrl(mp, INT_CAUSE_EXT(mp->port_num), ~int_cause_ext);
+	}
+
+	if (int_cause_ext & (INT_EXT_PHY | INT_EXT_LINK)) {
+		if (mp->phy_addr == -1 || mii_link_ok(&mp->mii)) {
+			int i;
+
+			if (mp->phy_addr != -1) {
+				struct ethtool_cmd cmd;
+
+				mii_ethtool_gset(&mp->mii, &cmd);
+				update_pscr(mp, cmd.speed, cmd.duplex);
+			}
+
+			for (i = 0; i < 8; i++)
+				if (mp->txq_mask & (1 << i))
+					txq_enable(mp->txq + i);
+
+			if (!netif_carrier_ok(dev)) {
+				netif_carrier_on(dev);
+				__txq_maybe_wake(mp->txq + mp->txq_primary);
+			}
+		} else if (netif_carrier_ok(dev)) {
+			netif_stop_queue(dev);
+			netif_carrier_off(dev);
+		}
+	}
+
+	/*
+	 * RxBuffer or RxError set for any of the 8 queues?
+	 */
+#ifdef MV643XX_ETH_NAPI
+	if (int_cause & INT_RX) {
+		wrl(mp, INT_MASK(mp->port_num), 0x00000000);
+		rdl(mp, INT_MASK(mp->port_num));
+
+		netif_rx_schedule(dev, &mp->napi);
+	}
+#else
+	if (int_cause & INT_RX) {
+		int i;
+
+		for (i = 7; i >= 0; i--)
+			if (mp->rxq_mask & (1 << i))
+				rxq_process(mp->rxq + i, INT_MAX);
+	}
 #endif
 
-#ifdef MV643XX_COAL
-	printk(KERN_NOTICE "%s: TX and RX Interrupt Coalescing ON \n",
-								dev->name);
-#endif
+	txq_active = rdl(mp, TXQ_COMMAND(mp->port_num));
+
+	/*
+	 * TxBuffer or TxError set for any of the 8 queues?
+	 */
+	if (int_cause_ext & INT_EXT_TX) {
+		int i;
+
+		for (i = 0; i < 8; i++)
+			if (mp->txq_mask & (1 << i))
+				txq_reclaim(mp->txq + i, 0);
+	}
+
+	/*
+	 * Any TxEnd interrupts?
+	 */
+	if (int_cause & INT_TX_END) {
+		int i;
+
+		wrl(mp, INT_CAUSE(mp->port_num), ~(int_cause & INT_TX_END));
+		for (i = 0; i < 8; i++) {
+			struct tx_queue *txq = mp->txq + i;
+			if (txq->tx_desc_count && !((txq_active >> i) & 1))
+				txq_enable(txq);
+		}
+	}
+
+	/*
+	 * Enough space again in the primary TX queue for a full packet?
+	 */
+	if (int_cause_ext & INT_EXT_TX) {
+		struct tx_queue *txq = mp->txq + mp->txq_primary;
+		__txq_maybe_wake(txq);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void phy_reset(struct mv643xx_eth_private *mp)
+{
+	unsigned int data;
+
+	smi_reg_read(mp, mp->phy_addr, 0, &data);
+	data |= 0x8000;
+	smi_reg_write(mp, mp->phy_addr, 0, data);
+
+	do {
+		udelay(1);
+		smi_reg_read(mp, mp->phy_addr, 0, &data);
+	} while (data & 0x8000);
+}
+
+static void port_start(struct mv643xx_eth_private *mp)
+{
+	u32 pscr;
+	int i;
+
+	/*
+	 * Configure basic link parameters.
+	 */
+	pscr = rdl(mp, PORT_SERIAL_CONTROL(mp->port_num));
+	pscr &= ~(SERIAL_PORT_ENABLE | FORCE_LINK_PASS);
+	wrl(mp, PORT_SERIAL_CONTROL(mp->port_num), pscr);
+	pscr |= DISABLE_AUTO_NEG_FOR_FLOW_CTRL |
+		DISABLE_AUTO_NEG_SPEED_GMII    |
+		DISABLE_AUTO_NEG_FOR_DUPLEX    |
+		DO_NOT_FORCE_LINK_FAIL	       |
+		SERIAL_PORT_CONTROL_RESERVED;
+	wrl(mp, PORT_SERIAL_CONTROL(mp->port_num), pscr);
+	pscr |= SERIAL_PORT_ENABLE;
+	wrl(mp, PORT_SERIAL_CONTROL(mp->port_num), pscr);
+
+	wrl(mp, SDMA_CONFIG(mp->port_num), PORT_SDMA_CONFIG_DEFAULT_VALUE);
+
+	/*
+	 * Perform PHY reset, if there is a PHY.
+	 */
+	if (mp->phy_addr != -1) {
+		struct ethtool_cmd cmd;
+
+		mv643xx_eth_get_settings(mp->dev, &cmd);
+		phy_reset(mp);
+		mv643xx_eth_set_settings(mp->dev, &cmd);
+	}
+
+	/*
+	 * Configure TX path and queues.
+	 */
+	tx_set_rate(mp, 1000000000, 16777216);
+	for (i = 0; i < 8; i++) {
+		struct tx_queue *txq = mp->txq + i;
+		int off = TXQ_CURRENT_DESC_PTR(mp->port_num, i);
+		u32 addr;
+
+		if ((mp->txq_mask & (1 << i)) == 0)
+			continue;
+
+		addr = (u32)txq->tx_desc_dma;
+		addr += txq->tx_curr_desc * sizeof(struct tx_desc);
+		wrl(mp, off, addr);
+
+		txq_set_rate(txq, 1000000000, 16777216);
+		txq_set_fixed_prio_mode(txq);
+	}
+
+	/*
+	 * Add configured unicast address to address filter table.
+	 */
+	uc_addr_set(mp, mp->dev->dev_addr);
+
+	/*
+	 * Receive all unmatched unicast, TCP, UDP, BPDU and broadcast
+	 * frames to RX queue #0.
+	 */
+	wrl(mp, PORT_CONFIG(mp->port_num), 0x00000000);
 
-#ifdef MV643XX_NAPI
-	printk(KERN_NOTICE "%s: RX NAPI Enabled \n", dev->name);
-#endif
+	/*
+	 * Treat BPDUs as normal multicasts, and disable partition mode.
+	 */
+	wrl(mp, PORT_CONFIG_EXT(mp->port_num), 0x00000000);
 
-	if (mp->tx_sram_size > 0)
-		printk(KERN_NOTICE "%s: Using SRAM\n", dev->name);
+	/*
+	 * Enable the receive queues.
+	 */
+	for (i = 0; i < 8; i++) {
+		struct rx_queue *rxq = mp->rxq + i;
+		int off = RXQ_CURRENT_DESC_PTR(mp->port_num, i);
+		u32 addr;
 
-	return 0;
+		if ((mp->rxq_mask & (1 << i)) == 0)
+			continue;
 
-out:
-	free_netdev(dev);
+		addr = (u32)rxq->rx_desc_dma;
+		addr += rxq->rx_curr_desc * sizeof(struct rx_desc);
+		wrl(mp, off, addr);
 
-	return err;
+		rxq_enable(rxq);
+	}
 }
 
-static int mv643xx_eth_remove(struct platform_device *pdev)
+static void set_rx_coal(struct mv643xx_eth_private *mp, unsigned int delay)
 {
-	struct net_device *dev = platform_get_drvdata(pdev);
+	unsigned int coal = ((mp->shared->t_clk / 1000000) * delay) / 64;
+	u32 val;
 
-	unregister_netdev(dev);
-	flush_scheduled_work();
+	val = rdl(mp, SDMA_CONFIG(mp->port_num));
+	if (mp->shared->extended_rx_coal_limit) {
+		if (coal > 0xffff)
+			coal = 0xffff;
+		val &= ~0x023fff80;
+		val |= (coal & 0x8000) << 10;
+		val |= (coal & 0x7fff) << 7;
+	} else {
+		if (coal > 0x3fff)
+			coal = 0x3fff;
+		val &= ~0x003fff00;
+		val |= (coal & 0x3fff) << 8;
+	}
+	wrl(mp, SDMA_CONFIG(mp->port_num), val);
+}
 
-	free_netdev(dev);
-	platform_set_drvdata(pdev, NULL);
-	return 0;
+static void set_tx_coal(struct mv643xx_eth_private *mp, unsigned int delay)
+{
+	unsigned int coal = ((mp->shared->t_clk / 1000000) * delay) / 64;
+
+	if (coal > 0x3fff)
+		coal = 0x3fff;
+	wrl(mp, TX_FIFO_URGENT_THRESHOLD(mp->port_num), (coal & 0x3fff) << 4);
 }
 
-static void mv643xx_eth_conf_mbus_windows(struct mv643xx_shared_private *msp,
-					  struct mbus_dram_target_info *dram)
+static int mv643xx_eth_open(struct net_device *dev)
 {
-	void __iomem *base = msp->eth_base;
-	u32 win_enable;
-	u32 win_protect;
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	int err;
 	int i;
 
-	for (i = 0; i < 6; i++) {
-		writel(0, base + WINDOW_BASE(i));
-		writel(0, base + WINDOW_SIZE(i));
-		if (i < 4)
-			writel(0, base + WINDOW_REMAP_HIGH(i));
+	wrl(mp, INT_CAUSE(mp->port_num), 0);
+	wrl(mp, INT_CAUSE_EXT(mp->port_num), 0);
+	rdl(mp, INT_CAUSE_EXT(mp->port_num));
+
+	err = request_irq(dev->irq, mv643xx_eth_irq,
+			  IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+			  dev->name, dev);
+	if (err) {
+		dev_printk(KERN_ERR, &dev->dev, "can't assign irq\n");
+		return -EAGAIN;
 	}
 
-	win_enable = 0x3f;
-	win_protect = 0;
-
-	for (i = 0; i < dram->num_cs; i++) {
-		struct mbus_dram_window *cs = dram->cs + i;
+	init_mac_tables(mp);
 
-		writel((cs->base & 0xffff0000) |
-			(cs->mbus_attr << 8) |
-			dram->mbus_dram_target_id, base + WINDOW_BASE(i));
-		writel((cs->size - 1) & 0xffff0000, base + WINDOW_SIZE(i));
+	for (i = 0; i < 8; i++) {
+		if ((mp->rxq_mask & (1 << i)) == 0)
+			continue;
+
+		err = rxq_init(mp, i);
+		if (err) {
+			while (--i >= 0)
+				if (mp->rxq_mask & (1 << i))
+					rxq_deinit(mp->rxq + i);
+			goto out;
+		}
 
-		win_enable &= ~(1 << i);
-		win_protect |= 3 << (2 * i);
+		rxq_refill(mp->rxq + i);
 	}
 
-	writel(win_enable, base + WINDOW_BAR_ENABLE);
-	msp->win_protect = win_protect;
-}
-
-static int mv643xx_eth_shared_probe(struct platform_device *pdev)
-{
-	static int mv643xx_version_printed = 0;
-	struct mv643xx_eth_shared_platform_data *pd = pdev->dev.platform_data;
-	struct mv643xx_shared_private *msp;
-	struct resource *res;
-	int ret;
-
-	if (!mv643xx_version_printed++)
-		printk(KERN_NOTICE "MV-643xx 10/100/1000 Ethernet Driver\n");
-
-	ret = -EINVAL;
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (res == NULL)
-		goto out;
+	for (i = 0; i < 8; i++) {
+		if ((mp->txq_mask & (1 << i)) == 0)
+			continue;
+
+		err = txq_init(mp, i);
+		if (err) {
+			while (--i >= 0)
+				if (mp->txq_mask & (1 << i))
+					txq_deinit(mp->txq + i);
+			goto out_free;
+		}
+	}
 
-	ret = -ENOMEM;
-	msp = kmalloc(sizeof(*msp), GFP_KERNEL);
-	if (msp == NULL)
-		goto out;
-	memset(msp, 0, sizeof(*msp));
+#ifdef MV643XX_ETH_NAPI
+	napi_enable(&mp->napi);
+#endif
 
-	msp->eth_base = ioremap(res->start, res->end - res->start + 1);
-	if (msp->eth_base == NULL)
-		goto out_free;
+	port_start(mp);
 
-	spin_lock_init(&msp->phy_lock);
-	msp->t_clk = (pd != NULL && pd->t_clk != 0) ? pd->t_clk : 133000000;
+	set_rx_coal(mp, 0);
+	set_tx_coal(mp, 0);
 
-	platform_set_drvdata(pdev, msp);
+	wrl(mp, INT_MASK_EXT(mp->port_num),
+	    INT_EXT_LINK | INT_EXT_PHY | INT_EXT_TX);
 
-	/*
-	 * (Re-)program MBUS remapping windows if we are asked to.
-	 */
-	if (pd != NULL && pd->dram != NULL)
-		mv643xx_eth_conf_mbus_windows(msp, pd->dram);
+	wrl(mp, INT_MASK(mp->port_num), INT_TX_END | INT_RX | INT_EXT);
 
 	return 0;
 
+
 out_free:
-	kfree(msp);
+	for (i = 0; i < 8; i++)
+		if (mp->rxq_mask & (1 << i))
+			rxq_deinit(mp->rxq + i);
 out:
-	return ret;
+	free_irq(dev->irq, dev);
+
+	return err;
 }
 
-static int mv643xx_eth_shared_remove(struct platform_device *pdev)
+static void port_reset(struct mv643xx_eth_private *mp)
 {
-	struct mv643xx_shared_private *msp = platform_get_drvdata(pdev);
+	unsigned int data;
+	int i;
 
-	iounmap(msp->eth_base);
-	kfree(msp);
+	for (i = 0; i < 8; i++) {
+		if (mp->rxq_mask & (1 << i))
+			rxq_disable(mp->rxq + i);
+		if (mp->txq_mask & (1 << i))
+			txq_disable(mp->txq + i);
+	}
+	while (!(rdl(mp, PORT_STATUS(mp->port_num)) & TX_FIFO_EMPTY))
+		udelay(10);
 
-	return 0;
+	/* Reset the Enable bit in the Configuration Register */
+	data = rdl(mp, PORT_SERIAL_CONTROL(mp->port_num));
+	data &= ~(SERIAL_PORT_ENABLE		|
+		  DO_NOT_FORCE_LINK_FAIL	|
+		  FORCE_LINK_PASS);
+	wrl(mp, PORT_SERIAL_CONTROL(mp->port_num), data);
 }
 
-static void mv643xx_eth_shutdown(struct platform_device *pdev)
+static int mv643xx_eth_stop(struct net_device *dev)
 {
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct mv643xx_private *mp = netdev_priv(dev);
-	unsigned int port_num = mp->port_num;
-
-	/* Mask all interrupts on ethernet port */
-	wrl(mp, INTERRUPT_MASK_REG(port_num), 0);
-	rdl(mp, INTERRUPT_MASK_REG(port_num));
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	int i;
 
-	eth_port_reset(mp);
-}
+	wrl(mp, INT_MASK(mp->port_num), 0x00000000);
+	rdl(mp, INT_MASK(mp->port_num));
 
-static struct platform_driver mv643xx_eth_driver = {
-	.probe = mv643xx_eth_probe,
-	.remove = mv643xx_eth_remove,
-	.shutdown = mv643xx_eth_shutdown,
-	.driver = {
-		.name = MV643XX_ETH_NAME,
-		.owner	= THIS_MODULE,
-	},
-};
+#ifdef MV643XX_ETH_NAPI
+	napi_disable(&mp->napi);
+#endif
+	netif_carrier_off(dev);
+	netif_stop_queue(dev);
 
-static struct platform_driver mv643xx_eth_shared_driver = {
-	.probe = mv643xx_eth_shared_probe,
-	.remove = mv643xx_eth_shared_remove,
-	.driver = {
-		.name = MV643XX_ETH_SHARED_NAME,
-		.owner	= THIS_MODULE,
-	},
-};
+	free_irq(dev->irq, dev);
 
-/*
- * mv643xx_init_module
- *
- * Registers the network drivers into the Linux kernel
- *
- * Input :	N/A
- *
- * Output :	N/A
- */
-static int __init mv643xx_init_module(void)
-{
-	int rc;
+	port_reset(mp);
+	mib_counters_update(mp);
 
-	rc = platform_driver_register(&mv643xx_eth_shared_driver);
-	if (!rc) {
-		rc = platform_driver_register(&mv643xx_eth_driver);
-		if (rc)
-			platform_driver_unregister(&mv643xx_eth_shared_driver);
+	for (i = 0; i < 8; i++) {
+		if (mp->rxq_mask & (1 << i))
+			rxq_deinit(mp->rxq + i);
+		if (mp->txq_mask & (1 << i))
+			txq_deinit(mp->txq + i);
 	}
-	return rc;
-}
 
-/*
- * mv643xx_cleanup_module
- *
- * Registers the network drivers into the Linux kernel
- *
- * Input :	N/A
- *
- * Output :	N/A
- */
-static void __exit mv643xx_cleanup_module(void)
-{
-	platform_driver_unregister(&mv643xx_eth_driver);
-	platform_driver_unregister(&mv643xx_eth_shared_driver);
+	return 0;
 }
 
-module_init(mv643xx_init_module);
-module_exit(mv643xx_cleanup_module);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR(	"Rabeeh Khoury, Assaf Hoffman, Matthew Dharm, Manish Lachwani"
-		" and Dale Farnsworth");
-MODULE_DESCRIPTION("Ethernet driver for Marvell MV643XX");
-MODULE_ALIAS("platform:" MV643XX_ETH_NAME);
-MODULE_ALIAS("platform:" MV643XX_ETH_SHARED_NAME);
-
-/*
- * The second part is the low level driver of the gigE ethernet ports.
- */
-
-/*
- * Marvell's Gigabit Ethernet controller low level driver
- *
- * DESCRIPTION:
- *	This file introduce low level API to Marvell's Gigabit Ethernet
- *		controller. This Gigabit Ethernet Controller driver API controls
- *		1) Operations (i.e. port init, start, reset etc').
- *		2) Data flow (i.e. port send, receive etc').
- *		Each Gigabit Ethernet port is controlled via
- *		struct mv643xx_private.
- *		This struct includes user configuration information as well as
- *		driver internal data needed for its operations.
- *
- *		Supported Features:
- *		- This low level driver is OS independent. Allocating memory for
- *		  the descriptor rings and buffers are not within the scope of
- *		  this driver.
- *		- The user is free from Rx/Tx queue managing.
- *		- This low level driver introduce functionality API that enable
- *		  the to operate Marvell's Gigabit Ethernet Controller in a
- *		  convenient way.
- *		- Simple Gigabit Ethernet port operation API.
- *		- Simple Gigabit Ethernet port data flow API.
- *		- Data flow and operation API support per queue functionality.
- *		- Support cached descriptors for better performance.
- *		- Enable access to all four DRAM banks and internal SRAM memory
- *		  spaces.
- *		- PHY access and control API.
- *		- Port control register configuration API.
- *		- Full control over Unicast and Multicast MAC configurations.
- *
- *		Operation flow:
- *
- *		Initialization phase
- *		This phase complete the initialization of the the
- *		mv643xx_private struct.
- *		User information regarding port configuration has to be set
- *		prior to calling the port initialization routine.
- *
- *		In this phase any port Tx/Rx activity is halted, MIB counters
- *		are cleared, PHY address is set according to user parameter and
- *		access to DRAM and internal SRAM memory spaces.
- *
- *		Driver ring initialization
- *		Allocating memory for the descriptor rings and buffers is not
- *		within the scope of this driver. Thus, the user is required to
- *		allocate memory for the descriptors ring and buffers. Those
- *		memory parameters are used by the Rx and Tx ring initialization
- *		routines in order to curve the descriptor linked list in a form
- *		of a ring.
- *		Note: Pay special attention to alignment issues when using
- *		cached descriptors/buffers. In this phase the driver store
- *		information in the mv643xx_private struct regarding each queue
- *		ring.
- *
- *		Driver start
- *		This phase prepares the Ethernet port for Rx and Tx activity.
- *		It uses the information stored in the mv643xx_private struct to
- *		initialize the various port registers.
- *
- *		Data flow:
- *		All packet references to/from the driver are done using
- *		struct pkt_info.
- *		This struct is a unified struct used with Rx and Tx operations.
- *		This way the user is not required to be familiar with neither
- *		Tx nor Rx descriptors structures.
- *		The driver's descriptors rings are management by indexes.
- *		Those indexes controls the ring resources and used to indicate
- *		a SW resource error:
- *		'current'
- *		This index points to the current available resource for use. For
- *		example in Rx process this index will point to the descriptor
- *		that will be passed to the user upon calling the receive
- *		routine.  In Tx process, this index will point to the descriptor
- *		that will be assigned with the user packet info and transmitted.
- *		'used'
- *		This index points to the descriptor that need to restore its
- *		resources. For example in Rx process, using the Rx buffer return
- *		API will attach the buffer returned in packet info to the
- *		descriptor pointed by 'used'. In Tx process, using the Tx
- *		descriptor return will merely return the user packet info with
- *		the command status of the transmitted buffer pointed by the
- *		'used' index. Nevertheless, it is essential to use this routine
- *		to update the 'used' index.
- *		'first'
- *		This index supports Tx Scatter-Gather. It points to the first
- *		descriptor of a packet assembled of multiple buffers. For
- *		example when in middle of Such packet we have a Tx resource
- *		error the 'curr' index get the value of 'first' to indicate
- *		that the ring returned to its state before trying to transmit
- *		this packet.
- *
- *		Receive operation:
- *		The eth_port_receive API set the packet information struct,
- *		passed by the caller, with received information from the
- *		'current' SDMA descriptor.
- *		It is the user responsibility to return this resource back
- *		to the Rx descriptor ring to enable the reuse of this source.
- *		Return Rx resource is done using the eth_rx_return_buff API.
- *
- *	Prior to calling the initialization routine eth_port_init() the user
- *	must set the following fields under mv643xx_private struct:
- *	port_num		User Ethernet port number.
- *	port_config		User port configuration value.
- *	port_config_extend	User port config extend value.
- *	port_sdma_config	User port SDMA config value.
- *	port_serial_control	User port serial control value.
- *
- *		This driver data flow is done using the struct pkt_info which
- *		is a unified struct for Rx and Tx operations:
- *
- *		byte_cnt	Tx/Rx descriptor buffer byte count.
- *		l4i_chk		CPU provided TCP Checksum. For Tx operation
- *				only.
- *		cmd_sts		Tx/Rx descriptor command status.
- *		buf_ptr		Tx/Rx descriptor buffer pointer.
- *		return_info	Tx/Rx user resource return information.
- */
-
-/* Ethernet Port routines */
-static void eth_port_set_filter_table_entry(struct mv643xx_private *mp,
-					    int table, unsigned char entry);
-
-/*
- * eth_port_init - Initialize the Ethernet port driver
- *
- * DESCRIPTION:
- *	This function prepares the ethernet port to start its activity:
- *	1) Completes the ethernet port driver struct initialization toward port
- *		start routine.
- *	2) Resets the device to a quiescent state in case of warm reboot.
- *	3) Enable SDMA access to all four DRAM banks as well as internal SRAM.
- *	4) Clean MAC tables. The reset status of those tables is unknown.
- *	5) Set PHY address.
- *	Note: Call this routine prior to eth_port_start routine and after
- *	setting user values in the user fields of Ethernet port control
- *	struct.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet port control struct
- *
- * OUTPUT:
- *	See description.
- *
- * RETURN:
- *	None.
- */
-static void eth_port_init(struct mv643xx_private *mp)
+static int mv643xx_eth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
-	mp->rx_resource_err = 0;
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
 
-	eth_port_reset(mp);
+	if (mp->phy_addr != -1)
+		return generic_mii_ioctl(&mp->mii, if_mii(ifr), cmd, NULL);
 
-	eth_port_init_mac_tables(mp);
+	return -EOPNOTSUPP;
 }
 
-/*
- * eth_port_start - Start the Ethernet port activity.
- *
- * DESCRIPTION:
- *	This routine prepares the Ethernet port for Rx and Tx activity:
- *	 1. Initialize Tx and Rx Current Descriptor Pointer for each queue that
- *	    has been initialized a descriptor's ring (using
- *	    ether_init_tx_desc_ring for Tx and ether_init_rx_desc_ring for Rx)
- *	 2. Initialize and enable the Ethernet configuration port by writing to
- *	    the port's configuration and command registers.
- *	 3. Initialize and enable the SDMA by writing to the SDMA's
- *	    configuration and command registers.  After completing these steps,
- *	    the ethernet port SDMA can starts to perform Rx and Tx activities.
- *
- *	Note: Each Rx and Tx queue descriptor's list must be initialized prior
- *	to calling this function (use ether_init_tx_desc_ring for Tx queues
- *	and ether_init_rx_desc_ring for Rx queues).
- *
- * INPUT:
- *	dev - a pointer to the required interface
- *
- * OUTPUT:
- *	Ethernet port is ready to receive and transmit.
- *
- * RETURN:
- *	None.
- */
-static void eth_port_start(struct net_device *dev)
+static int mv643xx_eth_change_mtu(struct net_device *dev, int new_mtu)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-	unsigned int port_num = mp->port_num;
-	int tx_curr_desc, rx_curr_desc;
-	u32 pscr;
-	struct ethtool_cmd ethtool_cmd;
-
-	/* Assignment of Tx CTRP of given queue */
-	tx_curr_desc = mp->tx_curr_desc_q;
-	wrl(mp, TX_CURRENT_QUEUE_DESC_PTR_0(port_num),
-		(u32)((struct eth_tx_desc *)mp->tx_desc_dma + tx_curr_desc));
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
 
-	/* Assignment of Rx CRDP of given queue */
-	rx_curr_desc = mp->rx_curr_desc_q;
-	wrl(mp, RX_CURRENT_QUEUE_DESC_PTR_0(port_num),
-		(u32)((struct eth_rx_desc *)mp->rx_desc_dma + rx_curr_desc));
-
-	/* Add the assigned Ethernet address to the port's address table */
-	eth_port_uc_addr_set(mp, dev->dev_addr);
+	if (new_mtu < 64 || new_mtu > 9500)
+		return -EINVAL;
 
-	/* Assign port configuration and command. */
-	wrl(mp, PORT_CONFIG_REG(port_num),
-			  PORT_CONFIG_DEFAULT_VALUE);
+	dev->mtu = new_mtu;
+	tx_set_rate(mp, 1000000000, 16777216);
 
-	wrl(mp, PORT_CONFIG_EXTEND_REG(port_num),
-			  PORT_CONFIG_EXTEND_DEFAULT_VALUE);
+	if (!netif_running(dev))
+		return 0;
 
-	pscr = rdl(mp, PORT_SERIAL_CONTROL_REG(port_num));
+	/*
+	 * Stop and then re-open the interface. This will allocate RX
+	 * skbs of the new MTU.
+	 * There is a possible danger that the open will not succeed,
+	 * due to memory being full.
+	 */
+	mv643xx_eth_stop(dev);
+	if (mv643xx_eth_open(dev)) {
+		dev_printk(KERN_ERR, &dev->dev,
+			   "fatal error on re-opening device after "
+			   "MTU change\n");
+	}
 
-	pscr &= ~(SERIAL_PORT_ENABLE | FORCE_LINK_PASS);
-	wrl(mp, PORT_SERIAL_CONTROL_REG(port_num), pscr);
+	return 0;
+}
 
-	pscr |= DISABLE_AUTO_NEG_FOR_FLOW_CTRL |
-		DISABLE_AUTO_NEG_SPEED_GMII    |
-		DISABLE_AUTO_NEG_FOR_DUPLX     |
-		DO_NOT_FORCE_LINK_FAIL	   |
-		SERIAL_PORT_CONTROL_RESERVED;
+static void tx_timeout_task(struct work_struct *ugly)
+{
+	struct mv643xx_eth_private *mp;
 
-	wrl(mp, PORT_SERIAL_CONTROL_REG(port_num), pscr);
+	mp = container_of(ugly, struct mv643xx_eth_private, tx_timeout_task);
+	if (netif_running(mp->dev)) {
+		netif_stop_queue(mp->dev);
 
-	pscr |= SERIAL_PORT_ENABLE;
-	wrl(mp, PORT_SERIAL_CONTROL_REG(port_num), pscr);
+		port_reset(mp);
+		port_start(mp);
 
-	/* Assign port SDMA configuration */
-	wrl(mp, SDMA_CONFIG_REG(port_num),
-			  PORT_SDMA_CONFIG_DEFAULT_VALUE);
-
-	/* Enable port Rx. */
-	mv643xx_eth_port_enable_rx(mp, ETH_RX_QUEUES_ENABLED);
-
-	/* Disable port bandwidth limits by clearing MTU register */
-	wrl(mp, MAXIMUM_TRANSMIT_UNIT(port_num), 0);
-
-	/* save phy settings across reset */
-	mv643xx_get_settings(dev, &ethtool_cmd);
-	ethernet_phy_reset(mp);
-	mv643xx_set_settings(dev, &ethtool_cmd);
+		__txq_maybe_wake(mp->txq + mp->txq_primary);
+	}
 }
 
-/*
- * eth_port_uc_addr_set - Write a MAC address into the port's hw registers
- */
-static void eth_port_uc_addr_set(struct mv643xx_private *mp,
-				 unsigned char *p_addr)
+static void mv643xx_eth_tx_timeout(struct net_device *dev)
 {
-	unsigned int port_num = mp->port_num;
-	unsigned int mac_h;
-	unsigned int mac_l;
-	int table;
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
 
-	mac_l = (p_addr[4] << 8) | (p_addr[5]);
-	mac_h = (p_addr[0] << 24) | (p_addr[1] << 16) | (p_addr[2] << 8) |
-							(p_addr[3] << 0);
-
-	wrl(mp, MAC_ADDR_LOW(port_num), mac_l);
-	wrl(mp, MAC_ADDR_HIGH(port_num), mac_h);
-
-	/* Accept frames with this address */
-	table = DA_FILTER_UNICAST_TABLE_BASE(port_num);
-	eth_port_set_filter_table_entry(mp, table, p_addr[5] & 0x0f);
+	dev_printk(KERN_INFO, &dev->dev, "tx timeout\n");
+
+	schedule_work(&mp->tx_timeout_task);
 }
 
-/*
- * eth_port_uc_addr_get - Read the MAC address from the port's hw registers
- */
-static void eth_port_uc_addr_get(struct mv643xx_private *mp,
-				 unsigned char *p_addr)
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void mv643xx_eth_netpoll(struct net_device *dev)
 {
-	unsigned int port_num = mp->port_num;
-	unsigned int mac_h;
-	unsigned int mac_l;
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+
+	wrl(mp, INT_MASK(mp->port_num), 0x00000000);
+	rdl(mp, INT_MASK(mp->port_num));
 
-	mac_h = rdl(mp, MAC_ADDR_HIGH(port_num));
-	mac_l = rdl(mp, MAC_ADDR_LOW(port_num));
+	mv643xx_eth_irq(dev->irq, dev);
 
-	p_addr[0] = (mac_h >> 24) & 0xff;
-	p_addr[1] = (mac_h >> 16) & 0xff;
-	p_addr[2] = (mac_h >> 8) & 0xff;
-	p_addr[3] = mac_h & 0xff;
-	p_addr[4] = (mac_l >> 8) & 0xff;
-	p_addr[5] = mac_l & 0xff;
+	wrl(mp, INT_MASK(mp->port_num), INT_TX_END | INT_RX | INT_CAUSE_EXT);
 }
+#endif
 
-/*
- * The entries in each table are indexed by a hash of a packet's MAC
- * address.  One bit in each entry determines whether the packet is
- * accepted.  There are 4 entries (each 8 bits wide) in each register
- * of the table.  The bits in each entry are defined as follows:
- *	0	Accept=1, Drop=0
- *	3-1	Queue			(ETH_Q0=0)
- *	7-4	Reserved = 0;
- */
-static void eth_port_set_filter_table_entry(struct mv643xx_private *mp,
-					    int table, unsigned char entry)
+static int mv643xx_eth_mdio_read(struct net_device *dev, int addr, int reg)
 {
-	unsigned int table_reg;
-	unsigned int tbl_offset;
-	unsigned int reg_offset;
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	int val;
 
-	tbl_offset = (entry / 4) * 4;	/* Register offset of DA table entry */
-	reg_offset = entry % 4;		/* Entry offset within the register */
+	smi_reg_read(mp, addr, reg, &val);
 
-	/* Set "accepts frame bit" at specified table entry */
-	table_reg = rdl(mp, table + tbl_offset);
-	table_reg |= 0x01 << (8 * reg_offset);
-	wrl(mp, table + tbl_offset, table_reg);
+	return val;
 }
 
-/*
- * eth_port_mc_addr - Multicast address settings.
- *
- * The MV device supports multicast using two tables:
- * 1) Special Multicast Table for MAC addresses of the form
- *    0x01-00-5E-00-00-XX (where XX is between 0x00 and 0x_FF).
- *    The MAC DA[7:0] bits are used as a pointer to the Special Multicast
- *    Table entries in the DA-Filter table.
- * 2) Other Multicast Table for multicast of another type. A CRC-8bit
- *    is used as an index to the Other Multicast Table entries in the
- *    DA-Filter table.  This function calculates the CRC-8bit value.
- * In either case, eth_port_set_filter_table_entry() is then called
- * to set to set the actual table entry.
- */
-static void eth_port_mc_addr(struct mv643xx_private *mp, unsigned char *p_addr)
+static void mv643xx_eth_mdio_write(struct net_device *dev, int addr, int reg, int val)
 {
-	unsigned int port_num = mp->port_num;
-	unsigned int mac_h;
-	unsigned int mac_l;
-	unsigned char crc_result = 0;
-	int table;
-	int mac_array[48];
-	int crc[8];
-	int i;
+	struct mv643xx_eth_private *mp = netdev_priv(dev);
+	smi_reg_write(mp, addr, reg, val);
+}
 
-	if ((p_addr[0] == 0x01) && (p_addr[1] == 0x00) &&
-	    (p_addr[2] == 0x5E) && (p_addr[3] == 0x00) && (p_addr[4] == 0x00)) {
-		table = DA_FILTER_SPECIAL_MULTICAST_TABLE_BASE(port_num);
-		eth_port_set_filter_table_entry(mp, table, p_addr[5]);
-		return;
-	}
 
-	/* Calculate CRC-8 out of the given address */
-	mac_h = (p_addr[0] << 8) | (p_addr[1]);
-	mac_l = (p_addr[2] << 24) | (p_addr[3] << 16) |
-			(p_addr[4] << 8) | (p_addr[5] << 0);
-
-	for (i = 0; i < 32; i++)
-		mac_array[i] = (mac_l >> i) & 0x1;
-	for (i = 32; i < 48; i++)
-		mac_array[i] = (mac_h >> (i - 32)) & 0x1;
-
-	crc[0] = mac_array[45] ^ mac_array[43] ^ mac_array[40] ^ mac_array[39] ^
-		 mac_array[35] ^ mac_array[34] ^ mac_array[31] ^ mac_array[30] ^
-		 mac_array[28] ^ mac_array[23] ^ mac_array[21] ^ mac_array[19] ^
-		 mac_array[18] ^ mac_array[16] ^ mac_array[14] ^ mac_array[12] ^
-		 mac_array[8]  ^ mac_array[7]  ^ mac_array[6]  ^ mac_array[0];
-
-	crc[1] = mac_array[46] ^ mac_array[45] ^ mac_array[44] ^ mac_array[43] ^
-		 mac_array[41] ^ mac_array[39] ^ mac_array[36] ^ mac_array[34] ^
-		 mac_array[32] ^ mac_array[30] ^ mac_array[29] ^ mac_array[28] ^
-		 mac_array[24] ^ mac_array[23] ^ mac_array[22] ^ mac_array[21] ^
-		 mac_array[20] ^ mac_array[18] ^ mac_array[17] ^ mac_array[16] ^
-		 mac_array[15] ^ mac_array[14] ^ mac_array[13] ^ mac_array[12] ^
-		 mac_array[9]  ^ mac_array[6]  ^ mac_array[1]  ^ mac_array[0];
-
-	crc[2] = mac_array[47] ^ mac_array[46] ^ mac_array[44] ^ mac_array[43] ^
-		 mac_array[42] ^ mac_array[39] ^ mac_array[37] ^ mac_array[34] ^
-		 mac_array[33] ^ mac_array[29] ^ mac_array[28] ^ mac_array[25] ^
-		 mac_array[24] ^ mac_array[22] ^ mac_array[17] ^ mac_array[15] ^
-		 mac_array[13] ^ mac_array[12] ^ mac_array[10] ^ mac_array[8]  ^
-		 mac_array[6]  ^ mac_array[2]  ^ mac_array[1]  ^ mac_array[0];
-
-	crc[3] = mac_array[47] ^ mac_array[45] ^ mac_array[44] ^ mac_array[43] ^
-		 mac_array[40] ^ mac_array[38] ^ mac_array[35] ^ mac_array[34] ^
-		 mac_array[30] ^ mac_array[29] ^ mac_array[26] ^ mac_array[25] ^
-		 mac_array[23] ^ mac_array[18] ^ mac_array[16] ^ mac_array[14] ^
-		 mac_array[13] ^ mac_array[11] ^ mac_array[9]  ^ mac_array[7]  ^
-		 mac_array[3]  ^ mac_array[2]  ^ mac_array[1];
-
-	crc[4] = mac_array[46] ^ mac_array[45] ^ mac_array[44] ^ mac_array[41] ^
-		 mac_array[39] ^ mac_array[36] ^ mac_array[35] ^ mac_array[31] ^
-		 mac_array[30] ^ mac_array[27] ^ mac_array[26] ^ mac_array[24] ^
-		 mac_array[19] ^ mac_array[17] ^ mac_array[15] ^ mac_array[14] ^
-		 mac_array[12] ^ mac_array[10] ^ mac_array[8]  ^ mac_array[4]  ^
-		 mac_array[3]  ^ mac_array[2];
-
-	crc[5] = mac_array[47] ^ mac_array[46] ^ mac_array[45] ^ mac_array[42] ^
-		 mac_array[40] ^ mac_array[37] ^ mac_array[36] ^ mac_array[32] ^
-		 mac_array[31] ^ mac_array[28] ^ mac_array[27] ^ mac_array[25] ^
-		 mac_array[20] ^ mac_array[18] ^ mac_array[16] ^ mac_array[15] ^
-		 mac_array[13] ^ mac_array[11] ^ mac_array[9]  ^ mac_array[5]  ^
-		 mac_array[4]  ^ mac_array[3];
-
-	crc[6] = mac_array[47] ^ mac_array[46] ^ mac_array[43] ^ mac_array[41] ^
-		 mac_array[38] ^ mac_array[37] ^ mac_array[33] ^ mac_array[32] ^
-		 mac_array[29] ^ mac_array[28] ^ mac_array[26] ^ mac_array[21] ^
-		 mac_array[19] ^ mac_array[17] ^ mac_array[16] ^ mac_array[14] ^
-		 mac_array[12] ^ mac_array[10] ^ mac_array[6]  ^ mac_array[5]  ^
-		 mac_array[4];
-
-	crc[7] = mac_array[47] ^ mac_array[44] ^ mac_array[42] ^ mac_array[39] ^
-		 mac_array[38] ^ mac_array[34] ^ mac_array[33] ^ mac_array[30] ^
-		 mac_array[29] ^ mac_array[27] ^ mac_array[22] ^ mac_array[20] ^
-		 mac_array[18] ^ mac_array[17] ^ mac_array[15] ^ mac_array[13] ^
-		 mac_array[11] ^ mac_array[7]  ^ mac_array[6]  ^ mac_array[5];
+/* platform glue ************************************************************/
+static void
+mv643xx_eth_conf_mbus_windows(struct mv643xx_eth_shared_private *msp,
+			      struct mbus_dram_target_info *dram)
+{
+	void __iomem *base = msp->base;
+	u32 win_enable;
+	u32 win_protect;
+	int i;
 
-	for (i = 0; i < 8; i++)
-		crc_result = crc_result | (crc[i] << i);
+	for (i = 0; i < 6; i++) {
+		writel(0, base + WINDOW_BASE(i));
+		writel(0, base + WINDOW_SIZE(i));
+		if (i < 4)
+			writel(0, base + WINDOW_REMAP_HIGH(i));
+	}
 
-	table = DA_FILTER_OTHER_MULTICAST_TABLE_BASE(port_num);
-	eth_port_set_filter_table_entry(mp, table, crc_result);
-}
+	win_enable = 0x3f;
+	win_protect = 0;
 
-/*
- * Set the entire multicast list based on dev->mc_list.
- */
-static void eth_port_set_multicast_list(struct net_device *dev)
-{
+	for (i = 0; i < dram->num_cs; i++) {
+		struct mbus_dram_window *cs = dram->cs + i;
 
-	struct dev_mc_list	*mc_list;
-	int			i;
-	int			table_index;
-	struct mv643xx_private	*mp = netdev_priv(dev);
-	unsigned int		eth_port_num = mp->port_num;
-
-	/* If the device is in promiscuous mode or in all multicast mode,
-	 * we will fully populate both multicast tables with accept.
-	 * This is guaranteed to yield a match on all multicast addresses...
-	 */
-	if ((dev->flags & IFF_PROMISC) || (dev->flags & IFF_ALLMULTI)) {
-		for (table_index = 0; table_index <= 0xFC; table_index += 4) {
-			/* Set all entries in DA filter special multicast
-			 * table (Ex_dFSMT)
-			 * Set for ETH_Q0 for now
-			 * Bits
-			 * 0	  Accept=1, Drop=0
-			 * 3-1  Queue	 ETH_Q0=0
-			 * 7-4  Reserved = 0;
-			 */
-			wrl(mp, DA_FILTER_SPECIAL_MULTICAST_TABLE_BASE(eth_port_num) + table_index, 0x01010101);
+		writel((cs->base & 0xffff0000) |
+			(cs->mbus_attr << 8) |
+			dram->mbus_dram_target_id, base + WINDOW_BASE(i));
+		writel((cs->size - 1) & 0xffff0000, base + WINDOW_SIZE(i));
 
-			/* Set all entries in DA filter other multicast
-			 * table (Ex_dFOMT)
-			 * Set for ETH_Q0 for now
-			 * Bits
-			 * 0	  Accept=1, Drop=0
-			 * 3-1  Queue	 ETH_Q0=0
-			 * 7-4  Reserved = 0;
-			 */
-			wrl(mp, DA_FILTER_OTHER_MULTICAST_TABLE_BASE(eth_port_num) + table_index, 0x01010101);
-		}
-		return;
+		win_enable &= ~(1 << i);
+		win_protect |= 3 << (2 * i);
 	}
 
-	/* We will clear out multicast tables every time we get the list.
-	 * Then add the entire new list...
-	 */
-	for (table_index = 0; table_index <= 0xFC; table_index += 4) {
-		/* Clear DA filter special multicast table (Ex_dFSMT) */
-		wrl(mp, DA_FILTER_SPECIAL_MULTICAST_TABLE_BASE
-				(eth_port_num) + table_index, 0);
-
-		/* Clear DA filter other multicast table (Ex_dFOMT) */
-		wrl(mp, DA_FILTER_OTHER_MULTICAST_TABLE_BASE
-				(eth_port_num) + table_index, 0);
-	}
-
-	/* Get pointer to net_device multicast list and add each one... */
-	for (i = 0, mc_list = dev->mc_list;
-			(i < 256) && (mc_list != NULL) && (i < dev->mc_count);
-			i++, mc_list = mc_list->next)
-		if (mc_list->dmi_addrlen == 6)
-			eth_port_mc_addr(mp, mc_list->dmi_addr);
+	writel(win_enable, base + WINDOW_BAR_ENABLE);
+	msp->win_protect = win_protect;
 }
 
-/*
- * eth_port_init_mac_tables - Clear all entrance in the UC, SMC and OMC tables
- *
- * DESCRIPTION:
- *	Go through all the DA filter tables (Unicast, Special Multicast &
- *	Other Multicast) and set each entry to 0.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *
- * OUTPUT:
- *	Multicast and Unicast packets are rejected.
- *
- * RETURN:
- *	None.
- */
-static void eth_port_init_mac_tables(struct mv643xx_private *mp)
+static void infer_hw_params(struct mv643xx_eth_shared_private *msp)
 {
-	unsigned int port_num = mp->port_num;
-	int table_index;
+	/*
+	 * Check whether we have a 14-bit coal limit field in bits
+	 * [21:8], or a 16-bit coal limit in bits [25,21:7] of the
+	 * SDMA config register.
+	 */
+	writel(0x02000000, msp->base + SDMA_CONFIG(0));
+	if (readl(msp->base + SDMA_CONFIG(0)) & 0x02000000)
+		msp->extended_rx_coal_limit = 1;
+	else
+		msp->extended_rx_coal_limit = 0;
 
-	/* Clear DA filter unicast table (Ex_dFUT) */
-	for (table_index = 0; table_index <= 0xC; table_index += 4)
-		wrl(mp, DA_FILTER_UNICAST_TABLE_BASE(port_num) +
-					table_index, 0);
-
-	for (table_index = 0; table_index <= 0xFC; table_index += 4) {
-		/* Clear DA filter special multicast table (Ex_dFSMT) */
-		wrl(mp, DA_FILTER_SPECIAL_MULTICAST_TABLE_BASE(port_num) +
-					table_index, 0);
-		/* Clear DA filter other multicast table (Ex_dFOMT) */
-		wrl(mp, DA_FILTER_OTHER_MULTICAST_TABLE_BASE(port_num) +
-					table_index, 0);
-	}
+	/*
+	 * Check whether the TX rate control registers are in the
+	 * old or the new place.
+	 */
+	writel(1, msp->base + TX_BW_MTU_MOVED(0));
+	if (readl(msp->base + TX_BW_MTU_MOVED(0)) & 1)
+		msp->tx_bw_control_moved = 1;
+	else
+		msp->tx_bw_control_moved = 0;
 }
 
-/*
- * eth_clear_mib_counters - Clear all MIB counters
- *
- * DESCRIPTION:
- *	This function clears all MIB counters of a specific ethernet port.
- *	A read from the MIB counter will reset the counter.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *
- * OUTPUT:
- *	After reading all MIB counters, the counters resets.
- *
- * RETURN:
- *	MIB counter value.
- *
- */
-static void eth_clear_mib_counters(struct mv643xx_private *mp)
+static int mv643xx_eth_shared_probe(struct platform_device *pdev)
 {
-	unsigned int port_num = mp->port_num;
-	int i;
-
-	/* Perform dummy reads from MIB counters */
-	for (i = ETH_MIB_GOOD_OCTETS_RECEIVED_LOW; i < ETH_MIB_LATE_COLLISION;
-									i += 4)
-		rdl(mp, MIB_COUNTERS_BASE(port_num) + i);
-}
+	static int mv643xx_eth_version_printed = 0;
+	struct mv643xx_eth_shared_platform_data *pd = pdev->dev.platform_data;
+	struct mv643xx_eth_shared_private *msp;
+	struct resource *res;
+	int ret;
 
-static inline u32 read_mib(struct mv643xx_private *mp, int offset)
-{
-	return rdl(mp, MIB_COUNTERS_BASE(mp->port_num) + offset);
-}
+	if (!mv643xx_eth_version_printed++)
+		printk(KERN_NOTICE "MV-643xx 10/100/1000 Ethernet Driver\n");
 
-static void eth_update_mib_counters(struct mv643xx_private *mp)
-{
-	struct mv643xx_mib_counters *p = &mp->mib_counters;
-	int offset;
+	ret = -EINVAL;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		goto out;
 
-	p->good_octets_received +=
-		read_mib(mp, ETH_MIB_GOOD_OCTETS_RECEIVED_LOW);
-	p->good_octets_received +=
-		(u64)read_mib(mp, ETH_MIB_GOOD_OCTETS_RECEIVED_HIGH) << 32;
+	ret = -ENOMEM;
+	msp = kmalloc(sizeof(*msp), GFP_KERNEL);
+	if (msp == NULL)
+		goto out;
+	memset(msp, 0, sizeof(*msp));
 
-	for (offset = ETH_MIB_BAD_OCTETS_RECEIVED;
-			offset <= ETH_MIB_FRAMES_1024_TO_MAX_OCTETS;
-			offset += 4)
-		*(u32 *)((char *)p + offset) += read_mib(mp, offset);
+	msp->base = ioremap(res->start, res->end - res->start + 1);
+	if (msp->base == NULL)
+		goto out_free;
 
-	p->good_octets_sent += read_mib(mp, ETH_MIB_GOOD_OCTETS_SENT_LOW);
-	p->good_octets_sent +=
-		(u64)read_mib(mp, ETH_MIB_GOOD_OCTETS_SENT_HIGH) << 32;
+	spin_lock_init(&msp->phy_lock);
 
-	for (offset = ETH_MIB_GOOD_FRAMES_SENT;
-			offset <= ETH_MIB_LATE_COLLISION;
-			offset += 4)
-		*(u32 *)((char *)p + offset) += read_mib(mp, offset);
-}
+	/*
+	 * (Re-)program MBUS remapping windows if we are asked to.
+	 */
+	if (pd != NULL && pd->dram != NULL)
+		mv643xx_eth_conf_mbus_windows(msp, pd->dram);
 
-/*
- * ethernet_phy_detect - Detect whether a phy is present
- *
- * DESCRIPTION:
- *	This function tests whether there is a PHY present on
- *	the specified port.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *
- * OUTPUT:
- *	None
- *
- * RETURN:
- *	0 on success
- *	-ENODEV on failure
- *
- */
-static int ethernet_phy_detect(struct mv643xx_private *mp)
-{
-	unsigned int phy_reg_data0;
-	int auto_neg;
+	/*
+	 * Detect hardware parameters.
+	 */
+	msp->t_clk = (pd != NULL && pd->t_clk != 0) ? pd->t_clk : 133000000;
+	infer_hw_params(msp);
 
-	eth_port_read_smi_reg(mp, 0, &phy_reg_data0);
-	auto_neg = phy_reg_data0 & 0x1000;
-	phy_reg_data0 ^= 0x1000;	/* invert auto_neg */
-	eth_port_write_smi_reg(mp, 0, phy_reg_data0);
-
-	eth_port_read_smi_reg(mp, 0, &phy_reg_data0);
-	if ((phy_reg_data0 & 0x1000) == auto_neg)
-		return -ENODEV;				/* change didn't take */
+	platform_set_drvdata(pdev, msp);
 
-	phy_reg_data0 ^= 0x1000;
-	eth_port_write_smi_reg(mp, 0, phy_reg_data0);
 	return 0;
+
+out_free:
+	kfree(msp);
+out:
+	return ret;
 }
 
-/*
- * ethernet_phy_get - Get the ethernet port PHY address.
- *
- * DESCRIPTION:
- *	This routine returns the given ethernet port PHY address.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *
- * OUTPUT:
- *	None.
- *
- * RETURN:
- *	PHY address.
- *
- */
-static int ethernet_phy_get(struct mv643xx_private *mp)
+static int mv643xx_eth_shared_remove(struct platform_device *pdev)
 {
-	unsigned int reg_data;
+	struct mv643xx_eth_shared_private *msp = platform_get_drvdata(pdev);
 
-	reg_data = rdl(mp, PHY_ADDR_REG);
+	iounmap(msp->base);
+	kfree(msp);
 
-	return ((reg_data >> (5 * mp->port_num)) & 0x1f);
+	return 0;
 }
 
-/*
- * ethernet_phy_set - Set the ethernet port PHY address.
- *
- * DESCRIPTION:
- *	This routine sets the given ethernet port PHY address.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *	int		phy_addr	PHY address.
- *
- * OUTPUT:
- *	None.
- *
- * RETURN:
- *	None.
- *
- */
-static void ethernet_phy_set(struct mv643xx_private *mp, int phy_addr)
+static struct platform_driver mv643xx_eth_shared_driver = {
+	.probe		= mv643xx_eth_shared_probe,
+	.remove		= mv643xx_eth_shared_remove,
+	.driver = {
+		.name	= MV643XX_ETH_SHARED_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static void phy_addr_set(struct mv643xx_eth_private *mp, int phy_addr)
 {
-	u32 reg_data;
 	int addr_shift = 5 * mp->port_num;
+	u32 data;
 
-	reg_data = rdl(mp, PHY_ADDR_REG);
-	reg_data &= ~(0x1f << addr_shift);
-	reg_data |= (phy_addr & 0x1f) << addr_shift;
-	wrl(mp, PHY_ADDR_REG, reg_data);
+	data = rdl(mp, PHY_ADDR);
+	data &= ~(0x1f << addr_shift);
+	data |= (phy_addr & 0x1f) << addr_shift;
+	wrl(mp, PHY_ADDR, data);
 }
 
-/*
- * ethernet_phy_reset - Reset Ethernet port PHY.
- *
- * DESCRIPTION:
- *	This routine utilizes the SMI interface to reset the ethernet port PHY.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *
- * OUTPUT:
- *	The PHY is reset.
- *
- * RETURN:
- *	None.
- *
- */
-static void ethernet_phy_reset(struct mv643xx_private *mp)
+static int phy_addr_get(struct mv643xx_eth_private *mp)
 {
-	unsigned int phy_reg_data;
+	unsigned int data;
 
-	/* Reset the PHY */
-	eth_port_read_smi_reg(mp, 0, &phy_reg_data);
-	phy_reg_data |= 0x8000;	/* Set bit 15 to reset the PHY */
-	eth_port_write_smi_reg(mp, 0, phy_reg_data);
+	data = rdl(mp, PHY_ADDR);
 
-	/* wait for PHY to come out of reset */
-	do {
-		udelay(1);
-		eth_port_read_smi_reg(mp, 0, &phy_reg_data);
-	} while (phy_reg_data & 0x8000);
+	return (data >> (5 * mp->port_num)) & 0x1f;
 }
 
-static void mv643xx_eth_port_enable_tx(struct mv643xx_private *mp,
-					unsigned int queues)
+static void set_params(struct mv643xx_eth_private *mp,
+		       struct mv643xx_eth_platform_data *pd)
 {
-	wrl(mp, TRANSMIT_QUEUE_COMMAND_REG(mp->port_num), queues);
-}
+	struct net_device *dev = mp->dev;
 
-static void mv643xx_eth_port_enable_rx(struct mv643xx_private *mp,
-					unsigned int queues)
-{
-	wrl(mp, RECEIVE_QUEUE_COMMAND_REG(mp->port_num), queues);
-}
+	if (is_valid_ether_addr(pd->mac_addr))
+		memcpy(dev->dev_addr, pd->mac_addr, 6);
+	else
+		uc_addr_get(mp, dev->dev_addr);
 
-static unsigned int mv643xx_eth_port_disable_tx(struct mv643xx_private *mp)
-{
-	unsigned int port_num = mp->port_num;
-	u32 queues;
+	if (pd->phy_addr == -1) {
+		mp->shared_smi = NULL;
+		mp->phy_addr = -1;
+	} else {
+		mp->shared_smi = mp->shared;
+		if (pd->shared_smi != NULL)
+			mp->shared_smi = platform_get_drvdata(pd->shared_smi);
+
+		if (pd->force_phy_addr || pd->phy_addr) {
+			mp->phy_addr = pd->phy_addr & 0x3f;
+			phy_addr_set(mp, mp->phy_addr);
+		} else {
+			mp->phy_addr = phy_addr_get(mp);
+		}
+	}
 
-	/* Stop Tx port activity. Check port Tx activity. */
-	queues = rdl(mp, TRANSMIT_QUEUE_COMMAND_REG(port_num)) & 0xFF;
-	if (queues) {
-		/* Issue stop command for active queues only */
-		wrl(mp, TRANSMIT_QUEUE_COMMAND_REG(port_num), (queues << 8));
+	mp->default_rx_ring_size = DEFAULT_RX_QUEUE_SIZE;
+	if (pd->rx_queue_size)
+		mp->default_rx_ring_size = pd->rx_queue_size;
+	mp->rx_desc_sram_addr = pd->rx_sram_addr;
+	mp->rx_desc_sram_size = pd->rx_sram_size;
 
-		/* Wait for all Tx activity to terminate. */
-		/* Check port cause register that all Tx queues are stopped */
-		while (rdl(mp, TRANSMIT_QUEUE_COMMAND_REG(port_num)) & 0xFF)
-			udelay(PHY_WAIT_MICRO_SECONDS);
+	if (pd->rx_queue_mask)
+		mp->rxq_mask = pd->rx_queue_mask;
+	else
+		mp->rxq_mask = 0x01;
+	mp->rxq_primary = fls(mp->rxq_mask) - 1;
 
-		/* Wait for Tx FIFO to empty */
-		while (rdl(mp, PORT_STATUS_REG(port_num)) &
-							ETH_PORT_TX_FIFO_EMPTY)
-			udelay(PHY_WAIT_MICRO_SECONDS);
-	}
+	mp->default_tx_ring_size = DEFAULT_TX_QUEUE_SIZE;
+	if (pd->tx_queue_size)
+		mp->default_tx_ring_size = pd->tx_queue_size;
+	mp->tx_desc_sram_addr = pd->tx_sram_addr;
+	mp->tx_desc_sram_size = pd->tx_sram_size;
 
-	return queues;
+	if (pd->tx_queue_mask)
+		mp->txq_mask = pd->tx_queue_mask;
+	else
+		mp->txq_mask = 0x01;
+	mp->txq_primary = fls(mp->txq_mask) - 1;
 }
 
-static unsigned int mv643xx_eth_port_disable_rx(struct mv643xx_private *mp)
+static int phy_detect(struct mv643xx_eth_private *mp)
 {
-	unsigned int port_num = mp->port_num;
-	u32 queues;
+	unsigned int data;
+	unsigned int data2;
 
-	/* Stop Rx port activity. Check port Rx activity. */
-	queues = rdl(mp, RECEIVE_QUEUE_COMMAND_REG(port_num)) & 0xFF;
-	if (queues) {
-		/* Issue stop command for active queues only */
-		wrl(mp, RECEIVE_QUEUE_COMMAND_REG(port_num), (queues << 8));
+	smi_reg_read(mp, mp->phy_addr, 0, &data);
+	smi_reg_write(mp, mp->phy_addr, 0, data ^ 0x1000);
 
-		/* Wait for all Rx activity to terminate. */
-		/* Check port cause register that all Rx queues are stopped */
-		while (rdl(mp, RECEIVE_QUEUE_COMMAND_REG(port_num)) & 0xFF)
-			udelay(PHY_WAIT_MICRO_SECONDS);
-	}
+	smi_reg_read(mp, mp->phy_addr, 0, &data2);
+	if (((data ^ data2) & 0x1000) == 0)
+		return -ENODEV;
+
+	smi_reg_write(mp, mp->phy_addr, 0, data);
 
-	return queues;
+	return 0;
 }
 
-/*
- * eth_port_reset - Reset Ethernet port
- *
- * DESCRIPTION:
- * 	This routine resets the chip by aborting any SDMA engine activity and
- *	clearing the MIB counters. The Receiver and the Transmit unit are in
- *	idle state after this command is performed and the port is disabled.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *
- * OUTPUT:
- *	Channel activity is halted.
- *
- * RETURN:
- *	None.
- *
- */
-static void eth_port_reset(struct mv643xx_private *mp)
+static int phy_init(struct mv643xx_eth_private *mp,
+		    struct mv643xx_eth_platform_data *pd)
 {
-	unsigned int port_num = mp->port_num;
-	unsigned int reg_data;
-
-	mv643xx_eth_port_disable_tx(mp);
-	mv643xx_eth_port_disable_rx(mp);
-
-	/* Clear all MIB counters */
-	eth_clear_mib_counters(mp);
+	struct ethtool_cmd cmd;
+	int err;
 
-	/* Reset the Enable bit in the Configuration Register */
-	reg_data = rdl(mp, PORT_SERIAL_CONTROL_REG(port_num));
-	reg_data &= ~(SERIAL_PORT_ENABLE		|
-			DO_NOT_FORCE_LINK_FAIL	|
-			FORCE_LINK_PASS);
-	wrl(mp, PORT_SERIAL_CONTROL_REG(port_num), reg_data);
-}
+	err = phy_detect(mp);
+	if (err) {
+		dev_printk(KERN_INFO, &mp->dev->dev,
+			   "no PHY detected at addr %d\n", mp->phy_addr);
+		return err;
+	}
+	phy_reset(mp);
 
+	mp->mii.phy_id = mp->phy_addr;
+	mp->mii.phy_id_mask = 0x3f;
+	mp->mii.reg_num_mask = 0x1f;
+	mp->mii.dev = mp->dev;
+	mp->mii.mdio_read = mv643xx_eth_mdio_read;
+	mp->mii.mdio_write = mv643xx_eth_mdio_write;
 
-/*
- * eth_port_read_smi_reg - Read PHY registers
- *
- * DESCRIPTION:
- *	This routine utilize the SMI interface to interact with the PHY in
- *	order to perform PHY register read.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *	unsigned int	phy_reg		PHY register address offset.
- *	unsigned int	*value		Register value buffer.
- *
- * OUTPUT:
- *	Write the value of a specified PHY register into given buffer.
- *
- * RETURN:
- *	false if the PHY is busy or read data is not in valid state.
- *	true otherwise.
- *
- */
-static void eth_port_read_smi_reg(struct mv643xx_private *mp,
-				unsigned int phy_reg, unsigned int *value)
-{
-	void __iomem *smi_reg = mp->shared_smi->eth_base + SMI_REG;
-	int phy_addr = ethernet_phy_get(mp);
-	unsigned long flags;
-	int i;
+	mp->mii.supports_gmii = mii_check_gmii_support(&mp->mii);
 
-	/* the SMI register is a shared resource */
-	spin_lock_irqsave(&mp->shared_smi->phy_lock, flags);
+	memset(&cmd, 0, sizeof(cmd));
 
-	/* wait for the SMI register to become available */
-	for (i = 0; readl(smi_reg) & ETH_SMI_BUSY; i++) {
-		if (i == PHY_WAIT_ITERATIONS) {
-			printk("%s: PHY busy timeout\n", mp->dev->name);
-			goto out;
-		}
-		udelay(PHY_WAIT_MICRO_SECONDS);
+	cmd.port = PORT_MII;
+	cmd.transceiver = XCVR_INTERNAL;
+	cmd.phy_address = mp->phy_addr;
+	if (pd->speed == 0) {
+		cmd.autoneg = AUTONEG_ENABLE;
+		cmd.speed = SPEED_100;
+		cmd.advertising = ADVERTISED_10baseT_Half  |
+				  ADVERTISED_10baseT_Full  |
+				  ADVERTISED_100baseT_Half |
+				  ADVERTISED_100baseT_Full;
+		if (mp->mii.supports_gmii)
+			cmd.advertising |= ADVERTISED_1000baseT_Full;
+	} else {
+		cmd.autoneg = AUTONEG_DISABLE;
+		cmd.speed = pd->speed;
+		cmd.duplex = pd->duplex;
 	}
 
-	writel((phy_addr << 16) | (phy_reg << 21) | ETH_SMI_OPCODE_READ,
-		smi_reg);
-
-	/* now wait for the data to be valid */
-	for (i = 0; !(readl(smi_reg) & ETH_SMI_READ_VALID); i++) {
-		if (i == PHY_WAIT_ITERATIONS) {
-			printk("%s: PHY read timeout\n", mp->dev->name);
-			goto out;
-		}
-		udelay(PHY_WAIT_MICRO_SECONDS);
-	}
+	update_pscr(mp, cmd.speed, cmd.duplex);
+	mv643xx_eth_set_settings(mp->dev, &cmd);
 
-	*value = readl(smi_reg) & 0xffff;
-out:
-	spin_unlock_irqrestore(&mp->shared_smi->phy_lock, flags);
+	return 0;
 }
 
-/*
- * eth_port_write_smi_reg - Write to PHY registers
- *
- * DESCRIPTION:
- *	This routine utilize the SMI interface to interact with the PHY in
- *	order to perform writes to PHY registers.
- *
- * INPUT:
- *	struct mv643xx_private *mp	Ethernet Port.
- *	unsigned int	phy_reg		PHY register address offset.
- *	unsigned int	value		Register value.
- *
- * OUTPUT:
- *	Write the given value to the specified PHY register.
- *
- * RETURN:
- *	false if the PHY is busy.
- *	true otherwise.
- *
- */
-static void eth_port_write_smi_reg(struct mv643xx_private *mp,
-				   unsigned int phy_reg, unsigned int value)
+static int mv643xx_eth_probe(struct platform_device *pdev)
 {
-	void __iomem *smi_reg = mp->shared_smi->eth_base + SMI_REG;
-	int phy_addr = ethernet_phy_get(mp);
-	unsigned long flags;
-	int i;
+	struct mv643xx_eth_platform_data *pd;
+	struct mv643xx_eth_private *mp;
+	struct net_device *dev;
+	struct resource *res;
+	DECLARE_MAC_BUF(mac);
+	int err;
 
-	/* the SMI register is a shared resource */
-	spin_lock_irqsave(&mp->shared_smi->phy_lock, flags);
+	pd = pdev->dev.platform_data;
+	if (pd == NULL) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			   "no mv643xx_eth_platform_data\n");
+		return -ENODEV;
+	}
 
-	/* wait for the SMI register to become available */
-	for (i = 0; readl(smi_reg) & ETH_SMI_BUSY; i++) {
-		if (i == PHY_WAIT_ITERATIONS) {
-			printk("%s: PHY busy timeout\n", mp->dev->name);
-			goto out;
-		}
-		udelay(PHY_WAIT_MICRO_SECONDS);
+	if (pd->shared == NULL) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			   "no mv643xx_eth_platform_data->shared\n");
+		return -ENODEV;
 	}
 
-	writel((phy_addr << 16) | (phy_reg << 21) |
-		ETH_SMI_OPCODE_WRITE | (value & 0xffff), smi_reg);
-out:
-	spin_unlock_irqrestore(&mp->shared_smi->phy_lock, flags);
-}
+	dev = alloc_etherdev(sizeof(struct mv643xx_eth_private));
+	if (!dev)
+		return -ENOMEM;
 
-/*
- * Wrappers for MII support library.
- */
-static int mv643xx_mdio_read(struct net_device *dev, int phy_id, int location)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-	int val;
+	mp = netdev_priv(dev);
+	platform_set_drvdata(pdev, mp);
 
-	eth_port_read_smi_reg(mp, location, &val);
-	return val;
-}
+	mp->shared = platform_get_drvdata(pd->shared);
+	mp->port_num = pd->port_number;
 
-static void mv643xx_mdio_write(struct net_device *dev, int phy_id, int location, int val)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
-	eth_port_write_smi_reg(mp, location, val);
-}
+	mp->dev = dev;
+#ifdef MV643XX_ETH_NAPI
+	netif_napi_add(dev, &mp->napi, mv643xx_eth_poll, 64);
+#endif
 
-/*
- * eth_port_receive - Get received information from Rx ring.
- *
- * DESCRIPTION:
- * 	This routine returns the received data to the caller. There is no
- *	data copying during routine operation. All information is returned
- *	using pointer to packet information struct passed from the caller.
- *	If the routine exhausts Rx ring resources then the resource error flag
- *	is set.
- *
- * INPUT:
- *	struct mv643xx_private	*mp		Ethernet Port Control srtuct.
- *	struct pkt_info		*p_pkt_info	User packet buffer.
- *
- * OUTPUT:
- *	Rx ring current and used indexes are updated.
- *
- * RETURN:
- *	ETH_ERROR in case the routine can not access Rx desc ring.
- *	ETH_QUEUE_FULL if Rx ring resources are exhausted.
- *	ETH_END_OF_JOB if there is no received data.
- *	ETH_OK otherwise.
- */
-static ETH_FUNC_RET_STATUS eth_port_receive(struct mv643xx_private *mp,
-						struct pkt_info *p_pkt_info)
-{
-	int rx_next_curr_desc, rx_curr_desc, rx_used_desc;
-	volatile struct eth_rx_desc *p_rx_desc;
-	unsigned int command_status;
-	unsigned long flags;
+	set_params(mp, pd);
 
-	/* Do not process Rx ring in case of Rx ring resource error */
-	if (mp->rx_resource_err)
-		return ETH_QUEUE_FULL;
+	spin_lock_init(&mp->lock);
 
-	spin_lock_irqsave(&mp->lock, flags);
+	mib_counters_clear(mp);
+	INIT_WORK(&mp->tx_timeout_task, tx_timeout_task);
 
-	/* Get the Rx Desc ring 'curr and 'used' indexes */
-	rx_curr_desc = mp->rx_curr_desc_q;
-	rx_used_desc = mp->rx_used_desc_q;
-
-	p_rx_desc = &mp->p_rx_desc_area[rx_curr_desc];
-
-	/* The following parameters are used to save readings from memory */
-	command_status = p_rx_desc->cmd_sts;
-	rmb();
+	if (mp->phy_addr != -1) {
+		err = phy_init(mp, pd);
+		if (err)
+			goto out;
 
-	/* Nothing to receive... */
-	if (command_status & (ETH_BUFFER_OWNED_BY_DMA)) {
-		spin_unlock_irqrestore(&mp->lock, flags);
-		return ETH_END_OF_JOB;
+		SET_ETHTOOL_OPS(dev, &mv643xx_eth_ethtool_ops);
+	} else {
+		SET_ETHTOOL_OPS(dev, &mv643xx_eth_ethtool_ops_phyless);
 	}
 
-	p_pkt_info->byte_cnt = (p_rx_desc->byte_cnt) - RX_BUF_OFFSET;
-	p_pkt_info->cmd_sts = command_status;
-	p_pkt_info->buf_ptr = (p_rx_desc->buf_ptr) + RX_BUF_OFFSET;
-	p_pkt_info->return_info = mp->rx_skb[rx_curr_desc];
-	p_pkt_info->l4i_chk = p_rx_desc->buf_size;
-
-	/*
-	 * Clean the return info field to indicate that the
-	 * packet has been moved to the upper layers
-	 */
-	mp->rx_skb[rx_curr_desc] = NULL;
 
-	/* Update current index in data structure */
-	rx_next_curr_desc = (rx_curr_desc + 1) % mp->rx_ring_size;
-	mp->rx_curr_desc_q = rx_next_curr_desc;
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	BUG_ON(!res);
+	dev->irq = res->start;
 
-	/* Rx descriptors exhausted. Set the Rx ring resource error flag */
-	if (rx_next_curr_desc == rx_used_desc)
-		mp->rx_resource_err = 1;
+	dev->hard_start_xmit = mv643xx_eth_xmit;
+	dev->open = mv643xx_eth_open;
+	dev->stop = mv643xx_eth_stop;
+	dev->set_multicast_list = mv643xx_eth_set_rx_mode;
+	dev->set_mac_address = mv643xx_eth_set_mac_address;
+	dev->do_ioctl = mv643xx_eth_ioctl;
+	dev->change_mtu = mv643xx_eth_change_mtu;
+	dev->tx_timeout = mv643xx_eth_tx_timeout;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = mv643xx_eth_netpoll;
+#endif
+	dev->watchdog_timeo = 2 * HZ;
+	dev->base_addr = 0;
 
-	spin_unlock_irqrestore(&mp->lock, flags);
+#ifdef MV643XX_ETH_CHECKSUM_OFFLOAD_TX
+	/*
+	 * Zero copy can only work if we use Discovery II memory. Else, we will
+	 * have to map the buffers to ISA memory which is only 16 MB
+	 */
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM;
+#endif
 
-	return ETH_OK;
-}
+	SET_NETDEV_DEV(dev, &pdev->dev);
 
-/*
- * eth_rx_return_buff - Returns a Rx buffer back to the Rx ring.
- *
- * DESCRIPTION:
- *	This routine returns a Rx buffer back to the Rx ring. It retrieves the
- *	next 'used' descriptor and attached the returned buffer to it.
- *	In case the Rx ring was in "resource error" condition, where there are
- *	no available Rx resources, the function resets the resource error flag.
- *
- * INPUT:
- *	struct mv643xx_private	*mp		Ethernet Port Control srtuct.
- *	struct pkt_info		*p_pkt_info	Information on returned buffer.
- *
- * OUTPUT:
- *	New available Rx resource in Rx descriptor ring.
- *
- * RETURN:
- *	ETH_ERROR in case the routine can not access Rx desc ring.
- *	ETH_OK otherwise.
- */
-static ETH_FUNC_RET_STATUS eth_rx_return_buff(struct mv643xx_private *mp,
-						struct pkt_info *p_pkt_info)
-{
-	int used_rx_desc;	/* Where to return Rx resource */
-	volatile struct eth_rx_desc *p_used_rx_desc;
-	unsigned long flags;
+	if (mp->shared->win_protect)
+		wrl(mp, WINDOW_PROTECT(mp->port_num), mp->shared->win_protect);
 
-	spin_lock_irqsave(&mp->lock, flags);
+	err = register_netdev(dev);
+	if (err)
+		goto out;
 
-	/* Get 'used' Rx descriptor */
-	used_rx_desc = mp->rx_used_desc_q;
-	p_used_rx_desc = &mp->p_rx_desc_area[used_rx_desc];
+	dev_printk(KERN_NOTICE, &dev->dev, "port %d with MAC address %s\n",
+		   mp->port_num, print_mac(mac, dev->dev_addr));
 
-	p_used_rx_desc->buf_ptr = p_pkt_info->buf_ptr;
-	p_used_rx_desc->buf_size = p_pkt_info->byte_cnt;
-	mp->rx_skb[used_rx_desc] = p_pkt_info->return_info;
+	if (dev->features & NETIF_F_SG)
+		dev_printk(KERN_NOTICE, &dev->dev, "scatter/gather enabled\n");
 
-	/* Flush the write pipe */
+	if (dev->features & NETIF_F_IP_CSUM)
+		dev_printk(KERN_NOTICE, &dev->dev, "tx checksum offload\n");
 
-	/* Return the descriptor to DMA ownership */
-	wmb();
-	p_used_rx_desc->cmd_sts =
-			ETH_BUFFER_OWNED_BY_DMA | ETH_RX_ENABLE_INTERRUPT;
-	wmb();
+#ifdef MV643XX_ETH_NAPI
+	dev_printk(KERN_NOTICE, &dev->dev, "napi enabled\n");
+#endif
 
-	/* Move the used descriptor pointer to the next descriptor */
-	mp->rx_used_desc_q = (used_rx_desc + 1) % mp->rx_ring_size;
+	if (mp->tx_desc_sram_size > 0)
+		dev_printk(KERN_NOTICE, &dev->dev, "configured with sram\n");
 
-	/* Any Rx return cancels the Rx resource error status */
-	mp->rx_resource_err = 0;
+	return 0;
 
-	spin_unlock_irqrestore(&mp->lock, flags);
+out:
+	free_netdev(dev);
 
-	return ETH_OK;
+	return err;
 }
 
-/************* Begin ethtool support *************************/
-
-struct mv643xx_stats {
-	char stat_string[ETH_GSTRING_LEN];
-	int sizeof_stat;
-	int stat_offset;
-};
-
-#define MV643XX_STAT(m) FIELD_SIZEOF(struct mv643xx_private, m), \
-					offsetof(struct mv643xx_private, m)
-
-static const struct mv643xx_stats mv643xx_gstrings_stats[] = {
-	{ "rx_packets", MV643XX_STAT(stats.rx_packets) },
-	{ "tx_packets", MV643XX_STAT(stats.tx_packets) },
-	{ "rx_bytes", MV643XX_STAT(stats.rx_bytes) },
-	{ "tx_bytes", MV643XX_STAT(stats.tx_bytes) },
-	{ "rx_errors", MV643XX_STAT(stats.rx_errors) },
-	{ "tx_errors", MV643XX_STAT(stats.tx_errors) },
-	{ "rx_dropped", MV643XX_STAT(stats.rx_dropped) },
-	{ "tx_dropped", MV643XX_STAT(stats.tx_dropped) },
-	{ "good_octets_received", MV643XX_STAT(mib_counters.good_octets_received) },
-	{ "bad_octets_received", MV643XX_STAT(mib_counters.bad_octets_received) },
-	{ "internal_mac_transmit_err", MV643XX_STAT(mib_counters.internal_mac_transmit_err) },
-	{ "good_frames_received", MV643XX_STAT(mib_counters.good_frames_received) },
-	{ "bad_frames_received", MV643XX_STAT(mib_counters.bad_frames_received) },
-	{ "broadcast_frames_received", MV643XX_STAT(mib_counters.broadcast_frames_received) },
-	{ "multicast_frames_received", MV643XX_STAT(mib_counters.multicast_frames_received) },
-	{ "frames_64_octets", MV643XX_STAT(mib_counters.frames_64_octets) },
-	{ "frames_65_to_127_octets", MV643XX_STAT(mib_counters.frames_65_to_127_octets) },
-	{ "frames_128_to_255_octets", MV643XX_STAT(mib_counters.frames_128_to_255_octets) },
-	{ "frames_256_to_511_octets", MV643XX_STAT(mib_counters.frames_256_to_511_octets) },
-	{ "frames_512_to_1023_octets", MV643XX_STAT(mib_counters.frames_512_to_1023_octets) },
-	{ "frames_1024_to_max_octets", MV643XX_STAT(mib_counters.frames_1024_to_max_octets) },
-	{ "good_octets_sent", MV643XX_STAT(mib_counters.good_octets_sent) },
-	{ "good_frames_sent", MV643XX_STAT(mib_counters.good_frames_sent) },
-	{ "excessive_collision", MV643XX_STAT(mib_counters.excessive_collision) },
-	{ "multicast_frames_sent", MV643XX_STAT(mib_counters.multicast_frames_sent) },
-	{ "broadcast_frames_sent", MV643XX_STAT(mib_counters.broadcast_frames_sent) },
-	{ "unrec_mac_control_received", MV643XX_STAT(mib_counters.unrec_mac_control_received) },
-	{ "fc_sent", MV643XX_STAT(mib_counters.fc_sent) },
-	{ "good_fc_received", MV643XX_STAT(mib_counters.good_fc_received) },
-	{ "bad_fc_received", MV643XX_STAT(mib_counters.bad_fc_received) },
-	{ "undersize_received", MV643XX_STAT(mib_counters.undersize_received) },
-	{ "fragments_received", MV643XX_STAT(mib_counters.fragments_received) },
-	{ "oversize_received", MV643XX_STAT(mib_counters.oversize_received) },
-	{ "jabber_received", MV643XX_STAT(mib_counters.jabber_received) },
-	{ "mac_receive_error", MV643XX_STAT(mib_counters.mac_receive_error) },
-	{ "bad_crc_event", MV643XX_STAT(mib_counters.bad_crc_event) },
-	{ "collision", MV643XX_STAT(mib_counters.collision) },
-	{ "late_collision", MV643XX_STAT(mib_counters.late_collision) },
-};
+static int mv643xx_eth_remove(struct platform_device *pdev)
+{
+	struct mv643xx_eth_private *mp = platform_get_drvdata(pdev);
 
-#define MV643XX_STATS_LEN	ARRAY_SIZE(mv643xx_gstrings_stats)
+	unregister_netdev(mp->dev);
+	flush_scheduled_work();
+	free_netdev(mp->dev);
 
-static void mv643xx_get_drvinfo(struct net_device *netdev,
-				struct ethtool_drvinfo *drvinfo)
-{
-	strncpy(drvinfo->driver,  mv643xx_driver_name, 32);
-	strncpy(drvinfo->version, mv643xx_driver_version, 32);
-	strncpy(drvinfo->fw_version, "N/A", 32);
-	strncpy(drvinfo->bus_info, "mv643xx", 32);
-	drvinfo->n_stats = MV643XX_STATS_LEN;
-}
+	platform_set_drvdata(pdev, NULL);
 
-static int mv643xx_get_sset_count(struct net_device *netdev, int sset)
-{
-	switch (sset) {
-	case ETH_SS_STATS:
-		return MV643XX_STATS_LEN;
-	default:
-		return -EOPNOTSUPP;
-	}
+	return 0;
 }
 
-static void mv643xx_get_ethtool_stats(struct net_device *netdev,
-				struct ethtool_stats *stats, uint64_t *data)
+static void mv643xx_eth_shutdown(struct platform_device *pdev)
 {
-	struct mv643xx_private *mp = netdev->priv;
-	int i;
+	struct mv643xx_eth_private *mp = platform_get_drvdata(pdev);
 
-	eth_update_mib_counters(mp);
+	/* Mask all interrupts on ethernet port */
+	wrl(mp, INT_MASK(mp->port_num), 0);
+	rdl(mp, INT_MASK(mp->port_num));
 
-	for (i = 0; i < MV643XX_STATS_LEN; i++) {
-		char *p = (char *)mp+mv643xx_gstrings_stats[i].stat_offset;
-		data[i] = (mv643xx_gstrings_stats[i].sizeof_stat ==
-			sizeof(uint64_t)) ? *(uint64_t *)p : *(uint32_t *)p;
-	}
+	if (netif_running(mp->dev))
+		port_reset(mp);
 }
 
-static void mv643xx_get_strings(struct net_device *netdev, uint32_t stringset,
-				uint8_t *data)
-{
-	int i;
-
-	switch(stringset) {
-	case ETH_SS_STATS:
-		for (i=0; i < MV643XX_STATS_LEN; i++) {
-			memcpy(data + i * ETH_GSTRING_LEN,
-					mv643xx_gstrings_stats[i].stat_string,
-					ETH_GSTRING_LEN);
-		}
-		break;
-	}
-}
+static struct platform_driver mv643xx_eth_driver = {
+	.probe		= mv643xx_eth_probe,
+	.remove		= mv643xx_eth_remove,
+	.shutdown	= mv643xx_eth_shutdown,
+	.driver = {
+		.name	= MV643XX_ETH_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
 
-static u32 mv643xx_eth_get_link(struct net_device *dev)
+static int __init mv643xx_eth_init_module(void)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-
-	return mii_link_ok(&mp->mii);
-}
+	int rc;
 
-static int mv643xx_eth_nway_restart(struct net_device *dev)
-{
-	struct mv643xx_private *mp = netdev_priv(dev);
+	rc = platform_driver_register(&mv643xx_eth_shared_driver);
+	if (!rc) {
+		rc = platform_driver_register(&mv643xx_eth_driver);
+		if (rc)
+			platform_driver_unregister(&mv643xx_eth_shared_driver);
+	}
 
-	return mii_nway_restart(&mp->mii);
+	return rc;
 }
+module_init(mv643xx_eth_init_module);
 
-static int mv643xx_eth_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+static void __exit mv643xx_eth_cleanup_module(void)
 {
-	struct mv643xx_private *mp = netdev_priv(dev);
-
-	return generic_mii_ioctl(&mp->mii, if_mii(ifr), cmd, NULL);
+	platform_driver_unregister(&mv643xx_eth_driver);
+	platform_driver_unregister(&mv643xx_eth_shared_driver);
 }
+module_exit(mv643xx_eth_cleanup_module);
 
-static const struct ethtool_ops mv643xx_ethtool_ops = {
-	.get_settings           = mv643xx_get_settings,
-	.set_settings           = mv643xx_set_settings,
-	.get_drvinfo            = mv643xx_get_drvinfo,
-	.get_link               = mv643xx_eth_get_link,
-	.set_sg			= ethtool_op_set_sg,
-	.get_sset_count		= mv643xx_get_sset_count,
-	.get_ethtool_stats      = mv643xx_get_ethtool_stats,
-	.get_strings            = mv643xx_get_strings,
-	.nway_reset		= mv643xx_eth_nway_restart,
-};
-
-/************* End ethtool support *************************/
+MODULE_AUTHOR("Rabeeh Khoury, Assaf Hoffman, Matthew Dharm, "
+	      "Manish Lachwani, Dale Farnsworth and Lennert Buytenhek");
+MODULE_DESCRIPTION("Ethernet driver for Marvell MV643XX");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" MV643XX_ETH_SHARED_NAME);
+MODULE_ALIAS("platform:" MV643XX_ETH_NAME);
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/debug-macro.S
@@ -0,0 +1,20 @@
+/*
+ * include/asm-arm/arch-kirkwood/debug-macro.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <asm/arch/kirkwood.h>
+
+	.macro	addruart,rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1					@ MMU enabled?
+	ldreq	\rx, =KIRKWOOD_REGS_PHYS_BASE
+	ldrne	\rx, =KIRKWOOD_REGS_VIRT_BASE
+	orr	\rx, \rx, #0x00012000
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/dma.h
@@ -0,0 +1 @@
+/* empty */
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/entry-macro.S
@@ -0,0 +1,40 @@
+/*
+ * include/asm-arm/arch-kirkwood/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Marvell Kirkwood platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/arch/kirkwood.h>
+
+	.macro  disable_fiq
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	ldr	\base, =IRQ_VIRT_BASE
+	.endm
+
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	@ check low interrupts
+	ldr	\irqstat, [\base, #IRQ_CAUSE_LOW_OFF]
+	ldr	\tmp, [\base, #IRQ_MASK_LOW_OFF]
+	mov	\irqnr, #31
+	ands	\irqstat, \irqstat, \tmp
+	bne	1001f
+
+	@ if no low interrupts set, check high interrupts
+	ldr	\irqstat, [\base, #IRQ_CAUSE_HIGH_OFF]
+	ldr	\tmp, [\base, #IRQ_MASK_HIGH_OFF]
+	mov	\irqnr, #63
+	ands	\irqstat, \irqstat, \tmp
+
+	@ find first active interrupt source
+1001:	clzne	\irqstat, \irqstat
+	subne	\irqnr, \irqnr, \irqstat
+	.endm
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/hardware.h
@@ -0,0 +1,21 @@
+/*
+ * include/asm-arm/arch-kirkwood/hardware.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "kirkwood.h"
+
+#define pcibios_assign_all_busses()	1
+
+#define PCIBIOS_MIN_IO			0x00001000
+#define PCIBIOS_MIN_MEM			0x01000000
+#define PCIMEM_BASE			KIRKWOOD_PCIE_MEM_PHYS_BASE /* mem base for VGA */
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/io.h
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-kirkwood/io.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "kirkwood.h"
+
+#define IO_SPACE_LIMIT		0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)((addr - KIRKWOOD_PCIE_IO_PHYS_BASE)
+					+ KIRKWOOD_PCIE_IO_VIRT_BASE);
+}
+
+#define __io(a)			__io(a)
+#define __mem_pci(a)		(a)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/irqs.h
@@ -0,0 +1,63 @@
+/*
+ * include/asm-arm/arch-kirkwood/irqs.h
+ *
+ * IRQ definitions for Marvell Kirkwood SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include "kirkwood.h"	/* need GPIO_MAX */
+
+/*
+ * Low Interrupt Controller
+ */
+#define IRQ_KIRKWOOD_HIGH_SUM	0
+#define IRQ_KIRKWOOD_BRIDGE	1
+#define IRQ_KIRKWOOD_HOST2CPU	2
+#define IRQ_KIRKWOOD_CPU2HOST	3
+#define IRQ_KIRKWOOD_XOR_00	5
+#define IRQ_KIRKWOOD_XOR_01	6
+#define IRQ_KIRKWOOD_XOR_10	7
+#define IRQ_KIRKWOOD_XOR_11	8
+#define IRQ_KIRKWOOD_PCIE	9
+#define IRQ_KIRKWOOD_GE00_SUM	11
+#define IRQ_KIRKWOOD_GE01_SUM	15
+#define IRQ_KIRKWOOD_USB	19
+#define IRQ_KIRKWOOD_SATA	21
+#define IRQ_KIRKWOOD_CRYPTO	22
+#define IRQ_KIRKWOOD_SPI	23
+#define IRQ_KIRKWOOD_I2S	24
+#define IRQ_KIRKWOOD_TS_0	26
+#define IRQ_KIRKWOOD_SDIO	28
+#define IRQ_KIRKWOOD_TWSI	29
+#define IRQ_KIRKWOOD_AVB	30
+#define IRQ_KIRKWOOD_TDMI	31
+
+/*
+ * High Interrupt Controller
+ */
+#define IRQ_KIRKWOOD_UART_0	33
+#define IRQ_KIRKWOOD_UART_1	34
+#define IRQ_KIRKWOOD_GPIO_LOW_0_7	35
+#define IRQ_KIRKWOOD_GPIO_LOW_8_15	36
+#define IRQ_KIRKWOOD_GPIO_LOW_16_23	37
+#define IRQ_KIRKWOOD_GPIO_LOW_24_31	38
+#define IRQ_KIRKWOOD_GPIO_HIGH_0_7	39
+#define IRQ_KIRKWOOD_GPIO_HIGH_8_15	40
+#define IRQ_KIRKWOOD_GPIO_HIGH_16_23	41
+
+/*
+ * KIRKWOOD General Purpose Pins
+ */
+#define IRQ_KIRKWOOD_GPIO_START	64
+#define NR_GPIO_IRQS		GPIO_MAX
+
+#define NR_IRQS			(IRQ_KIRKWOOD_GPIO_START + NR_GPIO_IRQS)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/kirkwood.h
@@ -0,0 +1,99 @@
+/*
+ * include/asm-arm/arch-kirkwood/kirkwood.h
+ *
+ * Generic definitions for Marvell Kirkwood SoC flavors:
+ *  88F6180, 88F6192 and 88F6281.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_KIRKWOOD_H
+#define __ASM_ARCH_KIRKWOOD_H
+
+/*
+ * Marvell Kirkwood address maps.
+ *
+ * phys
+ * e0000000	PCIe Memory space
+ * f1000000	on-chip peripheral registers
+ * f2000000	PCIe I/O space
+ * f3000000	NAND controller address window
+ *
+ * virt		phys		size
+ * fee00000	f1000000	1M	on-chip peripheral registers
+ * fef00000	f2000000	1M	PCIe I/O space
+ */
+
+#define KIRKWOOD_NAND_MEM_PHYS_BASE	0xf3000000
+#define KIRKWOOD_NAND_MEM_SIZE		SZ_64K /* 1K is sufficient, but 64K
+						* is the minimal window size
+						*/
+
+#define KIRKWOOD_PCIE_IO_PHYS_BASE	0xf2000000
+#define KIRKWOOD_PCIE_IO_VIRT_BASE	0xfef00000
+#define KIRKWOOD_PCIE_IO_BUS_BASE	0x00000000
+#define KIRKWOOD_PCIE_IO_SIZE		SZ_1M
+
+#define KIRKWOOD_REGS_PHYS_BASE		0xf1000000
+#define KIRKWOOD_REGS_VIRT_BASE		0xfee00000
+#define KIRKWOOD_REGS_SIZE		SZ_1M
+
+#define KIRKWOOD_PCIE_MEM_PHYS_BASE	0xe0000000
+#define KIRKWOOD_PCIE_MEM_SIZE		SZ_128M
+
+/*
+ * MBUS bridge registers.
+ */
+#define BRIDGE_VIRT_BASE	(KIRKWOOD_REGS_VIRT_BASE | 0x20000)
+#define  CPU_CONTROL		(BRIDGE_VIRT_BASE | 0x0104)
+#define   CPU_RESET		0x00000002
+//#define   L2_WRITETHROUGH	0x00020000
+#define  RSTOUTn_MASK		(BRIDGE_VIRT_BASE | 0x0108)
+#define   SOFT_RESET_OUT_EN	0x00000004
+#define  SYSTEM_SOFT_RESET	(BRIDGE_VIRT_BASE | 0x010c)
+#define   SOFT_RESET		0x00000001
+#define  BRIDGE_CAUSE		(BRIDGE_VIRT_BASE | 0x0110)
+#define  BRIDGE_MASK		(BRIDGE_VIRT_BASE | 0x0114)
+#define   BRIDGE_INT_TIMER0	0x0002
+#define   BRIDGE_INT_TIMER1	0x0004
+#define   BRIDGE_INT_TIMER1_CLR	(~0x0004)
+#define  IRQ_VIRT_BASE		(BRIDGE_VIRT_BASE | 0x0200)
+#define   IRQ_CAUSE_LOW_OFF	0x0000
+#define   IRQ_MASK_LOW_OFF	0x0004
+#define   IRQ_CAUSE_HIGH_OFF	0x0010
+#define   IRQ_MASK_HIGH_OFF	0x0014
+#define  TIMER_VIRT_BASE	(BRIDGE_VIRT_BASE | 0x0300)
+
+/*
+ * Register Map
+ */
+#define DDR_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE | 0x00000)
+#define  DDR_WINDOW_CPU_BASE	(DDR_VIRT_BASE | 0x1500)
+
+#define DEV_BUS_PHYS_BASE	(KIRKWOOD_REGS_PHYS_BASE | 0x10000)
+#define DEV_BUS_VIRT_BASE	(KIRKWOOD_REGS_VIRT_BASE | 0x10000)
+#define  SAMPLE_AT_RESET	(DEV_BUS_VIRT_BASE | 0x0030)
+#define  DEVICE_ID		(DEV_BUS_VIRT_BASE | 0x0034)
+#define  RTC_PHYS_BASE		(DEV_BUS_PHYS_BASE | 0x0300)
+#define  SPI_PHYS_BASE		(DEV_BUS_PHYS_BASE | 0x0600)
+#define  UART0_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2000)
+#define  UART0_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x2000)
+#define  UART1_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2100)
+#define  UART1_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x2100)
+
+#define PCIE_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE | 0x40000)
+
+#define USB_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE | 0x50000)
+
+#define GE00_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE | 0x70000)
+#define GE01_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE | 0x74000)
+
+#define SATA_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE | 0x80000)
+
+
+#define GPIO_MAX		50
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/memory.h
@@ -0,0 +1,14 @@
+/*
+ * include/asm-arm/arch-kirkwood/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET		UL(0x00000000)
+
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/system.h
@@ -0,0 +1,37 @@
+/*
+ * include/asm-arm/arch-kirkwood/system.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/kirkwood.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	/*
+	 * Enable soft reset to assert RSTOUTn.
+	 */
+	writel(SOFT_RESET_OUT_EN, RSTOUTn_MASK);
+
+	/*
+	 * Assert soft reset.
+	 */
+	writel(SOFT_RESET, SYSTEM_SOFT_RESET);
+
+	while (1)
+		;
+}
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/timex.h
@@ -0,0 +1,11 @@
+/*
+ * include/asm-arm/arch-kirkwood/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
+
+#define KIRKWOOD_TCLK		166666667
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/uncompress.h
@@ -0,0 +1,47 @@
+/*
+ * include/asm-arm/arch-kirkwood/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/serial_reg.h>
+#include <asm/arch/kirkwood.h>
+
+#define SERIAL_BASE	((unsigned char *)UART0_PHYS_BASE)
+
+static void putc(const char c)
+{
+	unsigned char *base = SERIAL_BASE;
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		if (base[UART_LSR << 2] & UART_LSR_THRE)
+			break;
+		barrier();
+	}
+
+	base[UART_TX << 2] = c;
+}
+
+static void flush(void)
+{
+	unsigned char *base = SERIAL_BASE;
+	unsigned char mask;
+	int i;
+
+	mask = UART_LSR_TEMT | UART_LSR_THRE;
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((base[UART_LSR << 2] & mask) == mask)
+			break;
+		barrier();
+	}
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
--- /dev/null
+++ b/include/asm-arm/arch-kirkwood/vmalloc.h
@@ -0,0 +1,5 @@
+/*
+ * include/asm-arm/arch-kirkwood/vmalloc.h
+ */
+
+#define VMALLOC_END	0xfe800000
--- /dev/null
+++ b/include/asm-arm/arch-loki/debug-macro.S
@@ -0,0 +1,20 @@
+/*
+ * include/asm-arm/arch-loki/debug-macro.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <asm/arch/loki.h>
+
+	.macro	addruart,rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1					@ MMU enabled?
+	ldreq	\rx, =LOKI_REGS_PHYS_BASE
+	ldrne	\rx, =LOKI_REGS_VIRT_BASE
+	orr	\rx, \rx, #0x00012000
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
--- /dev/null
+++ b/include/asm-arm/arch-loki/dma.h
@@ -0,0 +1 @@
+/* empty */
--- /dev/null
+++ b/include/asm-arm/arch-loki/entry-macro.S
@@ -0,0 +1,30 @@
+/*
+ * include/asm-arm/arch-loki/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Marvell Loki (88RC8480) platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/arch/loki.h>
+
+	.macro  disable_fiq
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	ldr	\base, =IRQ_VIRT_BASE
+	.endm
+
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\irqstat, [\base, #IRQ_CAUSE_OFF]
+	ldr	\tmp, [\base, #IRQ_MASK_OFF]
+	mov	\irqnr, #0
+	ands	\irqstat, \irqstat, \tmp
+	clzne	\irqnr, \irqstat
+	rsbne	\irqnr, \irqnr, #31
+	.endm
--- /dev/null
+++ b/include/asm-arm/arch-loki/hardware.h
@@ -0,0 +1,15 @@
+/*
+ * include/asm-arm/arch-loki/hardware.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "loki.h"
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-loki/io.h
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-loki/io.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "loki.h"
+
+#define IO_SPACE_LIMIT		0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)((addr - LOKI_PCIE0_IO_PHYS_BASE)
+					+ LOKI_PCIE0_IO_VIRT_BASE);
+}
+
+#define __io(a)			__io(a)
+#define __mem_pci(a)		(a)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-loki/irqs.h
@@ -0,0 +1,58 @@
+/*
+ * include/asm-arm/arch-loki/irqs.h
+ *
+ * IRQ definitions for Marvell Loki (88RC8480) SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include "loki.h"	/* need GPIO_MAX */
+
+/*
+ * Interrupt Controller
+ */
+#define IRQ_LOKI_PCIE_A_CPU_DRBL	0
+#define IRQ_LOKI_CPU_PCIE_A_DRBL	1
+#define IRQ_LOKI_PCIE_B_CPU_DRBL	2
+#define IRQ_LOKI_CPU_PCIE_B_DRBL	3
+#define IRQ_LOKI_COM_A_ERR		6
+#define IRQ_LOKI_COM_A_IN		7
+#define IRQ_LOKI_COM_A_OUT		8
+#define IRQ_LOKI_COM_B_ERR		9
+#define IRQ_LOKI_COM_B_IN		10
+#define IRQ_LOKI_COM_B_OUT		11
+#define IRQ_LOKI_DMA_A			12
+#define IRQ_LOKI_DMA_B			13
+#define IRQ_LOKI_SAS_A			14
+#define IRQ_LOKI_SAS_B			15
+#define IRQ_LOKI_DDR			16
+#define IRQ_LOKI_XOR			17
+#define IRQ_LOKI_BRIDGE			18
+#define IRQ_LOKI_PCIE_A_ERR		20
+#define IRQ_LOKI_PCIE_A_INT		21
+#define IRQ_LOKI_PCIE_B_ERR		22
+#define IRQ_LOKI_PCIE_B_INT		23
+#define IRQ_LOKI_GBE_A_INT		24
+#define IRQ_LOKI_GBE_B_INT		25
+#define IRQ_LOKI_DEV_ERR		26
+#define IRQ_LOKI_UART0			27
+#define IRQ_LOKI_UART1			28
+#define IRQ_LOKI_TWSI			29
+#define IRQ_LOKI_GPIO_23_0		30
+#define IRQ_LOKI_GPIO_25_24		31
+
+/*
+ * Loki General Purpose Pins
+ */
+#define IRQ_LOKI_GPIO_START	32
+#define NR_GPIO_IRQS		GPIO_MAX
+
+#define NR_IRQS			(IRQ_LOKI_GPIO_START + NR_GPIO_IRQS)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-loki/loki.h
@@ -0,0 +1,97 @@
+/*
+ * include/asm-arm/arch-loki/loki.h
+ *
+ * Generic definitions for Marvell Loki (88RC8480) SoC flavors
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_LOKI_H
+#define __ASM_ARCH_LOKI_H
+
+/*
+ * Marvell Loki (88RC8480) address maps.
+ *
+ * phys
+ * d0000000	on-chip peripheral registers
+ * e0000000	PCIe 0 Memory space
+ * e8000000	PCIe 1 Memory space
+ * f0000000	PCIe 0 I/O space
+ * f0100000	PCIe 1 I/O space
+ *
+ * virt		phys		size
+ * fed00000	d0000000	1M	on-chip peripheral registers
+ * fee00000	f0000000	64K	PCIe 0 I/O space
+ * fef00000	f0100000	64K	PCIe 1 I/O space
+ */
+
+#define LOKI_REGS_PHYS_BASE		0xd0000000
+#define LOKI_REGS_VIRT_BASE		0xfed00000
+#define LOKI_REGS_SIZE			SZ_1M
+
+#define LOKI_PCIE0_IO_PHYS_BASE		0xf0000000
+#define LOKI_PCIE0_IO_VIRT_BASE		0xfee00000
+#define LOKI_PCIE0_IO_BUS_BASE		0x00000000
+#define LOKI_PCIE0_IO_SIZE		SZ_64K
+
+#define LOKI_PCIE1_IO_PHYS_BASE		0xf0100000
+#define LOKI_PCIE1_IO_VIRT_BASE		0xfef00000
+#define LOKI_PCIE1_IO_BUS_BASE		0x00000000
+#define LOKI_PCIE1_IO_SIZE		SZ_64K
+
+#define LOKI_PCIE0_MEM_PHYS_BASE	0xe0000000
+#define LOKI_PCIE0_MEM_SIZE		SZ_128M
+
+#define LOKI_PCIE1_MEM_PHYS_BASE	0xe8000000
+#define LOKI_PCIE1_MEM_SIZE		SZ_128M
+
+/*
+ * Register Map
+ */
+#define DEV_BUS_PHYS_BASE	(LOKI_REGS_PHYS_BASE | 0x10000)
+#define DEV_BUS_VIRT_BASE	(LOKI_REGS_VIRT_BASE | 0x10000)
+#define  UART0_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2000)
+#define  UART0_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x2000)
+#define  UART1_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2100)
+#define  UART1_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x2100)
+
+#define BRIDGE_VIRT_BASE	(LOKI_REGS_VIRT_BASE | 0x20000)
+#define  BRIDGE_REG(x)		(BRIDGE_VIRT_BASE | (x))
+#define  RSTOUTn_MASK		(BRIDGE_VIRT_BASE | 0x0108)
+#define   SOFT_RESET_OUT_EN	0x00000004
+#define  SYSTEM_SOFT_RESET	(BRIDGE_VIRT_BASE | 0x010c)
+#define   SOFT_RESET		0x00000001
+#define  BRIDGE_CAUSE		(BRIDGE_VIRT_BASE | 0x0110)
+#define  BRIDGE_MASK		(BRIDGE_VIRT_BASE | 0x0114)
+#define   BRIDGE_INT_TIMER0	0x0002
+#define   BRIDGE_INT_TIMER1	0x0004
+#define   BRIDGE_INT_TIMER1_CLR	0x0004
+#define  IRQ_VIRT_BASE		(BRIDGE_VIRT_BASE | 0x0200)
+#define   IRQ_CAUSE_OFF		0x0000
+#define   IRQ_MASK_OFF		0x0004
+#define  TIMER_VIRT_BASE	(BRIDGE_VIRT_BASE | 0x0300)
+
+#define PCIE0_VIRT_BASE		(LOKI_REGS_VIRT_BASE | 0x30000)
+
+#define PCIE1_VIRT_BASE		(LOKI_REGS_VIRT_BASE | 0x40000)
+
+#define SAS0_PHYS_BASE		(LOKI_REGS_PHYS_BASE | 0x80000)
+
+#define SAS1_PHYS_BASE		(LOKI_REGS_PHYS_BASE | 0x90000)
+
+#define GE0_PHYS_BASE		(LOKI_REGS_PHYS_BASE | 0xa0000)
+#define GE0_VIRT_BASE		(LOKI_REGS_VIRT_BASE | 0xa0000)
+
+#define GE1_PHYS_BASE		(LOKI_REGS_PHYS_BASE | 0xb0000)
+#define GE1_VIRT_BASE		(LOKI_REGS_VIRT_BASE | 0xb0000)
+
+#define DDR_VIRT_BASE		(LOKI_REGS_VIRT_BASE | 0xf0000)
+#define DDR_REG(x)		(DDR_VIRT_BASE | (x))
+
+
+#define GPIO_MAX		8
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-loki/memory.h
@@ -0,0 +1,14 @@
+/*
+ * include/asm-arm/arch-loki/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET		UL(0x00000000)
+
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-loki/system.h
@@ -0,0 +1,37 @@
+/*
+ * include/asm-arm/arch-loki/system.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/loki.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	/*
+	 * Enable soft reset to assert RSTOUTn.
+	 */
+	writel(SOFT_RESET_OUT_EN, RSTOUTn_MASK);
+
+	/*
+	 * Assert soft reset.
+	 */
+	writel(SOFT_RESET, SYSTEM_SOFT_RESET);
+
+	while (1)
+		;
+}
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-loki/timex.h
@@ -0,0 +1,11 @@
+/*
+ * include/asm-arm/arch-loki/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
+
+#define LOKI_TCLK		180000000
--- /dev/null
+++ b/include/asm-arm/arch-loki/uncompress.h
@@ -0,0 +1,47 @@
+/*
+ * include/asm-arm/arch-loki/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/serial_reg.h>
+#include <asm/arch/loki.h>
+
+#define SERIAL_BASE	((unsigned char *)UART0_PHYS_BASE)
+
+static void putc(const char c)
+{
+	unsigned char *base = SERIAL_BASE;
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		if (base[UART_LSR << 2] & UART_LSR_THRE)
+			break;
+		barrier();
+	}
+
+	base[UART_TX << 2] = c;
+}
+
+static void flush(void)
+{
+	unsigned char *base = SERIAL_BASE;
+	unsigned char mask;
+	int i;
+
+	mask = UART_LSR_TEMT | UART_LSR_THRE;
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((base[UART_LSR << 2] & mask) == mask)
+			break;
+		barrier();
+	}
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
--- /dev/null
+++ b/include/asm-arm/arch-loki/vmalloc.h
@@ -0,0 +1,5 @@
+/*
+ * include/asm-arm/arch-loki/vmalloc.h
+ */
+
+#define VMALLOC_END	0xfe800000
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/debug-macro.S
@@ -0,0 +1,20 @@
+/*
+ * include/asm-arm/arch-mv78xx0/debug-macro.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <asm/arch/mv78xx0.h>
+
+	.macro	addruart,rx
+	mrc	p15, 0, \rx, c1, c0
+	tst	\rx, #1					@ MMU enabled?
+	ldreq	\rx, =MV78XX0_REGS_PHYS_BASE
+	ldrne	\rx, =MV78XX0_REGS_VIRT_BASE
+	orr	\rx, \rx, #0x00012000
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/dma.h
@@ -0,0 +1 @@
+/* empty */
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/entry-macro.S
@@ -0,0 +1,39 @@
+/*
+ * include/asm-arm/arch-mv78xx0/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Marvell MV78xx0 platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/arch/mv78xx0.h>
+
+	.macro  disable_fiq
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	ldr	\base, =IRQ_VIRT_BASE
+	.endm
+
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	@ check low interrupts
+	ldr	\irqstat, [\base, #IRQ_CAUSE_LOW_OFF]
+	ldr	\tmp, [\base, #IRQ_MASK_LOW_OFF]
+	mov	\irqnr, #31
+	ands	\irqstat, \irqstat, \tmp
+
+	@ if no low interrupts set, check high interrupts
+	ldreq	\irqstat, [\base, #IRQ_CAUSE_HIGH_OFF]
+	ldreq	\tmp, [\base, #IRQ_MASK_HIGH_OFF]
+	moveq	\irqnr, #63
+	andeqs	\irqstat, \irqstat, \tmp
+
+	@ find first active interrupt source
+	clzne	\irqstat, \irqstat
+	subne	\irqnr, \irqnr, \irqstat
+	.endm
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/hardware.h
@@ -0,0 +1,21 @@
+/*
+ * include/asm-arm/arch-mv78xx0/hardware.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "mv78xx0.h"
+
+#define pcibios_assign_all_busses()	1
+
+#define PCIBIOS_MIN_IO			0x00001000
+#define PCIBIOS_MIN_MEM			0x01000000
+#define PCIMEM_BASE			MV78XX0_PCIE_MEM_PHYS_BASE /* mem base for VGA */
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/io.h
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-mv78xx0/io.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "mv78xx0.h"
+
+#define IO_SPACE_LIMIT		0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)((addr - MV78XX0_PCIE_IO_PHYS_BASE(0))
+					+ MV78XX0_PCIE_IO_VIRT_BASE(0));
+}
+
+#define __io(a)			__io(a)
+#define __mem_pci(a)		(a)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/irqs.h
@@ -0,0 +1,91 @@
+/*
+ * include/asm-arm/arch-mv78xx0/irqs.h
+ *
+ * IRQ definitions for Marvell MV78xx0 SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include "mv78xx0.h"	/* need GPIO_MAX */
+
+/*
+ * MV78xx0 Low Interrupt Controller
+ */
+#define IRQ_MV78XX0_ERR		0
+#define IRQ_MV78XX0_SPI		1
+#define IRQ_MV78XX0_I2C_0	2
+#define IRQ_MV78XX0_I2C_1	3
+#define IRQ_MV78XX0_IDMA_0	4
+#define IRQ_MV78XX0_IDMA_1	5
+#define IRQ_MV78XX0_IDMA_2	6
+#define IRQ_MV78XX0_IDMA_3	7
+#define IRQ_MV78XX0_TIMER_0	8
+#define IRQ_MV78XX0_TIMER_1	9
+#define IRQ_MV78XX0_TIMER_2	10
+#define IRQ_MV78XX0_TIMER_3	11
+#define IRQ_MV78XX0_UART_0	12
+#define IRQ_MV78XX0_UART_1	13
+#define IRQ_MV78XX0_UART_2	14
+#define IRQ_MV78XX0_UART_3	15
+#define IRQ_MV78XX0_USB_0	16
+#define IRQ_MV78XX0_USB_1	17
+#define IRQ_MV78XX0_USB_2	18
+#define IRQ_MV78XX0_CRYPTO	19
+#define IRQ_MV78XX0_SDIO_0	20
+#define IRQ_MV78XX0_SDIO_1	21
+#define IRQ_MV78XX0_XOR_0	22
+#define IRQ_MV78XX0_XOR_1	23
+#define IRQ_MV78XX0_I2S_0	24
+#define IRQ_MV78XX0_I2S_1	25
+#define IRQ_MV78XX0_SATA	26
+#define IRQ_MV78XX0_TDMI	27
+
+/*
+ * MV78xx0 High Interrupt Controller
+ */
+#define IRQ_MV78XX0_PCIE_00	32
+#define IRQ_MV78XX0_PCIE_01	33
+#define IRQ_MV78XX0_PCIE_02	34
+#define IRQ_MV78XX0_PCIE_03	35
+#define IRQ_MV78XX0_PCIE_10	36
+#define IRQ_MV78XX0_PCIE_11	37
+#define IRQ_MV78XX0_PCIE_12	38
+#define IRQ_MV78XX0_PCIE_13	39
+#define IRQ_MV78XX0_GE00_SUM	40
+#define IRQ_MV78XX0_GE00_RX	41
+#define IRQ_MV78XX0_GE00_TX	42
+#define IRQ_MV78XX0_GE00_MISC	43
+#define IRQ_MV78XX0_GE01_SUM	44
+#define IRQ_MV78XX0_GE01_RX	45
+#define IRQ_MV78XX0_GE01_TX	46
+#define IRQ_MV78XX0_GE01_MISC	47
+#define IRQ_MV78XX0_GE10_SUM	48
+#define IRQ_MV78XX0_GE10_RX	49
+#define IRQ_MV78XX0_GE10_TX	50
+#define IRQ_MV78XX0_GE10_MISC	51
+#define IRQ_MV78XX0_GE11_SUM	52
+#define IRQ_MV78XX0_GE11_RX	53
+#define IRQ_MV78XX0_GE11_TX	54
+#define IRQ_MV78XX0_GE11_MISC	55
+#define IRQ_MV78XX0_GPIO_0_7	56
+#define IRQ_MV78XX0_GPIO_8_15	57
+#define IRQ_MV78XX0_GPIO_16_23	58
+#define IRQ_MV78XX0_GPIO_24_31	59
+#define IRQ_MV78XX0_DB_IN	60
+#define IRQ_MV78XX0_DB_OUT	61
+
+/*
+ * MV78XX0 General Purpose Pins
+ */
+#define IRQ_MV78XX0_GPIO_START	64
+#define NR_GPIO_IRQS		GPIO_MAX
+
+#define NR_IRQS			(IRQ_MV78XX0_GPIO_START + NR_GPIO_IRQS)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/memory.h
@@ -0,0 +1,14 @@
+/*
+ * include/asm-arm/arch-mv78xx0/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET		UL(0x00000000)
+
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/mv78xx0.h
@@ -0,0 +1,126 @@
+/*
+ * include/asm-arm/arch-mv78xx0/mv78xx0.h
+ *
+ * Generic definitions for Marvell MV78xx0 SoC flavors:
+ *  MV781x0 and MV782x0.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_MV78XX0_H
+#define __ASM_ARCH_MV78XX0_H
+
+/*
+ * Marvell MV78xx0 address maps.
+ *
+ * phys
+ * c0000000	PCIe Memory space
+ * f0800000	PCIe #0 I/O space
+ * f0900000	PCIe #1 I/O space
+ * f0a00000	PCIe #2 I/O space
+ * f0b00000	PCIe #3 I/O space
+ * f0c00000	PCIe #4 I/O space
+ * f0d00000	PCIe #5 I/O space
+ * f0e00000	PCIe #6 I/O space
+ * f0f00000	PCIe #7 I/O space
+ * f1000000	on-chip peripheral registers
+ *
+ * virt		phys		size
+ * fe400000	f102x000	16K	core-specific peripheral registers
+ * fe700000	f0800000	1M	PCIe #0 I/O space
+ * fe800000	f0900000	1M	PCIe #1 I/O space
+ * fe900000	f0a00000	1M	PCIe #2 I/O space
+ * fea00000	f0b00000	1M	PCIe #3 I/O space
+ * feb00000	f0c00000	1M	PCIe #4 I/O space
+ * fec00000	f0d00000	1M	PCIe #5 I/O space
+ * fed00000	f0e00000	1M	PCIe #6 I/O space
+ * fee00000	f0f00000	1M	PCIe #7 I/O space
+ * fef00000	f1000000	1M	on-chip peripheral registers
+ */
+#define MV78XX0_CORE0_REGS_PHYS_BASE	0xf1020000
+#define MV78XX0_CORE1_REGS_PHYS_BASE	0xf1024000
+#define MV78XX0_CORE_REGS_VIRT_BASE	0xfe400000
+#define MV78XX0_CORE_REGS_SIZE		SZ_16K
+
+#define MV78XX0_PCIE_IO_PHYS_BASE(i)	(0xf0800000 + ((i) << 20))
+#define MV78XX0_PCIE_IO_VIRT_BASE(i)	(0xfe700000 + ((i) << 20))
+#define MV78XX0_PCIE_IO_SIZE		SZ_1M
+
+#define MV78XX0_REGS_PHYS_BASE		0xf1000000
+#define MV78XX0_REGS_VIRT_BASE		0xfef00000
+#define MV78XX0_REGS_SIZE		SZ_1M
+
+#define MV78XX0_PCIE_MEM_PHYS_BASE	0xc0000000
+#define MV78XX0_PCIE_MEM_SIZE		0x30000000
+
+/*
+ * Core-specific peripheral registers.
+ */
+#define BRIDGE_VIRT_BASE	(MV78XX0_CORE_REGS_VIRT_BASE)
+#define  CPU_CONTROL		(BRIDGE_VIRT_BASE | 0x0104)
+#define   L2_WRITETHROUGH	0x00020000
+#define  RSTOUTn_MASK		(BRIDGE_VIRT_BASE | 0x0108)
+#define   SOFT_RESET_OUT_EN	0x00000004
+#define  SYSTEM_SOFT_RESET	(BRIDGE_VIRT_BASE | 0x010c)
+#define   SOFT_RESET		0x00000001
+#define  BRIDGE_CAUSE		(BRIDGE_VIRT_BASE | 0x0110)
+#define  BRIDGE_MASK		(BRIDGE_VIRT_BASE | 0x0114)
+#define   BRIDGE_INT_TIMER0	0x0002
+#define   BRIDGE_INT_TIMER1	0x0004
+#define   BRIDGE_INT_TIMER1_CLR	(~0x0004)
+#define  IRQ_VIRT_BASE		(BRIDGE_VIRT_BASE | 0x0200)
+#define   IRQ_CAUSE_LOW_OFF	0x0004
+#define   IRQ_CAUSE_HIGH_OFF	0x0008
+#define   IRQ_MASK_LOW_OFF	0x0010
+#define   IRQ_MASK_HIGH_OFF	0x0014
+#define  TIMER_VIRT_BASE	(BRIDGE_VIRT_BASE | 0x0300)
+
+/*
+ * Register Map
+ */
+#define DDR_VIRT_BASE		(MV78XX0_REGS_VIRT_BASE | 0x00000)
+#define  DDR_WINDOW_CPU0_BASE	(DDR_VIRT_BASE | 0x1500)
+#define  DDR_WINDOW_CPU1_BASE	(DDR_VIRT_BASE | 0x1700)
+
+#define DEV_BUS_PHYS_BASE	(MV78XX0_REGS_PHYS_BASE | 0x10000)
+#define DEV_BUS_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x10000)
+#define  SAMPLE_AT_RESET_LOW	(DEV_BUS_VIRT_BASE | 0x0030)
+#define  SAMPLE_AT_RESET_HIGH	(DEV_BUS_VIRT_BASE | 0x0034)
+#define  UART0_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2000)
+#define  UART0_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x2000)
+#define  UART1_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2100)
+#define  UART1_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x2100)
+#define  UART2_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2200)
+#define  UART2_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x2200)
+#define  UART3_PHYS_BASE	(DEV_BUS_PHYS_BASE | 0x2300)
+#define  UART3_VIRT_BASE	(DEV_BUS_VIRT_BASE | 0x2300)
+
+#define GE10_PHYS_BASE		(MV78XX0_REGS_PHYS_BASE | 0x30000)
+#define GE11_PHYS_BASE		(MV78XX0_REGS_PHYS_BASE | 0x34000)
+
+#define PCIE00_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x40000)
+#define PCIE01_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x44000)
+#define PCIE02_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x48000)
+#define PCIE03_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x4c000)
+
+#define USB0_PHYS_BASE		(MV78XX0_REGS_PHYS_BASE | 0x50000)
+#define USB1_PHYS_BASE		(MV78XX0_REGS_PHYS_BASE | 0x51000)
+#define USB2_PHYS_BASE		(MV78XX0_REGS_PHYS_BASE | 0x52000)
+
+#define GE00_PHYS_BASE		(MV78XX0_REGS_PHYS_BASE | 0x70000)
+#define GE01_PHYS_BASE		(MV78XX0_REGS_PHYS_BASE | 0x74000)
+
+#define PCIE10_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x80000)
+#define PCIE11_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x84000)
+#define PCIE12_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x88000)
+#define PCIE13_VIRT_BASE	(MV78XX0_REGS_VIRT_BASE | 0x8c000)
+
+#define SATA_PHYS_BASE		(MV78XX0_REGS_PHYS_BASE | 0xa0000)
+
+
+#define GPIO_MAX		32
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/system.h
@@ -0,0 +1,37 @@
+/*
+ * include/asm-arm/arch-mv78xx0/system.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/mv78xx0.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode)
+{
+	/*
+	 * Enable soft reset to assert RSTOUTn.
+	 */
+	writel(SOFT_RESET_OUT_EN, RSTOUTn_MASK);
+
+	/*
+	 * Assert soft reset.
+	 */
+	writel(SOFT_RESET, SYSTEM_SOFT_RESET);
+
+	while (1)
+		;
+}
+
+
+#endif
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/timex.h
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-mv78xx0/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/uncompress.h
@@ -0,0 +1,47 @@
+/*
+ * include/asm-arm/arch-mv78xx0/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/serial_reg.h>
+#include <asm/arch/mv78xx0.h>
+
+#define SERIAL_BASE	((unsigned char *)UART0_PHYS_BASE)
+
+static void putc(const char c)
+{
+	unsigned char *base = SERIAL_BASE;
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		if (base[UART_LSR << 2] & UART_LSR_THRE)
+			break;
+		barrier();
+	}
+
+	base[UART_TX << 2] = c;
+}
+
+static void flush(void)
+{
+	unsigned char *base = SERIAL_BASE;
+	unsigned char mask;
+	int i;
+
+	mask = UART_LSR_TEMT | UART_LSR_THRE;
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((base[UART_LSR << 2] & mask) == mask)
+			break;
+		barrier();
+	}
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
--- /dev/null
+++ b/include/asm-arm/arch-mv78xx0/vmalloc.h
@@ -0,0 +1,5 @@
+/*
+ * include/asm-arm/arch-mv78xx0/vmalloc.h
+ */
+
+#define VMALLOC_END	0xfe000000
--- a/include/asm-arm/arch-orion5x/io.h
+++ b/include/asm-arm/arch-orion5x/io.h
@@ -14,7 +14,6 @@
 #include "orion5x.h"
 
 #define IO_SPACE_LIMIT		0xffffffff
-#define IO_SPACE_REMAP		ORION5X_PCI_SYS_IO_BASE
 
 static inline void __iomem *
 __arch_ioremap(unsigned long paddr, size_t size, unsigned int mtype)
@@ -53,15 +52,12 @@
 /*****************************************************************************
  * Helpers to access Orion registers
  ****************************************************************************/
-#define orion5x_read(r)		__raw_readl(r)
-#define orion5x_write(r, val)	__raw_writel(val, r)
-
 /*
  * These are not preempt-safe.  Locks, if needed, must be taken
  * care of by the caller.
  */
-#define orion5x_setbits(r, mask)	orion5x_write((r), orion5x_read(r) | (mask))
-#define orion5x_clrbits(r, mask)	orion5x_write((r), orion5x_read(r) & ~(mask))
+#define orion5x_setbits(r, mask)	writel(readl(r) | (mask), (r))
+#define orion5x_clrbits(r, mask)	writel(readl(r) & ~(mask), (r))
 
 
 #endif
--- a/include/asm-arm/arch-orion5x/orion5x.h
+++ b/include/asm-arm/arch-orion5x/orion5x.h
@@ -2,7 +2,7 @@
  * include/asm-arm/arch-orion5x/orion5x.h
  *
  * Generic definitions of Orion SoC flavors:
- *  Orion-1, Orion-NAS, Orion-VoIP, and Orion-2.
+ *  Orion-1, Orion-VoIP, Orion-NAS, and Orion-2.
  *
  * Maintainer: Tzachi Perelstein <tzachi@marvell.com>
  *
@@ -63,9 +63,11 @@
 /*******************************************************************************
  * Supported Devices & Revisions
  ******************************************************************************/
-/* Orion-1 (88F5181) */
+/* Orion-1 (88F5181) and Orion-VoIP (88F5181L) */
 #define MV88F5181_DEV_ID	0x5181
 #define MV88F5181_REV_B1	3
+#define MV88F5181L_REV_A0	8
+#define MV88F5181L_REV_A1	9
 /* Orion-NAS (88F5182) */
 #define MV88F5182_DEV_ID	0x5182
 #define MV88F5182_REV_A2	2
@@ -152,6 +154,7 @@
 #define BRIDGE_MASK		ORION5X_BRIDGE_REG(0x114)
 #define  BRIDGE_INT_TIMER0	0x0002
 #define  BRIDGE_INT_TIMER1	0x0004
+#define  BRIDGE_INT_TIMER1_CLR	(~0x0004)
 #define MAIN_IRQ_CAUSE		ORION5X_BRIDGE_REG(0x200)
 #define MAIN_IRQ_MASK		ORION5X_BRIDGE_REG(0x204)
 
--- a/include/asm-arm/arch-orion5x/uncompress.h
+++ b/include/asm-arm/arch-orion5x/uncompress.h
@@ -8,23 +8,38 @@
  * warranty of any kind, whether express or implied.
  */
 
+#include <linux/serial_reg.h>
 #include <asm/arch/orion5x.h>
 
-#define MV_UART_THR	((volatile unsigned char *)(UART0_PHYS_BASE + 0x0))
-#define MV_UART_LSR 	((volatile unsigned char *)(UART0_PHYS_BASE + 0x14))
-
-#define LSR_THRE	0x20
+#define SERIAL_BASE	((unsigned char *)UART0_PHYS_BASE)
 
 static void putc(const char c)
 {
-	int j = 0x1000;
-	while (--j && !(*MV_UART_LSR & LSR_THRE))
+	unsigned char *base = SERIAL_BASE;
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		if (base[UART_LSR << 2] & UART_LSR_THRE)
+			break;
 		barrier();
-	*MV_UART_THR = c;
+	}
+
+	base[UART_TX << 2] = c;
 }
 
 static void flush(void)
 {
+	unsigned char *base = SERIAL_BASE;
+	unsigned char mask;
+	int i;
+
+	mask = UART_LSR_TEMT | UART_LSR_THRE;
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((base[UART_LSR << 2] & mask) == mask)
+			break;
+		barrier();
+	}
 }
 
 /*
--- a/include/asm-arm/assembler.h
+++ b/include/asm-arm/assembler.h
@@ -56,6 +56,21 @@
 #endif
 
 /*
+ * This can be used to enable code to cacheline align the destination
+ * pointer when bulk writing to memory.  Experiments on StrongARM and
+ * XScale didn't show this a worthwhile thing to do when the cache is not
+ * set to write-allocate (this would need further testing on XScale when WA
+ * is used).
+ *
+ * On Feroceon there is much to gain however, regardless of cache mode.
+ */
+#ifdef CONFIG_CPU_FEROCEON
+#define CALGN(code...) code
+#else
+#define CALGN(code...)
+#endif
+
+/*
  * Enable and disable interrupts
  */
 #if __LINUX_ARM_ARCH__ >= 6
--- a/include/asm-arm/cacheflush.h
+++ b/include/asm-arm/cacheflush.h
@@ -95,11 +95,7 @@
 #endif
 
 #if defined(CONFIG_CPU_FEROCEON)
-# ifdef _CACHE
-#  define MULTI_CACHE 1
-# else
-#  define _CACHE feroceon
-# endif
+# define MULTI_CACHE 1
 #endif
 
 #if defined(CONFIG_CPU_V6)
--- /dev/null
+++ b/include/asm-arm/plat-orion/cache-feroceon-l2.h
@@ -0,0 +1,11 @@
+/*
+ * include/asm-arm/plat-orion/cache-feroceon-l2.h
+ *
+ * Copyright (C) 2008 Marvell Semiconductor
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+extern void __init feroceon_l2_init(int l2_wt_override);
--- a/include/asm-arm/plat-orion/pcie.h
+++ b/include/asm-arm/plat-orion/pcie.h
@@ -14,6 +14,7 @@
 u32 orion_pcie_dev_id(void __iomem *base);
 u32 orion_pcie_rev(void __iomem *base);
 int orion_pcie_link_up(void __iomem *base);
+int orion_pcie_x4_mode(void __iomem *base);
 int orion_pcie_get_local_bus_nr(void __iomem *base);
 void orion_pcie_set_local_bus_nr(void __iomem *base, int nr);
 void orion_pcie_setup(void __iomem *base,
--- a/include/asm-arm/tlbflush.h
+++ b/include/asm-arm/tlbflush.h
@@ -39,6 +39,7 @@
 #define TLB_V6_D_ASID	(1 << 17)
 #define TLB_V6_I_ASID	(1 << 18)
 
+#define TLB_L2CLEAN_FR	(1 << 29)		/* Feroceon */
 #define TLB_DCLEAN	(1 << 30)
 #define TLB_WB		(1 << 31)
 
@@ -51,6 +52,7 @@
  *	  v4    - ARMv4 without write buffer
  *	  v4wb  - ARMv4 with write buffer without I TLB flush entry instruction
  *	  v4wbi - ARMv4 with write buffer with I TLB flush entry instruction
+ *	  fr    - Feroceon (v4wbi with non-outer-cacheable page table walks)
  *	  v6wbi - ARMv6 with write buffer with I TLB flush entry instruction
  */
 #undef _TLB
@@ -103,6 +105,23 @@
 # define v4wbi_always_flags	(-1UL)
 #endif
 
+#define fr_tlb_flags	(TLB_WB | TLB_DCLEAN | TLB_L2CLEAN_FR | \
+			 TLB_V4_I_FULL | TLB_V4_D_FULL | \
+			 TLB_V4_I_PAGE | TLB_V4_D_PAGE)
+
+#ifdef CONFIG_CPU_TLB_FEROCEON
+# define fr_possible_flags	fr_tlb_flags
+# define fr_always_flags	fr_tlb_flags
+# ifdef _TLB
+#  define MULTI_TLB 1
+# else
+#  define _TLB v4wbi
+# endif
+#else
+# define fr_possible_flags	0
+# define fr_always_flags	(-1UL)
+#endif
+
 #define v4wb_tlb_flags	(TLB_WB | TLB_DCLEAN | \
 			 TLB_V4_I_FULL | TLB_V4_D_FULL | \
 			 TLB_V4_D_PAGE)
@@ -245,12 +264,14 @@
 #define possible_tlb_flags	(v3_possible_flags | \
 				 v4_possible_flags | \
 				 v4wbi_possible_flags | \
+				 fr_possible_flags | \
 				 v4wb_possible_flags | \
 				 v6wbi_possible_flags)
 
 #define always_tlb_flags	(v3_always_flags & \
 				 v4_always_flags & \
 				 v4wbi_always_flags & \
+				 fr_always_flags & \
 				 v4wb_always_flags & \
 				 v6wbi_always_flags)
 
@@ -417,6 +438,11 @@
 	if (tlb_flag(TLB_DCLEAN))
 		asm("mcr	p15, 0, %0, c7, c10, 1	@ flush_pmd"
 			: : "r" (pmd) : "cc");
+
+	if (tlb_flag(TLB_L2CLEAN_FR))
+		asm("mcr	p15, 1, %0, c15, c9, 1  @ L2 flush_pmd"
+			: : "r" (pmd) : "cc");
+
 	if (tlb_flag(TLB_WB))
 		dsb();
 }
@@ -428,6 +454,10 @@
 	if (tlb_flag(TLB_DCLEAN))
 		asm("mcr	p15, 0, %0, c7, c10, 1	@ flush_pmd"
 			: : "r" (pmd) : "cc");
+
+	if (tlb_flag(TLB_L2CLEAN_FR))
+		asm("mcr	p15, 1, %0, c15, c9, 1  @ L2 flush_pmd"
+			: : "r" (pmd) : "cc");
 }
 
 #undef tlb_flag
--- a/include/linux/mv643xx_eth.h
+++ b/include/linux/mv643xx_eth.h
@@ -17,30 +17,59 @@
 
 struct mv643xx_eth_shared_platform_data {
 	struct mbus_dram_target_info	*dram;
-	unsigned int	t_clk;
+	unsigned int		t_clk;
 };
 
 struct mv643xx_eth_platform_data {
+	/*
+	 * Pointer back to our parent instance, and our port number.
+	 */
 	struct platform_device	*shared;
-	int		port_number;
+	int			port_number;
 
+	/*
+	 * Whether a PHY is present, and if yes, at which address.
+	 */
 	struct platform_device	*shared_smi;
+	int			force_phy_addr;
+	int			phy_addr;
 
-	u16		force_phy_addr;	/* force override if phy_addr == 0 */
-	u16		phy_addr;
-
-	/* If speed is 0, then speed and duplex are autonegotiated. */
-	int		speed;		/* 0, SPEED_10, SPEED_100, SPEED_1000 */
-	int		duplex;		/* DUPLEX_HALF or DUPLEX_FULL */
-
-	/* non-zero values of the following fields override defaults */
-	u32		tx_queue_size;
-	u32		rx_queue_size;
-	u32		tx_sram_addr;
-	u32		tx_sram_size;
-	u32		rx_sram_addr;
-	u32		rx_sram_size;
-	u8		mac_addr[6];	/* mac address if non-zero*/
+	/*
+	 * Use this MAC address if it is valid, overriding the
+	 * address that is already in the hardware.
+	 */
+	u8			mac_addr[6];
+
+	/*
+	 * If speed is 0, autonegotiation is enabled.
+	 *   Valid values for speed: 0, SPEED_10, SPEED_100, SPEED_1000.
+	 *   Valid values for duplex: DUPLEX_HALF, DUPLEX_FULL.
+	 */
+	int			speed;
+	int			duplex;
+
+	/*
+	 * Which RX/TX queues to use.
+	 */
+	int			rx_queue_mask;
+	int			tx_queue_mask;
+
+	/*
+	 * Override default RX/TX queue sizes if nonzero.
+	 */
+	int			rx_queue_size;
+	int			tx_queue_size;
+
+	/*
+	 * Use on-chip SRAM for RX/TX descriptors if size is nonzero
+	 * and sufficient to contain all descriptors for the requested
+	 * ring sizes.
+	 */
+	unsigned long		rx_sram_addr;
+	int			rx_sram_size;
+	unsigned long		tx_sram_addr;
+	int			tx_sram_size;
 };
 
-#endif /* __LINUX_MV643XX_ETH_H */
+
+#endif
