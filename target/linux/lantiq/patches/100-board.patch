--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -139,6 +139,9 @@ config MACH_DECSTATION
 
 	  otherwise choose R3000.
 
+config LANTIQ
+	bool "Lantiq MIPS"
+
 config MACH_JAZZ
 	bool "Jazz family of machines"
 	select ARC
@@ -693,6 +696,7 @@ source "arch/mips/txx9/Kconfig"
 source "arch/mips/vr41xx/Kconfig"
 source "arch/mips/cavium-octeon/Kconfig"
 source "arch/mips/loongson/Kconfig"
+source "arch/mips/lantiq/Kconfig"
 
 endmenu
 
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -317,6 +317,17 @@ cflags-$(CONFIG_MIPS_COBALT)	+= -I$(srct
 load-$(CONFIG_MIPS_COBALT)	+= 0xffffffff80080000
 
 #
+# Lantiq
+#
+load-$(CONFIG_LANTIQ) += 0xffffffff80002000
+core-$(CONFIG_LANTIQ) += arch/mips/lantiq/
+cflags-$(CONFIG_LANTIQ)   += -I$(srctree)/arch/mips/include/asm/mach-lantiq
+core-$(CONFIG_SOC_LANTIQ_FALCON) += arch/mips/lantiq/falcon/
+cflags-$(CONFIG_SOC_LANTIQ_FALCON)   += -I$(srctree)/arch/mips/include/asm/mach-lantiq/falcon
+core-$(CONFIG_SOC_LANTIQ_XWAY) += arch/mips/lantiq/xway/
+cflags-$(CONFIG_SOC_LANTIQ_XWAY)   += -I$(srctree)/arch/mips/include/asm/mach-lantiq/xway
+
+#
 # DECstation family
 #
 core-$(CONFIG_MACH_DECSTATION)	+= arch/mips/dec/
--- /dev/null
+++ b/arch/mips/lantiq/Kconfig
@@ -0,0 +1,36 @@
+if LANTIQ
+
+config SOC_LANTIQ
+	bool
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select CEVT_R4K
+	select CSRC_R4K
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_MULTITHREADING
+	select SYS_HAS_EARLY_PRINTK
+	select HW_HAS_PCI
+	select ARCH_REQUIRE_GPIOLIB
+	select SWAP_IO_SPACE
+	select MIPS_MACHINE
+
+choice
+	prompt "SoC Type"
+	default SOC_LANTIQ_XWAY
+
+#config SOC_LANTIQ_FALCON
+#	bool "FALCON"
+#	select SOC_LANTIQ
+
+config SOC_LANTIQ_XWAY
+	bool "XWAY"
+	select SOC_LANTIQ
+endchoice
+
+#source "arch/mips/lantiq/falcon/Kconfig"
+source "arch/mips/lantiq/xway/Kconfig"
+
+endif
--- /dev/null
+++ b/arch/mips/lantiq/Makefile
@@ -0,0 +1,2 @@
+obj-y := irq.o setup.o clk.o prom.o
+obj-$(CONFIG_EARLY_PRINTK) += early_printk.o
--- /dev/null
+++ b/arch/mips/lantiq/setup.c
@@ -0,0 +1,47 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+
+#include <lantiq.h>
+#include <lantiq_regs.h>
+
+void __init
+plat_mem_setup(void)
+{
+	/* assume 16M as default */
+	int memsize = 16;
+	char **envp = (char **) KSEG1ADDR(fw_arg2);
+	u32 status;
+
+	/* make sure to have no "reverse endian" for user mode! */
+	status = read_c0_status();
+	status &= (~(1<<25));
+	write_c0_status(status);
+
+	ioport_resource.start = IOPORT_RESOURCE_START;
+	ioport_resource.end = IOPORT_RESOURCE_END;
+	iomem_resource.start = IOMEM_RESOURCE_START;
+	iomem_resource.end = IOMEM_RESOURCE_END;
+
+	while (*envp)
+	{
+		char *e = (char *)KSEG1ADDR(*envp);
+		if (!strncmp(e, "memsize=", 8))
+		{
+			e += 8;
+			memsize = simple_strtoul(e, NULL, 10);
+		}
+		envp++;
+	}
+	memsize *= 1024 * 1024;
+	add_memory_region(0x00000000, memsize, BOOT_MEM_RAM);
+}
--- /dev/null
+++ b/arch/mips/lantiq/clk.c
@@ -0,0 +1,141 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 Thomas Langer, Lantiq Deutschland
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/list.h>
+
+#include <asm/time.h>
+#include <asm/irq.h>
+#include <asm/div64.h>
+
+#include <lantiq.h>
+#ifdef CONFIG_SOC_LANTIQ_XWAY
+#include <xway.h>
+#endif
+
+extern unsigned long lq_get_cpu_hz(void);
+extern unsigned long lq_get_fpi_hz(void);
+extern unsigned long lq_get_io_region_clock(void);
+
+struct clk {
+	const char *name;
+	unsigned long rate;
+	unsigned long (*get_rate) (void);
+};
+
+static struct clk *cpu_clk = 0;
+static int cpu_clk_cnt = 0;
+
+static unsigned int r4k_offset;
+static unsigned int r4k_cur;
+
+static struct clk cpu_clk_generic[] = {
+	{
+		.name = "cpu",
+		.get_rate = lq_get_cpu_hz,
+	}, {
+		.name = "fpi",
+		.get_rate = lq_get_fpi_hz,
+	}, {
+		.name = "io",
+		.get_rate = lq_get_io_region_clock,
+	},
+};
+
+void
+clk_init(void)
+{
+	int i;
+	cpu_clk = cpu_clk_generic;
+	cpu_clk_cnt = ARRAY_SIZE(cpu_clk_generic);
+	for(i = 0; i < cpu_clk_cnt; i++)
+		printk("%s: %ld\n", cpu_clk[i].name, clk_get_rate(&cpu_clk[i]));
+}
+
+static inline int
+clk_good(struct clk *clk)
+{
+	return clk && !IS_ERR(clk);
+}
+
+unsigned long
+clk_get_rate(struct clk *clk)
+{
+	if (unlikely(!clk_good(clk)))
+		return 0;
+
+	if (clk->rate != 0)
+		return clk->rate;
+
+	if (clk->get_rate != NULL)
+		return clk->get_rate();
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+struct clk*
+clk_get(struct device *dev, const char *id)
+{
+	int i;
+	for(i = 0; i < cpu_clk_cnt; i++)
+		if (!strcmp(id, cpu_clk[i].name))
+			return &cpu_clk[i];
+	BUG();
+	return ERR_PTR(-ENOENT);
+}
+EXPORT_SYMBOL(clk_get);
+
+void
+clk_put(struct clk *clk)
+{
+	/* not used */
+}
+EXPORT_SYMBOL(clk_put);
+
+static inline u32
+lq_get_counter_resolution(void)
+{
+	u32 res;
+	__asm__ __volatile__(
+		".set   push\n"
+		".set   mips32r2\n"
+		".set   noreorder\n"
+		"rdhwr  %0, $3\n"
+		"ehb\n"
+		".set pop\n"
+		: "=&r" (res)
+		: /* no input */
+		: "memory");
+	instruction_hazard();
+	return res;
+}
+
+void __init
+plat_time_init(void)
+{
+	struct clk *clk = clk_get(0, "cpu");
+	mips_hpt_frequency = clk_get_rate(clk) / lq_get_counter_resolution();
+	r4k_cur = (read_c0_count() + r4k_offset);
+	write_c0_compare(r4k_cur);
+
+#ifdef CONFIG_SOC_LANTIQ_XWAY
+#define LQ_GPTU_GPT_CLC			((u32 *)(LQ_GPTU_BASE_ADDR + 0x0000))
+	lq_pmu_enable(PMU_GPT);
+	lq_pmu_enable(PMU_FPI);
+
+	lq_w32(0x100, LQ_GPTU_GPT_CLC);
+#endif
+}
--- /dev/null
+++ b/arch/mips/lantiq/prom.c
@@ -0,0 +1,118 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <asm/bootinfo.h>
+#include <asm/time.h>
+
+#include <lantiq.h>
+
+#include "prom.h"
+
+static struct lq_soc_info soc_info;
+
+/* for Multithreading (APRP) on MIPS34K */
+unsigned long physical_memsize;
+
+/* all access to the ebu must be locked */
+DEFINE_SPINLOCK(ebu_lock);
+EXPORT_SYMBOL_GPL(ebu_lock);
+
+extern void clk_init(void);
+
+unsigned int
+lq_get_cpu_ver(void)
+{
+	return soc_info.rev;
+}
+EXPORT_SYMBOL(lq_get_cpu_ver);
+
+unsigned int
+lq_get_soc_type(void)
+{
+	return soc_info.type;
+}
+EXPORT_SYMBOL(lq_get_soc_type);
+
+const char*
+get_system_type(void)
+{
+	return soc_info.sys_type;
+}
+
+void
+prom_free_prom_memory(void)
+{
+}
+
+#ifdef CONFIG_IMAGE_CMDLINE_HACK
+extern char __image_cmdline[];
+
+static void __init
+prom_init_image_cmdline(void)
+{
+	char *p = __image_cmdline;
+	int replace = 0;
+
+	if (*p == '-') {
+		replace = 1;
+		p++;
+	}
+
+	if (*p == '\0')
+		return;
+
+	if (replace) {
+		strlcpy(arcs_cmdline, p, sizeof(arcs_cmdline));
+	} else {
+		strlcat(arcs_cmdline, " ", sizeof(arcs_cmdline));
+		strlcat(arcs_cmdline, p, sizeof(arcs_cmdline));
+	}
+}
+#else
+static void __init prom_init_image_cmdline(void) { return; }
+#endif
+
+static void __init
+prom_init_cmdline(void)
+{
+	int argc = fw_arg0;
+	char **argv = (char**)KSEG1ADDR(fw_arg1);
+	int i;
+
+	arcs_cmdline[0] = '\0';
+	if(argc)
+		for (i = 1; i < argc; i++)
+		{
+			strlcat(arcs_cmdline, (char*)KSEG1ADDR(argv[i]), COMMAND_LINE_SIZE);
+			if(i + 1 != argc)
+				strlcat(arcs_cmdline, " ", COMMAND_LINE_SIZE);
+		}
+
+	if (!*arcs_cmdline)
+		strcpy(&(arcs_cmdline[0]),
+			"console=ttyS1,115200 rootfstype=squashfs,jffs2");
+	prom_init_image_cmdline();
+}
+
+void __init
+prom_init(void)
+{
+	struct clk *clk;
+	lq_soc_detect(&soc_info);
+
+	clk_init();
+	clk = clk_get(0, "cpu");
+	snprintf(soc_info.sys_type, LQ_SYS_TYPE_LEN - 1, "%s rev1.%d %ldMhz",
+		soc_info.name, soc_info.rev, clk_get_rate(clk) / 1000000);
+	soc_info.sys_type[LQ_SYS_TYPE_LEN - 1] = '\0';
+	printk("SoC: %s\n", soc_info.sys_type);
+
+	prom_init_cmdline();
+}
--- /dev/null
+++ b/arch/mips/lantiq/prom.h
@@ -0,0 +1,24 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ * Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+
+#ifndef _LQ_PROM_H__
+#define _LQ_PROM_H__
+
+#define LQ_SYS_TYPE_LEN	0x100
+
+struct lq_soc_info {
+	unsigned char *name;
+	unsigned int rev;
+	unsigned int partnum;
+	unsigned int type;
+	unsigned char sys_type[LQ_SYS_TYPE_LEN];
+};
+
+void lq_soc_detect(struct lq_soc_info *i);
+
+#endif
