diff -Nur linux-2.6.21.1/arch/mips/Kconfig linux-2.6.21.1-owrt/arch/mips/Kconfig
--- linux-2.6.21.1/arch/mips/Kconfig	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/arch/mips/Kconfig	2007-05-23 23:34:01.000000000 +0200
@@ -220,6 +220,17 @@
 	  <http://www.marvell.com/>.  Say Y here if you wish to build a
 	  kernel for this platform.
 
+config MACH_ARUBA
+	bool "Support for the ARUBA product line"
+	select DMA_NONCOHERENT
+	select CPU_HAS_PREFETCH
+	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_BIG_ENDIAN
+
+
 config MACH_JAZZ
 	bool "Jazz family of machines"
 	select ARC
diff -Nur linux-2.6.21.1/arch/mips/Makefile linux-2.6.21.1-owrt/arch/mips/Makefile
--- linux-2.6.21.1/arch/mips/Makefile	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/arch/mips/Makefile	2007-05-23 23:34:01.000000000 +0200
@@ -158,6 +158,14 @@
 #
 
 #
+# Aruba
+#
+
+core-$(CONFIG_MACH_ARUBA)	+= arch/mips/aruba/
+cflags-$(CONFIG_MACH_ARUBA)	+= -Iinclude/asm-mips/aruba
+load-$(CONFIG_MACH_ARUBA)	+= 0x80100000
+
+#
 # Acer PICA 61, Mips Magnum 4000 and Olivetti M700.
 #
 core-$(CONFIG_MACH_JAZZ)	+= arch/mips/jazz/
diff -Nur linux-2.6.21.1/arch/mips/pci/Makefile linux-2.6.21.1-owrt/arch/mips/pci/Makefile
--- linux-2.6.21.1/arch/mips/pci/Makefile	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/arch/mips/pci/Makefile	2007-05-23 23:36:48.000000000 +0200
@@ -53,3 +53,4 @@
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
+obj-$(CONFIG_MACH_ARUBA)        += fixup-aruba.o ops-aruba.o pci-aruba.o
diff -Nur linux-2.6.21.1/drivers/char/watchdog/Makefile linux-2.6.21.1-owrt/drivers/char/watchdog/Makefile
--- linux-2.6.21.1/drivers/char/watchdog/Makefile	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/char/watchdog/Makefile	2007-05-23 23:36:53.000000000 +0200
@@ -82,5 +82,8 @@
 
 # SPARC64 Architecture
 
+# Aruba Architecture
+obj-$(CONFIG_MACH_ARUBA) += wdt_merlot.o
+
 # Architecture Independant
 obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
diff -Nur linux-2.6.21.1/drivers/mtd/chips/cfi_probe.c linux-2.6.21.1-owrt/drivers/mtd/chips/cfi_probe.c
--- linux-2.6.21.1/drivers/mtd/chips/cfi_probe.c	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/mtd/chips/cfi_probe.c	2007-05-23 23:36:42.000000000 +0200
@@ -25,6 +25,74 @@
 static void print_cfi_ident(struct cfi_ident *);
 #endif
 
+#if 1
+
+#define AMD_AUTOSEL_OFF1	0xAAA
+#define AMD_AUTOSEL_OFF2	0x555
+#define AMD_MANUF_ID		0x1
+#define AMD_DEVICE_ID1		0xF6 /* T */
+#define AMD_DEVICE_ID2		0xF9 /* B */
+/* Foll. are definitions for Macronix Flash Part */
+#define MCX_MANUF_ID		0xC2
+#define MCX_DEVICE_ID1		0xA7
+#define MCX_DEVICE_ID2		0xA8
+/* Foll. common to both AMD and Macronix */
+#define FACTORY_LOCKED		0x99
+#define USER_LOCKED		0x19
+
+/* NOTE: AP-70/6x use BYTE mode flash access. Therefore the
+ * lowest Addr. pin in the flash is not A0 but A-1 (A minus 1).
+ * CPU's A0 is tied to Flash's A-1, A1 to A0 and so on. This
+ * gives 4MB of byte-addressable mem. In byte mode, all addr
+ * need to be multiplied by 2 (i.e compared to word mode).
+ * NOTE: AMD_AUTOSEL_OFF1 and OFF2 are already mult. by 2
+ * Just blindly use the addr offsets suggested in the manual
+ * for byte mode and you'll be OK. Offs. in Table 6 need to
+ * be mult by 2 (for getting autosel params)
+ */
+void
+flash_detect(struct map_info *map, __u32 base, struct cfi_private *cfi)
+{
+	map_word val[3];
+	int osf = cfi->interleave * cfi->device_type; // =2 for AP70/6x
+	char *manuf, *part, *lock ;
+
+	if (osf != 1) return ;
+
+	cfi_send_gen_cmd(0xAA, AMD_AUTOSEL_OFF1, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, AMD_AUTOSEL_OFF2, base, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x90, AMD_AUTOSEL_OFF1, base, map, cfi, cfi->device_type, NULL);
+	val[0] = map_read(map, base) ; // manuf ID
+	val[1] = map_read(map, base+2) ; // device ID
+	val[2] = map_read(map, base+6) ; // lock indicator
+#if 0
+printk("v1=0x%x v2=0x%x v3=0x%x\n", val[0], val[1], val[2]) ;
+#endif
+	if (val[0].x[0] == AMD_MANUF_ID) {
+		manuf = "AMD Flash" ;
+		if (val[1].x[0] == AMD_DEVICE_ID1)
+			part = "AM29LV320D (Top)" ;
+		else if (val[1].x[0] == AMD_DEVICE_ID2)
+			part = "AM29LV320D (Bot)" ;
+		else part = "Unknown" ;
+	} else if (val[0].x[0] == MCX_MANUF_ID) {
+		manuf = "Macronix Flash" ;
+		if (val[1].x[0] == MCX_DEVICE_ID1)
+			part = "MX29LV320A (Top)" ;
+		else if (val[1].x[0] == MCX_DEVICE_ID2)
+			part = "MX29LV320A (Bot)" ;
+		else part = "Unknown" ;
+	} else
+		return ;
+	if (val[2].x[0] == FACTORY_LOCKED)
+		lock = "Factory Locked" ;
+	else if (val[2].x[0] == USER_LOCKED)
+		lock = "User Locked" ;
+	else lock = "Unknown locking" ;
+	printk("%s %s (%s)\n", manuf, part, lock) ;
+}
+#endif
+
 static int cfi_probe_chip(struct map_info *map, __u32 base,
 			  unsigned long *chip_map, struct cfi_private *cfi);
 static int cfi_chip_setup(struct map_info *map, struct cfi_private *cfi);
@@ -117,6 +185,10 @@
 	}
 
 	xip_disable();
+#if 1
+	//cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
+	flash_detect(map, base, cfi) ;
+#endif
 	cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);
diff -Nur linux-2.6.21.1/drivers/net/Kconfig linux-2.6.21.1-owrt/drivers/net/Kconfig
--- linux-2.6.21.1/drivers/net/Kconfig	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/net/Kconfig	2007-05-23 23:37:01.000000000 +0200
@@ -201,6 +201,19 @@
 
 source "drivers/net/arm/Kconfig"
 
+config AR2313
+	tristate "AR2313 Ethernet support"
+	depends on NET_ETHERNET && MACH_ARUBA
+	help
+	  Support for the AR2313 Ethernet part on Aruba AP60/61
+
+config IDT_RC32434_ETH
+        tristate "IDT RC32434 Local Ethernet support"
+        depends on NET_ETHERNET
+        help
+        IDT RC32434 has one local ethernet port. Say Y here to enable it.
+        To compile this driver as a module, choose M here.
+
 config MACE
 	tristate "MACE (Power Mac ethernet) support"
 	depends on NET_ETHERNET && PPC_PMAC && PPC32
diff -Nur linux-2.6.21.1/drivers/net/Makefile linux-2.6.21.1-owrt/drivers/net/Makefile
--- linux-2.6.21.1/drivers/net/Makefile	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/net/Makefile	2007-05-23 23:37:01.000000000 +0200
@@ -11,6 +11,7 @@
 obj-$(CONFIG_BONDING) += bonding/
 obj-$(CONFIG_ATL1) += atl1/
 obj-$(CONFIG_GIANFAR) += gianfar_driver.o
+obj-$(CONFIG_AR2313) += ar2313/
 
 gianfar_driver-objs := gianfar.o \
 		gianfar_ethtool.o \
@@ -38,6 +39,7 @@
 obj-$(CONFIG_MACE) += mace.o
 obj-$(CONFIG_BMAC) += bmac.o
 
+obj-$(CONFIG_IDT_RC32434_ETH) += rc32434_eth.o
 obj-$(CONFIG_DGRS) += dgrs.o
 obj-$(CONFIG_VORTEX) += 3c59x.o
 obj-$(CONFIG_TYPHOON) += typhoon.o
diff -Nur linux-2.6.21.1/drivers/net/natsemi.c linux-2.6.21.1-owrt/drivers/net/natsemi.c
--- linux-2.6.21.1/drivers/net/natsemi.c	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/net/natsemi.c	2007-05-23 23:34:01.000000000 +0200
@@ -656,6 +656,49 @@
 static int netdev_get_eeprom(struct net_device *dev, u8 *buf);
 static const struct ethtool_ops ethtool_ops;
 
+#ifdef CONFIG_MACH_ARUBA
+
+#include <linux/ctype.h>
+
+#ifndef ERR
+#define ERR(fmt, args...) printk("%s: " fmt, __func__, ##args)
+#endif
+
+static int parse_mac_addr(struct net_device *dev, char* macstr)
+{
+        int i, j;
+        unsigned char result, value;
+
+        for (i=0; i<6; i++) {
+                result = 0;
+                if (i != 5 && *(macstr+2) != ':') {
+                        ERR("invalid mac address format: %d %c\n",
+                            i, *(macstr+2));
+                        return -EINVAL;
+                }
+                for (j=0; j<2; j++) {
+                        if (isxdigit(*macstr) && (value = isdigit(*macstr) ? *macstr-'0' :
+                                                  toupper(*macstr)-'A'+10) < 16) {
+                                result = result*16 + value;
+                                macstr++;
+                        }
+                        else {
+                                ERR("invalid mac address "
+                                    "character: %c\n", *macstr);
+                                return -EINVAL;
+                        }
+                }
+
+                macstr++;
+                dev->dev_addr[i] = result;
+        }
+
+	dev->dev_addr[5]++;
+        return 0;
+}
+
+#endif
+
 static inline void __iomem *ns_ioaddr(struct net_device *dev)
 {
 	return (void __iomem *) dev->base_addr;
@@ -794,6 +837,7 @@
 		goto err_ioremap;
 	}
 
+#ifndef CONFIG_MACH_ARUBA
 	/* Work around the dropped serial bit. */
 	prev_eedata = eeprom_read(ioaddr, 6);
 	for (i = 0; i < 3; i++) {
@@ -802,6 +846,19 @@
 		dev->dev_addr[i*2+1] = eedata >> 7;
 		prev_eedata = eedata;
 	}
+#else
+	{
+		char mac[32];
+		unsigned char def_mac[6] = {00, 0x0b, 0x86, 0xba, 0xdb, 0xad};
+		extern char *getenv(char *e);
+		memset(mac, 0, 32);
+		memcpy(mac, getenv("ethaddr"), 17);
+		if (parse_mac_addr(dev, mac)){
+			printk("%s: MAC address not found\n", __func__);
+			memcpy(dev->dev_addr, def_mac, 6);
+		}
+	}
+#endif
 
 	dev->base_addr = (unsigned long __force) ioaddr;
 	dev->irq = irq;
diff -Nur linux-2.6.21.1/drivers/pci/access.c linux-2.6.21.1-owrt/drivers/pci/access.c
--- linux-2.6.21.1/drivers/pci/access.c	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/pci/access.c	2007-05-23 23:36:48.000000000 +0200
@@ -23,6 +23,7 @@
 #define PCI_word_BAD (pos & 1)
 #define PCI_dword_BAD (pos & 3)
 
+#ifdef __MIPSEB__
 #define PCI_OP_READ(size,type,len) \
 int pci_bus_read_config_##size \
 	(struct pci_bus *bus, unsigned int devfn, int pos, type *value)	\
@@ -33,11 +34,32 @@
 	if (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	\
 	spin_lock_irqsave(&pci_lock, flags);				\
 	res = bus->ops->read(bus, devfn, pos, len, &data);		\
+	if (len == 1)							\
+	 *value = (type)((data >> 24) & 0xff);				\
+	 else if (len == 2)						\
+	 *value = (type)((data >> 16) & 0xffff);			\
+	else								\
 	*value = (type)data;						\
 	spin_unlock_irqrestore(&pci_lock, flags);			\
 	return res;							\
 }
+#else
 
+#define PCI_OP_READ(size,type,len) \
+int pci_bus_read_config_##size \
+	(struct pci_bus *bus, unsigned int devfn, int pos, type *value) \
+{									\
+	int res;							\
+	unsigned long flags;						\
+	u32 data = 0;							\
+	if (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	\
+	spin_lock_irqsave(&pci_lock, flags);				\
+	res = bus->ops->read(bus, devfn, pos, len, &data);		\
+	*value = (type)data;						\
+	spin_unlock_irqrestore(&pci_lock, flags);			\
+	return res;							\
+}
+#endif
 #define PCI_OP_WRITE(size,type,len) \
 int pci_bus_write_config_##size \
 	(struct pci_bus *bus, unsigned int devfn, int pos, type value)	\
diff -Nur linux-2.6.21.1/drivers/serial/8250.c linux-2.6.21.1-owrt/drivers/serial/8250.c
--- linux-2.6.21.1/drivers/serial/8250.c	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/serial/8250.c	2007-05-23 23:37:11.000000000 +0200
@@ -1635,7 +1635,7 @@
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 	unsigned long flags;
-	unsigned char lsr, iir;
+//	unsigned char lsr, iir;
 	int retval;
 
 	up->capabilities = uart_config[up->port.type].flags;
@@ -1772,6 +1772,8 @@
 
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
 
+// For some reason this test causes problems on the AP6x serial console
+#if 0
 	/*
 	 * Do a quick test to see if we receive an
 	 * interrupt when we enable the TX irq.
@@ -1790,7 +1792,8 @@
 	} else {
 		up->bugs &= ~UART_BUG_TXEN;
 	}
-
+#endif
+	
 	spin_unlock_irqrestore(&up->port.lock, flags);
 
 	/*
diff -Nur linux-2.6.21.1/drivers/usb/host/ehci.h linux-2.6.21.1-owrt/drivers/usb/host/ehci.h
--- linux-2.6.21.1/drivers/usb/host/ehci.h	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/usb/host/ehci.h	2007-05-23 23:37:18.000000000 +0200
@@ -87,6 +87,7 @@
 	struct dma_pool		*sitd_pool;	/* sitd per split iso urb */
 
 	struct timer_list	watchdog;
+	struct timer_list	softirq;
 	unsigned long		actions;
 	unsigned		stamp;
 	unsigned long		next_statechange;
diff -Nur linux-2.6.21.1/drivers/usb/host/ehci-hcd.c linux-2.6.21.1-owrt/drivers/usb/host/ehci-hcd.c
--- linux-2.6.21.1/drivers/usb/host/ehci-hcd.c	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/drivers/usb/host/ehci-hcd.c	2007-05-23 23:37:18.000000000 +0200
@@ -118,6 +118,7 @@
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog > irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
+#define EHCI_SOFTIRQ		(HZ/400)
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -273,6 +274,16 @@
 #include "ehci-sched.c"
 
 /*-------------------------------------------------------------------------*/
+static irqreturn_t ehci_irq (struct usb_hcd *hcd);
+
+static void ehci_softirq (unsigned long param)
+{
+	struct ehci_hcd         *ehci = (struct ehci_hcd *) param;
+
+	if (ehci_irq(ehci_to_hcd(ehci)) != IRQ_NONE)
+		set_bit(HCD_FLAG_SAW_IRQ, &(ehci_to_hcd(ehci))->flags);
+	mod_timer (&ehci->softirq, jiffies + EHCI_SOFTIRQ);
+}
 
 static void ehci_watchdog (unsigned long param)
 {
@@ -289,6 +300,10 @@
 			COUNT (ehci->stats.lost_iaa);
 			ehci_writel(ehci, STS_IAA, &ehci->regs->status);
 			ehci->reclaim_ready = 1;
+			if (!timer_pending(&ehci->softirq)) {
+				ehci_info(ehci, "switching to softirq\n");
+				mod_timer (&ehci->softirq, jiffies + EHCI_SOFTIRQ);
+			}
 		}
 	}
 
@@ -396,6 +411,7 @@
 
 	/* no more interrupts ... */
 	del_timer_sync (&ehci->watchdog);
+	del_timer_sync (&ehci->softirq);
 
 	spin_lock_irq(&ehci->lock);
 	if (HC_IS_RUNNING (hcd->state))
@@ -444,6 +460,10 @@
 	ehci->watchdog.function = ehci_watchdog;
 	ehci->watchdog.data = (unsigned long) ehci;
 
+	init_timer(&ehci->softirq);
+	ehci->softirq.function = ehci_softirq;
+	ehci->softirq.data = (unsigned long) ehci;
+
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
diff -Nur linux-2.6.21.1/include/asm-mips/bootinfo.h linux-2.6.21.1-owrt/include/asm-mips/bootinfo.h
--- linux-2.6.21.1/include/asm-mips/bootinfo.h	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/include/asm-mips/bootinfo.h	2007-05-23 23:34:01.000000000 +0200
@@ -213,6 +213,17 @@
 #define MACH_GROUP_NEC_EMMA2RH 25	/* NEC EMMA2RH (was 23)		*/
 #define  MACH_NEC_MARKEINS	0	/* NEC EMMA2RH Mark-eins	*/
 
+
+/*
+ * Valid machtype for group ARUBA
+ */
+#define MACH_GROUP_ARUBA	23
+#define  MACH_ARUBA_UNKNOWN	0
+#define  MACH_ARUBA_AP60	1
+#define  MACH_ARUBA_AP65	2
+#define  MACH_ARUBA_AP70	3
+#define  MACH_ARUBA_AP40	4
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -Nur linux-2.6.21.1/include/asm-mips/cpu.h linux-2.6.21.1-owrt/include/asm-mips/cpu.h
--- linux-2.6.21.1/include/asm-mips/cpu.h	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/include/asm-mips/cpu.h	2007-05-23 23:34:01.000000000 +0200
@@ -54,6 +54,9 @@
 #define PRID_IMP_R14000		0x0f00
 #define PRID_IMP_R8000		0x1000
 #define PRID_IMP_PR4450		0x1200
+#define PRID_IMP_RC32334	0x1800
+#define PRID_IMP_RC32355	0x1900
+#define PRID_IMP_RC32365	0x1900
 #define PRID_IMP_R4600		0x2000
 #define PRID_IMP_R4700		0x2100
 #define PRID_IMP_TX39		0x2200
@@ -200,7 +203,8 @@
 #define CPU_SB1A		62
 #define CPU_74K			63
 #define CPU_R14000		64
-#define CPU_LAST		64
+#define CPU_RC32300		65
+#define CPU_LAST		65
 
 /*
  * ISA Level encodings
diff -Nur linux-2.6.21.1/include/asm-mips/mach-generic/irq.h linux-2.6.21.1-owrt/include/asm-mips/mach-generic/irq.h
--- linux-2.6.21.1/include/asm-mips/mach-generic/irq.h	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/include/asm-mips/mach-generic/irq.h	2007-05-23 23:35:55.000000000 +0200
@@ -9,7 +9,7 @@
 #define __ASM_MACH_GENERIC_IRQ_H
 
 #ifndef NR_IRQS
-#define NR_IRQS	128
+#define NR_IRQS	256
 #endif
 
 #ifdef CONFIG_I8259
diff -Nur linux-2.6.21.1/include/linux/kernel.h linux-2.6.21.1-owrt/include/linux/kernel.h
--- linux-2.6.21.1/include/linux/kernel.h	2007-04-27 23:49:26.000000000 +0200
+++ linux-2.6.21.1-owrt/include/linux/kernel.h	2007-05-23 23:34:01.000000000 +0200
@@ -334,6 +334,7 @@
 };
 
 /* Force a compilation error if condition is true */
+extern void BUILD_BUG(void);
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 
 /* Force a compilation error if condition is true, but also produce a
diff -Nur linux-2.6.21.1/include/linux/kernel.h.orig linux-2.6.21.1-owrt/include/linux/kernel.h.orig
--- linux-2.6.21.1/include/linux/kernel.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-owrt/include/linux/kernel.h.orig	2007-04-27 23:49:26.000000000 +0200
@@ -0,0 +1,355 @@
+#ifndef _LINUX_KERNEL_H
+#define _LINUX_KERNEL_H
+
+/*
+ * 'kernel.h' contains some often-used function prototypes etc
+ */
+
+#ifdef __KERNEL__
+
+#include <stdarg.h>
+#include <linux/linkage.h>
+#include <linux/stddef.h>
+#include <linux/types.h>
+#include <linux/compiler.h>
+#include <linux/bitops.h>
+#include <linux/log2.h>
+#include <asm/byteorder.h>
+#include <asm/bug.h>
+
+extern const char linux_banner[];
+extern const char linux_proc_banner[];
+
+#define INT_MAX		((int)(~0U>>1))
+#define INT_MIN		(-INT_MAX - 1)
+#define UINT_MAX	(~0U)
+#define LONG_MAX	((long)(~0UL>>1))
+#define LONG_MIN	(-LONG_MAX - 1)
+#define ULONG_MAX	(~0UL)
+#define LLONG_MAX	((long long)(~0ULL>>1))
+#define LLONG_MIN	(-LLONG_MAX - 1)
+#define ULLONG_MAX	(~0ULL)
+
+#define STACK_MAGIC	0xdeadbeef
+
+#define ALIGN(x,a)		__ALIGN_MASK(x,(typeof(x))(a)-1)
+#define __ALIGN_MASK(x,mask)	(((x)+(mask))&~(mask))
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#define roundup(x, y) ((((x) + ((y) - 1)) / (y)) * (y))
+
+#define	KERN_EMERG	"<0>"	/* system is unusable			*/
+#define	KERN_ALERT	"<1>"	/* action must be taken immediately	*/
+#define	KERN_CRIT	"<2>"	/* critical conditions			*/
+#define	KERN_ERR	"<3>"	/* error conditions			*/
+#define	KERN_WARNING	"<4>"	/* warning conditions			*/
+#define	KERN_NOTICE	"<5>"	/* normal but significant condition	*/
+#define	KERN_INFO	"<6>"	/* informational			*/
+#define	KERN_DEBUG	"<7>"	/* debug-level messages			*/
+
+extern int console_printk[];
+
+#define console_loglevel (console_printk[0])
+#define default_message_loglevel (console_printk[1])
+#define minimum_console_loglevel (console_printk[2])
+#define default_console_loglevel (console_printk[3])
+
+struct completion;
+struct pt_regs;
+struct user;
+
+/**
+ * might_sleep - annotation for functions that can sleep
+ *
+ * this macro will print a stack trace if it is executed in an atomic
+ * context (spinlock, irq-handler, ...).
+ *
+ * This is a useful debugging help to be able to catch problems early and not
+ * be bitten later when the calling function happens to sleep when it is not
+ * supposed to.
+ */
+#ifdef CONFIG_PREEMPT_VOLUNTARY
+extern int cond_resched(void);
+# define might_resched() cond_resched()
+#else
+# define might_resched() do { } while (0)
+#endif
+
+#ifdef CONFIG_DEBUG_SPINLOCK_SLEEP
+  void __might_sleep(char *file, int line);
+# define might_sleep() \
+	do { __might_sleep(__FILE__, __LINE__); might_resched(); } while (0)
+#else
+# define might_sleep() do { might_resched(); } while (0)
+#endif
+
+#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)
+
+#define abs(x) ({				\
+		int __x = (x);			\
+		(__x < 0) ? -__x : __x;		\
+	})
+
+extern struct atomic_notifier_head panic_notifier_list;
+extern long (*panic_blink)(long time);
+NORET_TYPE void panic(const char * fmt, ...)
+	__attribute__ ((NORET_AND format (printf, 1, 2)));
+extern void oops_enter(void);
+extern void oops_exit(void);
+extern int oops_may_print(void);
+fastcall NORET_TYPE void do_exit(long error_code)
+	ATTRIB_NORET;
+NORET_TYPE void complete_and_exit(struct completion *, long)
+	ATTRIB_NORET;
+extern unsigned long simple_strtoul(const char *,char **,unsigned int);
+extern long simple_strtol(const char *,char **,unsigned int);
+extern unsigned long long simple_strtoull(const char *,char **,unsigned int);
+extern long long simple_strtoll(const char *,char **,unsigned int);
+extern int sprintf(char * buf, const char * fmt, ...)
+	__attribute__ ((format (printf, 2, 3)));
+extern int vsprintf(char *buf, const char *, va_list)
+	__attribute__ ((format (printf, 2, 0)));
+extern int snprintf(char * buf, size_t size, const char * fmt, ...)
+	__attribute__ ((format (printf, 3, 4)));
+extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
+	__attribute__ ((format (printf, 3, 0)));
+extern int scnprintf(char * buf, size_t size, const char * fmt, ...)
+	__attribute__ ((format (printf, 3, 4)));
+extern int vscnprintf(char *buf, size_t size, const char *fmt, va_list args)
+	__attribute__ ((format (printf, 3, 0)));
+extern char *kasprintf(gfp_t gfp, const char *fmt, ...)
+	__attribute__ ((format (printf, 2, 3)));
+
+extern int sscanf(const char *, const char *, ...)
+	__attribute__ ((format (scanf, 2, 3)));
+extern int vsscanf(const char *, const char *, va_list)
+	__attribute__ ((format (scanf, 2, 0)));
+
+extern int get_option(char **str, int *pint);
+extern char *get_options(const char *str, int nints, int *ints);
+extern unsigned long long memparse(char *ptr, char **retptr);
+
+extern int core_kernel_text(unsigned long addr);
+extern int __kernel_text_address(unsigned long addr);
+extern int kernel_text_address(unsigned long addr);
+struct pid;
+extern struct pid *session_of_pgrp(struct pid *pgrp);
+
+extern void dump_thread(struct pt_regs *regs, struct user *dump);
+
+#ifdef CONFIG_PRINTK
+asmlinkage int vprintk(const char *fmt, va_list args)
+	__attribute__ ((format (printf, 1, 0)));
+asmlinkage int printk(const char * fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+#else
+static inline int vprintk(const char *s, va_list args)
+	__attribute__ ((format (printf, 1, 0)));
+static inline int vprintk(const char *s, va_list args) { return 0; }
+static inline int printk(const char *s, ...)
+	__attribute__ ((format (printf, 1, 2)));
+static inline int printk(const char *s, ...) { return 0; }
+#endif
+
+unsigned long int_sqrt(unsigned long);
+
+extern int printk_ratelimit(void);
+extern int __printk_ratelimit(int ratelimit_jiffies, int ratelimit_burst);
+extern bool printk_timed_ratelimit(unsigned long *caller_jiffies,
+				unsigned int interval_msec);
+
+static inline void console_silent(void)
+{
+	console_loglevel = 0;
+}
+
+static inline void console_verbose(void)
+{
+	if (console_loglevel)
+		console_loglevel = 15;
+}
+
+extern void bust_spinlocks(int yes);
+extern void wake_up_klogd(void);
+extern int oops_in_progress;		/* If set, an oops, panic(), BUG() or die() is in progress */
+extern int panic_timeout;
+extern int panic_on_oops;
+extern int panic_on_unrecovered_nmi;
+extern int tainted;
+extern const char *print_tainted(void);
+extern void add_taint(unsigned);
+
+/* Values used for system_state */
+extern enum system_states {
+	SYSTEM_BOOTING,
+	SYSTEM_RUNNING,
+	SYSTEM_HALT,
+	SYSTEM_POWER_OFF,
+	SYSTEM_RESTART,
+	SYSTEM_SUSPEND_DISK,
+} system_state;
+
+#define TAINT_PROPRIETARY_MODULE	(1<<0)
+#define TAINT_FORCED_MODULE		(1<<1)
+#define TAINT_UNSAFE_SMP		(1<<2)
+#define TAINT_FORCED_RMMOD		(1<<3)
+#define TAINT_MACHINE_CHECK		(1<<4)
+#define TAINT_BAD_PAGE			(1<<5)
+#define TAINT_USER			(1<<6)
+
+extern void dump_stack(void);
+
+#ifdef DEBUG
+/* If you are writing a driver, please use dev_dbg instead */
+#define pr_debug(fmt,arg...) \
+	printk(KERN_DEBUG fmt,##arg)
+#else
+static inline int __attribute__ ((format (printf, 1, 2))) pr_debug(const char * fmt, ...)
+{
+	return 0;
+}
+#endif
+
+#define pr_info(fmt,arg...) \
+	printk(KERN_INFO fmt,##arg)
+
+/*
+ *      Display an IP address in readable format.
+ */
+
+#define NIPQUAD(addr) \
+	((unsigned char *)&addr)[0], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[2], \
+	((unsigned char *)&addr)[3]
+#define NIPQUAD_FMT "%u.%u.%u.%u"
+
+#define NIP6(addr) \
+	ntohs((addr).s6_addr16[0]), \
+	ntohs((addr).s6_addr16[1]), \
+	ntohs((addr).s6_addr16[2]), \
+	ntohs((addr).s6_addr16[3]), \
+	ntohs((addr).s6_addr16[4]), \
+	ntohs((addr).s6_addr16[5]), \
+	ntohs((addr).s6_addr16[6]), \
+	ntohs((addr).s6_addr16[7])
+#define NIP6_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
+#define NIP6_SEQFMT "%04x%04x%04x%04x%04x%04x%04x%04x"
+
+#if defined(__LITTLE_ENDIAN)
+#define HIPQUAD(addr) \
+	((unsigned char *)&addr)[3], \
+	((unsigned char *)&addr)[2], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[0]
+#elif defined(__BIG_ENDIAN)
+#define HIPQUAD	NIPQUAD
+#else
+#error "Please fix asm/byteorder.h"
+#endif /* __LITTLE_ENDIAN */
+
+/*
+ * min()/max() macros that also do
+ * strict type-checking.. See the
+ * "unnecessary" pointer comparison.
+ */
+#define min(x,y) ({ \
+	typeof(x) _x = (x);	\
+	typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x < _y ? _x : _y; })
+
+#define max(x,y) ({ \
+	typeof(x) _x = (x);	\
+	typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x > _y ? _x : _y; })
+
+/*
+ * ..and if you can't take the strict
+ * types, you can specify one yourself.
+ *
+ * Or not use min/max at all, of course.
+ */
+#define min_t(type,x,y) \
+	({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+#define max_t(type,x,y) \
+	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
+
+
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ * @ptr:	the pointer to the member.
+ * @type:	the type of the container struct this is embedded in.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+/*
+ * Check at compile time that something is of a particular type.
+ * Always evaluates to 1 so you may use it easily in comparisons.
+ */
+#define typecheck(type,x) \
+({	type __dummy; \
+	typeof(x) __dummy2; \
+	(void)(&__dummy == &__dummy2); \
+	1; \
+})
+
+/*
+ * Check at compile time that 'function' is a certain type, or is a pointer
+ * to that type (needs to use typedef for the function type.)
+ */
+#define typecheck_fn(type,function) \
+({	typeof(type) __tmp = function; \
+	(void)__tmp; \
+})
+
+struct sysinfo;
+extern int do_sysinfo(struct sysinfo *info);
+
+#endif /* __KERNEL__ */
+
+#define SI_LOAD_SHIFT	16
+struct sysinfo {
+	long uptime;			/* Seconds since boot */
+	unsigned long loads[3];		/* 1, 5, and 15 minute load averages */
+	unsigned long totalram;		/* Total usable main memory size */
+	unsigned long freeram;		/* Available memory size */
+	unsigned long sharedram;	/* Amount of shared memory */
+	unsigned long bufferram;	/* Memory used by buffers */
+	unsigned long totalswap;	/* Total swap space size */
+	unsigned long freeswap;		/* swap space still available */
+	unsigned short procs;		/* Number of current processes */
+	unsigned short pad;		/* explicit padding for m68k */
+	unsigned long totalhigh;	/* Total high memory size */
+	unsigned long freehigh;		/* Available high memory size */
+	unsigned int mem_unit;		/* Memory unit size in bytes */
+	char _f[20-2*sizeof(long)-sizeof(int)];	/* Padding: libc5 uses this.. */
+};
+
+/* Force a compilation error if condition is true */
+#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
+
+/* Force a compilation error if condition is true, but also produce a
+   result (of value 0 and type size_t), so the expression can be used
+   e.g. in a structure initializer (or where-ever else comma expressions
+   aren't permitted). */
+#define BUILD_BUG_ON_ZERO(e) (sizeof(char[1 - 2 * !!(e)]) - 1)
+
+/* Trap pasters of __FUNCTION__ at compile-time */
+#define __FUNCTION__ (__func__)
+
+/* This helps us to avoid #ifdef CONFIG_NUMA */
+#ifdef CONFIG_NUMA
+#define NUMA_BUILD 1
+#else
+#define NUMA_BUILD 0
+#endif
+
+#endif
