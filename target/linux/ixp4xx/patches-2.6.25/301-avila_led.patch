diff -ruN clean/linux-2.6.25.4/arch/arm/mach-ixp4xx/avila-setup.c linux-2.6.25.4/arch/arm/mach-ixp4xx/avila-setup.c
--- clean/linux-2.6.25.4/arch/arm/mach-ixp4xx/avila-setup.c	2008-05-20 09:18:21.000000000 -0700
+++ linux-2.6.25.4/arch/arm/mach-ixp4xx/avila-setup.c	2008-05-20 09:31:55.000000000 -0700
@@ -26,6 +26,7 @@
 # include <linux/eeprom.h>
 #endif
 
+#include <linux/leds.h>
 #include <linux/i2c-gpio.h>
 
 #include <asm/types.h>
@@ -172,6 +173,72 @@
 	.dev.platform_data	= &avila_npec_data,
 };
 
+static struct gpio_led avila_gpio_leds[] = {
+	{
+		.name		= "user",  /* green led */
+		.gpio		= AVILA_GW23XX_LED_USER_GPIO,
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_led_platform_data avila_gpio_leds_data = {
+	.num_leds		= 1,
+	.leds			= avila_gpio_leds,
+};
+
+static struct platform_device avila_gpio_leds_device = {
+	.name			= "leds-gpio",
+	.id			= -1,
+	.dev.platform_data	= &avila_gpio_leds_data,
+};
+
+static struct latch_led avila_latch_leds[] = {
+	{
+		.name   = "led0",  /* green led */
+		.bit    = 0,
+	},
+	{
+		.name   = "led1",  /* green led */
+		.bit    = 1,
+	},
+	{
+		.name   = "led2",  /* green led */
+		.bit    = 2,
+	},
+	{
+		.name   = "led3",  /* green led */
+		.bit    = 3,
+	},
+	{
+		.name   = "led4",  /* green led */
+		.bit    = 4,
+	},
+	{
+		.name   = "led5",  /* green led */
+		.bit    = 5,
+	},
+	{
+		.name   = "led6",  /* green led */
+		.bit    = 6,
+	},
+	{
+		.name   = "led7",  /* green led */
+		.bit    = 7,
+	}
+};
+
+static struct latch_led_platform_data avila_latch_leds_data = {
+	.num_leds   = 8,
+	.leds       = avila_latch_leds,
+	.mem        = 0x51000000,
+};
+
+static struct platform_device avila_latch_leds_device = {
+	.name     = "leds-latch",
+	.id     = -1,
+	.dev.platform_data  = &avila_latch_leds_data,
+};
+
 static struct platform_device *avila_devices[] __initdata = {
 	&avila_i2c_gpio,
 	&avila_flash,
@@ -182,6 +249,8 @@
 {
 	platform_device_register(&avila_npeb_device);
 	platform_device_register(&avila_npec_device);
+
+	platform_device_register(&avila_gpio_leds_device);
 }
 
 #ifdef CONFIG_SENSORS_EEPROM
@@ -189,6 +258,8 @@
 {
 	platform_device_register(&avila_npeb_device);
 	platform_device_register(&avila_npec_device);
+
+	platform_device_register(&avila_gpio_leds_device);
 }
 
 static void __init avila_gw2345_setup(void)
@@ -199,22 +270,30 @@
 
 	avila_npec_data.phy = 5; /* port 5 of the KS8995 switch */
 	platform_device_register(&avila_npec_device);
+
+	platform_device_register(&avila_gpio_leds_device);
 }
 
 static void __init avila_gw2347_setup(void)
 {
 	platform_device_register(&avila_npeb_device);
+
+	avila_gpio_leds[0].gpio = AVILA_GW23X7_LED_USER_GPIO;
+	platform_device_register(&avila_gpio_leds_device);
 }
 
 static void __init avila_gw2348_setup(void)
 {
 	platform_device_register(&avila_npeb_device);
 	platform_device_register(&avila_npec_device);
+
+	platform_device_register(&avila_gpio_leds_device);
 }
 
 static void __init avila_gw2353_setup(void)
 {
 	platform_device_register(&avila_npeb_device);
+	platform_device_register(&avila_gpio_leds_device);
 }
 
 static void __init avila_gw2355_setup(void)
@@ -225,11 +304,29 @@
 
 	avila_npec_data.phy = 16;
 	platform_device_register(&avila_npec_device);
+
+	platform_device_register(&avila_gpio_leds_device);
+
+	*IXP4XX_EXP_CS4 |= 0xbfff3c03;
+	avila_latch_leds[0].name = "RXD";
+	avila_latch_leds[1].name = "TXD";
+	avila_latch_leds[2].name = "POL";
+	avila_latch_leds[3].name = "LNK";
+	avila_latch_leds[4].name = "ERR";
+	avila_latch_leds_data.num_leds = 5;
+	avila_latch_leds_data.mem = 0x54000000;
+	platform_device_register(&avila_latch_leds_device);
 }
 
 static void __init avila_gw2357_setup(void)
 {
 	platform_device_register(&avila_npeb_device);
+
+	avila_gpio_leds[0].gpio = AVILA_GW23X7_LED_USER_GPIO;
+	platform_device_register(&avila_gpio_leds_device);
+
+	*IXP4XX_EXP_CS1 |= 0xbfff3c03;
+	platform_device_register(&avila_latch_leds_device);
 }
 
 static struct avila_board_info avila_boards[] __initdata = {
diff -ruN clean/linux-2.6.25.4/drivers/leds/Kconfig linux-2.6.25.4/drivers/leds/Kconfig
--- clean/linux-2.6.25.4/drivers/leds/Kconfig	2008-05-15 08:00:12.000000000 -0700
+++ linux-2.6.25.4/drivers/leds/Kconfig	2008-05-20 09:25:15.000000000 -0700
@@ -113,6 +113,12 @@
 	  outputs. To be useful the particular board must have LEDs
 	  and they must be connected to the GPIO lines.
 
+config LEDS_LATCH
+	tristate "LED Support for Memory Latched LEDs"
+	depends on LEDS_CLASS
+	help
+		-- To Do --
+
 config LEDS_CM_X270
 	tristate "LED Support for the CM-X270 LEDs"
 	depends on LEDS_CLASS && MACH_ARMCORE
diff -ruN clean/linux-2.6.25.4/drivers/leds/leds-latch.c linux-2.6.25.4/drivers/leds/leds-latch.c
--- clean/linux-2.6.25.4/drivers/leds/leds-latch.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.25.4/drivers/leds/leds-latch.c	2008-04-30 14:03:21.000000000 -0700
@@ -0,0 +1,141 @@
+/*
+ * LEDs driver for Memory Latched Devices
+ *
+ * Copyright (C) 2008 Gateworks Corp.
+ * Chris Lang <clang@gateworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/workqueue.h>
+#include <asm/io.h>
+#include <linux/spinlock.h>
+
+static unsigned int mem_keep = 0xFF;
+static spinlock_t mem_lock;
+static unsigned char *iobase;
+
+struct latch_led_data {
+	struct led_classdev cdev;
+	struct work_struct work;
+	u8 new_level;
+	u8 bit;
+};
+
+static void latch_led_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct latch_led_data *led_dat =
+		container_of(led_cdev, struct latch_led_data, cdev);
+
+	spin_lock(mem_lock);
+
+	if (value == LED_OFF)
+		mem_keep |= (0x1 << led_dat->bit);
+	else
+		mem_keep &= ~(0x1 << led_dat->bit);
+
+	writeb(mem_keep, iobase);
+
+	spin_unlock(mem_lock);
+}
+
+static int latch_led_probe(struct platform_device *pdev)
+{
+	struct latch_led_platform_data *pdata = pdev->dev.platform_data;
+	struct latch_led *cur_led;
+	struct latch_led_data *leds_data, *led_dat;
+	int i, ret = 0;
+
+	if (!pdata)
+		return -EBUSY;
+
+	leds_data = kzalloc(sizeof(struct latch_led_data) * pdata->num_leds,
+				GFP_KERNEL);
+	if (!leds_data)
+		return -ENOMEM;
+
+	iobase = ioremap_nocache(pdata->mem, 0x1000);
+	writeb(0xFF, iobase);
+
+	for (i = 0; i < pdata->num_leds; i++) {
+		cur_led = &pdata->leds[i];
+		led_dat = &leds_data[i];
+
+		led_dat->cdev.name = cur_led->name;
+		led_dat->cdev.default_trigger = cur_led->default_trigger;
+		led_dat->cdev.brightness_set = latch_led_set;
+		led_dat->cdev.brightness = LED_OFF;
+		led_dat->bit = cur_led->bit;
+
+		ret = led_classdev_register(&pdev->dev, &led_dat->cdev);
+		if (ret < 0) {
+			goto err;
+		}
+	}
+
+	platform_set_drvdata(pdev, leds_data);
+
+	return 0;
+
+err:
+	if (i > 0) {
+		for (i = i - 1; i >= 0; i--) {
+			led_classdev_unregister(&leds_data[i].cdev);
+		}
+	}
+
+	kfree(leds_data);
+
+	return ret;
+}
+
+static int __devexit latch_led_remove(struct platform_device *pdev)
+{
+	int i;
+	struct latch_led_platform_data *pdata = pdev->dev.platform_data;
+	struct latch_led_data *leds_data;
+
+	leds_data = platform_get_drvdata(pdev);
+
+	for (i = 0; i < pdata->num_leds; i++) {
+		led_classdev_unregister(&leds_data[i].cdev);
+		cancel_work_sync(&leds_data[i].work);
+	}
+
+	kfree(leds_data);
+
+	return 0;
+}
+
+static struct platform_driver latch_led_driver = {
+	.probe		= latch_led_probe,
+	.remove		= __devexit_p(latch_led_remove),
+	.driver		= {
+		.name	= "leds-latch",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init latch_led_init(void)
+{
+	return platform_driver_register(&latch_led_driver);
+}
+
+static void __exit latch_led_exit(void)
+{
+	platform_driver_unregister(&latch_led_driver);
+}
+
+module_init(latch_led_init);
+module_exit(latch_led_exit);
+
+MODULE_AUTHOR("Chris Lang <clang@gateworks.com>");
+MODULE_DESCRIPTION("Latch LED driver");
+MODULE_LICENSE("GPL");
diff -ruN clean/linux-2.6.25.4/drivers/leds/Makefile linux-2.6.25.4/drivers/leds/Makefile
--- clean/linux-2.6.25.4/drivers/leds/Makefile	2008-05-15 08:00:12.000000000 -0700
+++ linux-2.6.25.4/drivers/leds/Makefile	2008-05-20 09:26:14.000000000 -0700
@@ -18,6 +18,7 @@
 obj-$(CONFIG_LEDS_COBALT_QUBE)		+= leds-cobalt-qube.o
 obj-$(CONFIG_LEDS_COBALT_RAQ)		+= leds-cobalt-raq.o
 obj-$(CONFIG_LEDS_GPIO)			+= leds-gpio.o
+obj-$(CONFIG_LEDS_LATCH)     += leds-latch.o
 obj-$(CONFIG_LEDS_CM_X270)              += leds-cm-x270.o
 obj-$(CONFIG_LEDS_CLEVO_MAIL)		+= leds-clevo-mail.o
 obj-$(CONFIG_LEDS_HP6XX)		+= leds-hp6xx.o
diff -ruN clean/linux-2.6.25.4/include/asm-arm/arch-ixp4xx/avila.h linux-2.6.25.4/include/asm-arm/arch-ixp4xx/avila.h
--- clean/linux-2.6.25.4/include/asm-arm/arch-ixp4xx/avila.h	2008-05-15 08:00:12.000000000 -0700
+++ linux-2.6.25.4/include/asm-arm/arch-ixp4xx/avila.h	2008-05-20 09:22:28.000000000 -0700
@@ -36,4 +36,6 @@
 #define AVILA_PCI_INTC_PIN	9
 #define AVILA_PCI_INTD_PIN	8
 
-
+/* User LEDs */
+#define AVILA_GW23XX_LED_USER_GPIO	3
+#define AVILA_GW23X7_LED_USER_GPIO	4
diff -ruN clean/linux-2.6.25.4/include/linux/leds.h linux-2.6.25.4/include/linux/leds.h
--- clean/linux-2.6.25.4/include/linux/leds.h	2008-05-15 08:00:12.000000000 -0700
+++ linux-2.6.25.4/include/linux/leds.h	2008-05-20 09:32:35.000000000 -0700
@@ -136,5 +136,18 @@
 	struct gpio_led *leds;
 };
 
+/* For the leds-latch driver */
+struct latch_led {
+	const char *name;
+	char *default_trigger;
+	unsigned  bit;
+};
+
+struct latch_led_platform_data {
+	int     num_leds;
+	u32     mem;
+	struct latch_led *leds;
+};
+
 
 #endif		/* __LINUX_LEDS_H_INCLUDED */
