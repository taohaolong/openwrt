---
 arch/arm/mach-omap2/board-n8x0.c |   13 +
 drivers/cbus/Kconfig             |   12 +
 drivers/cbus/Makefile            |    1 
 drivers/cbus/n810bm.c            |  396 +++++++++++++++++++++++++++++++++++++++
 drivers/cbus/retu.c              |    4 
 drivers/cbus/retu.h              |    2 
 6 files changed, 425 insertions(+), 3 deletions(-)

--- linux-2.6.36-rc4.orig/drivers/cbus/Kconfig
+++ linux-2.6.36-rc4/drivers/cbus/Kconfig
@@ -94,4 +94,16 @@ config CBUS_RETU_HEADSET
 	  to Retu/Vilma. Detection state and events are exposed through
 	  sysfs.
 
+config N810BM
+	depends on CBUS_RETU && CBUS_TAHVO
+	tristate "Nokia n810 battery management"
+	---help---
+	  Nokia n810 device battery management.
+
+	  WARNING: This driver is based on reverse engineered information.
+	  It is possibly dangerous to use this software.
+	  Use this software at your own risk!
+
+	  If unsure, say N.
+
 endmenu
--- linux-2.6.36-rc4.orig/drivers/cbus/Makefile
+++ linux-2.6.36-rc4/drivers/cbus/Makefile
@@ -12,3 +12,4 @@ obj-$(CONFIG_CBUS_RETU_WDT)	+= retu-wdt.
 obj-$(CONFIG_CBUS_TAHVO_USER)	+= tahvo-user.o
 obj-$(CONFIG_CBUS_RETU_USER)	+= retu-user.o
 obj-$(CONFIG_CBUS_RETU_HEADSET)	+= retu-headset.o
+obj-$(CONFIG_N810BM)		+= n810bm.o
--- /dev/null
+++ linux-2.6.36-rc4/drivers/cbus/n810bm.c
@@ -0,0 +1,396 @@
+/*
+ *   Nokia n810 battery management
+ *
+ *   WARNING: This driver is based on reverse engineered information.
+ *            It is possibly dangerous to use this software.
+ *            Use this software at your own risk!
+ *
+ *   Copyright (c) 2010 Michael Buesch <mb@bu3sch.de>
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version 2
+ *   of the License, or (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/reboot.h>
+
+#include "retu.h"
+#include "tahvo.h"
+
+
+#define N810BM_CHECK_INTERVAL		(HZ * 5)
+#define N810BM_MIN_VOLTAGE_THRES	3400 /* Absolute minimum voltage threshold */
+/* FIXME: Not sure about the actual value of the low threshold, yet.
+ * We must give userspace a chance to detect undervoltage and perform
+ * a clean shutdown, before we flip the big switch. */
+
+
+/* Battery related retu ADC channels */
+#define RETU_ADC_BSI		0x01 /* Battery Size Indicator */
+#define RETU_ADC_BATTVOLT	0x08 /* Battery voltage measurement */
+
+/* RETU_ADC_BSI
+ * The battery size indicator ADC measures the resistance between
+ * the battery BSI pin and ground. This is used to detect the battery
+ * capacity, as the BSI resistor is related to capacity.
+ *
+ * Manually measured lookup table.
+ * Hard to measure, thus not very accurate.
+ *
+ * Resistance  |  ADC value
+ * ========================
+ * 120k        |  0x3AC
+ * 110k        |  0x37C
+ * 100k        |  0x351
+ *  90k        |  0x329
+ */
+
+/* RETU_ADC_BATTVOLT
+ * Manually measured lookup table.
+ * Hard to measure, thus not very accurate.
+ *
+ * Voltage  |  ADC value
+ * =====================
+ * 2.80V    |  0x037
+ * 2.90V    |  0x05E
+ * 3.00V    |  0x090
+ * 3.10V    |  0x0A4
+ * 3.20V    |  0x0CC
+ * 3.30V    |  0x0EF
+ * 3.40V    |  0x115
+ * 3.50V    |  0x136
+ * 3.60V    |  0x15C
+ * 3.70V    |  0x187
+ * 3.80V    |  0x1A5
+ * 3.90V    |  0x1C9
+ * 4.00V    |  0x1ED
+ * 4.10V    |  0x212
+ * 4.20V    |  0x236
+ */
+
+
+enum n810bm_capacity {
+	N810BM_CAP_UNKNOWN	= 0,
+	N810BM_CAP_1500MAH	= 1500,	/* 1500 mAh battery */
+};
+
+struct n810bm {
+	struct platform_device *pdev;
+	enum n810bm_capacity capacity;
+	struct timer_list check_timer;
+	spinlock_t lock;
+};
+
+
+static NORET_TYPE void n810bm_emergency(struct n810bm *bm, const char *message) ATTRIB_NORET;
+static void n810bm_emergency(struct n810bm *bm, const char *message)
+{
+	printk(KERN_EMERG "Nokia n810 battery management fatal fault: %s\n", message);
+	/* Force a hard shutdown. */
+	machine_power_off();
+	panic("n810bm: Failed to halt machine in emergency state\n");
+}
+
+#if 0
+static u16 retu_read(struct n810bm *bm, unsigned int reg)
+{
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&retu_lock, flags);
+	ret = retu_read_reg(reg);
+	spin_unlock_irqrestore(&retu_lock, flags);
+	if (ret < 0 || ret > 0xFFFF)
+		n810bm_emergency(bm, "retu_read");
+
+	return ret;
+}
+#endif
+
+static void retu_maskset(struct n810bm *bm, unsigned int reg, u16 mask, u16 set)
+{
+	int ret;
+	unsigned long flags;
+	u16 value;
+
+	spin_lock_irqsave(&retu_lock, flags);
+	if (~mask) {
+		ret = retu_read_reg(reg);
+		if (ret < 0 || ret > 0xFFFF)
+			goto fatal_unlock;
+		value = ret;
+	} else
+		value = 0;
+	value &= ~mask;
+	value |= set;
+	ret = retu_write_reg(reg, value);
+	if (ret)
+		goto fatal_unlock;
+	spin_unlock_irqrestore(&retu_lock, flags);
+
+	return;
+
+fatal_unlock:
+	spin_unlock_irqrestore(&retu_lock, flags);
+	n810bm_emergency(bm, "retu_maskset");
+}
+
+static inline void retu_write(struct n810bm *bm, unsigned int reg, u16 value)
+{
+	return retu_maskset(bm, reg, 0xFFFF, value);
+}
+
+static int retu_adc_average(struct n810bm *bm, unsigned int chan,
+			    unsigned int nr_passes)
+{
+	unsigned int i, value = 0;
+	int ret;
+
+	if (WARN_ON(!nr_passes))
+		return 0;
+	for (i = 0; i < nr_passes; i++) {
+		ret = retu_read_adc(chan);
+		if (ret < 0)
+			return ret;
+		value += ret;
+	}
+	value /= nr_passes;
+
+	return value;
+}
+
+/* Measure the battery voltage. Returns the value in mV (or negative value on error). */
+static int n810bm_measure_batt_voltage(struct n810bm *bm)
+{
+	int adc;
+	unsigned int mv;
+	const unsigned int scale = 1000;
+
+	adc = retu_adc_average(bm, RETU_ADC_BATTVOLT, 5);
+	if (adc < 0)
+		return adc;
+	if (adc <= 0x37)
+		return 2800;
+	mv = 2800 + ((adc - 0x37) * (((4200 - 2800) * scale) / (0x236 - 0x37))) / scale;
+
+	return mv;
+}
+
+/* Read the battery capacity via BSI pin. */
+static enum n810bm_capacity n810bm_read_batt_capacity(struct n810bm *bm)
+{
+	int adc;
+	const unsigned int hyst = 16;
+
+	adc = retu_adc_average(bm, RETU_ADC_BSI, 5);
+	if (adc < 0)
+		return N810BM_CAP_UNKNOWN;
+
+	if (adc >= 0x3AC - hyst && adc <= 0x3AC + hyst)
+		return N810BM_CAP_1500MAH;
+
+	return N810BM_CAP_UNKNOWN;
+}
+
+struct mv2p {
+	unsigned int mv;
+	unsigned int p;
+};
+
+/* Convert a battery voltage (in mV) to percentage. */
+static unsigned int n810bm_mvolt2percent(unsigned int mv)
+{
+	/* FIXME: Create a correct table. */
+	static const struct mv2p table[] = {
+		{ .mv = 4200, .p = 100, },
+		{ .mv = 4150, .p = 90, },
+		{ .mv = 4100, .p = 80, },
+		{ .mv = 4050, .p = 70, },
+		{ .mv = 4000, .p = 60, },
+		{ .mv = 3950, .p = 50, },
+		{ .mv = 3900, .p = 40, },
+		{ .mv = 3850, .p = 30, },
+		{ .mv = 3800, .p = 20, },
+		{ .mv = 3750, .p = 10, },
+		{ .mv = 3700, .p = 0, },
+	};
+	const struct mv2p *e;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(table); i++) {
+		e = &table[i];
+		if (mv >= e->mv)
+			return e->p;
+	}
+
+	return 0;
+}
+
+static void n810bm_check_timer(unsigned long data)
+{
+	struct n810bm *bm = (struct n810bm *)data;
+	unsigned long flags;
+	int mv;
+
+	spin_lock_irqsave(&bm->lock, flags);
+
+	mv = n810bm_measure_batt_voltage(bm);
+	if (mv < 0)
+		n810bm_emergency(bm, "check timer: Failed to measure");
+	if (mv < N810BM_MIN_VOLTAGE_THRES)
+		n810bm_emergency(bm, "check timer: Minimum voltage threshold reached");
+
+	mod_timer(&bm->check_timer, round_jiffies(jiffies + N810BM_CHECK_INTERVAL));
+	spin_unlock_irqrestore(&bm->lock, flags);
+
+	return;
+}
+
+static ssize_t n810bm_attr_charge_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct n810bm *bm = platform_get_drvdata(pdev);
+	int err = -ENODEV;
+	ssize_t count = 0;
+	int millivolt;
+
+	spin_lock_irq(&bm->lock);
+	millivolt = n810bm_measure_batt_voltage(bm);
+	if (millivolt >= 0) {
+		count = snprintf(buf, PAGE_SIZE, "%u\n",
+				 n810bm_mvolt2percent(millivolt));
+		err = 0;
+	}
+	spin_unlock_irq(&bm->lock);
+
+	return err ? err : count;
+}
+static DEVICE_ATTR(batt_charge, 0444, n810bm_attr_charge_show, NULL);
+
+static ssize_t n810bm_attr_capacity_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct n810bm *bm = platform_get_drvdata(pdev);
+	ssize_t count;
+
+	spin_lock_irq(&bm->lock);
+	count = snprintf(buf, PAGE_SIZE, "%u\n",
+			 (unsigned int)bm->capacity);
+	spin_unlock_irq(&bm->lock);
+
+	return count;
+}
+static DEVICE_ATTR(batt_capacity, 0444, n810bm_attr_capacity_show, NULL);
+
+static void n810bm_hw_exit(struct n810bm *bm)
+{
+	retu_write(bm, RETU_REG_ADCSCR, 0);
+}
+
+static int n810bm_hw_init(struct n810bm *bm)
+{
+	retu_write(bm, RETU_REG_ADCSCR, 0);
+
+	bm->capacity = n810bm_read_batt_capacity(bm);
+	if (bm->capacity == N810BM_CAP_UNKNOWN) {
+		dev_err(&bm->pdev->dev, "Unknown battery detected");
+		return -ENODEV;
+	}
+	dev_info(&bm->pdev->dev, "Detected %u mAh battery\n",
+		 (unsigned int)bm->capacity);
+
+	return 0;
+}
+
+static int __devinit n810bm_probe(struct platform_device *pdev)
+{
+	struct n810bm *bm;
+	int err;
+
+	bm = kzalloc(sizeof(*bm), GFP_KERNEL);
+	if (!bm)
+		return -ENOMEM;
+	bm->pdev = pdev;
+	platform_set_drvdata(pdev, bm);
+	spin_lock_init(&bm->lock);
+	setup_timer(&bm->check_timer, n810bm_check_timer, (unsigned long)bm);
+
+	err = n810bm_hw_init(bm);
+	if (err)
+		goto err_free;
+	err = device_create_file(&pdev->dev, &dev_attr_batt_charge);
+	if (err)
+		goto err_exit;
+	err = device_create_file(&pdev->dev, &dev_attr_batt_capacity);
+	if (err)
+		goto err_rem_charge;
+
+	mod_timer(&bm->check_timer, round_jiffies(jiffies + N810BM_CHECK_INTERVAL));
+
+	dev_info(&pdev->dev, "Battery management initialized");
+
+	return 0;
+
+err_rem_charge:
+	device_remove_file(&pdev->dev, &dev_attr_batt_charge);
+err_exit:
+	n810bm_hw_exit(bm);
+err_free:
+	kfree(bm);
+	platform_set_drvdata(pdev, NULL);
+	return err;
+}
+
+static int __devexit n810bm_remove(struct platform_device *pdev)
+{
+	struct n810bm *bm = platform_get_drvdata(pdev);
+
+	del_timer_sync(&bm->check_timer);
+	device_remove_file(&pdev->dev, &dev_attr_batt_capacity);
+	device_remove_file(&pdev->dev, &dev_attr_batt_charge);
+	n810bm_hw_exit(bm);
+
+	kfree(bm);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver n810bm_driver = {
+	.remove		= __devexit_p(n810bm_remove),
+	.driver		= {
+		.name	= "n810bm",
+	}
+};
+
+static int __init n810bm_modinit(void)
+{
+	return platform_driver_probe(&n810bm_driver, n810bm_probe);
+}
+module_init(n810bm_modinit);
+
+static void __exit n810bm_modexit(void)
+{
+	platform_driver_unregister(&n810bm_driver);
+}
+module_exit(n810bm_modexit);
+
+MODULE_DESCRIPTION("Nokia n810 battery management");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Michael Buesch");
--- linux-2.6.36-rc4.orig/drivers/cbus/retu.c
+++ linux-2.6.36-rc4/drivers/cbus/retu.c
@@ -85,10 +85,10 @@ int retu_read_reg(int reg)
  *
  * This function writes a value to the specified register
  */
-void retu_write_reg(int reg, u16 val)
+int retu_write_reg(int reg, u16 val)
 {
 	BUG_ON(!retu_initialized);
-	cbus_write_reg(cbus_host, RETU_ID, reg, val);
+	return cbus_write_reg(cbus_host, RETU_ID, reg, val);
 }
 
 void retu_set_clear_reg_bits(int reg, u16 set, u16 clear)
--- linux-2.6.36-rc4.orig/drivers/cbus/retu.h
+++ linux-2.6.36-rc4/drivers/cbus/retu.h
@@ -58,7 +58,7 @@
 #define	MAX_RETU_IRQ_HANDLERS	16
 
 int retu_read_reg(int reg);
-void retu_write_reg(int reg, u16 val);
+int retu_write_reg(int reg, u16 val);
 void retu_set_clear_reg_bits(int reg, u16 set, u16 clear);
 int retu_read_adc(int channel);
 int retu_request_irq(int id, void *irq_handler, unsigned long arg, char *name);
--- linux-2.6.36-rc4.orig/arch/arm/mach-omap2/board-n8x0.c
+++ linux-2.6.36-rc4/arch/arm/mach-omap2/board-n8x0.c
@@ -833,6 +833,17 @@ static void __init n8x0_gpio_switches_in
 				    ARRAY_SIZE(n8x0_gpio_switches));
 }
 
+static struct platform_device n810_bm_device = {
+	.name		= "n810bm",
+	.id		= -1,
+};
+
+static void __init n810_bm_init(void)
+{
+	if (platform_device_register(&n810_bm_device))
+		BUG();
+}
+
 static void __init n8x0_init_machine(void)
 {
 	omap2420_mux_init(board_mux, OMAP_PACKAGE_ZAC);
@@ -860,6 +871,8 @@ static void __init n8x0_init_machine(voi
 	n8x0_onenand_init();
 	n8x0_mmc_init();
 	n8x0_usb_init();
+
+	n810_bm_init();
 }
 
 MACHINE_START(NOKIA_N800, "Nokia N800")
