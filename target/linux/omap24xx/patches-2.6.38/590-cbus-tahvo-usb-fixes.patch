Index: linux-2.6.38-rc7/drivers/cbus/tahvo-usb.c
===================================================================
--- linux-2.6.38-rc7.orig/drivers/cbus/tahvo-usb.c	2011-03-06 23:00:14.411191087 +0100
+++ linux-2.6.38-rc7/drivers/cbus/tahvo-usb.c	2011-03-06 23:43:26.524751556 +0100
@@ -98,8 +98,9 @@ struct tahvo_usb {
 #ifdef CONFIG_USB_OTG
 	int tahvo_mode;
 #endif
+	struct clk *ick;
 };
-static struct platform_device tahvo_usb_device;
+static struct tahvo_usb *tahvo_usb_device;
 
 /*
  * ---------------------------------------------------------------------------
@@ -114,8 +115,7 @@ static struct platform_device *tahvo_otg
 
 static irqreturn_t omap_otg_irq(int irq, void *arg)
 {
-	struct platform_device *otg_dev = arg;
-	struct tahvo_usb *tu = platform_get_drvdata(otg_dev);
+	struct tahvo_usb *tu = arg;
 	u16 otg_irq;
 
 	otg_irq = omap_readw(OTG_IRQ_SRC);
@@ -201,12 +201,12 @@ static int __init omap_otg_probe(struct
 
 	return request_irq(tahvo_otg_dev->resource[1].start,
 			   omap_otg_irq, IRQF_DISABLED, DRIVER_NAME,
-			   &tahvo_usb_device);
+			   tahvo_usb_device);
 }
 
 static int __exit omap_otg_remove(struct platform_device *pdev)
 {
-	free_irq(tahvo_otg_dev->resource[1].start, &tahvo_usb_device);
+	free_irq(tahvo_otg_dev->resource[1].start, tahvo_usb_device);
 	tahvo_otg_dev = NULL;
 
 	return 0;
@@ -659,6 +659,7 @@ static int __init tahvo_usb_probe(struct
 	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
 	if (!tu)
 		return -ENOMEM;
+	tahvo_usb_device = tu;
 
 	tu->pt_dev = container_of(dev, struct platform_device, dev);
 #ifdef CONFIG_USB_OTG
@@ -673,6 +674,14 @@ static int __init tahvo_usb_probe(struct
 	INIT_WORK(&tu->irq_work, tahvo_usb_irq_work);
 	mutex_init(&tu->serialize);
 
+	tu->ick = clk_get(NULL, "usb_l4_ick");
+	if (IS_ERR(tu->ick)) {
+		printk(KERN_ERR "Failed to get usb_l4_ick\n");
+		ret = PTR_ERR(tu->ick);
+		goto err_free_tu;
+	}
+	clk_enable(tu->ick);
+
 	/* Set initial state, so that we generate kevents only on
 	 * state changes */
 	tu->vbus_state = tahvo_read_reg(TAHVO_REG_IDSR) & 0x01;
@@ -680,10 +689,9 @@ static int __init tahvo_usb_probe(struct
 	/* We cannot enable interrupt until omap_udc is initialized */
 	ret = tahvo_request_irq(TAHVO_INT_VBUSON, tahvo_usb_vbus_interrupt,
 				(unsigned long) tu, "vbus_interrupt");
-	if (ret != 0) {
-		kfree(tu);
+	if (ret) {
 		printk(KERN_ERR "Could not register Tahvo interrupt for VBUS\n");
-		return ret;
+		goto err_release_clk;
 	}
 
 	/* Attributes */
@@ -708,9 +716,7 @@ static int __init tahvo_usb_probe(struct
 	ret = otg_set_transceiver(&tu->otg);
 	if (ret < 0) {
 		printk(KERN_ERR "Cannot register USB transceiver\n");
-		kfree(tu);
-		tahvo_free_irq(TAHVO_INT_VBUSON);
-		return ret;
+		goto err_free_irq;
 	}
 
 	dev_set_drvdata(dev, tu);
@@ -719,10 +725,23 @@ static int __init tahvo_usb_probe(struct
 	 * may not be generated in addition to this. */
 	schedule_work(&tu->irq_work);
 	return 0;
+
+err_free_irq:
+	tahvo_free_irq(TAHVO_INT_VBUSON);
+err_release_clk:
+	clk_disable(tu->ick);
+	clk_put(tu->ick);
+err_free_tu:
+	kfree(tu);
+	tahvo_usb_device = NULL;
+
+	return ret;
 }
 
 static int __exit tahvo_usb_remove(struct platform_device *pdev)
 {
+	struct tahvo_usb *tu = platform_get_drvdata(pdev);
+
 	dev_dbg(&pdev->dev, "remove\n");
 
 	tahvo_free_irq(TAHVO_INT_VBUSON);
@@ -732,6 +751,12 @@ static int __exit tahvo_usb_remove(struc
 #ifdef CONFIG_USB_OTG
 	device_remove_file(&pdev->dev, &dev_attr_otg_mode);
 #endif
+	clk_disable(tu->ick);
+	clk_put(tu->ick);
+
+	kfree(tu);
+	tahvo_usb_device = NULL;
+
 	return 0;
 }
 
Index: linux-2.6.38-rc7/arch/arm/mach-omap2/board-n8x0.c
===================================================================
--- linux-2.6.38-rc7.orig/arch/arm/mach-omap2/board-n8x0.c	2011-03-06 23:00:14.388188076 +0100
+++ linux-2.6.38-rc7/arch/arm/mach-omap2/board-n8x0.c	2011-03-06 23:06:50.508033149 +0100
@@ -40,6 +40,7 @@
 #include <plat/serial.h>
 #include <plat/cbus.h>
 #include <plat/gpio-switch.h>
+#include <plat/usb.h>
 
 #include "mux.h"
 
@@ -395,6 +396,14 @@ static struct musb_hdrc_platform_data tu
 	.config		= &musb_config,
 };
 
+static struct omap_usb_config n8x0_omap_usb_config __initdata = {
+	.otg		= 1,
+	.register_host	= 1,
+	.register_dev	= 1,
+	.hmc_mode	= 16,
+	.pins[0]	= 6,
+};
+
 static void __init n8x0_usb_init(void)
 {
 	int ret = 0;
@@ -417,6 +426,8 @@ static void __init n8x0_usb_init(void)
 	if (ret != 0)
 		goto err;
 
+	omap2_usbfs_init(&n8x0_omap_usb_config);
+
 	printk(announce);
 
 	return;
